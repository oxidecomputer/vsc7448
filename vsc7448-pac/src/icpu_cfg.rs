// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Based on mesa-v2021.09 (https://github.com/microchip-ung/mesa/) which has
// the following copyright and license:
//
// Copyright (c) 2004-2021 Microchip Technology Inc. and its subsidiaries.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// This is an autogenerated file; do not edit by hand!

use crate::types::RegisterAddress;

// Register groups are stored in the tree as submodules

pub mod cpu_system_ctrl;
pub mod fdma;
pub mod intr;
pub mod manual_xtrinj;
pub mod memctrl;
pub mod mpu8051;
pub mod pcie;
pub mod pi_mst;
pub mod spi_mst;
pub mod timers;
pub mod twi_delay;
pub mod twi_spike_filter;

/// Configurations for the CPU system.
pub struct CPU_SYSTEM_CTRL(pub(super) u32);
impl CPU_SYSTEM_CTRL {
    pub fn GENERAL_CTRL(&self) -> RegisterAddress<cpu_system_ctrl::GENERAL_CTRL> {
        RegisterAddress::new(self.0 + 0x24)
    }
    pub fn GENERAL_STAT(&self) -> RegisterAddress<cpu_system_ctrl::GENERAL_STAT> {
        RegisterAddress::new(self.0 + 0x28)
    }
    pub fn GPR(&self, index: u32) -> RegisterAddress<cpu_system_ctrl::GPR> {
        assert!(index < 8);
        RegisterAddress::new(self.0 + 0x0 + index * 0x4)
    }
    pub fn RESET(&self) -> RegisterAddress<cpu_system_ctrl::RESET> {
        RegisterAddress::new(self.0 + 0x20)
    }
}

/// Frame DMA
pub struct FDMA(pub(super) u32);
impl FDMA {
    pub fn FDMA_CH_ACTIVATE(&self) -> RegisterAddress<fdma::FDMA_CH_ACTIVATE> {
        RegisterAddress::new(self.0 + 0xd0)
    }
    pub fn FDMA_CH_CFG(&self, index: u32) -> RegisterAddress<fdma::FDMA_CH_CFG> {
        assert!(index < 10);
        RegisterAddress::new(self.0 + 0x18c + index * 0x4)
    }
    pub fn FDMA_CH_CNT(&self, index: u32) -> RegisterAddress<fdma::FDMA_CH_CNT> {
        assert!(index < 10);
        RegisterAddress::new(self.0 + 0xdc + index * 0x4)
    }
    pub fn FDMA_CH_DISABLE(&self) -> RegisterAddress<fdma::FDMA_CH_DISABLE> {
        RegisterAddress::new(self.0 + 0xd4)
    }
    pub fn FDMA_CH_FORCEDIS(&self) -> RegisterAddress<fdma::FDMA_CH_FORCEDIS> {
        RegisterAddress::new(self.0 + 0xd8)
    }
    pub fn FDMA_CH_INJ_TOKEN_CNT(
        &self,
        index: u32,
    ) -> RegisterAddress<fdma::FDMA_CH_INJ_TOKEN_CNT> {
        assert!(index < 8);
        RegisterAddress::new(self.0 + 0x104 + index * 0x4)
    }
    pub fn FDMA_CH_INJ_TOKEN_TICK_CNT(
        &self,
        index: u32,
    ) -> RegisterAddress<fdma::FDMA_CH_INJ_TOKEN_TICK_CNT> {
        assert!(index < 8);
        RegisterAddress::new(self.0 + 0x144 + index * 0x4)
    }
    pub fn FDMA_CH_INJ_TOKEN_TICK_RLD(
        &self,
        index: u32,
    ) -> RegisterAddress<fdma::FDMA_CH_INJ_TOKEN_TICK_RLD> {
        assert!(index < 8);
        RegisterAddress::new(self.0 + 0x124 + index * 0x4)
    }
    pub fn FDMA_CH_SAFE(&self) -> RegisterAddress<fdma::FDMA_CH_SAFE> {
        RegisterAddress::new(self.0 + 0xcc)
    }
    pub fn FDMA_CH_STAT(&self) -> RegisterAddress<fdma::FDMA_CH_STAT> {
        RegisterAddress::new(self.0 + 0xc8)
    }
    pub fn FDMA_CONST(&self) -> RegisterAddress<fdma::FDMA_CONST> {
        RegisterAddress::new(self.0 + 0x1c0)
    }
    pub fn FDMA_DCB_DATAL(&self, index: u32) -> RegisterAddress<fdma::FDMA_DCB_DATAL> {
        assert!(index < 10);
        RegisterAddress::new(self.0 + 0x50 + index * 0x4)
    }
    pub fn FDMA_DCB_DATAP(&self, index: u32) -> RegisterAddress<fdma::FDMA_DCB_DATAP> {
        assert!(index < 10);
        RegisterAddress::new(self.0 + 0x28 + index * 0x4)
    }
    pub fn FDMA_DCB_LLP(&self, index: u32) -> RegisterAddress<fdma::FDMA_DCB_LLP> {
        assert!(index < 10);
        RegisterAddress::new(self.0 + 0x0 + index * 0x4)
    }
    pub fn FDMA_DCB_LLP_PREV(&self, index: u32) -> RegisterAddress<fdma::FDMA_DCB_LLP_PREV> {
        assert!(index < 10);
        RegisterAddress::new(self.0 + 0xa0 + index * 0x4)
    }
    pub fn FDMA_DCB_STAT(&self, index: u32) -> RegisterAddress<fdma::FDMA_DCB_STAT> {
        assert!(index < 10);
        RegisterAddress::new(self.0 + 0x78 + index * 0x4)
    }
    pub fn FDMA_EVT_ERR(&self) -> RegisterAddress<fdma::FDMA_EVT_ERR> {
        RegisterAddress::new(self.0 + 0x164)
    }
    pub fn FDMA_EVT_ERR_CODE(&self) -> RegisterAddress<fdma::FDMA_EVT_ERR_CODE> {
        RegisterAddress::new(self.0 + 0x168)
    }
    pub fn FDMA_GCFG(&self) -> RegisterAddress<fdma::FDMA_GCFG> {
        RegisterAddress::new(self.0 + 0x1b4)
    }
    pub fn FDMA_GSTAT(&self) -> RegisterAddress<fdma::FDMA_GSTAT> {
        RegisterAddress::new(self.0 + 0x1b8)
    }
    pub fn FDMA_IDLECNT(&self) -> RegisterAddress<fdma::FDMA_IDLECNT> {
        RegisterAddress::new(self.0 + 0x1bc)
    }
    pub fn FDMA_INTR_ENA(&self) -> RegisterAddress<fdma::FDMA_INTR_ENA> {
        RegisterAddress::new(self.0 + 0x184)
    }
    pub fn FDMA_INTR_FRM(&self) -> RegisterAddress<fdma::FDMA_INTR_FRM> {
        RegisterAddress::new(self.0 + 0x174)
    }
    pub fn FDMA_INTR_FRM_ENA(&self) -> RegisterAddress<fdma::FDMA_INTR_FRM_ENA> {
        RegisterAddress::new(self.0 + 0x178)
    }
    pub fn FDMA_INTR_IDENT(&self) -> RegisterAddress<fdma::FDMA_INTR_IDENT> {
        RegisterAddress::new(self.0 + 0x188)
    }
    pub fn FDMA_INTR_LLP(&self) -> RegisterAddress<fdma::FDMA_INTR_LLP> {
        RegisterAddress::new(self.0 + 0x16c)
    }
    pub fn FDMA_INTR_LLP_ENA(&self) -> RegisterAddress<fdma::FDMA_INTR_LLP_ENA> {
        RegisterAddress::new(self.0 + 0x170)
    }
    pub fn FDMA_INTR_SIG(&self) -> RegisterAddress<fdma::FDMA_INTR_SIG> {
        RegisterAddress::new(self.0 + 0x17c)
    }
    pub fn FDMA_INTR_SIG_ENA(&self) -> RegisterAddress<fdma::FDMA_INTR_SIG_ENA> {
        RegisterAddress::new(self.0 + 0x180)
    }
}

/// Interrupt controller
pub struct INTR(pub(super) u32);
impl INTR {
    pub fn DEV_INTR_BYPASS(&self) -> RegisterAddress<intr::DEV_INTR_BYPASS> {
        RegisterAddress::new(self.0 + 0x7c)
    }
    pub fn DEV_INTR_BYPASS1(&self) -> RegisterAddress<intr::DEV_INTR_BYPASS1> {
        RegisterAddress::new(self.0 + 0x80)
    }
    pub fn DEV_INTR_ENA(&self) -> RegisterAddress<intr::DEV_INTR_ENA> {
        RegisterAddress::new(self.0 + 0x84)
    }
    pub fn DEV_INTR_ENA1(&self) -> RegisterAddress<intr::DEV_INTR_ENA1> {
        RegisterAddress::new(self.0 + 0x88)
    }
    pub fn DEV_INTR_IDENT(&self) -> RegisterAddress<intr::DEV_INTR_IDENT> {
        RegisterAddress::new(self.0 + 0x8c)
    }
    pub fn DEV_INTR_IDENT1(&self) -> RegisterAddress<intr::DEV_INTR_IDENT1> {
        RegisterAddress::new(self.0 + 0x90)
    }
    pub fn DEV_INTR_POL(&self) -> RegisterAddress<intr::DEV_INTR_POL> {
        RegisterAddress::new(self.0 + 0x54)
    }
    pub fn DEV_INTR_POL1(&self) -> RegisterAddress<intr::DEV_INTR_POL1> {
        RegisterAddress::new(self.0 + 0x58)
    }
    pub fn DEV_INTR_RAW(&self) -> RegisterAddress<intr::DEV_INTR_RAW> {
        RegisterAddress::new(self.0 + 0x5c)
    }
    pub fn DEV_INTR_RAW1(&self) -> RegisterAddress<intr::DEV_INTR_RAW1> {
        RegisterAddress::new(self.0 + 0x60)
    }
    pub fn DEV_INTR_STICKY(&self) -> RegisterAddress<intr::DEV_INTR_STICKY> {
        RegisterAddress::new(self.0 + 0x74)
    }
    pub fn DEV_INTR_STICKY1(&self) -> RegisterAddress<intr::DEV_INTR_STICKY1> {
        RegisterAddress::new(self.0 + 0x78)
    }
    pub fn DEV_INTR_TRIGGER(&self, index: u32) -> RegisterAddress<intr::DEV_INTR_TRIGGER> {
        assert!(index < 2);
        RegisterAddress::new(self.0 + 0x64 + index * 0x4)
    }
    pub fn DEV_INTR_TRIGGER1(&self, index: u32) -> RegisterAddress<intr::DEV_INTR_TRIGGER1> {
        assert!(index < 2);
        RegisterAddress::new(self.0 + 0x6c + index * 0x4)
    }
    pub fn DST_INTR_IDENT(&self, index: u32) -> RegisterAddress<intr::DST_INTR_IDENT> {
        assert!(index < 4);
        RegisterAddress::new(self.0 + 0x38 + index * 0x4)
    }
    pub fn DST_INTR_MAP(&self, index: u32) -> RegisterAddress<intr::DST_INTR_MAP> {
        assert!(index < 4);
        RegisterAddress::new(self.0 + 0x28 + index * 0x4)
    }
    pub fn EXT_DST_INTR_DRV(&self) -> RegisterAddress<intr::EXT_DST_INTR_DRV> {
        RegisterAddress::new(self.0 + 0x50)
    }
    pub fn EXT_DST_INTR_POL(&self) -> RegisterAddress<intr::EXT_DST_INTR_POL> {
        RegisterAddress::new(self.0 + 0x4c)
    }
    pub fn EXT_SRC_INTR_POL(&self) -> RegisterAddress<intr::EXT_SRC_INTR_POL> {
        RegisterAddress::new(self.0 + 0x48)
    }
    pub fn INTR_BYPASS(&self) -> RegisterAddress<intr::INTR_BYPASS> {
        RegisterAddress::new(self.0 + 0x14)
    }
    pub fn INTR_ENA(&self) -> RegisterAddress<intr::INTR_ENA> {
        RegisterAddress::new(self.0 + 0x18)
    }
    pub fn INTR_ENA_CLR(&self) -> RegisterAddress<intr::INTR_ENA_CLR> {
        RegisterAddress::new(self.0 + 0x1c)
    }
    pub fn INTR_ENA_SET(&self) -> RegisterAddress<intr::INTR_ENA_SET> {
        RegisterAddress::new(self.0 + 0x20)
    }
    pub fn INTR_FORCE(&self) -> RegisterAddress<intr::INTR_FORCE> {
        RegisterAddress::new(self.0 + 0xc)
    }
    pub fn INTR_IDENT(&self) -> RegisterAddress<intr::INTR_IDENT> {
        RegisterAddress::new(self.0 + 0x24)
    }
    pub fn INTR_RAW(&self) -> RegisterAddress<intr::INTR_RAW> {
        RegisterAddress::new(self.0 + 0x0)
    }
    pub fn INTR_STICKY(&self) -> RegisterAddress<intr::INTR_STICKY> {
        RegisterAddress::new(self.0 + 0x10)
    }
    pub fn INTR_TRIGGER(&self, index: u32) -> RegisterAddress<intr::INTR_TRIGGER> {
        assert!(index < 2);
        RegisterAddress::new(self.0 + 0x4 + index * 0x4)
    }
}

/// Manual extraction and injection via FDMA
pub struct MANUAL_XTRINJ(pub(super) u32);
impl MANUAL_XTRINJ {
    pub fn MANUAL_CFG(&self) -> RegisterAddress<manual_xtrinj::MANUAL_CFG> {
        RegisterAddress::new(self.0 + 0x8000)
    }
    pub fn MANUAL_INJ(&self, index: u32) -> RegisterAddress<manual_xtrinj::MANUAL_INJ> {
        assert!(index < 4096);
        RegisterAddress::new(self.0 + 0x4000 + index * 0x4)
    }
    pub fn MANUAL_INTR(&self) -> RegisterAddress<manual_xtrinj::MANUAL_INTR> {
        RegisterAddress::new(self.0 + 0x8004)
    }
    pub fn MANUAL_INTR_ENA(&self) -> RegisterAddress<manual_xtrinj::MANUAL_INTR_ENA> {
        RegisterAddress::new(self.0 + 0x8008)
    }
    pub fn MANUAL_XTR(&self, index: u32) -> RegisterAddress<manual_xtrinj::MANUAL_XTR> {
        assert!(index < 4096);
        RegisterAddress::new(self.0 + 0x0 + index * 0x4)
    }
}

/// DDR2/3 memory controller
pub struct MEMCTRL(pub(super) u32);
impl MEMCTRL {
    pub fn MEMCTRL_CFG(&self) -> RegisterAddress<memctrl::MEMCTRL_CFG> {
        RegisterAddress::new(self.0 + 0x4)
    }
    pub fn MEMCTRL_CTRL(&self) -> RegisterAddress<memctrl::MEMCTRL_CTRL> {
        RegisterAddress::new(self.0 + 0x0)
    }
    pub fn MEMCTRL_DFT(&self) -> RegisterAddress<memctrl::MEMCTRL_DFT> {
        RegisterAddress::new(self.0 + 0x3c)
    }
    pub fn MEMCTRL_DQS_AUTO(&self, index: u32) -> RegisterAddress<memctrl::MEMCTRL_DQS_AUTO> {
        assert!(index < 2);
        RegisterAddress::new(self.0 + 0x48 + index * 0x4)
    }
    pub fn MEMCTRL_DQS_DLY(&self, index: u32) -> RegisterAddress<memctrl::MEMCTRL_DQS_DLY> {
        assert!(index < 2);
        RegisterAddress::new(self.0 + 0x40 + index * 0x4)
    }
    pub fn MEMCTRL_MR0_VAL(&self) -> RegisterAddress<memctrl::MEMCTRL_MR0_VAL> {
        RegisterAddress::new(self.0 + 0x28)
    }
    pub fn MEMCTRL_MR1_VAL(&self) -> RegisterAddress<memctrl::MEMCTRL_MR1_VAL> {
        RegisterAddress::new(self.0 + 0x2c)
    }
    pub fn MEMCTRL_MR2_VAL(&self) -> RegisterAddress<memctrl::MEMCTRL_MR2_VAL> {
        RegisterAddress::new(self.0 + 0x30)
    }
    pub fn MEMCTRL_MR3_VAL(&self) -> RegisterAddress<memctrl::MEMCTRL_MR3_VAL> {
        RegisterAddress::new(self.0 + 0x34)
    }
    pub fn MEMCTRL_REF_PERIOD(&self) -> RegisterAddress<memctrl::MEMCTRL_REF_PERIOD> {
        RegisterAddress::new(self.0 + 0xc)
    }
    pub fn MEMCTRL_STAT(&self) -> RegisterAddress<memctrl::MEMCTRL_STAT> {
        RegisterAddress::new(self.0 + 0x8)
    }
    pub fn MEMCTRL_TERMRES_CTRL(&self) -> RegisterAddress<memctrl::MEMCTRL_TERMRES_CTRL> {
        RegisterAddress::new(self.0 + 0x38)
    }
    pub fn MEMCTRL_TIMING0(&self) -> RegisterAddress<memctrl::MEMCTRL_TIMING0> {
        RegisterAddress::new(self.0 + 0x14)
    }
    pub fn MEMCTRL_TIMING1(&self) -> RegisterAddress<memctrl::MEMCTRL_TIMING1> {
        RegisterAddress::new(self.0 + 0x18)
    }
    pub fn MEMCTRL_TIMING2(&self) -> RegisterAddress<memctrl::MEMCTRL_TIMING2> {
        RegisterAddress::new(self.0 + 0x1c)
    }
    pub fn MEMCTRL_TIMING3(&self) -> RegisterAddress<memctrl::MEMCTRL_TIMING3> {
        RegisterAddress::new(self.0 + 0x20)
    }
    pub fn MEMCTRL_TIMING4(&self) -> RegisterAddress<memctrl::MEMCTRL_TIMING4> {
        RegisterAddress::new(self.0 + 0x24)
    }
    pub fn MEMCTRL_ZQCAL(&self) -> RegisterAddress<memctrl::MEMCTRL_ZQCAL> {
        RegisterAddress::new(self.0 + 0x10)
    }
    pub fn MEMPHY_CFG(&self) -> RegisterAddress<memctrl::MEMPHY_CFG> {
        RegisterAddress::new(self.0 + 0x50)
    }
    pub fn MEMPHY_DFT(&self) -> RegisterAddress<memctrl::MEMPHY_DFT> {
        RegisterAddress::new(self.0 + 0x54)
    }
    pub fn MEMPHY_DLLCFG0(&self, index: u32) -> RegisterAddress<memctrl::MEMPHY_DLLCFG0> {
        assert!(index < 3);
        RegisterAddress::new(self.0 + 0x58 + index * 0x4)
    }
    pub fn MEMPHY_DLLCFG1(&self, index: u32) -> RegisterAddress<memctrl::MEMPHY_DLLCFG1> {
        assert!(index < 3);
        RegisterAddress::new(self.0 + 0x64 + index * 0x4)
    }
    pub fn MEMPHY_DQ_DLY_TRM(&self, index: u32) -> RegisterAddress<memctrl::MEMPHY_DQ_DLY_TRM> {
        assert!(index < 2);
        RegisterAddress::new(self.0 + 0x70 + index * 0x4)
    }
    pub fn MEMPHY_ZCAL(&self) -> RegisterAddress<memctrl::MEMPHY_ZCAL> {
        RegisterAddress::new(self.0 + 0x78)
    }
    pub fn MEMPHY_ZCAL_FORCE(&self) -> RegisterAddress<memctrl::MEMPHY_ZCAL_FORCE> {
        RegisterAddress::new(self.0 + 0x84)
    }
    pub fn MEMPHY_ZCAL_OVR(&self) -> RegisterAddress<memctrl::MEMPHY_ZCAL_OVR> {
        RegisterAddress::new(self.0 + 0x80)
    }
    pub fn MEMPHY_ZCAL_STAT(&self) -> RegisterAddress<memctrl::MEMPHY_ZCAL_STAT> {
        RegisterAddress::new(self.0 + 0x7c)
    }
}

/// Configuration/status for the 8051
pub struct MPU8051(pub(super) u32);
impl MPU8051 {
    pub fn MEMACC(&self) -> RegisterAddress<mpu8051::MEMACC> {
        RegisterAddress::new(self.0 + 0x10)
    }
    pub fn MEMACC_CTRL(&self) -> RegisterAddress<mpu8051::MEMACC_CTRL> {
        RegisterAddress::new(self.0 + 0xc)
    }
    pub fn MEMACC_SBA(&self) -> RegisterAddress<mpu8051::MEMACC_SBA> {
        RegisterAddress::new(self.0 + 0x14)
    }
    pub fn MPU8051_CFG(&self) -> RegisterAddress<mpu8051::MPU8051_CFG> {
        RegisterAddress::new(self.0 + 0x0)
    }
    pub fn MPU8051_IROM(&self) -> RegisterAddress<mpu8051::MPU8051_IROM> {
        RegisterAddress::new(self.0 + 0x18)
    }
    pub fn MPU8051_MMAP(&self) -> RegisterAddress<mpu8051::MPU8051_MMAP> {
        RegisterAddress::new(self.0 + 0x8)
    }
    pub fn MPU8051_STAT(&self) -> RegisterAddress<mpu8051::MPU8051_STAT> {
        RegisterAddress::new(self.0 + 0x4)
    }
}

/// PCIe endpoint
pub struct PCIE(pub(super) u32);
impl PCIE {
    pub fn PCIEMST_BAR1_MASK(&self) -> RegisterAddress<pcie::PCIEMST_BAR1_MASK> {
        RegisterAddress::new(self.0 + 0x1c)
    }
    pub fn PCIEMST_BAR1_OFFSET(&self) -> RegisterAddress<pcie::PCIEMST_BAR1_OFFSET> {
        RegisterAddress::new(self.0 + 0x18)
    }
    pub fn PCIEMST_BAR2_MASK(&self) -> RegisterAddress<pcie::PCIEMST_BAR2_MASK> {
        RegisterAddress::new(self.0 + 0x24)
    }
    pub fn PCIEMST_BAR2_OFFSET(&self) -> RegisterAddress<pcie::PCIEMST_BAR2_OFFSET> {
        RegisterAddress::new(self.0 + 0x20)
    }
    pub fn PCIEMST_REPLY_INFO(&self) -> RegisterAddress<pcie::PCIEMST_REPLY_INFO> {
        RegisterAddress::new(self.0 + 0x14)
    }
    pub fn PCIEPCS_BEACON(&self) -> RegisterAddress<pcie::PCIEPCS_BEACON> {
        RegisterAddress::new(self.0 + 0x34)
    }
    pub fn PCIEPCS_CFG(&self) -> RegisterAddress<pcie::PCIEPCS_CFG> {
        RegisterAddress::new(self.0 + 0x30)
    }
    pub fn PCIESLV_FDMA(&self) -> RegisterAddress<pcie::PCIESLV_FDMA> {
        RegisterAddress::new(self.0 + 0x28)
    }
    pub fn PCIESLV_SBA(&self) -> RegisterAddress<pcie::PCIESLV_SBA> {
        RegisterAddress::new(self.0 + 0x2c)
    }
    pub fn PCIE_AUX_CFG(&self) -> RegisterAddress<pcie::PCIE_AUX_CFG> {
        RegisterAddress::new(self.0 + 0xc)
    }
    pub fn PCIE_CFG(&self) -> RegisterAddress<pcie::PCIE_CFG> {
        RegisterAddress::new(self.0 + 0x4)
    }
    pub fn PCIE_CTRL(&self) -> RegisterAddress<pcie::PCIE_CTRL> {
        RegisterAddress::new(self.0 + 0x0)
    }
    pub fn PCIE_DBG_STAT(&self) -> RegisterAddress<pcie::PCIE_DBG_STAT> {
        RegisterAddress::new(self.0 + 0x10)
    }
    pub fn PCIE_INTR(&self) -> RegisterAddress<pcie::PCIE_INTR> {
        RegisterAddress::new(self.0 + 0x38)
    }
    pub fn PCIE_INTR_CFG(&self, index: u32) -> RegisterAddress<pcie::PCIE_INTR_CFG> {
        assert!(index < 2);
        RegisterAddress::new(self.0 + 0x48 + index * 0x4)
    }
    pub fn PCIE_INTR_COMMON_CFG(&self) -> RegisterAddress<pcie::PCIE_INTR_COMMON_CFG> {
        RegisterAddress::new(self.0 + 0x44)
    }
    pub fn PCIE_INTR_ENA(&self) -> RegisterAddress<pcie::PCIE_INTR_ENA> {
        RegisterAddress::new(self.0 + 0x3c)
    }
    pub fn PCIE_INTR_IDENT(&self) -> RegisterAddress<pcie::PCIE_INTR_IDENT> {
        RegisterAddress::new(self.0 + 0x40)
    }
    pub fn PCIE_INTR_STAT(&self, index: u32) -> RegisterAddress<pcie::PCIE_INTR_STAT> {
        assert!(index < 2);
        RegisterAddress::new(self.0 + 0x50 + index * 0x4)
    }
    pub fn PCIE_STAT(&self) -> RegisterAddress<pcie::PCIE_STAT> {
        RegisterAddress::new(self.0 + 0x8)
    }
}

/// Parallel Interface Configuration
pub struct PI_MST(pub(super) u32);
impl PI_MST {
    pub fn PI_MST_CFG(&self) -> RegisterAddress<pi_mst::PI_MST_CFG> {
        RegisterAddress::new(self.0 + 0x0)
    }
    pub fn PI_MST_CTRL(&self) -> RegisterAddress<pi_mst::PI_MST_CTRL> {
        RegisterAddress::new(self.0 + 0x4)
    }
    pub fn PI_MST_STATUS(&self) -> RegisterAddress<pi_mst::PI_MST_STATUS> {
        RegisterAddress::new(self.0 + 0x8)
    }
    pub fn PI_SLV_CFG(&self) -> RegisterAddress<pi_mst::PI_SLV_CFG> {
        RegisterAddress::new(self.0 + 0xc)
    }
}

/// SPI boot master
pub struct SPI_MST(pub(super) u32);
impl SPI_MST {
    pub fn SPI_MST_CFG(&self) -> RegisterAddress<spi_mst::SPI_MST_CFG> {
        RegisterAddress::new(self.0 + 0x0)
    }
    pub fn SPI_MST_STATUS(&self, index: u32) -> RegisterAddress<spi_mst::SPI_MST_STATUS> {
        assert!(index < 4);
        RegisterAddress::new(self.0 + 0x4 + index * 0x4)
    }
    pub fn SW_MODE(&self) -> RegisterAddress<spi_mst::SW_MODE> {
        RegisterAddress::new(self.0 + 0x14)
    }
}

/// Timers
pub struct TIMERS(pub(super) u32);
impl TIMERS {
    pub fn TIMER_CTRL(&self, index: u32) -> RegisterAddress<timers::TIMER_CTRL> {
        assert!(index < 3);
        RegisterAddress::new(self.0 + 0x20 + index * 0x4)
    }
    pub fn TIMER_RELOAD_VALUE(&self, index: u32) -> RegisterAddress<timers::TIMER_RELOAD_VALUE> {
        assert!(index < 3);
        RegisterAddress::new(self.0 + 0x14 + index * 0x4)
    }
    pub fn TIMER_TICK_DIV(&self) -> RegisterAddress<timers::TIMER_TICK_DIV> {
        RegisterAddress::new(self.0 + 0x4)
    }
    pub fn TIMER_VALUE(&self, index: u32) -> RegisterAddress<timers::TIMER_VALUE> {
        assert!(index < 3);
        RegisterAddress::new(self.0 + 0x8 + index * 0x4)
    }
    pub fn WDT(&self) -> RegisterAddress<timers::WDT> {
        RegisterAddress::new(self.0 + 0x0)
    }
}

/// TWI hold time configuration
pub struct TWI_DELAY(pub(super) u32);
impl TWI_DELAY {
    pub fn TWI_CONFIG(&self) -> RegisterAddress<twi_delay::TWI_CONFIG> {
        RegisterAddress::new(self.0 + 0x0)
    }
}

/// TWI spike filter configuration
pub struct TWI_SPIKE_FILTER(pub(super) u32);
impl TWI_SPIKE_FILTER {
    pub fn TWI_SPIKE_FILTER_CFG(&self) -> RegisterAddress<twi_spike_filter::TWI_SPIKE_FILTER_CFG> {
        RegisterAddress::new(self.0 + 0x0)
    }
}
