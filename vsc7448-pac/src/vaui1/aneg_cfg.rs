// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Based on mesa-v2021.09 (https://github.com/microchip-ung/mesa/) which has
// the following copyright and license:
//
// Copyright (c) 2004-2021 Microchip Technology Inc. and its subsidiaries.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// This is an autogenerated file; do not edit by hand!
use derive_more::{From, Into};
/// ANEG Advertised Ability 0
///
/// 48 bits that contain the advertised abilities link code word for auto-negotiation (here: lower 32 bit).
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct ANEG_ADV_ABILITY_0(u32);
impl ANEG_ADV_ABILITY_0 {
    /// Acknowledge bit (this bit is automatically overwritten by ANEG)
    #[inline]
    pub fn ackn(&self) -> u32 {
        (self.0 & 0x4000) >> 14
    }
    #[inline]
    pub fn set_ackn(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 14;
        self.0 &= !0x4000;
        self.0 |= value;
    }
    /// Reserved for future technology as defined in IEEE 802.3ap clause 73.
    #[inline]
    pub fn adv_abil_lsb(&self) -> u32 {
        (self.0 & 0xff000000) >> 24
    }
    #[inline]
    pub fn set_adv_abil_lsb(&mut self, value: u32) {
        assert!(value <= 0xff);
        let value = value << 24;
        self.0 &= !0xff000000;
        self.0 |= value;
    }
    /// Technology Ability to be advertised (here: 10GBase-KR)
    ///
    /// 0: Do not advertise 10GB-KR capability 1: Advertise 10GB-KR capability
    #[inline]
    pub fn cap_10gkr(&self) -> u32 {
        (self.0 & 0x800000) >> 23
    }
    #[inline]
    pub fn set_cap_10gkr(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 23;
        self.0 &= !0x800000;
        self.0 |= value;
    }
    /// Technology Ability to be advertised (here: 10GBase-KX4)
    ///
    /// 0: Do not advertise 10GB-KX4 capability 1: Advertise 10GB-KX4 capability
    #[inline]
    pub fn cap_10gkx4(&self) -> u32 {
        (self.0 & 0x400000) >> 22
    }
    #[inline]
    pub fn set_cap_10gkx4(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 22;
        self.0 &= !0x400000;
        self.0 |= value;
    }
    /// Technology Ability to be advertised (here: 1000Base-KX)
    ///
    /// 0: Do not advertise 1GB-KX capability 1: Advertise 1GB-KX capability
    #[inline]
    pub fn cap_1gkx(&self) -> u32 {
        (self.0 & 0x200000) >> 21
    }
    #[inline]
    pub fn set_cap_1gkx(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 21;
        self.0 &= !0x200000;
        self.0 |= value;
    }
    /// Reserved for echoed nonce field (must be cleared)
    #[inline]
    pub fn echoed_nonce(&self) -> u32 {
        (self.0 & 0x3e0) >> 5
    }
    #[inline]
    pub fn set_echoed_nonce(&mut self, value: u32) {
        assert!(value <= 0x1f);
        let value = value << 5;
        self.0 &= !0x3e0;
        self.0 |= value;
    }
    /// Next page exchange desired
    ///
    /// 0: Disable NP exchange 1: Enable NP exchange
    #[inline]
    pub fn np(&self) -> u32 {
        (self.0 & 0x8000) >> 15
    }
    #[inline]
    pub fn set_np(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 15;
        self.0 &= !0x8000;
        self.0 |= value;
    }
    /// Pause field
    #[inline]
    pub fn pause(&self) -> u32 {
        (self.0 & 0x1c00) >> 10
    }
    #[inline]
    pub fn set_pause(&mut self, value: u32) {
        assert!(value <= 0x7);
        let value = value << 10;
        self.0 &= !0x1c00;
        self.0 |= value;
    }
    /// RF bit (initial value)
    #[inline]
    pub fn rf(&self) -> u32 {
        (self.0 & 0x2000) >> 13
    }
    #[inline]
    pub fn set_rf(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 13;
        self.0 &= !0x2000;
        self.0 |= value;
    }
    /// Selector field (must be 0x1)
    #[inline]
    pub fn sel_field(&self) -> u32 {
        self.0 & 0x1f
    }
    #[inline]
    pub fn set_sel_field(&mut self, value: u32) {
        assert!(value <= 0x1f);
        self.0 &= !0x1f;
        self.0 |= value;
    }
    /// Initial value for Transmit-Nonce field
    #[inline]
    pub fn tx_nonce(&self) -> u32 {
        (self.0 & 0x1f0000) >> 16
    }
    #[inline]
    pub fn set_tx_nonce(&mut self, value: u32) {
        assert!(value <= 0x1f);
        let value = value << 16;
        self.0 &= !0x1f0000;
        self.0 |= value;
    }
}
/// ANEG Advertised Ability 1
///
/// 48 bits that contain the advertised abilities link code word for auto-negotiation (here: upper 16 bit).
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct ANEG_ADV_ABILITY_1(u32);
impl ANEG_ADV_ABILITY_1 {
    /// Reserved for future technology as defined in IEEE 802.3ap clause 73.
    #[inline]
    pub fn adv_abil_msb(&self) -> u32 {
        self.0 & 0x3fff
    }
    #[inline]
    pub fn set_adv_abil_msb(&mut self, value: u32) {
        assert!(value <= 0x3fff);
        self.0 &= !0x3fff;
        self.0 |= value;
    }
    /// FEC capability (bit 14: FEC ability, bit 15: FEC requested) - Only used with 10GBase-KR
    #[inline]
    pub fn fec(&self) -> u32 {
        (self.0 & 0xc000) >> 14
    }
    #[inline]
    pub fn set_fec(&mut self, value: u32) {
        assert!(value <= 0x3);
        let value = value << 14;
        self.0 &= !0xc000;
        self.0 |= value;
    }
}
/// ANEG Configuration
///
/// Auto-negotiation configuration register. Note: Setting one of the parallel detect wait times to 0 disables parallel detect function for that specific mode.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct ANEG_CFG(u32);
impl ANEG_CFG {
    /// Auto-negotiation enable
    ///
    /// 1: Enable 0: Disable
    #[inline]
    pub fn aneg_ena(&self) -> u32 {
        self.0 & 0x1
    }
    #[inline]
    pub fn set_aneg_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
    /// Disable automatic ANEG speed setting
    ///
    /// 0: Allow ANEG to select frequency 1: Frequency is programmed using mode2g5_ena and hr_mode_ena
    #[inline]
    pub fn aneg_freqsel_dis(&self) -> u32 {
        (self.0 & 0x8000) >> 15
    }
    #[inline]
    pub fn set_aneg_freqsel_dis(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 15;
        self.0 &= !0x8000;
        self.0 |= value;
    }
    /// Disable automatic ANEG OB configuration
    ///
    /// 0: Allow ANEG block to control OB during auto-negotiation 1: OB settings are not touched by ANEG block
    #[inline]
    pub fn aneg_ob_ctrl_dis(&self) -> u32 {
        (self.0 & 0x10000) >> 16
    }
    #[inline]
    pub fn set_aneg_ob_ctrl_dis(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 16;
        self.0 &= !0x10000;
        self.0 |= value;
    }
    /// Disable automatic power down of lane controlled by ANEG
    ///
    /// 0: Allow ANEG to power down unused lane 1: Power down is not controlled by ANEG
    #[inline]
    pub fn aneg_pwdn_dis(&self) -> u32 {
        (self.0 & 0x4000) >> 14
    }
    #[inline]
    pub fn set_aneg_pwdn_dis(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 14;
        self.0 &= !0x4000;
        self.0 |= value;
    }
    /// Asynchronous reset reseting all auto-negotiation logic
    ///
    /// 1: Reset
    #[inline]
    pub fn aneg_reset_one_shot(&self) -> u32 {
        (self.0 & 0x80000000) >> 31
    }
    #[inline]
    pub fn set_aneg_reset_one_shot(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 31;
        self.0 &= !0x80000000;
        self.0 |= value;
    }
    /// Reserved for test purposes. ANEG wait timer values are divided by 2^15 and the parallel detect timers are divided by 2^10
    ///
    /// 1: Enable division 0: Normal operation
    #[inline]
    pub fn arb_testmode(&self) -> u32 {
        (self.0 & 0x100000) >> 20
    }
    #[inline]
    pub fn set_arb_testmode(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 20;
        self.0 &= !0x100000;
        self.0 |= value;
    }
    /// Reserved for test purposes. Disable nonce/link_status checks
    ///
    /// 1: Disable checks 0: Normal operation
    #[inline]
    pub fn ate_testmode(&self) -> u32 {
        (self.0 & 0x400000) >> 22
    }
    #[inline]
    pub fn set_ate_testmode(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 22;
        self.0 &= !0x400000;
        self.0 |= value;
    }
    /// Reserved
    #[inline]
    pub fn bltd_ena(&self) -> u32 {
        (self.0 & 0x80) >> 7
    }
    #[inline]
    pub fn set_bltd_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 7;
        self.0 &= !0x80;
        self.0 |= value;
    }
    /// Parallel detect wait time for 10G using four lanes
    ///
    /// 0: 0 ms 1: 10 ms 2: 20 ms 3: 40 ms
    #[inline]
    pub fn pd_timer_10gkx4(&self) -> u32 {
        (self.0 & 0x3000) >> 12
    }
    #[inline]
    pub fn set_pd_timer_10gkx4(&mut self, value: u32) {
        assert!(value <= 0x3);
        let value = value << 12;
        self.0 &= !0x3000;
        self.0 |= value;
    }
    /// Parallel detect wait time for 1G using single lane
    ///
    /// 0: 0 ms 1: 10 ms 2: 20 ms 3: 40 ms
    #[inline]
    pub fn pd_timer_1gkx(&self) -> u32 {
        (self.0 & 0xc00) >> 10
    }
    #[inline]
    pub fn set_pd_timer_1gkx(&mut self, value: u32) {
        assert!(value <= 0x3);
        let value = value << 10;
        self.0 &= !0xc00;
        self.0 |= value;
    }
    /// Parallel detect wait time for 2.5G using single lane
    ///
    /// 0: 0 ms 1: 10 ms 2: 20 ms 3: 40 ms
    #[inline]
    pub fn pd_timer_2g5(&self) -> u32 {
        (self.0 & 0x300) >> 8
    }
    #[inline]
    pub fn set_pd_timer_2g5(&mut self, value: u32) {
        assert!(value <= 0x3);
        let value = value << 8;
        self.0 &= !0x300;
        self.0 |= value;
    }
    /// Restart negotiation process
    ///
    /// 1: Restart
    #[inline]
    pub fn restart_aneg_one_shot(&self) -> u32 {
        (self.0 & 0x2) >> 1
    }
    #[inline]
    pub fn set_restart_aneg_one_shot(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 1;
        self.0 &= !0x2;
        self.0 |= value;
    }
    /// Reserved for test purposes. Control of page_test_max_timer_done check
    ///
    /// 1: Disable check 0: Normal operation
    #[inline]
    pub fn rx_testmode(&self) -> u32 {
        (self.0 & 0x200000) >> 21
    }
    #[inline]
    pub fn set_rx_testmode(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 21;
        self.0 &= !0x200000;
        self.0 |= value;
    }
    /// Reserved for test purposes. Transmit data 0 on all bit positions if ANEG is active
    ///
    /// 1: Bypass ANEG data 0: Normal operation
    #[inline]
    pub fn txbyp_testmode(&self) -> u32 {
        (self.0 & 0x800000) >> 23
    }
    #[inline]
    pub fn set_txbyp_testmode(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 23;
        self.0 &= !0x800000;
        self.0 |= value;
    }
}
/// ANEG Next Page 0
///
/// 48 bits that contain the new next page to transmit during auto-negotiation (here: lower 32 bits).
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct ANEG_NEXT_PAGE_0(u32);
impl ANEG_NEXT_PAGE_0 {
    /// Lower 32 bits of next page link code word
    #[inline]
    pub fn np_tx_lsb(&self) -> u32 {
        self.0
    }
    #[inline]
    pub fn set_np_tx_lsb(&mut self, value: u32) {
        self.0 = value;
    }
}
/// ANEG Next Page 1
///
/// 48 bits that contain the new next page to transmit during auto-negotiation (here: upper 16 bits).
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct ANEG_NEXT_PAGE_1(u32);
impl ANEG_NEXT_PAGE_1 {
    /// Must be set when a new next page is programmed (self-clearing)
    #[inline]
    pub fn next_page_loaded_one_shot(&self) -> u32 {
        (self.0 & 0x80000000) >> 31
    }
    #[inline]
    pub fn set_next_page_loaded_one_shot(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 31;
        self.0 &= !0x80000000;
        self.0 |= value;
    }
    /// Upper 16 bits of next page link code word
    #[inline]
    pub fn np_tx_msb(&self) -> u32 {
        self.0 & 0xffff
    }
    #[inline]
    pub fn set_np_tx_msb(&mut self, value: u32) {
        assert!(value <= 0xffff);
        self.0 &= !0xffff;
        self.0 |= value;
    }
}
