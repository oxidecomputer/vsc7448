// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Based on mesa-v2021.09 (https://github.com/microchip-ung/mesa/) which has
// the following copyright and license:
//
// Copyright (c) 2004-2021 Microchip Technology Inc. and its subsidiaries.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// This is an autogenerated file; do not edit by hand!
use derive_more::{From, Into};
/// PI Slave Configuration
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct PI_SLV_CFG(u32);
impl PI_SLV_CFG {
    /// Set to configure PI interface for big-endian mode.
    pub fn bigendian(&self) -> u32 {
        (self.0 & 0x400000) >> 22
    }
    pub fn set_bigendian(&mut self, value: u32) {
        let value = value << 22;
        assert!(value <= 0x400000);
        self.0 &= !0x400000;
        self.0 |= value;
    }
    /// Configures number of clock cycles after detecting asserted CS to control/data is sampled.
    ///
    /// n: Wait n clocks after detecting CS before sampling control/data.
    pub fn cswait(&self) -> u32 {
        self.0 & 0xff
    }
    pub fn set_cswait(&mut self, value: u32) {
        assert!(value <= 0xff);
        self.0 &= !0xff;
        self.0 |= value;
    }
    /// Configure a minimum number of cycles after release of NCS until ndone is no longer driven by device. The device will deassert ndone value when NCS is released, this setting allows parking of the ndone at inactive level before releasing drive of output.
    ///
    /// 0: Immediate release of ndone (async path from CS input). n: Wait at least n+1 clocks after CS release until ndone is released.
    pub fn donepark(&self) -> u32 {
        (self.0 & 0x3f0000) >> 16
    }
    pub fn set_donepark(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0x3f0000);
        self.0 &= !0x3f0000;
        self.0 |= value;
    }
    /// Set this field to force the value in ICPU_CFG::PI_SLV_CFG.DONEPOL_VAL into ICPU_CFG::GENERAL_CTRL.IF_PI_SLV_DONEPOL. This field is immediately cleared.
    pub fn donepol_set(&self) -> u32 {
        (self.0 & 0x800000) >> 23
    }
    pub fn set_donepol_set(&mut self, value: u32) {
        let value = value << 23;
        assert!(value <= 0x800000);
        self.0 &= !0x800000;
        self.0 |= value;
    }
    /// See ICPU_CFG::PI_SLV_CFG.DONEPOL_SET for more information.
    pub fn donepol_val(&self) -> u32 {
        (self.0 & 0x1000000) >> 24
    }
    pub fn set_donepol_val(&mut self, value: u32) {
        let value = value << 24;
        assert!(value <= 0x1000000);
        self.0 &= !0x1000000;
        self.0 |= value;
    }
    /// Configures number of clock cycles to delay nDone indication for read operations after accerss is done.
    ///
    /// n: Wait n clocks after read data ready before asserting nDone indication.
    pub fn donewait(&self) -> u32 {
        (self.0 & 0xff00) >> 8
    }
    pub fn set_donewait(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0xff00);
        self.0 &= !0xff00;
        self.0 |= value;
    }
}
/// SPI boot master configuration
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct SPI_MST_CFG(u32);
impl SPI_MST_CFG {
    /// Set to enable 32bit address mode. In 32bit addressing mode only CS0 is used, the SPI address region is limited to 256MByte reserved for the SI interface.
    ///
    /// 0: Use 24bit addressing with 4 different CS. 1: Use 32bit addressing on CS0, max 256MByte
    pub fn a32b_ena(&self) -> u32 {
        (self.0 & 0x800) >> 11
    }
    pub fn set_a32b_ena(&mut self, value: u32) {
        let value = value << 11;
        assert!(value <= 0x800);
        self.0 &= !0x800;
        self.0 |= value;
    }
    /// Controls the clock frequency for the SPI interface (SI_Clk). The clock frequency is VCore system clock divided by the value of this field. Setting this field to 0 or 1 value is illegal.
    ///
    /// The SPI interface frequency is: 250MHz/CLK_DIV.
    pub fn clk_div(&self) -> u32 {
        self.0 & 0x1f
    }
    pub fn set_clk_div(&mut self, value: u32) {
        assert!(value <= 0x1f);
        self.0 &= !0x1f;
        self.0 |= value;
    }
    /// The minimum number of SPI clock cycles for which the SPI chip select (SI_nEn) must be deasserted in between transfers. Typical value of this is 100 ns. Setting this field to 0 is illegal.
    pub fn cs_deselect_time(&self) -> u32 {
        (self.0 & 0x3e0) >> 5
    }
    pub fn set_cs_deselect_time(&mut self, value: u32) {
        let value = value << 5;
        assert!(value <= 0x3e0);
        self.0 &= !0x3e0;
        self.0 |= value;
    }
    /// The type of read-instruction that the SPI Controller generates for reads.
    ///
    /// 0: READ (slow read - Instruction code - 0x03) 1: FAST READ (fast read - Instruction code - 0x0B)
    pub fn fast_read_ena(&self) -> u32 {
        (self.0 & 0x400) >> 10
    }
    pub fn set_fast_read_ena(&mut self, value: u32) {
        let value = value << 10;
        assert!(value <= 0x400);
        self.0 &= !0x400;
        self.0 |= value;
    }
}
/// SPI boot master status
///
/// This is a replicated register, where each replication holds the status for one chip select.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct SPI_MST_STATUS(u32);
impl SPI_MST_STATUS {
    /// Upsupported operation has been performed on the SPI master from AHB slave.
    pub fn unsup_err(&self) -> u32 {
        self.0 & 0x1
    }
    pub fn set_unsup_err(&mut self, value: u32) {
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
}
