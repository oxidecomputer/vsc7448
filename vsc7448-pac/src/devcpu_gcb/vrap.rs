// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Based on mesa-v2021.09 (https://github.com/microchip-ung/mesa/) which has
// the following copyright and license:
//
// Copyright (c) 2004-2021 Microchip Technology Inc. and its subsidiaries.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// This is an autogenerated file; do not edit by hand!
use derive_more::{From, Into};
/// Debug registers
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct MEMITGR_DBG(u32);
impl MEMITGR_DBG {
    /// Always shows the (resynced) value of the data-field of the integrity-ring into the monitor.
    pub fn data_in(&self) -> u32 {
        (self.0 & 0x20) >> 5
    }
    pub fn set_data_in(&mut self, value: u32) {
        let value = value << 5;
        assert!(value <= 0x20);
        self.0 &= !0x20;
        self.0 |= value;
    }
    /// Set this field to enable detection of parity detections and ecc corrections. The monitor must be initialized before first use (after reset), this is done by making the first transtion from IDLE to LISTEN mode without enabeling detections (this field is cleared) and then setting this field once the monitor reaches the LISTEN mode.
    pub fn detect_ena(&self) -> u32 {
        self.0 & 0x1
    }
    pub fn set_detect_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
    /// Always shows the (resynced) value of the ena-field of the integrity-ring into the monitor.
    pub fn ena_in(&self) -> u32 {
        (self.0 & 0x40) >> 6
    }
    pub fn set_ena_in(&mut self, value: u32) {
        let value = value << 6;
        assert!(value <= 0x40);
        self.0 &= !0x40;
        self.0 |= value;
    }
    /// When DEVCPU_GCB::MEMITGR_DBG.FORCE_ENA is set, this value is driven to ena-field of the intgrity-ring out from the monitor.
    pub fn ena_out(&self) -> u32 {
        (self.0 & 0x4) >> 2
    }
    pub fn set_ena_out(&mut self, value: u32) {
        let value = value << 2;
        assert!(value <= 0x4);
        self.0 &= !0x4;
        self.0 |= value;
    }
    /// Set to overtake ena and sync outputs (bit banging on the integrity ring) and drive these by DEVCPU_GCB::MEMITGR_DBG.ENA_OUT and DEVCPU_GCB::MEMITGR_DBG.SYNC_OUT respectively.
    pub fn force_ena(&self) -> u32 {
        (self.0 & 0x2) >> 1
    }
    pub fn set_force_ena(&mut self, value: u32) {
        let value = value << 1;
        assert!(value <= 0x2);
        self.0 &= !0x2;
        self.0 |= value;
    }
    /// Set to force the intr-field of the intgrity-ring out from the monitor.
    pub fn force_intr(&self) -> u32 {
        (self.0 & 0x100) >> 8
    }
    pub fn set_force_intr(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0x100);
        self.0 &= !0x100;
        self.0 |= value;
    }
    /// Always shows the (resynced) value of the intr-field of the integrity-ring into the monitor.
    pub fn intr_in(&self) -> u32 {
        (self.0 & 0x10) >> 4
    }
    pub fn set_intr_in(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x10);
        self.0 &= !0x10;
        self.0 |= value;
    }
    /// This field is used for test purposes.
    pub fn mem_div_sense(&self) -> u32 {
        (self.0 & 0x200) >> 9
    }
    pub fn set_mem_div_sense(&mut self, value: u32) {
        let value = value << 9;
        assert!(value <= 0x200);
        self.0 &= !0x200;
        self.0 |= value;
    }
    /// Always shows the (resynced) value of the sync-field of the integrity-ring into the monitor.
    pub fn sync_in(&self) -> u32 {
        (self.0 & 0x80) >> 7
    }
    pub fn set_sync_in(&mut self, value: u32) {
        let value = value << 7;
        assert!(value <= 0x80);
        self.0 &= !0x80;
        self.0 |= value;
    }
    /// When DEVCPU_GCB::MEMITGR_DBG.FORCE_ENA is set, this value is driven to sync-field of the intgrity-ring out from the monitor.
    pub fn sync_out(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    pub fn set_sync_out(&mut self, value: u32) {
        let value = value << 3;
        assert!(value <= 0x8);
        self.0 &= !0x8;
        self.0 |= value;
    }
}
/// VRAP events
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct VRAP_ACCESS_STAT(u32);
impl VRAP_ACCESS_STAT {
    /// This field is set if an invalid command inside a valid VRAP frame has been received. The VRAP engine has ignored the command.
    pub fn cmd_invalid_sticky(&self) -> u32 {
        (self.0 & 0x4) >> 2
    }
    pub fn set_cmd_invalid_sticky(&mut self, value: u32) {
        let value = value << 2;
        assert!(value <= 0x4);
        self.0 &= !0x4;
        self.0 |= value;
    }
    /// This field is set if an invalid VRAP frame has been received and discarded by the VRAP-engine. Frames with a VRAP header different from V1 are considered invalid.
    pub fn frm_invalid_sticky(&self) -> u32 {
        (self.0 & 0x2) >> 1
    }
    pub fn set_frm_invalid_sticky(&mut self, value: u32) {
        let value = value << 1;
        assert!(value <= 0x2);
        self.0 &= !0x2;
        self.0 |= value;
    }
    /// This field is set if a valid VRAP (Vitesse Register Access Protocol) frame has been received.
    pub fn frm_recv_sticky(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    pub fn set_frm_recv_sticky(&mut self, value: u32) {
        let value = value << 3;
        assert!(value <= 0x8);
        self.0 &= !0x8;
        self.0 |= value;
    }
    /// This field is set if a VRAP reply frame has been aborted. This my happen if a protocol violation is detected during VRAP request frame processing.
    pub fn reply_abort_sticky(&self) -> u32 {
        self.0 & 0x1
    }
    pub fn set_reply_abort_sticky(&mut self, value: u32) {
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
}
