// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Based on mesa-v2021.09 (https://github.com/microchip-ung/mesa/) which has
// the following copyright and license:
//
// Copyright (c) 2004-2021 Microchip Technology Inc. and its subsidiaries.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// This is an autogenerated file; do not edit by hand!
use derive_more::{From, Into};

/// Register `FAN_CNT`
///
/// TACH counter
#[derive(From, Into)]
pub struct FAN_CNT(u32);
impl FAN_CNT {    ///
    /// Counts the number of TACH input ticks. If DEVCPU_GCB::FAN_CFG.FAN_STAT_CFG is set then this is a wrapping counter that shows the total number of registered TACH ticks. If DEVCPU_GCB::FAN_CFG.FAN_STAT_CFG is cleared then this counter is updated once every second with the number of TACH ticks registered during the last second.
    pub fn fan_cnt(&self) -> u32 {
        (self.0 & 0xffff) >> 0
    }
    pub fn set_fan_cnt(&mut self, value: u32) {
        let value = value << 0;
        assert!(value <= 0xffff);
        self.0 &= !0xffff;
        self.0 |= value;
    }
}

/// Register `MEMITGR_CTRL`
///
/// Monitor control
#[derive(From, Into)]
pub struct MEMITGR_CTRL(u32);
impl MEMITGR_CTRL {    ///
    /// Setting this field transitions the integrity monitor between operating modes. Transitioning between modes takes time, this field remains set until the new mode is reached. During this time the monitor also reports busy DEVCPU_GCB::MEMITGR_STAT.MODE_BUSY is set). From IDLE (DEVCPU_GCB::MEMITGR_STAT.MODE_IDLE is set) the monitor can transition into either DETECT or LISTEN mode, the DETECT mode is entered if a memory reports an indication - the LISTEN mode is entered if no indications are reported. The first time after reset the monitor will not detect indications, that is; it will transition directly from IDLE to LISTEN mode. From DETECT (DEVCPU_GCB::MEMITGR_STAT.MODE_DETECT is set) the monitor can transition into either DETECT or LISTEN mode, the DETECT mode is entered if more indications are reported - the LISTEN mode is entered if no more indications are reported. From LISTEN (DEVCPU_GCB::MEMITGR_STAT.MODE_LISTEN is set) the monitor can transition into IDLE mode. Software shall not set this field when the monitor is BUSY (when DEVCPU_GCB::MEMITGR_STAT.MODE_BUSY is set.)
    pub fn activate(&self) -> u32 {
        (self.0 & 0x1) >> 0
    }
    pub fn set_activate(&mut self, value: u32) {
        let value = value << 0;
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
}

/// Register `MEMITGR_DIV`
///
/// Monitor speed
#[derive(From, Into)]
pub struct MEMITGR_DIV(u32);
impl MEMITGR_DIV {    ///
    /// Configure divider for generating the sync-pulse to memories (controls the speed at which the monitor talks to the memories). The lower this is set the faster indications can be read out of the memories.
    ///
    /// See datasheet for appropriate value.
    pub fn mem_div(&self) -> u32 {
        (self.0 & 0xffff) >> 0
    }
    pub fn set_mem_div(&mut self, value: u32) {
        let value = value << 0;
        assert!(value <= 0xffff);
        self.0 &= !0xffff;
        self.0 |= value;
    }
}

/// Register `MEMITGR_IDX`
///
/// Memory index
///
/// This field is only valid when the monitor is in the DETECT (DEVCPU_GCB::MEMITGR_STAT.MODE_DETECT is set) mode.
#[derive(From, Into)]
pub struct MEMITGR_IDX(u32);
impl MEMITGR_IDX {    ///
    /// This field contains a unique index for the memory for which info is currently provided in DEVCPU_GCB::MEMITGR_INFO. Indexes are counted from 1 (not 0).
    pub fn mem_idx(&self) -> u32 {
        (self.0 & 0xffff) >> 0
    }
    pub fn set_mem_idx(&mut self, value: u32) {
        let value = value << 0;
        assert!(value <= 0xffff);
        self.0 &= !0xffff;
        self.0 |= value;
    }
}

/// Register `MEMITGR_INFO`
///
/// Memory indication
///
/// This field is only valid when the monitor is in the DETECT (DEVCPU_GCB::MEMITGR_STAT.MODE_DETECT is set) mode.
#[derive(From, Into)]
pub struct MEMITGR_INFO(u32);
impl MEMITGR_INFO {    ///
    /// This field is valid only when DEVCPU_GCB::MEMITGR_INFO.MEM_ERR or DEVCPU_GCB::MEMITGR_INFO.MEM_COR is set.
    pub fn mem_addr(&self) -> u32 {
        (self.0 & 0xfffffff) >> 0
    }
    pub fn set_mem_addr(&mut self, value: u32) {
        let value = value << 0;
        assert!(value <= 0xfffffff);
        self.0 &= !0xfffffff;
        self.0 |= value;
    }    ///
    /// This field is set if the monitor has detected a correction.
    pub fn mem_cor(&self) -> u32 {
        (self.0 & 0x40000000) >> 30
    }
    pub fn set_mem_cor(&mut self, value: u32) {
        let value = value << 30;
        assert!(value <= 0x40000000);
        self.0 &= !0x40000000;
        self.0 |= value;
    }    ///
    /// This field is set if the monitor has correction indication for which the address has not been recorded. If DEVCPU_GCB::MEMITGR_INFO.MEM_ERR is set then there has also been a parity indication (or an unrecoverable correction) which takes priority over correction indications. If DEVCPU_GCB::MEMITGR_INFO.MEM_ERR is cleared and DEVCPU_GCB::MEMITGR_INFO.MEM_COR is set then there has been more than one correction indication, then only the address of the newest correction indication has been kept. If DEVCPU_GCB::MEMITGR_INFO.MEM_ERR and DEVCPU_GCB::MEMITGR_INFO.MEM_COR is both cleared then a correction indication has occurred for which the address could not be stored, this is a very rare situation that can only happen if an indication is detected just as the memory is talking to the monitor.
    pub fn mem_cor_ovf(&self) -> u32 {
        (self.0 & 0x10000000) >> 28
    }
    pub fn set_mem_cor_ovf(&mut self, value: u32) {
        let value = value << 28;
        assert!(value <= 0x10000000);
        self.0 &= !0x10000000;
        self.0 |= value;
    }    ///
    /// This field is set if the monitor has detected a parity indication (or an unrecoverable correction).
    pub fn mem_err(&self) -> u32 {
        (self.0 & 0x7fffffff) >> 31
    }
    pub fn set_mem_err(&mut self, value: u32) {
        let value = value << 31;
        assert!(value <= 0x7fffffff);
        self.0 &= !0x7fffffff;
        self.0 |= value;
    }    ///
    /// This field is set if the monitor has detected a parity indication (or an unrecoverable correction) for which the address has not been recorded. If DEVCPU_GCB::MEMITGR_INFO.MEM_ERR is set then there has been more than one indication, then only the address of the newest indication has been kept. If DEVCPU_GCB::MEMITGR_INFO.MEM_ERR is cleared then an indication has occurred for which the address could not be stored, this is a very rare situation that can only happen if an indication is detected just as the memory is talking to the monitor.
    pub fn mem_err_ovf(&self) -> u32 {
        (self.0 & 0x20000000) >> 29
    }
    pub fn set_mem_err_ovf(&mut self, value: u32) {
        let value = value << 29;
        assert!(value <= 0x20000000);
        self.0 &= !0x20000000;
        self.0 |= value;
    }
}

/// Register `MEMITGR_STAT`
///
/// Monitor status
#[derive(From, Into)]
pub struct MEMITGR_STAT(u32);
impl MEMITGR_STAT {    ///
    /// If this field is set then there is an indication from one of the memories that needs to be analyzed. An indication is either a parity detection or an error correction. This field is only set when the monitor is in LISTEN mode (DEVCPU_GCB::MEMITGR_STAT.MODE_LISTEN is set), in all other states (including BUSY) this field returns 0.
    pub fn indication(&self) -> u32 {
        (self.0 & 0x10) >> 4
    }
    pub fn set_indication(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x10);
        self.0 &= !0x10;
        self.0 |= value;
    }    ///
    /// This field is set if there is an overflow when recording indications from the memories. If this happens (setting of this field) the value of the DEVCPU_GCB::MEMITGR_DIV.MEM_DIV field is set too low!
    pub fn indication_ovf(&self) -> u32 {
        (self.0 & 0x20) >> 5
    }
    pub fn set_indication_ovf(&mut self, value: u32) {
        let value = value << 5;
        assert!(value <= 0x20);
        self.0 &= !0x20;
        self.0 |= value;
    }    ///
    /// The busy signal is a copy of the DEVCPU_GCB::MEMITGR_CTRL.ACTIVATE field, see description of that field for more information about the different states/modes of the monitor.
    pub fn mode_busy(&self) -> u32 {
        (self.0 & 0x1) >> 0
    }
    pub fn set_mode_busy(&mut self, value: u32) {
        let value = value << 0;
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }    ///
    /// This field is set when the monitor is in DETECT mode, during detect mode the DEVCPU_GCB::MEMITGR_INFO and DEVCPU_GCB::MEMITGR_IDX registers contains valid information about one indication.
    pub fn mode_detect(&self) -> u32 {
        (self.0 & 0x4) >> 2
    }
    pub fn set_mode_detect(&mut self, value: u32) {
        let value = value << 2;
        assert!(value <= 0x4);
        self.0 &= !0x4;
        self.0 |= value;
    }    ///
    /// This field is set when the monitor is in IDLE mode.
    pub fn mode_idle(&self) -> u32 {
        (self.0 & 0x2) >> 1
    }
    pub fn set_mode_idle(&mut self, value: u32) {
        let value = value << 1;
        assert!(value <= 0x2);
        self.0 &= !0x2;
        self.0 |= value;
    }    ///
    /// This field is set when the monitor is in LISTEN mode, during listen mode the monitor continually check for parity/correction indications from the memories.
    pub fn mode_listen(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    pub fn set_mode_listen(&mut self, value: u32) {
        let value = value << 3;
        assert!(value <= 0x8);
        self.0 &= !0x8;
        self.0 |= value;
    }
}
