// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Based on mesa-v2021.09 (https://github.com/microchip-ung/mesa/) which has
// the following copyright and license:
//
// Copyright (c) 2004-2021 Microchip Technology Inc. and its subsidiaries.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// This is an autogenerated file; do not edit by hand!
use derive_more::{From, Into};
/// GPIO alternate functions
#[derive(From, Into)]
pub struct GPIO_ALT(u32);
impl GPIO_ALT {
    /// Configures alternate functions for individual GPIOs. See datasheet for information on possible alternate functions. The LSB of the GPIO encoding is placed in replication 0, MSB is placed in replication 1. For example; to encode Alternate mode 2 for GPIO[n] write DEVCPU_GCB::GPIO_ALT[0][n] = 0, and DEVCPU_GCB::GPIO_ALT[1][n] = 1. Note: This register is only reset by the device's reset input, i.e. it is not affected by soft reset!

    ///

    /// 00: GPIO mode 01: Alternate mode 1 10: Alternate mode 2 11: Alternate mode 3
    pub fn g_alt(&self) -> u32 {
        self.0
    }
    pub fn set_g_alt(&mut self, value: u32) {
        self.0 = value;
    }
}
/// GPIO alternate functions
#[derive(From, Into)]
pub struct GPIO_ALT1(u32);
impl GPIO_ALT1 {
    /// Bit 32-63 of field G_ALT.

    ///

    /// 00: GPIO mode 01: Alternate mode 1 10: Alternate mode 2 11: Alternate mode 3
    pub fn g_alt1(&self) -> u32 {
        self.0
    }
    pub fn set_g_alt1(&mut self, value: u32) {
        self.0 = value;
    }
}
/// GPIO input
#[derive(From, Into)]
pub struct GPIO_IN(u32);
impl GPIO_IN {
    /// GPIO input register. Reflects the current state of the corresponding GPIO pins.
    pub fn g_in(&self) -> u32 {
        self.0
    }
    pub fn set_g_in(&mut self, value: u32) {
        self.0 = value;
    }
}
/// GPIO input
#[derive(From, Into)]
pub struct GPIO_IN1(u32);
impl GPIO_IN1 {
    /// Bit 32-63 of field G_IN.
    pub fn g_in1(&self) -> u32 {
        self.0
    }
    pub fn set_g_in1(&mut self, value: u32) {
        self.0 = value;
    }
}
/// GPIO interrupt
#[derive(From, Into)]
pub struct GPIO_INTR(u32);
impl GPIO_INTR {
    /// Indicates whether a GPIO input has changed since last clear.

    ///

    /// '0': No change '1': GPIO has changed
    pub fn g_intr(&self) -> u32 {
        self.0
    }
    pub fn set_g_intr(&mut self, value: u32) {
        self.0 = value;
    }
}
/// GPIO interrupt
#[derive(From, Into)]
pub struct GPIO_INTR1(u32);
impl GPIO_INTR1 {
    /// Bit 32-63 of field G_INTR.

    ///

    /// '0': No change '1': GPIO has changed
    pub fn g_intr1(&self) -> u32 {
        self.0
    }
    pub fn set_g_intr1(&mut self, value: u32) {
        self.0 = value;
    }
}
/// GPIO interrupt enable
#[derive(From, Into)]
pub struct GPIO_INTR_ENA(u32);
impl GPIO_INTR_ENA {
    /// Enables individual GPIO pins for interrupt.
    pub fn g_intr_ena(&self) -> u32 {
        self.0
    }
    pub fn set_g_intr_ena(&mut self, value: u32) {
        self.0 = value;
    }
}
/// GPIO interrupt enable
#[derive(From, Into)]
pub struct GPIO_INTR_ENA1(u32);
impl GPIO_INTR_ENA1 {
    /// Bit 32-63 of field G_INTR_ENA.
    pub fn g_intr_ena1(&self) -> u32 {
        self.0
    }
    pub fn set_g_intr_ena1(&mut self, value: u32) {
        self.0 = value;
    }
}
/// GPIO interrupt identity
#[derive(From, Into)]
pub struct GPIO_INTR_IDENT(u32);
impl GPIO_INTR_IDENT {
    /// Shows which GPIO sources that are currently interrupting. This field is the result of an AND-operation between the GPIO_INTR and the GPIO_INTR_ENA registers.
    pub fn g_intr_ident(&self) -> u32 {
        self.0
    }
    pub fn set_g_intr_ident(&mut self, value: u32) {
        self.0 = value;
    }
}
/// GPIO interrupt identity
#[derive(From, Into)]
pub struct GPIO_INTR_IDENT1(u32);
impl GPIO_INTR_IDENT1 {
    /// Bit 32-63 of field G_INTR_IDENT.
    pub fn g_intr_ident1(&self) -> u32 {
        self.0
    }
    pub fn set_g_intr_ident1(&mut self, value: u32) {
        self.0 = value;
    }
}
/// GPIO pin direction
#[derive(From, Into)]
pub struct GPIO_OE(u32);
impl GPIO_OE {
    /// Configures the direction of the GPIO pins.

    ///

    /// '0': Input '1': Output
    pub fn g_oe(&self) -> u32 {
        self.0
    }
    pub fn set_g_oe(&mut self, value: u32) {
        self.0 = value;
    }
}
/// GPIO pin direction
#[derive(From, Into)]
pub struct GPIO_OE1(u32);
impl GPIO_OE1 {
    /// Bit 32-63 of field G_OE.

    ///

    /// '0': Input '1': Output
    pub fn g_oe1(&self) -> u32 {
        self.0
    }
    pub fn set_g_oe1(&mut self, value: u32) {
        self.0 = value;
    }
}
/// GPIO output
///
/// In a multi-threaded software environment using the registers GPIO_OUT_SET and GPIO_OUT_CLR for modifying GPIO values removes the need for software-locked access.
#[derive(From, Into)]
pub struct GPIO_OUT(u32);
impl GPIO_OUT {
    /// Controls the value on the GPIO pins enabled for output (via the GPIO_OE register). This field can be modified directly or by using the GPIO_O_SET and GPIO_O_CLR registers.
    pub fn g_out(&self) -> u32 {
        self.0
    }
    pub fn set_g_out(&mut self, value: u32) {
        self.0 = value;
    }
}
/// GPIO output
///
/// In a multi-threaded software environment using the registers GPIO_OUT_SET and GPIO_OUT_CLR for modifying GPIO values removes the need for software-locked access.
#[derive(From, Into)]
pub struct GPIO_OUT1(u32);
impl GPIO_OUT1 {
    /// Bit 32-63 of field G_OUT.
    pub fn g_out1(&self) -> u32 {
        self.0
    }
    pub fn set_g_out1(&mut self, value: u32) {
        self.0 = value;
    }
}
/// GPIO output clear
#[derive(From, Into)]
pub struct GPIO_OUT_CLR(u32);
impl GPIO_OUT_CLR {
    /// Setting a bit in this field will immediately clear the corresponding bit in GPIO_OUT.G_OUT. Reading this register always return 0.

    ///

    /// '0': No change '1': Corresponding bit in GPIO_OUT.G_OUT is cleared.
    pub fn g_out_clr(&self) -> u32 {
        self.0
    }
    pub fn set_g_out_clr(&mut self, value: u32) {
        self.0 = value;
    }
}
/// GPIO output clear
#[derive(From, Into)]
pub struct GPIO_OUT_CLR1(u32);
impl GPIO_OUT_CLR1 {
    /// Bit 32-63 of field G_OUT_CLR.

    ///

    /// '0': No change '1': Corresponding bit in GPIO_OUT.G_OUT is cleared.
    pub fn g_out_clr1(&self) -> u32 {
        self.0
    }
    pub fn set_g_out_clr1(&mut self, value: u32) {
        self.0 = value;
    }
}
/// GPIO output set
#[derive(From, Into)]
pub struct GPIO_OUT_SET(u32);
impl GPIO_OUT_SET {
    /// Setting a bit in this field will immediately set the corresponding bit in GPIO_OUT.G_OUT. Reading this register always return 0.

    ///

    /// '0': No change '1': Corresponding bit in GPIO_OUT.G_OUT is set.
    pub fn g_out_set(&self) -> u32 {
        self.0
    }
    pub fn set_g_out_set(&mut self, value: u32) {
        self.0 = value;
    }
}
/// GPIO output set
#[derive(From, Into)]
pub struct GPIO_OUT_SET1(u32);
impl GPIO_OUT_SET1 {
    /// Bit 32-63 of field G_OUT_SET.

    ///

    /// '0': No change '1': Corresponding bit in GPIO_OUT.G_OUT is set.
    pub fn g_out_set1(&self) -> u32 {
        self.0
    }
    pub fn set_g_out_set1(&mut self, value: u32) {
        self.0 = value;
    }
}
/// Data register for VCore accesses (will not initiate access)
#[derive(From, Into)]
pub struct VA_DATA_INERT(u32);
impl VA_DATA_INERT {
    /// This field behaves in the same way as VA_DATA.VA_DATA. Except accesses (read or write) does not initiate VCore accesses. Writing to this register just overwrites the value currently held by all of the data registers (VA_DATA, VA_DATA_INCR, and VA_DATA_INERT).
    pub fn va_data_inert(&self) -> u32 {
        self.0
    }
    pub fn set_va_data_inert(&mut self, value: u32) {
        self.0 = value;
    }
}
