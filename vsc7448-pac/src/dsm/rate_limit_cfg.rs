// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Based on mesa-v2021.09 (https://github.com/microchip-ung/mesa/) which has
// the following copyright and license:
//
// Copyright (c) 2004-2021 Microchip Technology Inc. and its subsidiaries.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// This is an autogenerated file; do not edit by hand!
use derive_more::{From, Into};

/// Register `PRE_CNT_OFLW_STICKY`
///
/// Pause Frame pre-counter overflow sticky register
///
/// Pause Frame pre-counter overflow sticky register
#[derive(From, Into)]
pub struct PRE_CNT_OFLW_STICKY(u32);
impl PRE_CNT_OFLW_STICKY {    ///
    /// Will be set if one of the statistics pre counter have an overflow.
    ///
    /// '0': Pre counter overflow has not occurred '1': Pre counter overflow has occurred Bit is cleared by writing a '1' to this position.
    pub fn pre_cnt_oflw_sticky(&self) -> u32 {
        (self.0 & 0x100) >> 8
    }
    pub fn set_pre_cnt_oflw_sticky(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0x100);
        self.0 &= !0x100;
        self.0 |= value;
    }
}

/// Register `TX_FRAME_RATE_START_CFG`
///
/// Configuration register for txFrameRateStart
///
/// Configuration register for txFrameRateStart
#[derive(From, Into)]
pub struct TX_FRAME_RATE_START_CFG(u32);
impl TX_FRAME_RATE_START_CFG {    ///
    /// Value loaded into the txFrameRateTimer at the start of each packet, when TX_RATE_LIMIT_FRAME_RATE mode is enabled. Timer is decremented with each byte transmitted. IPG is set to timer value at EOF. Note: If resulting IPG is smaller than the minimum IPG of 12 bytes, it will be set to 12 bytes.
    ///
    /// Timer start value in bytes. To take effect, value must be above 84. (64byte min frame size, 8 byte preamble, 12 byte minimum IFG).
    pub fn tx_frame_rate_start(&self) -> u32 {
        (self.0 & 0xffff) >> 0
    }
    pub fn set_tx_frame_rate_start(&mut self, value: u32) {
        let value = value << 0;
        assert!(value <= 0xffff);
        self.0 &= !0xffff;
        self.0 |= value;
    }
}

/// Register `TX_IPG_STRETCH_RATIO_CFG`
///
/// Configuration register for txFineIpgStretchRatio
///
/// Configuration register for txFineIpgStretchRatio
#[derive(From, Into)]
pub struct TX_IPG_STRETCH_RATIO_CFG(u32);
impl TX_IPG_STRETCH_RATIO_CFG {    ///
    /// Determines the extent of the interPacketGap extension, when txRateLimitPayloadRate mode is enabled. It may be considered as the number of bits in a packet that would require 32 octets of interPacketGap extension. Note that each interPacketGap is increased by an integer number of octets, the average increase is ( (frame length in bits) * 32) / txFineIpgStretchRatio. Note: fractions left at frame border will be carried on to the next frame. Example: Packet length = 64 bytes + 8 bytes preamble value = 2048 IPG increase = 9 bytes Maximum IPG increase is 255 bytes.
    ///
    /// IPG increase = frame length in bits * 32 / value. values below 2048 and above 518143 are reserved for arithmetic processing  reasons.
    pub fn tx_fine_ipg_stretch_ratio(&self) -> u32 {
        (self.0 & 0x7ffff) >> 0
    }
    pub fn set_tx_fine_ipg_stretch_ratio(&mut self, value: u32) {
        let value = value << 0;
        assert!(value <= 0x7ffff);
        self.0 &= !0x7ffff;
        self.0 |= value;
    }
}

/// Register `TX_RATE_LIMIT_MODE`
///
/// Configuration register for rate limit modes
///
/// Configuration register for rate limit modes
#[derive(From, Into)]
pub struct TX_RATE_LIMIT_MODE(u32);
impl TX_RATE_LIMIT_MODE {    ///
    /// Scale the IPG calculated by txRateLimitFrameOverhead and/or txRateLimitPayloadRate by a power of 2 to enable shaping down to lower BW. Note: For txRateLimitPayloadRate only the additional overhead excluding the standard 12 byte IPG is scaled whereas for txRateLimitFrameOverhead the complete value is scaled.
    ///
    /// 0: Don't scale 1: Multiply by 2 2: Multiply by 4 (...) 10: Multiply by 1024 11-15: Reserved
    pub fn ipg_scale_val(&self) -> u32 {
        (self.0 & 0xf0000) >> 16
    }
    pub fn set_ipg_scale_val(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xf0000);
        self.0 &= !0xf0000;
        self.0 |= value;
    }    ///
    /// Defines if what is configured as header size in TX_RATE_LIMIT_HDR_SIZE::TX_RATE_LIMIT_HDR_CFG is subtracted form the payload in txRateLimitPayloadRate and txRateLimitFrameRate mode.
    ///
    /// 0: Nothing is subtracted from payload 1: TX_RATE_LIMIT_HDR_SIZE::TX_RATE_LIMIT_HDR_CFG is subtracted from payload
    pub fn payload_cfg(&self) -> u32 {
        (self.0 & 0x200) >> 9
    }
    pub fn set_payload_cfg(&mut self, value: u32) {
        let value = value << 9;
        assert!(value <= 0x200);
        self.0 &= !0x200;
        self.0 |= value;
    }    ///
    /// This bitgroup defines whether the preamble is counted as payload in txRateLimitPayloadRate and txRateLimitFrameRate mode.
    ///
    /// '0': Preamble is not counted as payload '1': Preamble is counted as payload
    pub fn payload_pream_cfg(&self) -> u32 {
        (self.0 & 0x100) >> 8
    }
    pub fn set_payload_pream_cfg(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0x100);
        self.0 &= !0x100;
        self.0 |= value;
    }    ///
    /// Enable for IPG reduction to allow adaption to clock frequency offsets. When this mode is enabled, all other TX_RATE_LIMIT modes must be disabled.
    ///
    /// '0': tx IPG reduction test feature disabled '1': tx IPG reduction test feature enabled
    pub fn tx_rate_ipg_ppm_adapt_ena(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    pub fn set_tx_rate_ipg_ppm_adapt_ena(&mut self, value: u32) {
        let value = value << 3;
        assert!(value <= 0x8);
        self.0 &= !0x8;
        self.0 |= value;
    }    ///
    /// Enable for accumulated rate limit mode. Instead of taking the maximum  IPG of txRateLimitFrameOverhead, txRateLimitPayloadRate and txRateLimitFrameRate. The resulting IPG is the sum of txRateLimitFrameOverhead and txRateLimitPayloadRate. txRateLimitFrameRate must be disabled.
    ///
    /// '0': Accumulated rate limit mode is disabled '1': Accumulated rate limit mode is enabled
    pub fn tx_rate_limit_accum_mode_ena(&self) -> u32 {
        (self.0 & 0x10) >> 4
    }
    pub fn set_tx_rate_limit_accum_mode_ena(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x10);
        self.0 &= !0x10;
        self.0 |= value;
    }    ///
    /// Enable txRateLimitFrameOverhead mode. IPG is increased by a fixed value specified in RATE_CTRL::FRM_GAP_COMP
    ///
    /// '0': txRateLimitFrameOverhead disabled '1': txRateLimitFrameOverhead enabled
    pub fn tx_rate_limit_frame_overhead_ena(&self) -> u32 {
        (self.0 & 0x1) >> 0
    }
    pub fn set_tx_rate_limit_frame_overhead_ena(&mut self, value: u32) {
        let value = value << 0;
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }    ///
    /// Enable txRateLimitFrameRate mode. IPG is extended so that frame_size + IPG result in the value configured in RATE_CTRL::TX_FRAME_RATE_START
    ///
    /// '0': txRateLimitFrameRate disabled '1': txRateLimitFrameRate enabled
    pub fn tx_rate_limit_frame_rate_ena(&self) -> u32 {
        (self.0 & 0x4) >> 2
    }
    pub fn set_tx_rate_limit_frame_rate_ena(&mut self, value: u32) {
        let value = value << 2;
        assert!(value <= 0x4);
        self.0 &= !0x4;
        self.0 |= value;
    }    ///
    /// Enable txRateLimitPayloadRate mode. IPG is increased relative to payload size.
    ///
    /// '0': txRateLimitPayloadRate disabled '1': txRateLimitPayloadRate enable
    pub fn tx_rate_limit_payload_rate_ena(&self) -> u32 {
        (self.0 & 0x2) >> 1
    }
    pub fn set_tx_rate_limit_payload_rate_ena(&mut self, value: u32) {
        let value = value << 1;
        assert!(value <= 0x2);
        self.0 &= !0x2;
        self.0 |= value;
    }
}
