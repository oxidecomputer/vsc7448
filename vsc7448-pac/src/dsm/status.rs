// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Based on mesa-v2021.09 (https://github.com/microchip-ung/mesa/) which has
// the following copyright and license:
//
// Copyright (c) 2004-2021 Microchip Technology Inc. and its subsidiaries.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// This is an autogenerated file; do not edit by hand!
use derive_more::{From, Into};
/// Counts number of aged frames.
///
/// This counter holds the number of aged frames from this port.
#[derive(From, Into)]
pub struct AGED_FRMS(u32);
impl AGED_FRMS {
    /// Count number of aged frames for each port.
    ///
    /// Counter can be written by SW.
    pub fn aged_frms_cnt(&self) -> u32 {
        self.0
    }
    pub fn set_aged_frms_cnt(&mut self, value: u32) {
        self.0 = value;
    }
}
/// Buffer Overflow
///
/// Buffer Overflow
#[derive(From, Into)]
pub struct BUF_OFLW_STICKY(u32);
impl BUF_OFLW_STICKY {
    /// Sticky bits for detecting buffer overflow in any of the cell buffers in the DSM.
    ///
    /// '0': No buffer overflow detected. '1': Buffer overflow detected. Bit is cleared by writing a '1' to this position.
    pub fn buf_oflw_sticky(&self) -> u32 {
        self.0
    }
    pub fn set_buf_oflw_sticky(&mut self, value: u32) {
        self.0 = value;
    }
}
/// Buffer Underrun
///
/// Buffer Underrun
#[derive(From, Into)]
pub struct BUF_UFLW_STICKY(u32);
impl BUF_UFLW_STICKY {
    /// Sticky bits for detecting buffer underflow in any of the cell buffers in the DSM.
    ///
    /// '0': No buffer underflow detected. '1': Buffer underflow detected. Bit is cleared by writing a '1' to this position.
    pub fn buf_uflw_sticky(&self) -> u32 {
        self.0
    }
    pub fn set_buf_uflw_sticky(&mut self, value: u32) {
        self.0 = value;
    }
}
/// Sticky bits for the DSM cell bus interface.
///
/// This register holds sticky bit information for the cell bus interface of the DSM.
#[derive(From, Into)]
pub struct CELL_BUS_STICKY(u32);
impl CELL_BUS_STICKY {
    /// This bit is set if data marked as SOF is received without the current frame has been terminated with EOF. The current frame will be terminated by setting the abort bit and the next frame will be discarded.
    ///
    /// '0': Missing EOF has not been detected. '1': Missing EOF has been detected. Bit is cleared by writing a '1' to this position.
    pub fn cell_bus_missing_eof_sticky(&self) -> u32 {
        self.0 & 0x1
    }
    pub fn set_cell_bus_missing_eof_sticky(&mut self, value: u32) {
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
    /// This bit is set if cells are received after an EOF and before the following SOF.
    ///
    /// '0': Missing SOF has not been detected. '1': Missing SOF has been detected. Bit is cleared by writing a '1' to this position.
    pub fn cell_bus_missing_sof_sticky(&self) -> u32 {
        (self.0 & 0x2) >> 1
    }
    pub fn set_cell_bus_missing_sof_sticky(&mut self, value: u32) {
        let value = value << 1;
        assert!(value <= 0x2);
        self.0 &= !0x2;
        self.0 |= value;
    }
}
/// Debug control
///
/// Configures which events are counterd in the ageing counter.
#[derive(From, Into)]
pub struct DBG_CTRL(u32);
impl DBG_CTRL {
    /// Controls which event the AGE counter counts. This setting is common for all aging counters.
    ///
    /// 0: Number of aged frames 1: Number of SOF transmitted on taxi bus 2: Number of EOF transmitted on taxi bus 3: Number of ABORT transmitted on taxi bus 4: Reserved 5: Number of retransmits requests received from port status 6: Reserved 7: Reserved
    pub fn dbg_event_ctrl(&self) -> u32 {
        self.0 & 0x7
    }
    pub fn set_dbg_event_ctrl(&mut self, value: u32) {
        assert!(value <= 0x7);
        self.0 &= !0x7;
        self.0 |= value;
    }
}
