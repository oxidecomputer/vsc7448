// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Based on mesa-v2021.09 (https://github.com/microchip-ung/mesa/) which has
// the following copyright and license:
//
// Copyright (c) 2004-2021 Microchip Technology Inc. and its subsidiaries.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// This is an autogenerated file; do not edit by hand!
use derive_more::{From, Into};
/// VCAP_CLM configuration
///
/// Replicated per lookup in VCAP_CLM.
#[derive(From, Into)]
pub struct ADV_CL_CFG(u32);
impl ADV_CL_CFG {
    /// VCAP_CLM key type used for frame types other than MPLS and IPv4/IPv6.
    ///
    /// 0: No Lookup 1: MLL 2: SGL_MLBS 3: DBL_MLBS 4: TRI_MLBS 5: TRI_VID 6: LL_FULL 7: NORMAL with SRC information 8: NORMAL with DST information 9: NORMAL_7TUPLE 10 NORMAL_5TUPLE_IP4 11 PURE_5TUPLE_IP4 15: No Lookup other: reserved
    pub fn etype_clm_key_sel(&self) -> u32 {
        (self.0 & 0x1e) >> 1
    }
    pub fn set_etype_clm_key_sel(&mut self, value: u32) {
        let value = value << 1;
        assert!(value <= 0x1e);
        self.0 &= !0x1e;
        self.0 |= value;
    }
    /// VCAP_CLM key type used for IPv4 frames.
    ///
    /// 0: Follow ETYPE_CLM_KEY_SEL selection 1: MLL 2: SGL_MLBS 3: DBL_MLBS 4: TRI_MLBS 5: TRI_VID 6: LL_FULL 7: NORMAL with SRC information 8: NORMAL with DST information 9: NORMAL_7TUPLE 10 NORMAL_5TUPLE_IP4 11 PURE_5TUPLE_IP4 15: No Lookup other: reserved
    pub fn ip4_clm_key_sel(&self) -> u32 {
        (self.0 & 0x1e00000) >> 21
    }
    pub fn set_ip4_clm_key_sel(&mut self, value: u32) {
        let value = value << 21;
        assert!(value <= 0x1e00000);
        self.0 &= !0x1e00000;
        self.0 |= value;
    }
    /// VCAP_CLM key type used for IPv6 frames.
    ///
    /// 0: Follow ETYPE_CLM_KEY_SEL selection 1: MLL 2: SGL_MLBS 3: DBL_MLBS 4: TRI_MLBS 5: TRI_VID 6: LL_FULL 7: NORMAL with SRC information 8: NORMAL with DST information 9: NORMAL_7TUPLE 10 NORMAL_5TUPLE_IP4 11 PURE_5TUPLE_IP4 15: No Lookup other: reserved
    pub fn ip6_clm_key_sel(&self) -> u32 {
        (self.0 & 0x1e0000) >> 17
    }
    pub fn set_ip6_clm_key_sel(&mut self, value: u32) {
        let value = value << 17;
        assert!(value <= 0x1e0000);
        self.0 &= !0x1e0000;
        self.0 |= value;
    }
    /// Enable VCAP_CLM lookup.
    ///
    /// 1: Enable 0: Disable
    pub fn lookup_ena(&self) -> u32 {
        self.0 & 0x1
    }
    pub fn set_lookup_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
    /// VCAP_CLM key type used when current protocol layer is MPLS label stack.
    ///
    /// 0: Follow ETYPE_CLM_KEY_SEL selection 2: SGL_MLBS 3: DBL_MLBS 4: TRI_MLBS 15: No Lookup other: reserved
    pub fn mlbs_clm_key_sel(&self) -> u32 {
        (self.0 & 0x1e0) >> 5
    }
    pub fn set_mlbs_clm_key_sel(&mut self, value: u32) {
        let value = value << 5;
        assert!(value <= 0x1e0);
        self.0 &= !0x1e0;
        self.0 |= value;
    }
    /// VCAP_CLM key type used for multicast MPLS frames (EtherType = 0x8847).
    ///
    /// 0: Follow ETYPE_CLM_KEY_SEL selection 1: MLL 2: SGL_MLBS 3: DBL_MLBS 4: TRI_MLBS 5: TRI_VID 6: LL_FULL 7: NORMAL with SRC information 8: NORMAL with DST information 9: NORMAL_7TUPLE 10 NORMAL_5TUPLE_IP4 11 PURE_5TUPLE_IP4 15: No Lookup other: reserved
    pub fn mpls_mc_clm_key_sel(&self) -> u32 {
        (self.0 & 0x1e00) >> 9
    }
    pub fn set_mpls_mc_clm_key_sel(&mut self, value: u32) {
        let value = value << 9;
        assert!(value <= 0x1e00);
        self.0 &= !0x1e00;
        self.0 |= value;
    }
    /// VCAP_CLM key type used for unicast MPLS frames (EtherType = 0x8847).
    ///
    /// 0: Follow ETYPE_CLM_KEY_SEL selection 1: MLL 2: SGL_MLBS 3: DBL_MLBS 4: TRI_MLBS 5: TRI_VID 6: LL_FULL 7: NORMAL with SRC information 8: NORMAL with DST information 9: NORMAL_7TUPLE 10 NORMAL_5TUPLE_IP4 11 PURE_5TUPLE_IP4 15: No Lookup other: reserved
    pub fn mpls_uc_clm_key_sel(&self) -> u32 {
        (self.0 & 0x1e000) >> 13
    }
    pub fn set_mpls_uc_clm_key_sel(&mut self, value: u32) {
        let value = value << 13;
        assert!(value <= 0x1e000);
        self.0 &= !0x1e000;
        self.0 |= value;
    }
    /// If set, the VCAP_CLM lookup uses the basic classified DSCP instead of the value from the frame.
    ///
    /// 1: Enable 0: Disable
    pub fn use_cl_dscp_ena(&self) -> u32 {
        (self.0 & 0x2000000) >> 25
    }
    pub fn set_use_cl_dscp_ena(&mut self, value: u32) {
        let value = value << 25;
        assert!(value <= 0x2000000);
        self.0 &= !0x2000000;
        self.0 |= value;
    }
    /// If set, the VCAP_CLM lookup uses the basic classified VID, DEI and PCP instead of the values from the frame.
    ///
    /// 1: Enable 0: Disable
    pub fn use_cl_tci0_ena(&self) -> u32 {
        (self.0 & 0x4000000) >> 26
    }
    pub fn set_use_cl_tci0_ena(&mut self, value: u32) {
        let value = value << 26;
        assert!(value <= 0x4000000);
        self.0 &= !0x4000000;
        self.0 |= value;
    }
}
/// VCAP_CLM range types per range checker
///
/// Define range checkers used in VCAP_CLM keys.
#[derive(From, Into)]
pub struct ADV_RNG_CTRL(u32);
impl ADV_RNG_CTRL {
    /// Selected frame field is matched against the range defined in ANA_CL::ADV_RNG_VALUE_CFG.
    ///
    /// 0: Idle (no matching) 1: TCP/UDP destination port is matched against range 2: TCP/UDP source port is matched against range 3: TCP/UDP destination and source ports are matched against range. There is a match if either of them matches. 4: Basic classified VID is matched against range 5: Basic classified DSCP value is matched against range 6: EtherType is matched against range.
    pub fn rng_type_sel(&self) -> u32 {
        self.0 & 0x7
    }
    pub fn set_rng_type_sel(&mut self, value: u32) {
        assert!(value <= 0x7);
        self.0 &= !0x7;
        self.0 |= value;
    }
}
/// VCAP_CLM range values per range checker
#[derive(From, Into)]
pub struct ADV_RNG_VALUE_CFG(u32);
impl ADV_RNG_VALUE_CFG {
    /// Upper range value. Value is included in range.
    pub fn rng_max_value(&self) -> u32 {
        (self.0 & 0xffff0000) >> 16
    }
    pub fn set_rng_max_value(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xffff0000);
        self.0 &= !0xffff0000;
        self.0 |= value;
    }
    /// Lower range value. Value is included in range.
    pub fn rng_min_value(&self) -> u32 {
        self.0 & 0xffff
    }
    pub fn set_rng_min_value(&mut self, value: u32) {
        assert!(value <= 0xffff);
        self.0 &= !0xffff;
        self.0 |= value;
    }
}
/// Aggregation code calculation
///
/// This register determines which fields contribute to the calculation of the 4-bit aggregation code. The aggregation code is used to select the egress port if multiple ports are aggregated. Fields enabled are XOR'ed together to generate the final aggregation code.
#[derive(From, Into)]
pub struct AGGR_CFG(u32);
impl AGGR_CFG {
    /// Allow destination MAC address to contribute to the aggregation code calculation.
    ///
    /// 0: Disable 1: Enable.
    pub fn aggr_dmac_ena(&self) -> u32 {
        (self.0 & 0x2) >> 1
    }
    pub fn set_aggr_dmac_ena(&mut self, value: u32) {
        let value = value << 1;
        assert!(value <= 0x2);
        self.0 &= !0x2;
        self.0 |= value;
    }
    /// Allow reversed DMAC address contribute to the aggregation code calculation.
    ///
    /// 0: Disable 1: Enable.
    pub fn aggr_dmac_reversed_ena(&self) -> u32 {
        (self.0 & 0x100) >> 8
    }
    pub fn set_aggr_dmac_reversed_ena(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0x100);
        self.0 &= !0x100;
        self.0 |= value;
    }
    /// Allow source and destination IPv4 addresses to contribute to the aggregation code calculation.
    ///
    /// 0: Disable 1: Enable.
    pub fn aggr_ip4_sipdip_ena(&self) -> u32 {
        (self.0 & 0x4) >> 2
    }
    pub fn set_aggr_ip4_sipdip_ena(&mut self, value: u32) {
        let value = value << 2;
        assert!(value <= 0x4);
        self.0 &= !0x4;
        self.0 |= value;
    }
    /// Allow IPv4 UDP/TCP destination and source port numbers to contribute to the aggregation code calculation.
    ///
    /// 0: Disable 1: Enable.
    pub fn aggr_ip4_tcpudp_port_ena(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    pub fn set_aggr_ip4_tcpudp_port_ena(&mut self, value: u32) {
        let value = value << 3;
        assert!(value <= 0x8);
        self.0 &= !0x8;
        self.0 |= value;
    }
    /// Allow IPv6 flow label to contribute to the aggregation code calculation.
    ///
    /// 0: Disable 1: Enable.
    pub fn aggr_ip6_flow_lbl_ena(&self) -> u32 {
        (self.0 & 0x20) >> 5
    }
    pub fn set_aggr_ip6_flow_lbl_ena(&mut self, value: u32) {
        let value = value << 5;
        assert!(value <= 0x20);
        self.0 &= !0x20;
        self.0 |= value;
    }
    /// Enable source and destination IPv6 addresses to contribute to the aggregation code calculation.
    ///
    /// 0: Disable 1: Enable.
    pub fn aggr_ip6_sipdip_ena(&self) -> u32 {
        (self.0 & 0x40) >> 6
    }
    pub fn set_aggr_ip6_sipdip_ena(&mut self, value: u32) {
        let value = value << 6;
        assert!(value <= 0x40);
        self.0 &= !0x40;
        self.0 |= value;
    }
    /// Allow IPv6 UDP/TCP destination and source port numbers to contribute to the aggregation code calculation.
    ///
    /// 0: Disable 1: Enable.
    pub fn aggr_ip6_tcpudp_port_ena(&self) -> u32 {
        (self.0 & 0x10) >> 4
    }
    pub fn set_aggr_ip6_tcpudp_port_ena(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x10);
        self.0 &= !0x10;
        self.0 |= value;
    }
    /// Allow the classified ISDX value to contribute to the aggregation code calculation.
    ///
    /// 0: Disable 1: Enable
    pub fn aggr_isdx_ena(&self) -> u32 {
        (self.0 & 0x400) >> 10
    }
    pub fn set_aggr_isdx_ena(&mut self, value: u32) {
        let value = value << 10;
        assert!(value <= 0x400);
        self.0 &= !0x400;
        self.0 |= value;
    }
    /// Enable a randomly generated aggregation code.
    ///
    /// 0: Disable 1: Enable.
    pub fn aggr_rnd_ena(&self) -> u32 {
        (self.0 & 0x80) >> 7
    }
    pub fn set_aggr_rnd_ena(&mut self, value: u32) {
        let value = value << 7;
        assert!(value <= 0x80);
        self.0 &= !0x80;
        self.0 |= value;
    }
    /// Allow source MAC address to contribute to the aggregation code calculation.
    ///
    /// 0: Disable 1: Enable.
    pub fn aggr_smac_ena(&self) -> u32 {
        self.0 & 0x1
    }
    pub fn set_aggr_smac_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
    /// Use the AC code received in the VStaX header as aggregation code.
    ///
    /// 0: Disable 1: Enable.
    pub fn aggr_use_vstax_ac_ena(&self) -> u32 {
        (self.0 & 0x200) >> 9
    }
    pub fn set_aggr_use_vstax_ac_ena(&mut self, value: u32) {
        let value = value << 9;
        assert!(value <= 0x200);
        self.0 &= !0x200;
        self.0 |= value;
    }
    /// Enable routed frames to update the aggregation code.
    ///
    /// 0: Disable 1: Enable.
    pub fn rt_upd_vstax_ac_ena(&self) -> u32 {
        (self.0 & 0x1000) >> 12
    }
    pub fn set_rt_upd_vstax_ac_ena(&mut self, value: u32) {
        let value = value << 12;
        assert!(value <= 0x1000);
        self.0 &= !0x1000;
        self.0 |= value;
    }
    /// Enable aggregation code calculations as in Jaguar1.
    ///
    /// 0: Disable 1: Enable.
    pub fn short_aggr_ena(&self) -> u32 {
        (self.0 & 0x800) >> 11
    }
    pub fn set_short_aggr_ena(&mut self, value: u32) {
        let value = value << 11;
        assert!(value <= 0x800);
        self.0 &= !0x800;
        self.0 |= value;
    }
}
/// Miscellaneous CLM configuration per lookup.
///
/// Miscellaneous CLM configuration per lookup.
#[derive(From, Into)]
pub struct CLM_KEY_CFG(u32);
impl CLM_KEY_CFG {
    /// Select version of TRI_VID key.
    ///
    /// 0: Use TRI_VID 1: Use TRI_VID_IDX
    pub fn clm_tri_vid_sel(&self) -> u32 {
        self.0 & 0x1
    }
    pub fn set_clm_tri_vid_sel(&mut self, value: u32) {
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
}
/// Miscellaneous VCAP_CLM configuration
#[derive(From, Into)]
pub struct CLM_MISC_CTRL(u32);
impl CLM_MISC_CTRL {
    /// Select default value of the G_IDX field in VCAP CLM.
    ///
    /// 0: Set G_IDX to zero 1: Set G_IDX to the frame's logical port number 2: Set G_IDX to the frame's masqueraded port number 3: Reserved
    pub fn clm_gidx_def_sel(&self) -> u32 {
        (self.0 & 0x180000) >> 19
    }
    pub fn set_clm_gidx_def_sel(&mut self, value: u32) {
        let value = value << 19;
        assert!(value <= 0x180000);
        self.0 &= !0x180000;
        self.0 |= value;
    }
    /// Enable VCAP_CLM key field IGR_PORT_MASK_SEL=3 for CPU injected frames.
    ///
    /// 0: Disable 1: Enable.
    pub fn cpu_igr_mask_ena(&self) -> u32 {
        self.0 & 0x1
    }
    pub fn set_cpu_igr_mask_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
    /// Select VCAP_CLM key when a VCAP_CLM lookup is enforced by LBK_CLM_FORCE_ENA or IGR_PORT_CLM_FORCE_ENA.
    ///
    /// 0: Use NORMAL key with destination information 1: Use NORMAL key with source information 2: Use NORMAL_7TUPLE key 3: Use NORMAL_5TUPLE_IP4 key
    pub fn forced_key_sel(&self) -> u32 {
        (self.0 & 0x60000) >> 17
    }
    pub fn set_forced_key_sel(&mut self, value: u32) {
        let value = value << 17;
        assert!(value <= 0x60000);
        self.0 &= !0x60000;
        self.0 |= value;
    }
    /// Force no VCAP_CLM lookup if frame is discarded or redirected by VCAP_CLM (this can be overruled with IGR_PORT_CLM_FORCE_ENA).
    ///
    /// 0: Disable 1: Enable.
    pub fn force_no_clm_for_basic_dis(&self) -> u32 {
        (self.0 & 0x200000) >> 21
    }
    pub fn set_force_no_clm_for_basic_dis(&mut self, value: u32) {
        let value = value << 21;
        assert!(value <= 0x200000);
        self.0 &= !0x200000;
        self.0 |= value;
    }
    /// Enable VCAP_CLM key field IGR_PORT_MASK_SEL=3 for frames received with VStaX header.
    ///
    /// 0: Disable 1: Enable.
    pub fn fp_vs2_igr_mask_ena(&self) -> u32 {
        (self.0 & 0x4) >> 2
    }
    pub fn set_fp_vs2_igr_mask_ena(&mut self, value: u32) {
        let value = value << 2;
        assert!(value <= 0x4);
        self.0 &= !0x4;
        self.0 |= value;
    }
    /// By default, frames discarded or redirected at a earlier pipeline point are not subject to further VCAP_CLM lookups. This configuration controls whether a VCAP_CLM lookup is enforced. See FORCED_KEY_SEL for key selection. When enforcing a VCAP_CLM lookup, the classified ISDX is placed in the VCAP_CLM key field G_IDX.
    ///
    /// Bit 0: Force VCAP_CLM lookup #0 with key selected by FORCED_KEY_SEL Bit 1: Force VCAP_CLM lookup #1 with key selected by FORCED_KEY_SEL ...
    pub fn igr_port_clm_force_ena(&self) -> u32 {
        (self.0 & 0x7e0) >> 5
    }
    pub fn set_igr_port_clm_force_ena(&mut self, value: u32) {
        let value = value << 5;
        assert!(value <= 0x7e0);
        self.0 &= !0x7e0;
        self.0 |= value;
    }
    /// By default, looped frames are not subject to VCAP_CLM lookups. This configuration controls whether a VCAP_CLM lookup is enforced. See FORCED_KEY_SEL for key selection. When enforcing a VCAP_CLM lookup for looped frames, the classified ISDX is placed in the VCAP_CLM key field G_IDX.
    ///
    /// Bit 0: Force VCAP_CLM lookup #0 with key selected by FORCED_KEY_SEL Bit 1: Force VCAP_CLM lookup #1 with key selected by FORCED_KEY_SEL ...
    pub fn lbk_clm_force_ena(&self) -> u32 {
        (self.0 & 0x1f800) >> 11
    }
    pub fn set_lbk_clm_force_ena(&mut self, value: u32) {
        let value = value << 11;
        assert!(value <= 0x1f800);
        self.0 &= !0x1f800;
        self.0 |= value;
    }
    /// Force VCAP_CLM lookup to use VCAP_CLM key field IGR_PORT_MASK_SEL=3 for looped frames instead of IGR_PORT_MASK_SEL=1.
    ///
    /// 0: Disable 1: Enable.
    pub fn lbk_igr_mask_sel3_ena(&self) -> u32 {
        (self.0 & 0x10) >> 4
    }
    pub fn set_lbk_igr_mask_sel3_ena(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x10);
        self.0 &= !0x10;
        self.0 |= value;
    }
    /// Enable VCAP_CLM key field IGR_PORT_MASK_SEL=2 for masqueraded frames.
    ///
    /// 0: Disable 1: Enable.
    pub fn masq_igr_mask_ena(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    pub fn set_masq_igr_mask_ena(&mut self, value: u32) {
        let value = value << 3;
        assert!(value <= 0x8);
        self.0 &= !0x8;
        self.0 |= value;
    }
    /// Enable VCAP_CLM key field IGR_PORT_MASK_SEL=3 for frames from VD0 or VD1.
    ///
    /// 0: Disable 1: Enable.
    pub fn vd_igr_mask_ena(&self) -> u32 {
        (self.0 & 0x2) >> 1
    }
    pub fn set_vd_igr_mask_ena(&mut self, value: u32) {
        let value = value << 1;
        assert!(value <= 0x2);
        self.0 &= !0x2;
        self.0 |= value;
    }
}
/// Common stack configuration
#[derive(From, Into)]
pub struct COMMON_VSTAX_CFG(u32);
impl COMMON_VSTAX_CFG {
    /// Enable / disable getting DSCP from VSTAX MISC field when encoding as AC.
    ///
    /// 0: Disable 1: Enable (VSTAX MISC contains DSCP)
    pub fn vstax2_misc_dscp_ena(&self) -> u32 {
        self.0 & 0x1
    }
    pub fn set_vstax2_misc_dscp_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
}
/// QoS class per address of BPDU, GARP, and CCM frames.
///
/// The register instance number corresponds to the address of the extracted frame. For instance: CPU_8021_QOS_CFG[4].BPDU_QOS is the QoS class used for BPDU frames with address 01-80-C2-00-00-04.
#[derive(From, Into)]
pub struct CPU_8021_QOS_CFG(u32);
impl CPU_8021_QOS_CFG {
    /// Configures QoS class for frames with DMAC in BPDU range that are redirected to the CPU.
    pub fn bpdu_qos(&self) -> u32 {
        self.0 & 0x7
    }
    pub fn set_bpdu_qos(&mut self, value: u32) {
        assert!(value <= 0x7);
        self.0 &= !0x7;
        self.0 |= value;
    }
    /// Configures QoS class for frames with DMAC in GXRP range that are redirected to the CPU.
    pub fn gxrp_qos(&self) -> u32 {
        (self.0 & 0x70) >> 4
    }
    pub fn set_gxrp_qos(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x70);
        self.0 &= !0x70;
        self.0 |= value;
    }
    /// Configures QoS class for frames with DMAC in Y1731_AG protocol range that are redirected to the CPU.
    pub fn y1731_ag_qos(&self) -> u32 {
        (self.0 & 0x700) >> 8
    }
    pub fn set_y1731_ag_qos(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0x700);
        self.0 &= !0x700;
        self.0 |= value;
    }
}
/// CPU extraction queue per address of BPDU, GARP, and CCM frames.
///
/// The register instance number corresponds to the address of the extracted frame. For instance: CPU_8021_QU_CFG[4].CPU_BPDU_QU is the CPU extraction queue used for BPDU frames with address 01-80-C2-00-00-04.
#[derive(From, Into)]
pub struct CPU_8021_QU_CFG(u32);
impl CPU_8021_QU_CFG {
    /// CPU extraction queue for BPDU frames.
    pub fn cpu_bpdu_qu(&self) -> u32 {
        self.0 & 0x7
    }
    pub fn set_cpu_bpdu_qu(&mut self, value: u32) {
        assert!(value <= 0x7);
        self.0 &= !0x7;
        self.0 |= value;
    }
    /// CPU extraction queue for GXRP frames.
    pub fn cpu_gxrp_qu(&self) -> u32 {
        (self.0 & 0x38) >> 3
    }
    pub fn set_cpu_gxrp_qu(&mut self, value: u32) {
        let value = value << 3;
        assert!(value <= 0x38);
        self.0 &= !0x38;
        self.0 |= value;
    }
    /// CPU extraction queue used for IEEE802.1ag and Y.1731 frames.
    pub fn cpu_y1731_ag_qu(&self) -> u32 {
        (self.0 & 0x1c0) >> 6
    }
    pub fn set_cpu_y1731_ag_qu(&mut self, value: u32) {
        let value = value << 6;
        assert!(value <= 0x1c0);
        self.0 &= !0x1c0;
        self.0 |= value;
    }
}
/// CPU extraction queue configuration
#[derive(From, Into)]
pub struct CPU_PROTO_QU_CFG(u32);
impl CPU_PROTO_QU_CFG {
    /// CPU extraction queue used for IPv6 Hop by hop and ICMP frames.
    pub fn cpu_hop_by_hop_icmp_qu(&self) -> u32 {
        (self.0 & 0x7000) >> 12
    }
    pub fn set_cpu_hop_by_hop_icmp_qu(&mut self, value: u32) {
        let value = value << 12;
        assert!(value <= 0x7000);
        self.0 &= !0x7000;
        self.0 |= value;
    }
    /// CPU extraction queue used for IGMP frames.
    pub fn cpu_igmp_qu(&self) -> u32 {
        self.0 & 0x7
    }
    pub fn set_cpu_igmp_qu(&mut self, value: u32) {
        assert!(value <= 0x7);
        self.0 &= !0x7;
        self.0 |= value;
    }
    /// CPU extraction queue used for IPv4 multicast control frames.
    pub fn cpu_ip4_mc_ctrl_qu(&self) -> u32 {
        (self.0 & 0x38) >> 3
    }
    pub fn set_cpu_ip4_mc_ctrl_qu(&mut self, value: u32) {
        let value = value << 3;
        assert!(value <= 0x38);
        self.0 &= !0x38;
        self.0 |= value;
    }
    /// CPU extraction queue used for IPv6 multicast control frames.
    pub fn cpu_ip6_mc_ctrl_qu(&self) -> u32 {
        (self.0 & 0x1c0) >> 6
    }
    pub fn set_cpu_ip6_mc_ctrl_qu(&mut self, value: u32) {
        let value = value << 6;
        assert!(value <= 0x1c0);
        self.0 &= !0x1c0;
        self.0 |= value;
    }
    /// CPU extraction queue used for MLD frames.
    pub fn cpu_mld_qu(&self) -> u32 {
        (self.0 & 0xe00) >> 9
    }
    pub fn set_cpu_mld_qu(&mut self, value: u32) {
        let value = value << 9;
        assert!(value <= 0xe00);
        self.0 &= !0xe00;
        self.0 |= value;
    }
    /// CPU extraction queue used for VRAP frames.
    pub fn cpu_vrap_qu(&self) -> u32 {
        (self.0 & 0x38000) >> 15
    }
    pub fn set_cpu_vrap_qu(&mut self, value: u32) {
        let value = value << 15;
        assert!(value <= 0x38000);
        self.0 &= !0x38000;
        self.0 |= value;
    }
}
/// Various configuration per DSCP
#[derive(From, Into)]
pub struct DSCP_CFG(u32);
impl DSCP_CFG {
    /// DP level for DSCP value if enabled (ANA_CL:PORT:QOS_CFG.DSCP_DP_ENA).
    pub fn dscp_dp_val(&self) -> u32 {
        (self.0 & 0xc) >> 2
    }
    pub fn set_dscp_dp_val(&mut self, value: u32) {
        let value = value << 2;
        assert!(value <= 0xc);
        self.0 &= !0xc;
        self.0 |= value;
    }
    /// QoS class for DSCP value if enabled (ANA_CL:PORT:QOS_CFG.DSCP_QOS_ENA).
    pub fn dscp_qos_val(&self) -> u32 {
        (self.0 & 0x70) >> 4
    }
    pub fn set_dscp_qos_val(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x70);
        self.0 &= !0x70;
        self.0 |= value;
    }
    /// Set if the DSCP value is selected to be rewritten. This is controlled in ANA_CL:PORT:QOS_CFG.DSCP_REWR_MODE_SEL.
    pub fn dscp_rewr_ena(&self) -> u32 {
        (self.0 & 0x2) >> 1
    }
    pub fn set_dscp_rewr_ena(&mut self, value: u32) {
        let value = value << 1;
        assert!(value <= 0x2);
        self.0 &= !0x2;
        self.0 |= value;
    }
    /// Translated DSCP value if DSCP translation is enabled on the port (ANA_CL:PORT:QOS_CFG.DSCP_TRANSLATE_ENA).
    pub fn dscp_translate_val(&self) -> u32 {
        (self.0 & 0x1f80) >> 7
    }
    pub fn set_dscp_translate_val(&mut self, value: u32) {
        let value = value << 7;
        assert!(value <= 0x1f80);
        self.0 &= !0x1f80;
        self.0 |= value;
    }
    /// If set, the DSCP value is trusted and can be used for QoS and DP classification.
    pub fn dscp_trust_ena(&self) -> u32 {
        self.0 & 0x1
    }
    pub fn set_dscp_trust_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
}
/// HMD port configurations
#[derive(From, Into)]
pub struct HM_CFG(u32);
impl HM_CFG {
    /// Contains the port number of the used HMD X port
    pub fn hmd_port(&self) -> u32 {
        (self.0 & 0xfc) >> 2
    }
    pub fn set_hmd_port(&mut self, value: u32) {
        let value = value << 2;
        assert!(value <= 0xfc);
        self.0 &= !0xfc;
        self.0 |= value;
    }
    /// Enable the configured port as HMD port.
    ///
    /// 0: Disable 1: Enable
    pub fn hmd_port_vld(&self) -> u32 {
        self.0 & 0x1
    }
    pub fn set_hmd_port_vld(&mut self, value: u32) {
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
    /// If set, VCAP_CLM action MAP_KEY = 2 uses HIH.PCP and HIH.DEI instead of PCP and DEI from the frame's third tag. This enables mapping HIH values to internal values (DP, COS ID).
    ///
    /// 0: Disable 1: Enable
    pub fn hm_force_mode_ena(&self) -> u32 {
        (self.0 & 0x2) >> 1
    }
    pub fn set_hm_force_mode_ena(&mut self, value: u32) {
        let value = value << 1;
        assert!(value <= 0x2);
        self.0 &= !0x2;
        self.0 |= value;
    }
}
/// Various MPLS configuration
#[derive(From, Into)]
pub struct MPLS_CFG(u32);
impl MPLS_CFG {
    /// CPU copy of frames when channel_type check for G8113.1 (MPLS_OAM_FLAVOR) is not 0x8902.
    pub fn cpu_mpls_g8113_1_non_oam_ena(&self) -> u32 {
        (self.0 & 0x20000) >> 17
    }
    pub fn set_cpu_mpls_g8113_1_non_oam_ena(&mut self, value: u32) {
        let value = value << 17;
        assert!(value <= 0x20000);
        self.0 &= !0x20000;
        self.0 |= value;
    }
    /// Selects CPU queue when channel type is not 0x8902 and CPU_MPLS_G8113_1_NON_OAM_ENA is set.
    pub fn cpu_mpls_g8113_1_non_oam_qu(&self) -> u32 {
        (self.0 & 0x1c0000) >> 18
    }
    pub fn set_cpu_mpls_g8113_1_non_oam_qu(&mut self, value: u32) {
        let value = value << 18;
        assert!(value <= 0x1c0000);
        self.0 &= !0x1c0000;
        self.0 |= value;
    }
    /// Selects CPU queue for IP frames received as LSR POP (FWD_TYPE=3) with (nxt_type_after_offset = CW).
    pub fn cpu_mpls_ip_traffic_qu(&self) -> u32 {
        (self.0 & 0x38000000) >> 27
    }
    pub fn set_cpu_mpls_ip_traffic_qu(&mut self, value: u32) {
        let value = value << 27;
        assert!(value <= 0x38000000);
        self.0 &= !0x38000000;
        self.0 |= value;
    }
    /// CPU queue when frames are detected as MPLS MIP OAM.
    pub fn cpu_mpls_mip_qu(&self) -> u32 {
        (self.0 & 0xe00000) >> 21
    }
    pub fn set_cpu_mpls_mip_qu(&mut self, value: u32) {
        let value = value << 21;
        assert!(value <= 0xe00000);
        self.0 &= !0xe00000;
        self.0 |= value;
    }
    /// CPU queue when frames are detected as Vccv2 or Vccv3 OAM but without (nxt_type_after_offset = CW) or incorrect ACH.
    pub fn cpu_mpls_oam_def_qu(&self) -> u32 {
        (self.0 & 0x7000000) >> 24
    }
    pub fn set_cpu_mpls_oam_def_qu(&mut self, value: u32) {
        let value = value << 24;
        assert!(value <= 0x7000000);
        self.0 &= !0x7000000;
        self.0 |= value;
    }
    /// CPU copy of frames when MPLS OAM MEP err occur.
    pub fn cpu_mpls_oam_mep_err_ena(&self) -> u32 {
        (self.0 & 0x2000) >> 13
    }
    pub fn set_cpu_mpls_oam_mep_err_ena(&mut self, value: u32) {
        let value = value << 13;
        assert!(value <= 0x2000);
        self.0 &= !0x2000;
        self.0 |= value;
    }
    /// Selects CPU queue when error occured when fwd_type = 3.
    pub fn cpu_mpls_oam_mep_err_qu(&self) -> u32 {
        (self.0 & 0x1c000) >> 14
    }
    pub fn set_cpu_mpls_oam_mep_err_qu(&mut self, value: u32) {
        let value = value << 14;
        assert!(value <= 0x1c000);
        self.0 &= !0x1c000;
        self.0 |= value;
    }
    /// CPU copy of frames when MPLS POP err occur.
    pub fn cpu_mpls_pop_err_ena(&self) -> u32 {
        (self.0 & 0x200) >> 9
    }
    pub fn set_cpu_mpls_pop_err_ena(&mut self, value: u32) {
        let value = value << 9;
        assert!(value <= 0x200);
        self.0 &= !0x200;
        self.0 |= value;
    }
    /// Selects CPU queue when error occured when fwd_type = 3.
    pub fn cpu_mpls_pop_err_qu(&self) -> u32 {
        (self.0 & 0x1c00) >> 10
    }
    pub fn set_cpu_mpls_pop_err_qu(&mut self, value: u32) {
        let value = value << 10;
        assert!(value <= 0x1c00);
        self.0 &= !0x1c00;
        self.0 |= value;
    }
    /// CPU copy of frames when termination PW (fwd_type = PW).
    pub fn cpu_mpls_pw_err_ena(&self) -> u32 {
        self.0 & 0x1
    }
    pub fn set_cpu_mpls_pw_err_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
    /// Selects CPU queue when error occured when fwd_type = PW.
    pub fn cpu_mpls_pw_err_qu(&self) -> u32 {
        (self.0 & 0xe) >> 1
    }
    pub fn set_cpu_mpls_pw_err_qu(&mut self, value: u32) {
        let value = value << 1;
        assert!(value <= 0xe);
        self.0 &= !0xe;
        self.0 |= value;
    }
    /// CPU termination of frames when termination PW (fwd_type = PW) with iTTL TTL=0. Can be send to CPU controlled through CPU_MPLS_PW_ERR_ENA
    pub fn cpu_mpls_pw_ttl0_redir_ena(&self) -> u32 {
        (self.0 & 0x10) >> 4
    }
    pub fn set_cpu_mpls_pw_ttl0_redir_ena(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x10);
        self.0 &= !0x10;
        self.0 |= value;
    }
    /// CPU copy of frames when MPLS swap err occur.
    pub fn cpu_mpls_swap_err_ena(&self) -> u32 {
        (self.0 & 0x20) >> 5
    }
    pub fn set_cpu_mpls_swap_err_ena(&mut self, value: u32) {
        let value = value << 5;
        assert!(value <= 0x20);
        self.0 &= !0x20;
        self.0 |= value;
    }
    /// Selects CPU queue when error occured when fwd_type = 2.
    pub fn cpu_mpls_swap_err_qu(&self) -> u32 {
        (self.0 & 0x1c0) >> 6
    }
    pub fn set_cpu_mpls_swap_err_qu(&mut self, value: u32) {
        let value = value << 6;
        assert!(value <= 0x1c0);
        self.0 &= !0x1c0;
        self.0 |= value;
    }
    /// If set Rsvd label is kept for VCCV4, LSP and SEGMENT OAM.
    pub fn mpls_oam_keep_gal_ena(&self) -> u32 {
        (self.0 & 0x80000000) >> 31
    }
    pub fn set_mpls_oam_keep_gal_ena(&mut self, value: u32) {
        let value = value << 31;
        assert!(value <= 0x80000000);
        self.0 &= !0x80000000;
        self.0 |= value;
    }
    /// If set only a valid selected TC_VAL by means of VCAP_CLM action TC_LABEL / TC_ENA can be used for looking up the QoS mapping table.
    pub fn mpls_sel_tc_only_ena(&self) -> u32 {
        (self.0 & 0x40000000) >> 30
    }
    pub fn set_mpls_sel_tc_only_ena(&mut self, value: u32) {
        let value = value << 30;
        assert!(value <= 0x40000000);
        self.0 &= !0x40000000;
        self.0 |= value;
    }
}
/// Various MPLS OAM LM configuration
#[derive(From, Into)]
pub struct MPLS_LM_CFG(u32);
impl MPLS_LM_CFG {
    /// Controls if profile should be part of OAM LM count.
    pub fn mpls_common_err_lm_cnt_dis(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    pub fn set_mpls_common_err_lm_cnt_dis(&mut self, value: u32) {
        let value = value << 3;
        assert!(value <= 0x8);
        self.0 &= !0x8;
        self.0 |= value;
    }
    /// Controls if profile should be part of OAM LM count.
    pub fn mpls_g8113_1_non_oam_lm_cnt_dis(&self) -> u32 {
        self.0 & 0x1
    }
    pub fn set_mpls_g8113_1_non_oam_lm_cnt_dis(&mut self, value: u32) {
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
    /// Controls if profile should be part of OAM LM count.
    pub fn mpls_ip_err_lm_cnt_dis(&self) -> u32 {
        (self.0 & 0x10) >> 4
    }
    pub fn set_mpls_ip_err_lm_cnt_dis(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x10);
        self.0 &= !0x10;
        self.0 |= value;
    }
    /// Controls if profile should be part of OAM LM count.
    pub fn mpls_oam_def_lm_cnt_dis(&self) -> u32 {
        (self.0 & 0x4) >> 2
    }
    pub fn set_mpls_oam_def_lm_cnt_dis(&mut self, value: u32) {
        let value = value << 2;
        assert!(value <= 0x4);
        self.0 &= !0x4;
        self.0 |= value;
    }
    /// Controls if profile should be part of OAM LM count.
    pub fn mpls_oam_err_lm_cnt_dis(&self) -> u32 {
        (self.0 & 0x2) >> 1
    }
    pub fn set_mpls_oam_err_lm_cnt_dis(&mut self, value: u32) {
        let value = value << 1;
        assert!(value <= 0x2);
        self.0 &= !0x2;
        self.0 |= value;
    }
    /// Controls if profile should be part of OAM LM count.
    pub fn mpls_pw_term_err_lm_cnt_dis(&self) -> u32 {
        (self.0 & 0x20) >> 5
    }
    pub fn set_mpls_pw_term_err_lm_cnt_dis(&mut self, value: u32) {
        let value = value << 5;
        assert!(value <= 0x20);
        self.0 &= !0x20;
        self.0 |= value;
    }
}
/// Miscellaneous MPLS configuration.
///
/// Miscellaneous MPLS configuration.
#[derive(From, Into)]
pub struct MPLS_MISC_CFG(u32);
impl MPLS_MISC_CFG {
    /// Enable skipping of reserved label during label extract. In order for a reserved label to be skipped, either MPLS_RSV_LBL_CFG[<label>].RSVD_LBL_SKIP_ENA or MPLS_MISC_CFG.CLM_RSVD_LBL_SKIP_ENA[<clm idx>] must be set.
    ///
    /// Bit 0: Skip reserved label when generating MPLS label keys for VCAP_CLM lookup #0. Bit 1: Skip reserved label when generating MPLS label keys for VCAP_CLM lookup #1. ...
    pub fn clm_rsvd_lbl_skip_ena(&self) -> u32 {
        self.0 & 0x3f
    }
    pub fn set_clm_rsvd_lbl_skip_ena(&mut self, value: u32) {
        assert!(value <= 0x3f);
        self.0 &= !0x3f;
        self.0 |= value;
    }
    /// G8113_1 Channel type
    pub fn g8113_1_ach_ch_type(&self) -> u32 {
        (self.0 & 0xffff0000) >> 16
    }
    pub fn set_g8113_1_ach_ch_type(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xffff0000);
        self.0 &= !0xffff0000;
        self.0 |= value;
    }
}
/// MPLS configuration per reserved MPLS label
///
/// This register enabling each of the 16 Reserved MPLS Labels (Label Value < 16) for Skipping. Note: Handling of reserved labels require that the reserved label is within NUM_VLD_LABELS of the CLM entry that has been hit for MLBS or FULL action or that the reserved label is first label for MLBS_REDUCED action. The RESERVED LABELS have been assigned the following meaning (RFC 3032). ------------------------------------------------------------------- 0: IPv4 Explicit NULL Label 1: Router Alert Label (RAL) 2: IPv6 Explicit NULL Label 3: Reserved (Implicit NULL Label - Never in stack) 4: (Reserved - Not yet assigned) 5: (Reserved - Not yet assigned) 6: (Reserved - Not yet assigned) 7: (Reserved - Not yet assigned) 8: (Reserved - Not yet assigned) 9: (Reserved - Not yet assigned) 10: (Reserved - Not yet assigned) 11: (Reserved - Not yet assigned) 12: (Reserved - Not yet assigned) 13: Generic Alert Label (GAL) 14: OAM Alert Label (OAL) 15: (Reserved - Not yet assigned) -------------------------------------------------------------------
#[derive(From, Into)]
pub struct MPLS_RSV_LBL_CFG(u32);
impl MPLS_RSV_LBL_CFG {
    /// Enable skipping of reserved label during label extract. In order for a reserved label to be skipped, either MPLS_RSV_LBL_CFG[<label>].RSVD_LBL_SKIP_ENA or MPLS_MISC_CFG.CLM_RSVD_LBL_SKIP_ENA[<clm idx>] must be set.
    ///
    /// 0: Allow reserved label to be part of MPLS label keys 1: Reserved label will be skipped when generating MPLS label keys
    pub fn rsvd_lbl_skip_ena(&self) -> u32 {
        self.0 & 0x1
    }
    pub fn set_rsvd_lbl_skip_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
}
/// Various MPLS OAM configuration
#[derive(From, Into)]
pub struct OAM_CFG(u32);
impl OAM_CFG {
    /// Used to enable VCCV2 OAM signalling. If not enabled, VCCV2 signalling can not be configured.
    ///
    /// 0: Disable VCCV2 signalling 1: Enable VCCV2 signalling
    pub fn vccv2_ena(&self) -> u32 {
        self.0 & 0x1
    }
    pub fn set_vccv2_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
    /// Reserved Label used for PW VCCV2 OAM channel. Default is to use (Router Alert Label = 1)
    pub fn vccv2_label(&self) -> u32 {
        (self.0 & 0x1e) >> 1
    }
    pub fn set_vccv2_label(&mut self, value: u32) {
        let value = value << 1;
        assert!(value <= 0x1e);
        self.0 &= !0x1e;
        self.0 |= value;
    }
}
/// Configuration per QoS class and DP level
#[derive(From, Into)]
pub struct QOS_MAP_CFG(u32);
impl QOS_MAP_CFG {
    /// Table values for rewriting DSCP values using DP level and QoS class if enabled. Map the frame's DP level and QoS class to a DSCP value. DSCP = QOS_MAP_CFG[8*DP level + QoS class].DSCP_REWR_VAL. This is controlled in ANA_CL:PORT:QOS_CFG.DSCP_REWR_MODE_SEL and ANA_CL::DSCP_CFG.DSCP_REWR_ENA.
    pub fn dscp_rewr_val(&self) -> u32 {
        (self.0 & 0x3f0) >> 4
    }
    pub fn set_dscp_rewr_val(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x3f0);
        self.0 &= !0x3f0;
        self.0 |= value;
    }
}
/// Configure UPSID when stacking
#[derive(From, Into)]
pub struct UPSID_CFG(u32);
impl UPSID_CFG {
    /// Configures own unit port set ID (UPSID) to be used for stacking. The configured value must be even. Port numbers below 32 will use the configured (even) UPSID, whereas port numbers >=32 will use the configured UPSID plus 1. This must be configured consistently across the following registers: ANA_CL::UPSID_CFG.UPSID_NUM ANA_AC::COMMON_VSTAX_CFG.OWN_UPSID ANA_L2::VSTAX_CTRL.OWN_UPSID REW::COMMON_CTRL.OWN_UPSID
    pub fn upsid_num(&self) -> u32 {
        self.0 & 0x1f
    }
    pub fn set_upsid_num(&mut self, value: u32) {
        assert!(value <= 0x1f);
        self.0 &= !0x1f;
        self.0 |= value;
    }
}
/// Custom S-tag EtherTypes
///
/// In addition to these custom TPID values, tags with TPID = 0x88A8 are always recognized as S-tags.
#[derive(From, Into)]
pub struct VLAN_STAG_CFG(u32);
impl VLAN_STAG_CFG {
    /// Configurable S-tag TPID EtherType. This value must be configured identically in REW::TPID_CFG.TPID_VAL.
    pub fn stag_etype_val(&self) -> u32 {
        self.0 & 0xffff
    }
    pub fn set_stag_etype_val(&mut self, value: u32) {
        assert!(value <= 0xffff);
        self.0 &= !0xffff;
        self.0 |= value;
    }
}
/// VRAP classifier configuration
#[derive(From, Into)]
pub struct VRAP_CFG(u32);
impl VRAP_CFG {
    /// VID value for VRAP frames.
    pub fn vrap_vid(&self) -> u32 {
        self.0 & 0xfff
    }
    pub fn set_vrap_vid(&mut self, value: u32) {
        assert!(value <= 0xfff);
        self.0 &= !0xfff;
        self.0 |= value;
    }
    /// If set, VRAP frames must be single VLAN tagged and the frame's VID must match ANA_CL::VRAP_CFG.VRAP_VID. If cleared, VRAP frames must be untagged.
    pub fn vrap_vlan_aware_ena(&self) -> u32 {
        (self.0 & 0x1000) >> 12
    }
    pub fn set_vrap_vlan_aware_ena(&mut self, value: u32) {
        let value = value << 12;
        assert!(value <= 0x1000);
        self.0 &= !0x1000;
        self.0 |= value;
    }
}
/// VRAP data
#[derive(From, Into)]
pub struct VRAP_HDR_DATA(u32);
impl VRAP_HDR_DATA {
    /// A VRAP frame's VRAP header is matched against VRAP_HDR_DATA, except for bits don't cared by VRAP_HDR_MASK. The VRAP header is four bytes located in the frame after EtherType = 0x8808 and EPID = 0x0004.
    pub fn vrap_hdr_data(&self) -> u32 {
        self.0
    }
    pub fn set_vrap_hdr_data(&mut self, value: u32) {
        self.0 = value;
    }
}
/// VRAP mask
#[derive(From, Into)]
pub struct VRAP_HDR_MASK(u32);
impl VRAP_HDR_MASK {
    /// Bits set in VRAP_HDR_MASK don't care the equivalent bits in VRAP_HDR_DATA.
    pub fn vrap_hdr_mask(&self) -> u32 {
        self.0
    }
    pub fn set_vrap_hdr_mask(&mut self, value: u32) {
        self.0 = value;
    }
}
