// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Based on mesa-v2021.09 (https://github.com/microchip-ung/mesa/) which has
// the following copyright and license:
//
// Copyright (c) 2004-2021 Microchip Technology Inc. and its subsidiaries.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// This is an autogenerated file; do not edit by hand!
use derive_more::{From, Into};

/// Register `MAC_ADV_CHK_CFG`
///
/// Advanced Check Feature Configuration Register
#[derive(From, Into)]
pub struct MAC_ADV_CHK_CFG(u32);
impl MAC_ADV_CHK_CFG {    ///
    /// Extended End Of Packet Check: Specifies the requirement for the Rx column when holding an EOP character.
    ///
    /// '0': The values of the remaining Rx lanes of a column holding an EOP are ignored. E.g. if lane 1 holds an EOP, the value of lanes 2 and 3 are ignored '1': A received frame is error-marked if an Error character is received in any lane of the column holding the EOP character. E.g. if lane 1 holds an EOP, the frame is error-marked if lanes 0, 2, or 3 holds an Error character.
    pub fn ext_eop_chk_ena(&self) -> u32 {
        (self.0 & 0x1000000) >> 24
    }
    pub fn set_ext_eop_chk_ena(&mut self, value: u32) {
        let value = value << 24;
        assert!(value <= 0x1000000);
        self.0 &= !0x1000000;
        self.0 |= value;
    }    ///
    /// Extended Start Of Packet Check Enable: Specifies the requirement for the Rx column prior to SOP character.
    ///
    /// '0': Value of Rx column at the XGMII interface prior to a SOP character is ignored '1': An IDLE column at the XGMII interface must be received prior to a SOP character for the MAC to detect a start of frame.
    pub fn ext_sop_chk_ena(&self) -> u32 {
        (self.0 & 0x100000) >> 20
    }
    pub fn set_ext_sop_chk_ena(&mut self, value: u32) {
        let value = value << 20;
        assert!(value <= 0x100000);
        self.0 &= !0x100000;
        self.0 |= value;
    }    ///
    /// In-Range Error Check Enable: Determines whether or not a received frame should be discarded if the frame length does not match the frame PDU size:
    ///
    /// '0': Frames which have a frame length field inconsistent with the actual frame length are not error-marked '1': Frames with inconsistent frame length fields are error marked and will be discarded by the Rx Queue System.
    pub fn inr_err_ena(&self) -> u32 {
        (self.0 & 0x1) >> 0
    }
    pub fn set_inr_err_ena(&mut self, value: u32) {
        let value = value << 0;
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }    ///
    /// Out-Of-Range Error Check Enable: Determines whether or not a received frame should be discarded if the frame length field is out of range.
    ///
    /// '0': Out-of-range errors are ignored '1': A frame is discarded if the frame length field value is out of range
    pub fn oor_err_ena(&self) -> u32 {
        (self.0 & 0x10) >> 4
    }
    pub fn set_oor_err_ena(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x10);
        self.0 &= !0x10;
        self.0 |= value;
    }    ///
    /// Preamble Check Enable: Specifies the preamble requirement for a successful frame reception.
    ///
    /// '0': Skip preamble check. A SOP control character is sufficient for a successful frame reception. The minimum allowed preamble size is still 8 bytes (incl. SOP and SFD) but the preamble bytes between the SOP and SFD can have any data value. '1': Strict preamble check enabled, i.e. the last 6 bytes of a preamble - prior to the SFD - must all be equal to 0x55 for a successful frame reception. For preambles larger than 8 bytes, only the last 6 preamble bytes prior to the SFD are checked when this bit is set to 1.
    pub fn prm_chk_ena(&self) -> u32 {
        (self.0 & 0x100) >> 8
    }
    pub fn set_prm_chk_ena(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0x100);
        self.0 &= !0x100;
        self.0 |= value;
    }    ///
    /// Preamble Shrink Check Disable: The MAC can be setup to discard a frame, if a SFD is received in lane 3 of the column containing the SOP. If stacking tags must be supported, the MAC must accept any data byte at this position.
    ///
    /// '0': Frames with a SFD in lane 3 of the column containing the SOP are discarded. '1': Frames with a SFD in lane 3 of the column containing the SOP are NOT discarded.
    pub fn prm_shk_chk_dis(&self) -> u32 {
        (self.0 & 0x1000) >> 12
    }
    pub fn set_prm_shk_chk_dis(&mut self, value: u32) {
        let value = value << 12;
        assert!(value <= 0x1000);
        self.0 &= !0x1000;
        self.0 |= value;
    }    ///
    /// Start-of-Frame-Delimiter Check Enable: Specifies the requirement for a successful frame reception. When disabled (='0'), MAC10G will assume that preamble is 8 bytes (incl. SOP & SFD) when SOP is received. No checking of SFD is carried out. When enabled (='1'), MAC10G will search for SFD in lane 3/7 after reception of SOP, before accepting frame data. MAC10G will search for SFD until SFD is found or a control character is encountered.
    ///
    /// '0': Skip SFD check '1': Strict SFD check enabled, i.e. the SFD must be "D5" for a successful frame reception.
    pub fn sfd_chk_ena(&self) -> u32 {
        (self.0 & 0x10000) >> 16
    }
    pub fn set_sfd_chk_ena(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0x10000);
        self.0 &= !0x10000;
        self.0 |= value;
    }
}

/// Register `MAC_ENA_CFG`
///
/// Mode Configuration Register
#[derive(From, Into)]
pub struct MAC_ENA_CFG(u32);
impl MAC_ENA_CFG {    ///
    /// Enable Receiver.
    ///
    /// '0': Disabled '1': Enabled.
    pub fn rx_ena(&self) -> u32 {
        (self.0 & 0x10) >> 4
    }
    pub fn set_rx_ena(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x10);
        self.0 &= !0x10;
        self.0 |= value;
    }    ///
    /// Enable Transmitter.
    ///
    /// '0': Disabled '1': Enabled.
    pub fn tx_ena(&self) -> u32 {
        (self.0 & 0x1) >> 0
    }
    pub fn set_tx_ena(&mut self, value: u32) {
        let value = value << 0;
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
}

/// Register `MAC_LB_CFG`
///
/// Miscellaneous Configuration Register
#[derive(From, Into)]
pub struct MAC_LB_CFG(u32);
impl MAC_LB_CFG {    ///
    /// Enables loopback from egress to ingress in the device. The MAC Rx clock is automatically set equal to the MAC Tx clock when the loop back is enabled.
    ///
    /// '0': Host loopback disabled at XGMII interface. '1': Host loopback enabled at XGMII interface.
    pub fn xgmii_host_lb_ena(&self) -> u32 {
        (self.0 & 0x10) >> 4
    }
    pub fn set_xgmii_host_lb_ena(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x10);
        self.0 &= !0x10;
        self.0 |= value;
    }    ///
    /// Enables loopback from ingress to egres data path at XGMII interface.
    ///
    /// '0': PHY Loopback Disabled at XGMII interface. '1': PHY Loopback Enabled at XGMII interface.
    pub fn xgmii_phy_lb_ena(&self) -> u32 {
        (self.0 & 0x1) >> 0
    }
    pub fn set_xgmii_phy_lb_ena(&mut self, value: u32) {
        let value = value << 0;
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
}

/// Register `MAC_LFS_CFG`
///
/// Link Fault Signaling Register
#[derive(From, Into)]
pub struct MAC_LFS_CFG(u32);
impl MAC_LFS_CFG {    ///
    /// Link Fault Signaling Mode Enable: If enabled, the transmitter reacts on received Link Fault indications.
    ///
    /// '0': Ignore Link Faults detected by the MAC receiver module '1': React on detected Link Faults and transmit the appropriate Sequence Ordered Set.
    pub fn lfs_mode_ena(&self) -> u32 {
        (self.0 & 0x1) >> 0
    }
    pub fn set_lfs_mode_ena(&mut self, value: u32) {
        let value = value << 0;
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }    ///
    /// LFS Unidirectional mode enable. Implementation of 802.3 clause 66. When asserted, this enables MAC to transmit data during reception of Local Fault and Remote Fault ordered sets from the PHY. When in Unidirectional mode: When receiving LF, frames are transmitted separated by RF ordered sets. When receiving RF, frames are transmitted separated by IDLE symbols
    ///
    /// '0' : LFS unidirectional mode is disabled '1' : LFS unidirectional mode is enabled
    pub fn lfs_unidir_ena(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    pub fn set_lfs_unidir_ena(&mut self, value: u32) {
        let value = value << 3;
        assert!(value <= 0x8);
        self.0 &= !0x8;
        self.0 |= value;
    }    ///
    /// During normal 802.3 compliant operation, it is possible to send spurious ||Q|| after the lfs condition was deasserted. Asserting this bit will prevent these spurious ||Q|| by delaying TX until the PCS reports that no ||Q|| are pending. Applicable for XAUI speeds only.
    ///
    /// 0 - Allow ||Q|| transmission (ieee 802.3 compliant) 1 - Suppress ||Q|| transmission
    pub fn spurious_q_dis(&self) -> u32 {
        (self.0 & 0x2) >> 1
    }
    pub fn set_spurious_q_dis(&mut self, value: u32) {
        let value = value << 1;
        assert!(value <= 0x2);
        self.0 &= !0x2;
        self.0 |= value;
    }    ///
    /// GNATS #6146. Use the leading edge of the TX_ENA signal to control the state machine in tx_datapath. This bit is implemented to disable the fix incase it is causing problems.
    ///
    /// 0 : Leading edge detect disabled 1 : Leading edge detect enabled
    pub fn use_leading_edge_detect(&self) -> u32 {
        (self.0 & 0x4) >> 2
    }
    pub fn set_use_leading_edge_detect(&mut self, value: u32) {
        let value = value << 2;
        assert!(value <= 0x4);
        self.0 &= !0x4;
        self.0 |= value;
    }
}

/// Register `MAC_MAXLEN_CFG`
///
/// Max Length Configuration Register
#[derive(From, Into)]
pub struct MAC_MAXLEN_CFG(u32);
impl MAC_MAXLEN_CFG {    ///
    /// The maximum frame length accepted by the Receive Module. If the length is exceeded, this is indicated in the Statistics Engine (LONG_FRAME). The maximum length is automatically adjusted to accommodate maximum sized frames containing a VLAN tag - given that the MAC is configured to be VLAN aware (default): MTU size = 10056 Bytes. This includes all encapsulations and TAGs. Not including IFH. Reason is: QS supports a max of 63 segments. A segment is 160 Bytes. The IFH must be stored in the QS also, so room must be allocated. Thereby: 63 x 160B - 24B (IFH) = 10056 Bytes
    ///
    /// The maximum allowable size is 10056 Bytes.
    pub fn max_len(&self) -> u32 {
        (self.0 & 0xffff) >> 0
    }
    pub fn set_max_len(&mut self, value: u32) {
        let value = value << 0;
        assert!(value <= 0xffff);
        self.0 &= !0xffff;
        self.0 |= value;
    }    ///
    /// Configures whether the Max Length Check takes the number of Q tags into consideration when assing if a frame is too long. If asserted, - 4 bytes will be added to MAX_LEN for single tagged frame. - 8 bytes will be added to MAX_LEN for double tagged frame. - 12 bytes will be added to MAX_LEN for tripple tagged frame.
    ///
    /// '0' : Only check max frame length against MAX_LEN '1' : Add 4/8/12 bytes to MAX_LEN when checking for max frame length
    pub fn max_len_tag_chk(&self) -> u32 {
        (self.0 & 0x10000) >> 16
    }
    pub fn set_max_len_tag_chk(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0x10000);
        self.0 &= !0x10000;
        self.0 |= value;
    }
}

/// Register `MAC_MODE_CFG`
///
/// Mode Configuration Register
#[derive(From, Into)]
pub struct MAC_MODE_CFG(u32);
impl MAC_MODE_CFG {    ///
    /// When asserted (=1) MAC10G must check HIH checksum and discard frames if HIH checksum is not valid. When deasserted (=0) MAC10G must disregard the HIH checksum.
    ///
    /// = 0 ; MAC10G should disregard the HIH CKSM. = 1 ; MAC10G should discard any frame with invalid CKSM
    pub fn hih_crc_check(&self) -> u32 {
        (self.0 & 0x1) >> 0
    }
    pub fn set_hih_crc_check(&mut self, value: u32) {
        let value = value << 0;
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }    ///
    /// Register configures the format of the IPG. 1) Normal IPG : Averaging IPG for average of 12 bytes 2) Shrinked IPG : Minimum IPG of 4 - 7 bytes (Incl. Terminate Character and IDLE BYTEs)
    ///
    /// '0': Normal IPG. '1': Shrink IPG.
    pub fn mac_ipg_cfg(&self) -> u32 {
        (self.0 & 0x100) >> 8
    }
    pub fn set_mac_ipg_cfg(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0x100);
        self.0 &= !0x100;
        self.0 |= value;
    }    ///
    /// This register configures the format of the preamble. This supports: 1) Standard preamble = 0xFB555555555555D5 2) Minimum preamble = 0xFB 3) Host Interface Header (HIH) located before the SFD 4) Host Interface Header (HIH) located after the SFD - default CRC 5) Host Interface Header (HIH) located after the SFD - HIH included in CRC
    ///
    /// 0: Standard Preamble 1: Minimum Preamble = 0xFB 2: HIH before SFD -	default CRC = 0xFB H0 H1 H2 H3 0x55 0x55 0xD5 3: HIH after SFD - default CRC = 0xFB 0x55 0x55 0xD5 H0 H1 H2 H3 4: HIH after SFD - HIH in CRC = 0xFB 0x55 0x55 0xD5 H0 H1 H2 H3 5 - 7: reserved HIH is 4 bytes: H0 H1 H2 H3
    pub fn mac_preamble_cfg(&self) -> u32 {
        (self.0 & 0x7000) >> 12
    }
    pub fn set_mac_preamble_cfg(&mut self, value: u32) {
        let value = value << 12;
        assert!(value <= 0x7000);
        self.0 &= !0x7000;
        self.0 |= value;
    }    ///
    /// On a given link, Pause Frames can be either "Link Pause frames" or "Tunnel Pause Frames". "Link Pause Frames" will have standard preamble, while "Tunnel Pause Frames" will have HIH in the preamble. For "Link Pause Frames" MAC10G should not verify HIH CKSM, while for "Tunnel Pause Frames" MAC10G should verify HIH CKSM.
    ///
    /// 0: Pause frames are expected to be Link Pause frames - No HIH CKSM verification in MAC10G 1: Pause frames are expected to be Tunnel Pause frames - HIH CKSM is verified in MAC10G
    pub fn tunnel_pause_frames(&self) -> u32 {
        (self.0 & 0x10000) >> 16
    }
    pub fn set_tunnel_pause_frames(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0x10000);
        self.0 &= !0x10000;
        self.0 |= value;
    }    ///
    /// XGMII Generator Mode Enable: In this mode, the transmitter will not insert the preamble and the end-of-packet control characters. Data that matches one of the XGMII control characters will be translated from a data character to a control character. This mode enables the MAC 10G to transmit e.g. special XGMII messages and/or malformed frames (in terms of the XGMII protocol).
    ///
    /// '0': XGMII Generator Mode Disabled '1': XGMII Generator Mode Enabled.
    pub fn xgmii_gen_mode_ena(&self) -> u32 {
        (self.0 & 0x10) >> 4
    }
    pub fn set_xgmii_gen_mode_ena(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x10);
        self.0 &= !0x10;
        self.0 |= value;
    }
}

/// Register `MAC_NUM_TAGS_CFG`
///
/// Register to specify no.of tags supoorted
#[derive(From, Into)]
pub struct MAC_NUM_TAGS_CFG(u32);
impl MAC_NUM_TAGS_CFG {    ///
    /// Configuration for number of consecutive VLAN Tags supported by the MAC. Maximum value is 3.
    ///
    /// '0': No tags are detected by MAC. 'n': Maximum of n consecutive VLAN Tags are detected by the MAC and accordingly MAX LEN is modified for frame length calculations.
    pub fn num_tags(&self) -> u32 {
        (self.0 & 0x3) >> 0
    }
    pub fn set_num_tags(&mut self, value: u32) {
        let value = value << 0;
        assert!(value <= 0x3);
        self.0 &= !0x3;
        self.0 |= value;
    }
}

/// Register `MAC_RX_LANE_STICKY_0`
///
/// XGMII Lane Debug Sticky bit Register 0
#[derive(From, Into)]
pub struct MAC_RX_LANE_STICKY_0(u32);
impl MAC_RX_LANE_STICKY_0 {    ///
    /// Sticky bits for debugging Lane 0.
    ///
    /// Bit 0: Sticky bit indicating that a Data character has been received on Lane 0. Writing a '1' clears the sticky bit. Bit 1: Sticky bit indicating that a Control character has been received on Lane 0. Writing a '1' clears the sticky bit. Bit 2: Sticky bit indicating that an Idle character has been received on Lane 0. Writing a '1' clears the sticky bit. Bit 3: Sticky bit indicating that a Sequence character (0x9C) has been received on Lane 0. Writing a '1' clears the sticky bit. Bit 4: Sticky bit indicating that a SOP character has been received on Lane 0. Writing a '1' clears the sticky bit. Bit 5: Sticky bit indicating that an EOP character has been received on Lane 0. Writing a '1' clears the sticky bit. Bit 6: Sticky bit indicating that an Error character has been received on Lane 0. Writing a '1' clears the sticky bit.
    pub fn lane0_sticky(&self) -> u32 {
        (self.0 & 0x7f) >> 0
    }
    pub fn set_lane0_sticky(&mut self, value: u32) {
        let value = value << 0;
        assert!(value <= 0x7f);
        self.0 &= !0x7f;
        self.0 |= value;
    }    ///
    /// Sticky bits for debugging Lane 1.
    ///
    /// See format of LANE0 sticky bit register.
    pub fn lane1_sticky(&self) -> u32 {
        (self.0 & 0x7f00) >> 8
    }
    pub fn set_lane1_sticky(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0x7f00);
        self.0 &= !0x7f00;
        self.0 |= value;
    }    ///
    /// Sticky bits for debugging Lane 2.
    ///
    /// See format of LANE0 sticky bit register.
    pub fn lane2_sticky(&self) -> u32 {
        (self.0 & 0x7f0000) >> 16
    }
    pub fn set_lane2_sticky(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0x7f0000);
        self.0 &= !0x7f0000;
        self.0 |= value;
    }    ///
    /// Sticky bits for debugging Lane 3.
    ///
    /// See format of LANE0 sticky bit register.
    pub fn lane3_sticky(&self) -> u32 {
        (self.0 & 0x7f000000) >> 24
    }
    pub fn set_lane3_sticky(&mut self, value: u32) {
        let value = value << 24;
        assert!(value <= 0x7f000000);
        self.0 &= !0x7f000000;
        self.0 |= value;
    }
}

/// Register `MAC_RX_LANE_STICKY_1`
///
/// XGMII Lane Debug Sticky bit Register 1
#[derive(From, Into)]
pub struct MAC_RX_LANE_STICKY_1(u32);
impl MAC_RX_LANE_STICKY_1 {    ///
    /// Sticky bits for debugging Lane 4.
    ///
    /// See format of LANE0 sticky bit register.
    pub fn lane4_sticky(&self) -> u32 {
        (self.0 & 0x7f) >> 0
    }
    pub fn set_lane4_sticky(&mut self, value: u32) {
        let value = value << 0;
        assert!(value <= 0x7f);
        self.0 &= !0x7f;
        self.0 |= value;
    }    ///
    /// Sticky bits for debugging Lane 5.
    ///
    /// See format of LANE0 sticky bit register.
    pub fn lane5_sticky(&self) -> u32 {
        (self.0 & 0x7f00) >> 8
    }
    pub fn set_lane5_sticky(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0x7f00);
        self.0 &= !0x7f00;
        self.0 |= value;
    }    ///
    /// Sticky bits for debugging Lane 6.
    ///
    /// See format of LANE0 sticky bit register.
    pub fn lane6_sticky(&self) -> u32 {
        (self.0 & 0x7f0000) >> 16
    }
    pub fn set_lane6_sticky(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0x7f0000);
        self.0 &= !0x7f0000;
        self.0 |= value;
    }    ///
    /// Sticky bits for debugging Lane 7.
    ///
    /// See format of LANE0 sticky bit register.
    pub fn lane7_sticky(&self) -> u32 {
        (self.0 & 0x7f000000) >> 24
    }
    pub fn set_lane7_sticky(&mut self, value: u32) {
        let value = value << 24;
        assert!(value <= 0x7f000000);
        self.0 &= !0x7f000000;
        self.0 |= value;
    }
}

/// Register `MAC_TAGS_CFG`
///
/// VLAN / Service tag configuration register
///
/// The MAC can be configured to accept 0, 1, 2 and 3 tags and the TAG value can be user-defined.
#[derive(From, Into)]
pub struct MAC_TAGS_CFG(u32);
impl MAC_TAGS_CFG {    ///
    /// Enables TAG_ID apart from standard 0x8100 and 0x88A8 for Tag comparision.
    ///
    /// '0': The MAC doesn't take TAG_ID for tag identification. '1': The MAC looks for tag according to encoding of TAG_ID
    pub fn tag_ena(&self) -> u32 {
        (self.0 & 0x10) >> 4
    }
    pub fn set_tag_ena(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x10);
        self.0 &= !0x10;
        self.0 |= value;
    }    ///
    /// This field defines which value is regarded as a VLAN/Service tag - besides 0x8100 and 0x88A8. The value is used for all ALL tag positions. I.e. a double tagged frame can have the following tag values: (INNER_TAG, OUTER_TAG): ( 0x8100, 0x8100 ) ( 0x8100, TAG_ID ) or ( TAG_ID, TAG_ID )
    ///
    /// "0x8100" - Standard Ethernet Bridge ethertype (C-tag) "0x88A8" - Provider Bridge Ethertype  (S-tag)
    pub fn tag_id(&self) -> u32 {
        (self.0 & 0xffff) >> 16
    }
    pub fn set_tag_id(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xffff);
        self.0 &= !0xffff;
        self.0 |= value;
    }
}

/// Register `MAC_TX_MONITOR_STICKY`
///
/// MAC10G Tx Monitor Sticky bit Register
#[derive(From, Into)]
pub struct MAC_TX_MONITOR_STICKY(u32);
impl MAC_TX_MONITOR_STICKY {    ///
    /// DISABLE state reached in Tx module of 10G MAC. Writing a '1' clears the sticky bit.
    ///
    /// '0': The DISABLE state has never been reached. '1': The DISABLE state has been reached. Bit is cleared by writing a '1' to this position.
    pub fn dis_state_sticky(&self) -> u32 {
        (self.0 & 0x1) >> 0
    }
    pub fn set_dis_state_sticky(&mut self, value: u32) {
        let value = value << 0;
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }    ///
    /// IDLE state reached in Tx module of 10G MAC. Writing a '1' clears the sticky bit.
    ///
    /// '0': The IDLE state has never been reached. '1': The  IDLE state has been reached. Bit is cleared by writing a '1' to this position.
    pub fn idle_state_sticky(&self) -> u32 {
        (self.0 & 0x2) >> 1
    }
    pub fn set_idle_state_sticky(&mut self, value: u32) {
        let value = value << 1;
        assert!(value <= 0x2);
        self.0 &= !0x2;
        self.0 |= value;
    }    ///
    /// LFS: LOCAL FAULT state reached in Tx module of 10G MAC. Writing a '1' clears the sticky bit.
    ///
    /// '0': The LOCAL_FAULT state has never been reached. '1': The LOCAL_FAULT state has been reached. Bit is cleared by writing a '1' to this position.
    pub fn local_err_state_sticky(&self) -> u32 {
        (self.0 & 0x10) >> 4
    }
    pub fn set_local_err_state_sticky(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x10);
        self.0 &= !0x10;
        self.0 |= value;
    }    ///
    /// LFS REMOTE FAULT state reached in Tx module of 10G MAC. Writing a '1' clears the sticky bit.
    ///
    /// '0': The REMOTE_FAULT state has never been reached. '1': The REMOTE_FAULT state has been reached. Bit is cleared by writing a '1' to this position.
    pub fn remote_err_state_sticky(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    pub fn set_remote_err_state_sticky(&mut self, value: u32) {
        let value = value << 3;
        assert!(value <= 0x8);
        self.0 &= !0x8;
        self.0 |= value;
    }
}
