// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Based on mesa-v2021.09 (https://github.com/microchip-ung/mesa/) which has
// the following copyright and license:
//
// Copyright (c) 2004-2021 Microchip Technology Inc. and its subsidiaries.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// This is an autogenerated file; do not edit by hand!
use derive_more::{From, Into};
/// SD10G65 IB Configuration register 0
///
/// Configuration register 0 for SD10G65 IB. Note: Configuration bit-grp IB_CLKDIV_ENA was named IB_VSCOPE_CLK_ENA in an early revision of the input buffer.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct SD10G65_IB_CFG0(u32);
impl SD10G65_IB_CFG0 {
    /// Enable for 1V mode
    ///
    /// 0: VDDI=1.2V 1: VDDI=1.0V
    #[inline(always)]
    pub fn ib_1v_ena(&self) -> u32 {
        (self.0 & 0x40) >> 6
    }
    #[inline(always)]
    pub fn set_ib_1v_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 6;
        self.0 &= !0x40;
        self.0 |= value;
    }
    /// Enable clock dividers in sampling stag
    ///
    /// 0: Disable (use in double rate mode) 1: Enable (use in full rate mode)
    #[inline(always)]
    pub fn ib_clkdiv_ena(&self) -> u32 {
        (self.0 & 0x20) >> 5
    }
    #[inline(always)]
    pub fn set_ib_clkdiv_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 5;
        self.0 &= !0x20;
        self.0 |= value;
    }
    /// Enable DFE stage (gates IB_ISEL_DFE)
    ///
    /// 0: Disable 1: Enable
    #[inline(always)]
    pub fn ib_dfe_ena(&self) -> u32 {
        (self.0 & 0x4000) >> 14
    }
    #[inline(always)]
    pub fn set_ib_dfe_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 14;
        self.0 &= !0x4000;
        self.0 |= value;
    }
    /// Is or'ed to the prim. input of the macro: sx_direct_data_ena_rx_i and is used to enable the direct data path.
    #[inline(always)]
    pub fn ib_direct_ena(&self) -> u32 {
        (self.0 & 0x8000) >> 15
    }
    #[inline(always)]
    pub fn set_ib_direct_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 15;
        self.0 &= !0x8000;
        self.0 |= value;
    }
    /// Enable EQualiZation stage
    ///
    /// 0: Disable 1: Enable (mission mode)
    #[inline(always)]
    pub fn ib_eqz_ena(&self) -> u32 {
        (self.0 & 0x2) >> 1
    }
    #[inline(always)]
    pub fn set_ib_eqz_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 1;
        self.0 &= !0x2;
        self.0 |= value;
    }
    /// Enable for IA including ACJtag
    ///
    /// 0: Disable 1: Enable
    #[inline(always)]
    pub fn ib_ia_ena(&self) -> u32 {
        (self.0 & 0x400) >> 10
    }
    #[inline(always)]
    pub fn set_ib_ia_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 10;
        self.0 &= !0x400;
        self.0 |= value;
    }
    /// Enable for IA signal detect circuit (IB_SDET_SEL = 0 required)
    ///
    /// 0: Disable 1: Enable
    #[inline(always)]
    pub fn ib_ia_sdet_ena(&self) -> u32 {
        (self.0 & 0x200) >> 9
    }
    #[inline(always)]
    pub fn set_ib_ia_sdet_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 9;
        self.0 &= !0x200;
        self.0 |= value;
    }
    /// Enable for IA signal detect circuit (IB_SDET_SEL = 1 required)
    ///
    /// 0: Disable 1: Enable
    #[inline(always)]
    pub fn ib_ie_sdet_ena(&self) -> u32 {
        (self.0 & 0x100) >> 8
    }
    #[inline(always)]
    pub fn set_ib_ie_sdet_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 8;
        self.0 &= !0x100;
        self.0 |= value;
    }
    /// Enable for level detect circuit
    ///
    /// 0: Disable 1: Enable
    #[inline(always)]
    pub fn ib_ld_ena(&self) -> u32 {
        (self.0 & 0x80) >> 7
    }
    #[inline(always)]
    pub fn set_ib_ld_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 7;
        self.0 &= !0x80;
        self.0 |= value;
    }
    /// Offset resistance adjustment for CML cells (two-complement)
    ///
    /// 1000: -8 1111: -1 0000: 0 0111: 7
    #[inline(always)]
    pub fn ib_rcml_adj(&self) -> u32 {
        (self.0 & 0x78000000) >> 27
    }
    #[inline(always)]
    pub fn set_ib_rcml_adj(&mut self, value: u32) {
        assert!(value <= 0xf);
        let value = value << 27;
        self.0 &= !0x78000000;
        self.0 |= value;
    }
    /// Offset resistance adjustment for termination (two-complement)
    ///
    /// 1000: -8 1111: -1 0000: 0 0111: 7
    #[inline(always)]
    pub fn ib_rib_adj(&self) -> u32 {
        (self.0 & 0x1e0000) >> 17
    }
    #[inline(always)]
    pub fn set_ib_rib_adj(&mut self, value: u32) {
        assert!(value <= 0xf);
        let value = value << 17;
        self.0 &= !0x1e0000;
        self.0 |= value;
    }
    /// Shifts resistance adjustment value ib_rib_adj by +1
    #[inline(always)]
    pub fn ib_rib_shift(&self) -> u32 {
        (self.0 & 0x200000) >> 21
    }
    #[inline(always)]
    pub fn set_ib_rib_shift(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 21;
        self.0 &= !0x200000;
        self.0 |= value;
    }
    /// Enable SAMpling stage
    ///
    /// 0: Disable 1: Enable (mission mode)
    #[inline(always)]
    pub fn ib_sam_ena(&self) -> u32 {
        (self.0 & 0x4) >> 2
    }
    #[inline(always)]
    pub fn set_ib_sam_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 2;
        self.0 &= !0x4;
        self.0 |= value;
    }
    /// Select input buffer input signal
    ///
    /// 0: normal operation 1: -6dB input 2: OB->IB data loop or test signal 3: RESERVED
    #[inline(always)]
    pub fn ib_sig_sel(&self) -> u32 {
        (self.0 & 0x3000) >> 12
    }
    #[inline(always)]
    pub fn set_ib_sig_sel(&mut self, value: u32) {
        assert!(value <= 0x3);
        let value = value << 12;
        self.0 &= !0x3000;
        self.0 |= value;
    }
    /// Routed to analog macro but not used inside! Vscope clock source is selected via ib_sel_vclk.
    #[inline(always)]
    pub fn ib_spare_pool2(&self) -> u32 {
        (self.0 & 0x10) >> 4
    }
    #[inline(always)]
    pub fn set_ib_spare_pool2(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 4;
        self.0 &= !0x10;
        self.0 |= value;
    }
    /// Enable common mode termination
    ///
    /// 0: no common mode termination (only AC-common mode termination) 1: termination to VDDI
    #[inline(always)]
    pub fn ib_term_vdd_ena(&self) -> u32 {
        (self.0 & 0x400000) >> 22
    }
    #[inline(always)]
    pub fn set_ib_term_vdd_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 22;
        self.0 &= !0x400000;
        self.0 |= value;
    }
    /// Select termination voltage
    #[inline(always)]
    pub fn ib_term_v_sel(&self) -> u32 {
        (self.0 & 0x7800000) >> 23
    }
    #[inline(always)]
    pub fn set_ib_term_v_sel(&mut self, value: u32) {
        assert!(value <= 0xf);
        let value = value << 23;
        self.0 &= !0x7800000;
        self.0 |= value;
    }
    /// Controls Bulk Voltage of High Speed Cells
    ///
    /// 0: High 1: Low (mission mode)
    #[inline(always)]
    pub fn ib_vbulk_sel(&self) -> u32 {
        (self.0 & 0x800) >> 11
    }
    #[inline(always)]
    pub fn set_ib_vbulk_sel(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 11;
        self.0 &= !0x800;
        self.0 |= value;
    }
    /// Enable VScope Path of Sampling-Stage
    ///
    /// 0: Disable 1: Enable
    #[inline(always)]
    pub fn ib_vscope_ena(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    #[inline(always)]
    pub fn set_ib_vscope_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 3;
        self.0 &= !0x8;
        self.0 |= value;
    }
}
/// SD10G65 IB Configuration register 1
///
/// Configuration register 1 for SD10G65 IB.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct SD10G65_IB_CFG1(u32);
impl SD10G65_IB_CFG1 {
    /// Inductor peaking of EQ-Buffer3 (over all 5. stage)
    ///
    /// 0: no peaking 15: max. peaking max. peaking >3dB at 8GHz
    #[inline(always)]
    pub fn ib_agc_l(&self) -> u32 {
        (self.0 & 0xf000) >> 12
    }
    #[inline(always)]
    pub fn set_ib_agc_l(&mut self, value: u32) {
        assert!(value <= 0xf);
        let value = value << 12;
        self.0 &= !0xf000;
        self.0 |= value;
    }
    /// C-gain peaking for IB-stage
    ///
    /// 0: no peaking 7: max. peaking corner frequency adjustment with ib_eqz_c_adj_ib
    #[inline(always)]
    pub fn ib_amp_c(&self) -> u32 {
        (self.0 & 0xe00) >> 9
    }
    #[inline(always)]
    pub fn set_ib_amp_c(&mut self, value: u32) {
        assert!(value <= 0x7);
        let value = value << 9;
        self.0 &= !0xe00;
        self.0 |= value;
    }
    /// Inductor peaking of 1. stage Input buffer
    ///
    /// 0: no peaking 15: max. peaking max. peaking > 3db at 8GHz
    #[inline(always)]
    pub fn ib_amp_l(&self) -> u32 {
        (self.0 & 0xf0000000) >> 28
    }
    #[inline(always)]
    pub fn set_ib_amp_l(&mut self, value: u32) {
        assert!(value <= 0xf);
        let value = value << 28;
        self.0 &= !0xf0000000;
        self.0 |= value;
    }
    /// C-gain peaking for EQ-stage0
    ///
    /// 0: no peaking 7: max. peaking corner frequency adjustment with ib_eqz_c_adj_es0
    #[inline(always)]
    pub fn ib_eqz_c0(&self) -> u32 {
        (self.0 & 0x1c0) >> 6
    }
    #[inline(always)]
    pub fn set_ib_eqz_c0(&mut self, value: u32) {
        assert!(value <= 0x7);
        let value = value << 6;
        self.0 &= !0x1c0;
        self.0 |= value;
    }
    /// C-gain peaking for EQ-stage1
    ///
    /// 0: no peaking 7: max. peaking corner frequency adjustment with ib_eqz_c_adj_es1
    #[inline(always)]
    pub fn ib_eqz_c1(&self) -> u32 {
        (self.0 & 0x38) >> 3
    }
    #[inline(always)]
    pub fn set_ib_eqz_c1(&mut self, value: u32) {
        assert!(value <= 0x7);
        let value = value << 3;
        self.0 &= !0x38;
        self.0 |= value;
    }
    /// C-gain peaking for EQ-stage2
    ///
    /// 0: no peaking 7: max. peaking corner frequency adjustment with ib_eqz_c_adj_es2
    #[inline(always)]
    pub fn ib_eqz_c2(&self) -> u32 {
        self.0 & 0x7
    }
    #[inline(always)]
    pub fn set_ib_eqz_c2(&mut self, value: u32) {
        assert!(value <= 0x7);
        self.0 &= !0x7;
        self.0 |= value;
    }
    /// Inductor peaking of EQ-Buffer0 (over all 2. stage)
    ///
    /// 0: no peaking 15: max. peaking max. peaking > 3db at 8GHz
    #[inline(always)]
    pub fn ib_eqz_l0(&self) -> u32 {
        (self.0 & 0xf000000) >> 24
    }
    #[inline(always)]
    pub fn set_ib_eqz_l0(&mut self, value: u32) {
        assert!(value <= 0xf);
        let value = value << 24;
        self.0 &= !0xf000000;
        self.0 |= value;
    }
    /// Inductor peaking of EQ-Buffer1 (over all 3. stage)
    ///
    /// 0: no peaking 15: max. peaking max. peaking > 3dB at 8GHz
    #[inline(always)]
    pub fn ib_eqz_l1(&self) -> u32 {
        (self.0 & 0xf00000) >> 20
    }
    #[inline(always)]
    pub fn set_ib_eqz_l1(&mut self, value: u32) {
        assert!(value <= 0xf);
        let value = value << 20;
        self.0 &= !0xf00000;
        self.0 |= value;
    }
    /// Inductor peaking of EQ-Buffer2 (over all 4. stage)
    ///
    /// 0: no peaking 15: max. peaking max. peaking > 3dB at 8GHz
    #[inline(always)]
    pub fn ib_eqz_l2(&self) -> u32 {
        (self.0 & 0xf0000) >> 16
    }
    #[inline(always)]
    pub fn set_ib_eqz_l2(&mut self, value: u32) {
        assert!(value <= 0xf);
        let value = value << 16;
        self.0 &= !0xf0000;
        self.0 |= value;
    }
}
/// SD10G65 IB Configuration register 10 JTAG related setting
///
/// Configuration register 10 for SD10G65 IB.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct SD10G65_IB_CFG10(u32);
impl SD10G65_IB_CFG10 {
    /// Result of Level-Detect0 (after IB-stage of EQZ) circuitry
    ///
    /// 1: Input level above threshold defined by IB_EQ_LD_LEV
    #[inline(always)]
    pub fn ib_eqz_ld0_nedge(&self) -> u32 {
        (self.0 & 0x400000) >> 22
    }
    #[inline(always)]
    pub fn set_ib_eqz_ld0_nedge(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 22;
        self.0 &= !0x400000;
        self.0 |= value;
    }
    /// Result of Level-Detect0 (after IB-stage of EQZ) circuitry
    ///
    /// 1: Input level above threshold defined by IB_EQ_LD_LEV
    #[inline(always)]
    pub fn ib_eqz_ld0_pedge(&self) -> u32 {
        (self.0 & 0x800000) >> 23
    }
    #[inline(always)]
    pub fn set_ib_eqz_ld0_pedge(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 23;
        self.0 &= !0x800000;
        self.0 |= value;
    }
    /// Result of Level-Detect1 (after ES2-stage of EQZ) circuitry
    ///
    /// 1: Input level above threshold defined by IB_EQ_LD_LEV
    #[inline(always)]
    pub fn ib_eqz_ld1_nedge(&self) -> u32 {
        (self.0 & 0x1000000) >> 24
    }
    #[inline(always)]
    pub fn set_ib_eqz_ld1_nedge(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 24;
        self.0 &= !0x1000000;
        self.0 |= value;
    }
    /// Result of Level-Detect1 (after ES2-stage of EQZ) circuitry
    ///
    /// 1: Input level above threshold defined by IB_EQ_LD_LEV
    #[inline(always)]
    pub fn ib_eqz_ld1_pedge(&self) -> u32 {
        (self.0 & 0x2000000) >> 25
    }
    #[inline(always)]
    pub fn set_ib_eqz_ld1_pedge(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 25;
        self.0 &= !0x2000000;
        self.0 |= value;
    }
    /// Direct Data output from IA block
    #[inline(always)]
    pub fn ib_ia_direct_data(&self) -> u32 {
        (self.0 & 0x100000) >> 20
    }
    #[inline(always)]
    pub fn set_ib_ia_direct_data(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 20;
        self.0 &= !0x100000;
        self.0 |= value;
    }
    /// Data offset calibration result IA stage
    #[inline(always)]
    pub fn ib_ia_doffs_cal(&self) -> u32 {
        (self.0 & 0x80000000) >> 31
    }
    #[inline(always)]
    pub fn set_ib_ia_doffs_cal(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 31;
        self.0 &= !0x80000000;
        self.0 |= value;
    }
    /// Result signal detect of IA stage
    #[inline(always)]
    pub fn ib_ia_sdet(&self) -> u32 {
        (self.0 & 0x4000000) >> 26
    }
    #[inline(always)]
    pub fn set_ib_ia_sdet(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 26;
        self.0 &= !0x4000000;
        self.0 |= value;
    }
    /// Direct Data output from IE block
    #[inline(always)]
    pub fn ib_ie_direct_data(&self) -> u32 {
        (self.0 & 0x200000) >> 21
    }
    #[inline(always)]
    pub fn set_ib_ie_direct_data(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 21;
        self.0 &= !0x200000;
        self.0 |= value;
    }
    /// Result signal detect of IE stage
    #[inline(always)]
    pub fn ib_ie_sdet(&self) -> u32 {
        (self.0 & 0x8000000) >> 27
    }
    #[inline(always)]
    pub fn set_ib_ie_sdet(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 27;
        self.0 &= !0x8000000;
        self.0 |= value;
    }
    /// Detection of toggling signal at PADP and PADN
    #[inline(always)]
    pub fn ib_ie_sdet_nedge(&self) -> u32 {
        (self.0 & 0x10000000) >> 28
    }
    #[inline(always)]
    pub fn set_ib_ie_sdet_nedge(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 28;
        self.0 &= !0x10000000;
        self.0 |= value;
    }
    /// Detection of toggling signal at PADP and PADN
    #[inline(always)]
    pub fn ib_ie_sdet_pedge(&self) -> u32 {
        (self.0 & 0x20000000) >> 29
    }
    #[inline(always)]
    pub fn set_ib_ie_sdet_pedge(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 29;
        self.0 &= !0x20000000;
        self.0 |= value;
    }
    /// Data offset calibration result IS stage
    #[inline(always)]
    pub fn ib_is_doffs_cal(&self) -> u32 {
        (self.0 & 0x40000000) >> 30
    }
    #[inline(always)]
    pub fn set_ib_is_doffs_cal(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 30;
        self.0 &= !0x40000000;
        self.0 |= value;
    }
    /// JTAG debug clk
    #[inline(always)]
    pub fn ib_jtag_clk(&self) -> u32 {
        (self.0 & 0x2) >> 1
    }
    #[inline(always)]
    pub fn set_ib_jtag_clk(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 1;
        self.0 &= !0x2;
        self.0 |= value;
    }
    /// JTAG debug enable
    #[inline(always)]
    pub fn ib_jtag_ena(&self) -> u32 {
        self.0 & 0x1
    }
    #[inline(always)]
    pub fn set_ib_jtag_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
    /// JTAG debug n-input
    #[inline(always)]
    pub fn ib_jtag_in_n(&self) -> u32 {
        (self.0 & 0x4) >> 2
    }
    #[inline(always)]
    pub fn set_ib_jtag_in_n(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 2;
        self.0 &= !0x4;
        self.0 |= value;
    }
    /// JTAG debug p-input
    #[inline(always)]
    pub fn ib_jtag_in_p(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    #[inline(always)]
    pub fn set_ib_jtag_in_p(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 3;
        self.0 &= !0x8;
        self.0 |= value;
    }
    /// JTAG debug n-output
    #[inline(always)]
    pub fn ib_jtag_out_n(&self) -> u32 {
        (self.0 & 0x200) >> 9
    }
    #[inline(always)]
    pub fn set_ib_jtag_out_n(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 9;
        self.0 &= !0x200;
        self.0 |= value;
    }
    /// JTAG debug p-output
    #[inline(always)]
    pub fn ib_jtag_out_p(&self) -> u32 {
        (self.0 & 0x400) >> 10
    }
    #[inline(always)]
    pub fn set_ib_jtag_out_p(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 10;
        self.0 &= !0x400;
        self.0 |= value;
    }
    /// JTAG debug threshold
    ///
    /// 0: 0mV 1: 10mV 31: 310mV
    #[inline(always)]
    pub fn ib_jtag_thres(&self) -> u32 {
        (self.0 & 0x1f0) >> 4
    }
    #[inline(always)]
    pub fn set_ib_jtag_thres(&mut self, value: u32) {
        assert!(value <= 0x1f);
        let value = value << 4;
        self.0 &= !0x1f0;
        self.0 |= value;
    }
    /// Drive enable for BiDi loop (a.k.a. Input loop o. RX->TX loop). Is or'ed with primary input: ib_inp_loop_ena_i. Is overruled by PAD loop.
    #[inline(always)]
    pub fn ib_loop_drv(&self) -> u32 {
        (self.0 & 0x10000) >> 16
    }
    #[inline(always)]
    pub fn set_ib_loop_drv(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 16;
        self.0 &= !0x10000;
        self.0 |= value;
    }
    /// Receive enable for BiDi loop (a.k.a. PAD loop o. TX->RX loop). Is or'ed with primary input: ib_pad_loop_ena_i. Disable testgenerator 'ib_tstgen_ena' if input loop is used
    #[inline(always)]
    pub fn ib_loop_rec(&self) -> u32 {
        (self.0 & 0x20000) >> 17
    }
    #[inline(always)]
    pub fn set_ib_loop_rec(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 17;
        self.0 &= !0x20000;
        self.0 |= value;
    }
}
/// SD10G65 IB Configuration register 11 JTAG related setting
///
/// Configuration register 11 for SD10G65 IB.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct SD10G65_IB_CFG11(u32);
impl SD10G65_IB_CFG11 {
    /// DFE Bias current settings (bit-group is gated with IB_DFE_ENA)
    ///
    /// 0: DFE disabled 1: Minimum current 15: Maximum current
    #[inline(always)]
    pub fn ib_dfe_isel(&self) -> u32 {
        (self.0 & 0xf000) >> 12
    }
    #[inline(always)]
    pub fn set_ib_dfe_isel(&mut self, value: u32) {
        assert!(value <= 0xf);
        let value = value << 12;
        self.0 &= !0xf000;
        self.0 |= value;
    }
    /// Increase current in first stage (only available in 1.2 Volt mode)
    #[inline(always)]
    pub fn ib_ena_400_inp(&self) -> u32 {
        (self.0 & 0x800) >> 11
    }
    #[inline(always)]
    pub fn set_ib_ena_400_inp(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 11;
        self.0 &= !0x800;
        self.0 |= value;
    }
    /// Reserved
    #[inline(always)]
    pub fn ib_spare_pool(&self) -> u32 {
        (self.0 & 0x10000) >> 16
    }
    #[inline(always)]
    pub fn set_ib_spare_pool(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 16;
        self.0 &= !0x10000;
        self.0 |= value;
    }
    /// Gain temperature coefficient for DFE stage
    #[inline(always)]
    pub fn ib_tc_dfe(&self) -> u32 {
        (self.0 & 0x7c0) >> 6
    }
    #[inline(always)]
    pub fn set_ib_tc_dfe(&mut self, value: u32) {
        assert!(value <= 0x1f);
        let value = value << 6;
        self.0 &= !0x7c0;
        self.0 |= value;
    }
    /// Gain temperature coefficient for AGC stage
    #[inline(always)]
    pub fn ib_tc_eq(&self) -> u32 {
        (self.0 & 0x3e) >> 1
    }
    #[inline(always)]
    pub fn set_ib_tc_eq(&mut self, value: u32) {
        assert!(value <= 0x1f);
        let value = value << 1;
        self.0 &= !0x3e;
        self.0 |= value;
    }
}
/// SD10G65 IB Configuration register 2
///
/// Configuration register 2 for SD10G65 IB.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct SD10G65_IB_CFG2(u32);
impl SD10G65_IB_CFG2 {
    /// Amplification (gain) of AGC in Input Buffer (normal operation)
    ///
    /// after gain calibration 0: gain = 0.3 255: gain = 1.5 if disp/disn is active dac function for dfe gain calibration
    #[inline(always)]
    pub fn ib_eqz_agc(&self) -> u32 {
        (self.0 & 0x3fc00) >> 10
    }
    #[inline(always)]
    pub fn set_ib_eqz_agc(&mut self, value: u32) {
        assert!(value <= 0xff);
        let value = value << 10;
        self.0 &= !0x3fc00;
        self.0 |= value;
    }
    /// Gain of Input Buffer
    ///
    /// 0-511 gain adjustment only in first stage > 511 gain in first stage at max. 512-639 gain in 2.stage increased from 1 to 2 > 639 gain = 2 640-767 gain in 3.stage increased from 1 to 2 >767 gain = 2 768-895 gain in 4.stage increased from 1 to 2 >895 gain at max.
    #[inline(always)]
    pub fn ib_eqz_gain(&self) -> u32 {
        (self.0 & 0xffc0000) >> 18
    }
    #[inline(always)]
    pub fn set_ib_eqz_gain(&mut self, value: u32) {
        assert!(value <= 0x3ff);
        let value = value << 18;
        self.0 &= !0xffc0000;
        self.0 |= value;
    }
    /// Offset value for IB-stage of Input Buffer
    ///
    /// 512: neutral > 512: positive < 512: negative range +/- 600mV (low gain) to +/-30mV (high gain) gain dependent offset sensitivity requiered for Base line wander compensation not supported in test chip
    #[inline(always)]
    pub fn ib_eqz_offset(&self) -> u32 {
        self.0 & 0x3ff
    }
    #[inline(always)]
    pub fn set_ib_eqz_offset(&mut self, value: u32) {
        assert!(value <= 0x3ff);
        self.0 &= !0x3ff;
        self.0 |= value;
    }
}
/// SD10G65 IB Configuration register 3
///
/// Configuration register 1 for SD10G65 IB. Note: the behavior of IB_EQ_LD1_OFFSET changes when APC is disabled. In this case IB_EQ_LD1_OFFSET directly controls the level for Level-Detect circuitry 1. Coding: 0: 20mV, 1: 25mV, ... 63: 340mV.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct SD10G65_IB_CFG3(u32);
impl SD10G65_IB_CFG3 {
    /// Selects source of direct data path to core
    ///
    /// 0: IE 1: IA
    #[inline(always)]
    pub fn ib_direct_sel(&self) -> u32 {
        (self.0 & 0x800000) >> 23
    }
    #[inline(always)]
    pub fn set_ib_direct_sel(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 23;
        self.0 &= !0x800000;
        self.0 |= value;
    }
    /// Level for Level-Detect circuitry 0.
    ///
    /// 0: 20mV 1: 25mV ... 40: 220mV ... 63: 340mV
    #[inline(always)]
    pub fn ib_eq_ld0_level(&self) -> u32 {
        (self.0 & 0x1f800) >> 11
    }
    #[inline(always)]
    pub fn set_ib_eq_ld0_level(&mut self, value: u32) {
        assert!(value <= 0x3f);
        let value = value << 11;
        self.0 &= !0x1f800;
        self.0 |= value;
    }
    /// With APC enabled level offset (6bit-signed) compared to IB_EQ_LD0_LEVEL for Level-Detect circuitry 1. Saturating between 20mV and 340mV. See also note in register description.
    ///
    /// 0: no offset 1: +5mV 31: +155mV 63(= -1): -5mV 32(= -32): -160mV.
    #[inline(always)]
    pub fn ib_eq_ld1_offset(&self) -> u32 {
        (self.0 & 0x7e0000) >> 17
    }
    #[inline(always)]
    pub fn set_ib_eq_ld1_offset(&mut self, value: u32) {
        assert!(value <= 0x3f);
        let value = value << 17;
        self.0 &= !0x7e0000;
        self.0 |= value;
    }
    /// Threshold value for IA Signal-Detect.
    ///
    /// 0: 0mV ... 8: 80mV ... 31: 310mV
    #[inline(always)]
    pub fn ib_ia_sdet_level(&self) -> u32 {
        self.0 & 0x1f
    }
    #[inline(always)]
    pub fn set_ib_ia_sdet_level(&mut self, value: u32) {
        assert!(value <= 0x1f);
        self.0 &= !0x1f;
        self.0 |= value;
    }
    /// Threshold value for IE Signal-Detect.
    ///
    /// 0: 20mV 1: 25mV 2: 30mV ... 63: 340mV
    #[inline(always)]
    pub fn ib_ie_sdet_level(&self) -> u32 {
        (self.0 & 0x7e0) >> 5
    }
    #[inline(always)]
    pub fn set_ib_ie_sdet_level(&mut self, value: u32) {
        assert!(value <= 0x3f);
        let value = value << 5;
        self.0 &= !0x7e0;
        self.0 |= value;
    }
    /// Dividing factor for SDET and LD circuits of IE.
    ///
    /// 0: 128 1: 32 2: 8 3: 4
    #[inline(always)]
    pub fn ib_ldsd_divsel(&self) -> u32 {
        (self.0 & 0xc0000000) >> 30
    }
    #[inline(always)]
    pub fn set_ib_ldsd_divsel(&mut self, value: u32) {
        assert!(value <= 0x3);
        let value = value << 30;
        self.0 &= !0xc0000000;
        self.0 |= value;
    }
    /// Clock dividing factor for Signal Detect circuit of IA
    ///
    /// 0: 2 ... 7: 256
    #[inline(always)]
    pub fn ib_sdet_clk_div(&self) -> u32 {
        (self.0 & 0x38000000) >> 27
    }
    #[inline(always)]
    pub fn set_ib_sdet_clk_div(&mut self, value: u32) {
        assert!(value <= 0x7);
        let value = value << 27;
        self.0 &= !0x38000000;
        self.0 |= value;
    }
    /// Selects source of signal detect (ib_X_sdet_ena must be enabled accordingly)
    ///
    /// 0: IA 1: IE
    #[inline(always)]
    pub fn ib_sdet_sel(&self) -> u32 {
        (self.0 & 0x1000000) >> 24
    }
    #[inline(always)]
    pub fn set_ib_sdet_sel(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 24;
        self.0 &= !0x1000000;
        self.0 |= value;
    }
    /// Force Signal-Detect output to high level
    ///
    /// 0: Normal operation 1: Force sigdet high
    #[inline(always)]
    pub fn ib_set_sdet(&self) -> u32 {
        (self.0 & 0x4000000) >> 26
    }
    #[inline(always)]
    pub fn set_ib_set_sdet(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 26;
        self.0 &= !0x4000000;
        self.0 |= value;
    }
}
/// SD10G65 IB Configuration register 4
///
/// Configuration register 4 for SD10G65 IB.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct SD10G65_IB_CFG4(u32);
impl SD10G65_IB_CFG4 {
    /// corner frequency selection for c-gain peaking 4.stage
    ///
    /// 0: lowest corner frequency 3: highest corner frequency
    #[inline(always)]
    pub fn ib_eqz_c_adj_es0(&self) -> u32 {
        (self.0 & 0x3000000) >> 24
    }
    #[inline(always)]
    pub fn set_ib_eqz_c_adj_es0(&mut self, value: u32) {
        assert!(value <= 0x3);
        let value = value << 24;
        self.0 &= !0x3000000;
        self.0 |= value;
    }
    /// corner frequency selection for c-gain peaking 3.stage
    ///
    /// 0: lowest corner frequency 3: highest corner frequency
    #[inline(always)]
    pub fn ib_eqz_c_adj_es1(&self) -> u32 {
        (self.0 & 0xc000000) >> 26
    }
    #[inline(always)]
    pub fn set_ib_eqz_c_adj_es1(&mut self, value: u32) {
        assert!(value <= 0x3);
        let value = value << 26;
        self.0 &= !0xc000000;
        self.0 |= value;
    }
    /// corner frequency selection for c-gain peaking 2.stage
    ///
    /// 0: lowest corner frequency 3: highest corner frequency
    #[inline(always)]
    pub fn ib_eqz_c_adj_es2(&self) -> u32 {
        (self.0 & 0x30000000) >> 28
    }
    #[inline(always)]
    pub fn set_ib_eqz_c_adj_es2(&mut self, value: u32) {
        assert!(value <= 0x3);
        let value = value << 28;
        self.0 &= !0x30000000;
        self.0 |= value;
    }
    /// corner frequency selection for c-gain peaking 1.stage
    ///
    /// 0: lowest corner frequency 3: highest corner frequency
    #[inline(always)]
    pub fn ib_eqz_c_adj_ib(&self) -> u32 {
        (self.0 & 0xc0000000) >> 30
    }
    #[inline(always)]
    pub fn set_ib_eqz_c_adj_ib(&mut self, value: u32) {
        assert!(value <= 0x3);
        let value = value << 30;
        self.0 &= !0xc0000000;
        self.0 |= value;
    }
    /// Coder mode: APC C value to IE capacitance
    ///
    /// 0: equ. distributed 2: 1st buffer max - 2nd buffer max - ...
    #[inline(always)]
    pub fn ib_eqz_c_mode(&self) -> u32 {
        (self.0 & 0x1c0000) >> 18
    }
    #[inline(always)]
    pub fn set_ib_eqz_c_mode(&mut self, value: u32) {
        assert!(value <= 0x7);
        let value = value << 18;
        self.0 &= !0x1c0000;
        self.0 |= value;
    }
    /// Coder mode: APC L value to IE inductance
    ///
    /// 0: equ. distributed (double step 3->4) 1: equ. distributed (no change 6+7) 2: 1st buffer max - 2nd buffer max - ...
    #[inline(always)]
    pub fn ib_eqz_l_mode(&self) -> u32 {
        (self.0 & 0xe00000) >> 21
    }
    #[inline(always)]
    pub fn set_ib_eqz_l_mode(&mut self, value: u32) {
        assert!(value <= 0x7);
        let value = value << 21;
        self.0 &= !0xe00000;
        self.0 |= value;
    }
    /// Threshold value (offset) for main sampling path
    ///
    /// 0: -max 31: -0 32: +0 63: +max (depending on calibration)
    #[inline(always)]
    pub fn ib_main_thres(&self) -> u32 {
        self.0 & 0x3f
    }
    #[inline(always)]
    pub fn set_ib_main_thres(&mut self, value: u32) {
        assert!(value <= 0x3f);
        self.0 &= !0x3f;
        self.0 |= value;
    }
    /// Threshold value (offset) for vscope-high sampling path
    ///
    /// 0: -max 31: -0 32: +0 63: +max (depending on calibration)
    #[inline(always)]
    pub fn ib_vscope_h_thres(&self) -> u32 {
        (self.0 & 0x3f000) >> 12
    }
    #[inline(always)]
    pub fn set_ib_vscope_h_thres(&mut self, value: u32) {
        assert!(value <= 0x3f);
        let value = value << 12;
        self.0 &= !0x3f000;
        self.0 |= value;
    }
    /// Threshold value (offset) for vscope-low sampling path
    ///
    /// 0: -max 31: -0 32: +0 63: +max (depending on calibration)
    #[inline(always)]
    pub fn ib_vscope_l_thres(&self) -> u32 {
        (self.0 & 0xfc0) >> 6
    }
    #[inline(always)]
    pub fn set_ib_vscope_l_thres(&mut self, value: u32) {
        assert!(value <= 0x3f);
        let value = value << 6;
        self.0 &= !0xfc0;
        self.0 |= value;
    }
}
/// SD10G65 IB Configuration register 5
///
/// Configuration register 5 for SD10G65 IB.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct SD10G65_IB_CFG5(u32);
impl SD10G65_IB_CFG5 {
    /// AGC output disable required to calibrate DFE-gain
    ///
    /// 0: mission mode 3: Vout = 0V 1: Vout= xx*ampldfe/64 2: Vout=-xx*ampldfe/64 ampldfe=270mV if ena1V = '1' (1V mode) ampldfe=360mV if ena1V = '0' (1.2V mode) xx=
    #[inline(always)]
    pub fn ib_agc_dis(&self) -> u32 {
        (self.0 & 0x60000) >> 17
    }
    #[inline(always)]
    pub fn set_ib_agc_dis(&mut self, value: u32) {
        assert!(value <= 0x3);
        let value = value << 17;
        self.0 &= !0x60000;
        self.0 |= value;
    }
    /// Enables IS MUX in detblk1
    #[inline(always)]
    pub fn ib_calmux_ena(&self) -> u32 {
        (self.0 & 0x400) >> 10
    }
    #[inline(always)]
    pub fn set_ib_calmux_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 10;
        self.0 &= !0x400;
        self.0 |= value;
    }
    /// DFE output disable required to calibrate IS
    ///
    /// 0: mission mode 3: Vout = 0V 1: Vout= xx*ampldfe/64 2: Vout=-xx*ampldfe/64 ampldfe=196mV if ena1V = '1' (1V mode) ampldfe=260mV if ena1V = '0' (1.2V mode) xx= TBD
    #[inline(always)]
    pub fn ib_dfe_dis(&self) -> u32 {
        (self.0 & 0x180000) >> 19
    }
    #[inline(always)]
    pub fn set_ib_dfe_dis(&mut self, value: u32) {
        assert!(value <= 0x3);
        let value = value << 19;
        self.0 &= !0x180000;
        self.0 |= value;
    }
    /// Selects EQ Level Detect for calibration
    #[inline(always)]
    pub fn ib_eq_ld_cal_ena(&self) -> u32 {
        (self.0 & 0x10000) >> 16
    }
    #[inline(always)]
    pub fn set_ib_eq_ld_cal_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 16;
        self.0 &= !0x10000;
        self.0 |= value;
    }
    /// Enable calibration in order to eliminate hysteresis
    ///
    /// 1: Enable 0: Disable
    #[inline(always)]
    pub fn ib_hys_cal_ena(&self) -> u32 {
        (self.0 & 0x800) >> 11
    }
    #[inline(always)]
    pub fn set_ib_hys_cal_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 11;
        self.0 &= !0x800;
        self.0 |= value;
    }
    /// Selects IA offset circuit for calibration
    #[inline(always)]
    pub fn ib_ia_offs_cal_ena(&self) -> u32 {
        (self.0 & 0x2000) >> 13
    }
    #[inline(always)]
    pub fn set_ib_ia_offs_cal_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 13;
        self.0 &= !0x2000;
        self.0 |= value;
    }
    /// Selects IE Signal Detect for calibration
    #[inline(always)]
    pub fn ib_ie_sdet_cal_ena(&self) -> u32 {
        (self.0 & 0x1000) >> 12
    }
    #[inline(always)]
    pub fn set_ib_ie_sdet_cal_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 12;
        self.0 &= !0x1000;
        self.0 |= value;
    }
    /// Selects IS offset circuit for calibration
    #[inline(always)]
    pub fn ib_is_offs_cal_ena(&self) -> u32 {
        (self.0 & 0x4000) >> 14
    }
    #[inline(always)]
    pub fn set_ib_is_offs_cal_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 14;
        self.0 &= !0x4000;
        self.0 |= value;
    }
    /// Enable jump to opposite half of h-channel
    ///
    /// 0: Post main sampler 1: Pre main sampler
    #[inline(always)]
    pub fn ib_jumph_ena(&self) -> u32 {
        (self.0 & 0x400000) >> 22
    }
    #[inline(always)]
    pub fn set_ib_jumph_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 22;
        self.0 &= !0x400000;
        self.0 |= value;
    }
    /// Enable jump to opposite half of l-channel
    ///
    /// 0: Post main sampler 1: Pre main sampler
    #[inline(always)]
    pub fn ib_jumpl_ena(&self) -> u32 {
        (self.0 & 0x200000) >> 21
    }
    #[inline(always)]
    pub fn set_ib_jumpl_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 21;
        self.0 &= !0x200000;
        self.0 |= value;
    }
    /// Selects calibration target (sample stage threshold, sample stage offset, aux.-stage offset), dependend on calibration group, see encoding.
    ///
    /// When ib_thres_cal_ena = 1 0: MD0 threshold 1: MD1 threshold 2: CP0 threshold 3: CP1 threshold 4: VH0 threshold 5: VH1 threshold 6: VL0 threshold 7: VL1 threshold When ib_is_offs_cal_ena = 1 0: MD0 offset 1: MD1 offset 2: CP0 offset 3: CP1 offset 4: VH0 offset 5: VH1 offset 6: VL0 offset 7: VL1 offset When ib_ia_offs_cal_ena = 1 0: Observe0 offset 1: Observe1 offset 2: Observe0 threshold 3: Observe1 threshold (MSB not used)
    #[inline(always)]
    pub fn ib_offs_blksel(&self) -> u32 {
        (self.0 & 0x3c0) >> 6
    }
    #[inline(always)]
    pub fn set_ib_offs_blksel(&mut self, value: u32) {
        assert!(value <= 0xf);
        let value = value << 6;
        self.0 &= !0x3c0;
        self.0 |= value;
    }
    /// Calibration value for IA/IS. Values for threshold calibration get inverted for negative threshold voltages (ib_vscope_h_thres, ib_vscope_l_thres or ib_main_thres).
    ///
    /// For offset calibration 0: -max_offset * 32/32 31: -max_offset * 1/32 32: +max_offset * 1/32 63: +max_offset * 32/32 For threshold calibration 0: min_threshold 63: max_threshold
    #[inline(always)]
    pub fn ib_offs_value(&self) -> u32 {
        self.0 & 0x3f
    }
    #[inline(always)]
    pub fn set_ib_offs_value(&mut self, value: u32) {
        assert!(value <= 0x3f);
        self.0 &= !0x3f;
        self.0 |= value;
    }
    /// Selects IS threshold circuit for calibration
    #[inline(always)]
    pub fn ib_thres_cal_ena(&self) -> u32 {
        (self.0 & 0x8000) >> 15
    }
    #[inline(always)]
    pub fn set_ib_thres_cal_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 15;
        self.0 &= !0x8000;
        self.0 |= value;
    }
    /// Test generator amplitude setting
    ///
    /// 0: 0mV ... 15: 150mV
    #[inline(always)]
    pub fn ib_tstgen_ampl(&self) -> u32 {
        (self.0 & 0xf0000000) >> 28
    }
    #[inline(always)]
    pub fn set_ib_tstgen_ampl(&mut self, value: u32) {
        assert!(value <= 0xf);
        let value = value << 28;
        self.0 &= !0xf0000000;
        self.0 |= value;
    }
    /// Test generator data
    ///
    /// 0: low 1: high
    #[inline(always)]
    pub fn ib_tstgen_data(&self) -> u32 {
        (self.0 & 0x4000000) >> 26
    }
    #[inline(always)]
    pub fn set_ib_tstgen_data(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 26;
        self.0 &= !0x4000000;
        self.0 |= value;
    }
    /// Test generator enable but data path selected with 'ib_sig_sel' (disable input loop if testgenerator is used)
    ///
    /// 0: inactive 1: active
    #[inline(always)]
    pub fn ib_tstgen_ena(&self) -> u32 {
        (self.0 & 0x8000000) >> 27
    }
    #[inline(always)]
    pub fn set_ib_tstgen_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 27;
        self.0 &= !0x8000000;
        self.0 |= value;
    }
    /// Test generator data toggle enable
    ///
    /// 0: inactive 1: active
    #[inline(always)]
    pub fn ib_tstgen_toggle_ena(&self) -> u32 {
        (self.0 & 0x2000000) >> 25
    }
    #[inline(always)]
    pub fn set_ib_tstgen_toggle_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 25;
        self.0 &= !0x2000000;
        self.0 |= value;
    }
}
/// SD10G65 IB Configuration register 6
///
/// Configuration register 6 for SD10G65 IB.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct SD10G65_IB_CFG6(u32);
impl SD10G65_IB_CFG6 {
    /// Enable automatic AGC adjustment
    ///
    /// 1: AGC is adjusted automatically (IB_EQZ_AGC_ADJ value is not used) 0: AGC is adjusted with value stored in IB_EQZ_AGC_ADJ
    #[inline(always)]
    pub fn ib_auto_agc_adj(&self) -> u32 {
        (self.0 & 0x1000) >> 12
    }
    #[inline(always)]
    pub fn set_ib_auto_agc_adj(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 12;
        self.0 &= !0x1000;
        self.0 |= value;
    }
    /// Gain adjustment of AGC-amplifier
    ///
    /// Bitgroup should be set to 2*IB_DFE_GAIN_ADJ
    #[inline(always)]
    pub fn ib_eqz_agc_adj(&self) -> u32 {
        (self.0 & 0xfe0) >> 5
    }
    #[inline(always)]
    pub fn set_ib_eqz_agc_adj(&mut self, value: u32) {
        assert!(value <= 0x7f);
        let value = value << 5;
        self.0 &= !0xfe0;
        self.0 |= value;
    }
    /// 0dB Gain adjustment for EQZ-stages of Input Buffer
    ///
    /// level at LD0 = LD1 -> 0dB level range 160mV-220mV
    #[inline(always)]
    pub fn ib_eqz_gain_adj(&self) -> u32 {
        (self.0 & 0x7f0000) >> 16
    }
    #[inline(always)]
    pub fn set_ib_eqz_gain_adj(&mut self, value: u32) {
        assert!(value <= 0x7f);
        let value = value << 16;
        self.0 &= !0x7f0000;
        self.0 |= value;
    }
    /// Range for offset calibration of all sampling pathes
    ///
    /// 0: 0mV 32: 80mV
    #[inline(always)]
    pub fn ib_sam_offs_adj(&self) -> u32 {
        self.0 & 0x1f
    }
    #[inline(always)]
    pub fn set_ib_sam_offs_adj(&mut self, value: u32) {
        assert!(value <= 0x1f);
        self.0 &= !0x1f;
        self.0 |= value;
    }
}
/// SD10G65 IB Configuration register 7
///
/// Configuration register 7 for SD10G65 IB.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct SD10G65_IB_CFG7(u32);
impl SD10G65_IB_CFG7 {
    /// Gain adjustment of DFEamplifier
    ///
    /// DFE Gain 1 Volt mode = 0dB 1.2 Volt mode 1dB measurement with int. DAC and Vscope Channels
    #[inline(always)]
    pub fn ib_dfe_gain_adj(&self) -> u32 {
        (self.0 & 0x3f0000) >> 16
    }
    #[inline(always)]
    pub fn set_ib_dfe_gain_adj(&mut self, value: u32) {
        assert!(value <= 0x3f);
        let value = value << 16;
        self.0 &= !0x3f0000;
        self.0 |= value;
    }
    /// Select configuration of DFEamplifier gain adjustment
    ///
    /// 0: Normal operation (APC can take over control) 1: Enforce configuration via IB_DFE_GAIN_ADJ
    #[inline(always)]
    pub fn ib_dfe_gain_adj_s(&self) -> u32 {
        (self.0 & 0x8000) >> 15
    }
    #[inline(always)]
    pub fn set_ib_dfe_gain_adj_s(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 15;
        self.0 &= !0x8000;
        self.0 |= value;
    }
    /// Higher threshold offset of DFE buffer for IS calibration
    ///
    /// 0: 0mv 63: 200mV
    #[inline(always)]
    pub fn ib_dfe_offset_h(&self) -> u32 {
        (self.0 & 0xfc0) >> 6
    }
    #[inline(always)]
    pub fn set_ib_dfe_offset_h(&mut self, value: u32) {
        assert!(value <= 0x3f);
        let value = value << 6;
        self.0 &= !0xfc0;
        self.0 |= value;
    }
    /// Selects higher or lower DFE offset for IS calibration
    ///
    /// 0: ib_dfe_offset_l 1: ib_dfe_offset_h
    #[inline(always)]
    pub fn ib_dfe_offset_h_l(&self) -> u32 {
        (self.0 & 0x400000) >> 22
    }
    #[inline(always)]
    pub fn set_ib_dfe_offset_h_l(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 22;
        self.0 &= !0x400000;
        self.0 |= value;
    }
    /// Lower sample offset of DFE buffer for IS calibration
    ///
    /// 0: 0mv 63: 200mV
    #[inline(always)]
    pub fn ib_dfe_offset_l(&self) -> u32 {
        self.0 & 0x3f
    }
    #[inline(always)]
    pub fn set_ib_dfe_offset_l(&mut self, value: u32) {
        assert!(value <= 0x3f);
        self.0 &= !0x3f;
        self.0 |= value;
    }
    /// Initial value for calibration of main sampling path
    #[inline(always)]
    pub fn ib_main_thres_cal(&self) -> u32 {
        (self.0 & 0x1f800000) >> 23
    }
    #[inline(always)]
    pub fn set_ib_main_thres_cal(&mut self, value: u32) {
        assert!(value <= 0x3f);
        let value = value << 23;
        self.0 &= !0x1f800000;
        self.0 |= value;
    }
}
/// SD10G65 IB Configuration register 8
///
/// Configuration register 8 for SD10G65 IB.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct SD10G65_IB_CFG8(u32);
impl SD10G65_IB_CFG8 {
    /// Enable analog output decoder in IE
    ///
    /// 1: Enable 0: Disable
    #[inline(always)]
    pub fn ib_aout_ena(&self) -> u32 {
        (self.0 & 0x40000000) >> 30
    }
    #[inline(always)]
    pub fn set_ib_aout_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 30;
        self.0 &= !0x40000000;
        self.0 |= value;
    }
    /// not used
    #[inline(always)]
    pub fn ib_aout_mux(&self) -> u32 {
        (self.0 & 0x80000000) >> 31
    }
    #[inline(always)]
    pub fn set_ib_aout_mux(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 31;
        self.0 &= !0x80000000;
        self.0 |= value;
    }
    /// Select analog signal routed to analog test output from either IB sampling stage or equalizer. See also SD10G65_IB_CFG8.IB_AOUT_ENA and SD10G65_SBUS_RX_CFG.SBUS_ANAOUT_SEL.
    ///
    /// Encoding for sampling stage: 0: VCMT 1: VCMR 2: CMLCI 3: RESIDL 4: RESCML 5: CMLSU 6: CMLBI 7: CMLRA 8: VCN 9: VCP 10: DIFSRC 11: VREGN 12: VREGP 13: TSTSRC 14: TSTDRN 15: TSTRES 16: CMLBF1P 17: CMLBF1N 18: CMLBF2P 19: CMLBF2P 20: CMLBF3P 21: CMLBF3P 22: CMLBF4P 23: CMLBF4P 24 to 31: same coding as for 16 to 23 Encoding for equalizer: 0: n.a. 1: vddi_int 2: eq1_vreg 3: eq2_vreg 4: eq3_vreg 5: agc_vreg 6: dfe_vreg 7: dfe_p 8: n.a. 9: ib_cmv 10: eq1_cmv 11: eq2_cmv 12: eq3_cmv 13: agc_cmv 14: dfe_cmv 15: dfe_n
    #[inline(always)]
    pub fn ib_aout_pool(&self) -> u32 {
        (self.0 & 0x3e000000) >> 25
    }
    #[inline(always)]
    pub fn set_ib_aout_pool(&mut self, value: u32) {
        assert!(value <= 0x1f);
        let value = value << 25;
        self.0 &= !0x3e000000;
        self.0 |= value;
    }
    /// Gain of cml stages inside IS
    ///
    /// 0: 3dB 31: 6dB 63: 9dB
    #[inline(always)]
    pub fn ib_bias_adj(&self) -> u32 {
        (self.0 & 0x3f0) >> 4
    }
    #[inline(always)]
    pub fn set_ib_bias_adj(&mut self, value: u32) {
        assert!(value <= 0x3f);
        let value = value << 4;
        self.0 &= !0x3f0;
        self.0 |= value;
    }
    /// Bias regulation mode
    ///
    /// 0: constant resistor 1: constant current
    #[inline(always)]
    pub fn ib_bias_mode(&self) -> u32 {
        (self.0 & 0x80000) >> 19
    }
    #[inline(always)]
    pub fn set_ib_bias_mode(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 19;
        self.0 &= !0x80000;
        self.0 |= value;
    }
    /// Amplitude of cml stages inside IS
    ///
    /// 0: 200mVppd 7: 240mVppd
    #[inline(always)]
    pub fn ib_cml_ampl(&self) -> u32 {
        (self.0 & 0x1c00) >> 10
    }
    #[inline(always)]
    pub fn set_ib_cml_ampl(&mut self, value: u32) {
        assert!(value <= 0x7);
        let value = value << 10;
        self.0 &= !0x1c00;
        self.0 |= value;
    }
    /// Current through CML Cells
    ///
    /// 0: 150% 5: 100% 15: 50%
    #[inline(always)]
    pub fn ib_cml_curr(&self) -> u32 {
        self.0 & 0xf
    }
    #[inline(always)]
    pub fn set_ib_cml_curr(&mut self, value: u32) {
        assert!(value <= 0xf);
        self.0 &= !0xf;
        self.0 |= value;
    }
    /// EQZ current control
    ///
    /// 0: mission mode 1: 1.5% current increase
    #[inline(always)]
    pub fn ib_eq_curr(&self) -> u32 {
        (self.0 & 0x200000) >> 21
    }
    #[inline(always)]
    pub fn set_ib_eq_curr(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 21;
        self.0 &= !0x200000;
        self.0 |= value;
    }
    /// Invert calibration value coming from the calibration FSM for IA calibration.
    #[inline(always)]
    pub fn ib_inv_ia_cal_val(&self) -> u32 {
        (self.0 & 0x8000) >> 15
    }
    #[inline(always)]
    pub fn set_ib_inv_ia_cal_val(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 15;
        self.0 &= !0x8000;
        self.0 |= value;
    }
    /// Invert observe signal from auxilary stage that goes to calibration FSM
    #[inline(always)]
    pub fn ib_inv_ia_dofs(&self) -> u32 {
        (self.0 & 0x20000) >> 17
    }
    #[inline(always)]
    pub fn set_ib_inv_ia_dofs(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 17;
        self.0 &= !0x20000;
        self.0 |= value;
    }
    /// Invert observe signal from sample stage that goes to calibration FSM
    #[inline(always)]
    pub fn ib_inv_is_dofs(&self) -> u32 {
        (self.0 & 0x10000) >> 16
    }
    #[inline(always)]
    pub fn set_ib_inv_is_dofs(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 16;
        self.0 &= !0x10000;
        self.0 |= value;
    }
    /// Invert calibration value coming from the calibration FSM for IS offset calibration.
    #[inline(always)]
    pub fn ib_inv_offs_cal_val(&self) -> u32 {
        (self.0 & 0x2000) >> 13
    }
    #[inline(always)]
    pub fn set_ib_inv_offs_cal_val(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 13;
        self.0 &= !0x2000;
        self.0 |= value;
    }
    /// Invert calibration value coming from the calibration FSM for IS threshold calibration.
    #[inline(always)]
    pub fn ib_inv_thr_cal_val(&self) -> u32 {
        (self.0 & 0x4000) >> 14
    }
    #[inline(always)]
    pub fn set_ib_inv_thr_cal_val(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 14;
        self.0 &= !0x4000;
        self.0 |= value;
    }
    /// Enables neutral setting of latches
    ///
    /// 1: Reset to mid values 0: Normal operation
    #[inline(always)]
    pub fn ib_lat_neutral(&self) -> u32 {
        (self.0 & 0x40000) >> 18
    }
    #[inline(always)]
    pub fn set_ib_lat_neutral(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 18;
        self.0 &= !0x40000;
        self.0 |= value;
    }
    /// Use separate vscope clock for vscope-channels
    #[inline(always)]
    pub fn ib_sel_vclk(&self) -> u32 {
        (self.0 & 0x100000) >> 20
    }
    #[inline(always)]
    pub fn set_ib_sel_vclk(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 20;
        self.0 &= !0x100000;
        self.0 |= value;
    }
}
/// SD10G65 IB Configuration register 9  automatically adapted DFE coefficients
///
/// Configuration register 9 for SD10G65 IB.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct SD10G65_IB_CFG9(u32);
impl SD10G65_IB_CFG9 {
    /// Weighting for first DFE coefficient
    #[inline(always)]
    pub fn ib_dfe_coef1(&self) -> u32 {
        self.0 & 0x7f
    }
    #[inline(always)]
    pub fn set_ib_dfe_coef1(&mut self, value: u32) {
        assert!(value <= 0x7f);
        self.0 &= !0x7f;
        self.0 |= value;
    }
    /// Weighting for second DFE coefficient
    #[inline(always)]
    pub fn ib_dfe_coef2(&self) -> u32 {
        (self.0 & 0x3f00) >> 8
    }
    #[inline(always)]
    pub fn set_ib_dfe_coef2(&mut self, value: u32) {
        assert!(value <= 0x3f);
        let value = value << 8;
        self.0 &= !0x3f00;
        self.0 |= value;
    }
    /// Weighting for third DFE coefficient
    #[inline(always)]
    pub fn ib_dfe_coef3(&self) -> u32 {
        (self.0 & 0x1f0000) >> 16
    }
    #[inline(always)]
    pub fn set_ib_dfe_coef3(&mut self, value: u32) {
        assert!(value <= 0x1f);
        let value = value << 16;
        self.0 &= !0x1f0000;
        self.0 |= value;
    }
    /// Weighting for fourth DFE coefficient
    #[inline(always)]
    pub fn ib_dfe_coef4(&self) -> u32 {
        (self.0 & 0x1f000000) >> 24
    }
    #[inline(always)]
    pub fn set_ib_dfe_coef4(&mut self, value: u32) {
        assert!(value <= 0x1f);
        let value = value << 24;
        self.0 &= !0x1f000000;
        self.0 |= value;
    }
}
/// SD10G65_RX Revision ID
///
/// Revision numbers of the analog sub IPs used in the SD10G65_RX
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct SD10G65_RX_REV_ID(u32);
impl SD10G65_RX_REV_ID {
    /// Feature set number of deserializer (des10g_N)
    #[inline(always)]
    pub fn des_rev_id(&self) -> u32 {
        (self.0 & 0xfc000000) >> 26
    }
    #[inline(always)]
    pub fn set_des_rev_id(&mut self, value: u32) {
        assert!(value <= 0x3f);
        let value = value << 26;
        self.0 &= !0xfc000000;
        self.0 |= value;
    }
    /// Feature set number of input buffer (ib10g_N)
    #[inline(always)]
    pub fn ib_rev_id(&self) -> u32 {
        (self.0 & 0x3f00000) >> 20
    }
    #[inline(always)]
    pub fn set_ib_rev_id(&mut self, value: u32) {
        assert!(value <= 0x3f);
        let value = value << 20;
        self.0 &= !0x3f00000;
        self.0 |= value;
    }
    /// Feature set number of RC-PLL (pll10g_N)
    #[inline(always)]
    pub fn rcpll_rev_id(&self) -> u32 {
        (self.0 & 0x3f00) >> 8
    }
    #[inline(always)]
    pub fn set_rcpll_rev_id(&mut self, value: u32) {
        assert!(value <= 0x3f);
        let value = value << 8;
        self.0 &= !0x3f00;
        self.0 |= value;
    }
    /// Feature set number of synthesizer (syn_N)
    #[inline(always)]
    pub fn synth_rev_id(&self) -> u32 {
        (self.0 & 0xfc000) >> 14
    }
    #[inline(always)]
    pub fn set_synth_rev_id(&mut self, value: u32) {
        assert!(value <= 0x3f);
        let value = value << 14;
        self.0 &= !0xfc000;
        self.0 |= value;
    }
    /// Feature set number of Toplevel (sd10g65_N)
    #[inline(always)]
    pub fn top_rev_id(&self) -> u32 {
        self.0 & 0xff
    }
    #[inline(always)]
    pub fn set_top_rev_id(&mut self, value: u32) {
        assert!(value <= 0xff);
        self.0 &= !0xff;
        self.0 |= value;
    }
}
/// SD10G65_RX subversion revision number
///
/// Subversion revision number for the RTL used in SD10G65_RX
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct SD10G65_RX_SVN_ID(u32);
impl SD10G65_RX_SVN_ID {
    /// SVN revision number of RTL sources
    #[inline(always)]
    pub fn rx_svn_id(&self) -> u32 {
        self.0
    }
    #[inline(always)]
    pub fn set_rx_svn_id(&mut self, value: u32) {
        self.0 = value;
    }
}
/// SD10G65 SBUS RX CFG Service-Bus related setting
///
/// Configuration register for Service-Bus related setting. Note: SBUS configuration applies for RX/TX aggregates only, any configuration applied to SBUS_TX_CFG (output buffer cfg space) will be ignored.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct SD10G65_SBUS_RX_CFG(u32);
impl SD10G65_SBUS_RX_CFG {
    /// Enable analog test output multiplexer
    #[inline(always)]
    pub fn sbus_anaout_en(&self) -> u32 {
        (self.0 & 0x80) >> 7
    }
    #[inline(always)]
    pub fn set_sbus_anaout_en(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 7;
        self.0 &= !0x80;
        self.0 |= value;
    }
    /// Analog test output
    ///
    /// 0: l0_ctrlspeed[0] 1: vbulk 2: nref 3: vref820m 4: vddfilt 5: vddfilt 6: ie_aout 7: ib_aout 8: ob_aout2 9: pll_frange 10: pll_srange 11: pll_vreg820m_tx 12: pll_vreg820m_rx 13: ob_aout_n 14: ob_aout_p 15: vddfilt
    #[inline(always)]
    pub fn sbus_anaout_sel(&self) -> u32 {
        (self.0 & 0xf00) >> 8
    }
    #[inline(always)]
    pub fn set_sbus_anaout_sel(&mut self, value: u32) {
        assert!(value <= 0xf);
        let value = value << 8;
        self.0 &= !0xf00;
        self.0 |= value;
    }
    /// Bias enable
    ///
    /// 1: Enable 0: Disable
    #[inline(always)]
    pub fn sbus_bias_en(&self) -> u32 {
        self.0 & 0x1
    }
    #[inline(always)]
    pub fn set_sbus_bias_en(&mut self, value: u32) {
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
    /// Bias speed selection
    ///
    /// 0: Below 4Gbps 1: 4Gbps to 6Gbps 2: 6Gbps to 9Gbps 3: Above 9Gbps
    #[inline(always)]
    pub fn sbus_bias_speed_sel(&self) -> u32 {
        (self.0 & 0x6) >> 1
    }
    #[inline(always)]
    pub fn set_sbus_bias_speed_sel(&mut self, value: u32) {
        assert!(value <= 0x3);
        let value = value << 1;
        self.0 &= !0x6;
        self.0 |= value;
    }
    /// Enable BiDi loop driver for F2DF testing
    #[inline(always)]
    pub fn sbus_loopdrv_ena(&self) -> u32 {
        (self.0 & 0x1000) >> 12
    }
    #[inline(always)]
    pub fn set_sbus_loopdrv_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 12;
        self.0 &= !0x1000;
        self.0 |= value;
    }
    /// Offset value for BIAS resistor calibration (2-complement)
    ///
    /// 1000: -8 1111: -1 0000: 0 0111: 7
    #[inline(always)]
    pub fn sbus_rcomp(&self) -> u32 {
        (self.0 & 0x78) >> 3
    }
    #[inline(always)]
    pub fn set_sbus_rcomp(&mut self, value: u32) {
        assert!(value <= 0xf);
        let value = value << 3;
        self.0 &= !0x78;
        self.0 |= value;
    }
    /// Pool of spare bits for use in late design changes.
    #[inline(always)]
    pub fn sbus_spare_pool(&self) -> u32 {
        (self.0 & 0xf0000) >> 16
    }
    #[inline(always)]
    pub fn set_sbus_spare_pool(&mut self, value: u32) {
        assert!(value <= 0xf);
        let value = value << 16;
        self.0 &= !0xf0000;
        self.0 |= value;
    }
}
