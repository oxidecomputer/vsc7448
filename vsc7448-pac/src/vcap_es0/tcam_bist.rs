// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Based on mesa-v2021.09 (https://github.com/microchip-ung/mesa/) which has
// the following copyright and license:
//
// Copyright (c) 2004-2021 Microchip Technology Inc. and its subsidiaries.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// This is an autogenerated file; do not edit by hand!
use derive_more::{From, Into};
/// Number of VCAP interfaces
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct IF_CNT(u32);
impl IF_CNT {
    /// The number of VCAP interfaces.
    pub fn if_cnt(&self) -> u32 {
        self.0
    }
    pub fn set_if_cnt(&mut self, value: u32) {
        self.0 = value;
    }
}
/// Configuration of the TCAM
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct TCAM_CFG(u32);
impl TCAM_CFG {
    /// Bias setting for the TCAM keeper circuit, configure as described in datasheet.
    pub fn tcam_bias(&self) -> u32 {
        self.0 & 0x3f
    }
    pub fn set_tcam_bias(&mut self, value: u32) {
        assert!(value <= 0x3f);
        self.0 &= !0x3f;
        self.0 |= value;
    }
    /// Configures the BIST engine to stop testing if an error is detected. This is a debug feature that leaves the contents of the TCAM at the point of the failure, thusly allowing debug of the failing pattern via normal R/W to the TCAM. Note that because the bist is pipelilned, the contents of the TCAM may have been modified a few times since the actual error.
    pub fn tcam_bist_soe_ena(&self) -> u32 {
        (self.0 & 0x100) >> 8
    }
    pub fn set_tcam_bist_soe_ena(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0x100);
        self.0 &= !0x100;
        self.0 |= value;
    }
    /// Disable clock-gating in the TCAM, clock-gating is implemented for conserving power while the TCAMs are IDLE.
    pub fn tcam_cg_dis(&self) -> u32 {
        (self.0 & 0x40) >> 6
    }
    pub fn set_tcam_cg_dis(&mut self, value: u32) {
        let value = value << 6;
        assert!(value <= 0x40);
        self.0 &= !0x40;
        self.0 |= value;
    }
    /// Disable clock-gating on previous stage hit in the TCAM, clock-gating on previous stage hit is implemented for conserving power when a hit is found in an early pipeline stage.
    pub fn tcam_hcg_dis(&self) -> u32 {
        (self.0 & 0x80) >> 7
    }
    pub fn set_tcam_hcg_dis(&mut self, value: u32) {
        let value = value << 7;
        assert!(value <= 0x80);
        self.0 &= !0x80;
        self.0 |= value;
    }
}
/// Control of the TCAM
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct TCAM_CTRL(u32);
impl TCAM_CTRL {
    /// Set this field to start manual BIST of the TCAM. This field will be cleared once BIST is complete. The BIST procedure requires that the TCAM is initialized before start, setting TCAM_INIT at the same time as setting this field will first initalize the TCAM and then run BIST.
    pub fn tcam_bist(&self) -> u32 {
        (self.0 & 0x2) >> 1
    }
    pub fn set_tcam_bist(&mut self, value: u32) {
        let value = value << 1;
        assert!(value <= 0x2);
        self.0 &= !0x2;
        self.0 |= value;
    }
    /// Set this field to start manual initialization of the TCAM. This field is cleared once initialization is complete. The TCAM has random contents after reset and must be initialized prior to usage.
    pub fn tcam_init(&self) -> u32 {
        self.0 & 0x1
    }
    pub fn set_tcam_init(&mut self, value: u32) {
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
}
/// Status for the TCAM
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct TCAM_STAT(u32);
impl TCAM_STAT {
    /// Set if BIST sub-procedure Address Decode failed.
    pub fn bist_addr_err(&self) -> u32 {
        (self.0 & 0x1000) >> 12
    }
    pub fn set_bist_addr_err(&mut self, value: u32) {
        let value = value << 12;
        assert!(value <= 0x1000);
        self.0 &= !0x1000;
        self.0 |= value;
    }
    /// Set if BIST sub-procedure Bit-Line-0 (extended) failed.
    pub fn bist_bl0e_err(&self) -> u32 {
        (self.0 & 0x200) >> 9
    }
    pub fn set_bist_bl0e_err(&mut self, value: u32) {
        let value = value << 9;
        assert!(value <= 0x200);
        self.0 &= !0x200;
        self.0 |= value;
    }
    /// Set if BIST sub-procedure Bit-Line-0 failed.
    pub fn bist_bl0_err(&self) -> u32 {
        (self.0 & 0x100) >> 8
    }
    pub fn set_bist_bl0_err(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0x100);
        self.0 &= !0x100;
        self.0 |= value;
    }
    /// Set if BIST sub-procedure Bit-Line-1 (extended) failed.
    pub fn bist_bl1e_err(&self) -> u32 {
        (self.0 & 0x800) >> 11
    }
    pub fn set_bist_bl1e_err(&mut self, value: u32) {
        let value = value << 11;
        assert!(value <= 0x800);
        self.0 &= !0x800;
        self.0 |= value;
    }
    /// Set if BIST sub-procedure Bit-Line-1 failed.
    pub fn bist_bl1_err(&self) -> u32 {
        (self.0 & 0x400) >> 10
    }
    pub fn set_bist_bl1_err(&mut self, value: u32) {
        let value = value << 10;
        assert!(value <= 0x400);
        self.0 &= !0x400;
        self.0 |= value;
    }
    /// Set while BIST is running. When checking the BIST result this field must be cleared.
    pub fn bist_busy(&self) -> u32 {
        (self.0 & 0x2) >> 1
    }
    pub fn set_bist_busy(&mut self, value: u32) {
        let value = value << 1;
        assert!(value <= 0x2);
        self.0 &= !0x2;
        self.0 |= value;
    }
    /// Set if BIST sub-procedure Compare failed.
    pub fn bist_comp_err(&self) -> u32 {
        (self.0 & 0x2000) >> 13
    }
    pub fn set_bist_comp_err(&mut self, value: u32) {
        let value = value << 13;
        assert!(value <= 0x2000);
        self.0 &= !0x2000;
        self.0 |= value;
    }
    /// Set if BIST failed.
    pub fn bist_err(&self) -> u32 {
        (self.0 & 0x4) >> 2
    }
    pub fn set_bist_err(&mut self, value: u32) {
        let value = value << 2;
        assert!(value <= 0x4);
        self.0 &= !0x4;
        self.0 |= value;
    }
    /// Set if BIST sub-procedure Priority-Encode failed.
    pub fn bist_penc_err(&self) -> u32 {
        (self.0 & 0x4000) >> 14
    }
    pub fn set_bist_penc_err(&mut self, value: u32) {
        let value = value << 14;
        assert!(value <= 0x4000);
        self.0 &= !0x4000;
        self.0 |= value;
    }
    /// Set if BIST sub-procedure Pattern-Horizontal-0 failed.
    pub fn bist_ph0_err(&self) -> u32 {
        (self.0 & 0x40) >> 6
    }
    pub fn set_bist_ph0_err(&mut self, value: u32) {
        let value = value << 6;
        assert!(value <= 0x40);
        self.0 &= !0x40;
        self.0 |= value;
    }
    /// Set if BIST sub-procedure Pattern-Horizontal-1 failed.
    pub fn bist_ph1_err(&self) -> u32 {
        (self.0 & 0x80) >> 7
    }
    pub fn set_bist_ph1_err(&mut self, value: u32) {
        let value = value << 7;
        assert!(value <= 0x80);
        self.0 &= !0x80;
        self.0 |= value;
    }
    /// Set if BIST sub-procedure Pattern-Vertical-0 failed.
    pub fn bist_pv0_err(&self) -> u32 {
        (self.0 & 0x10) >> 4
    }
    pub fn set_bist_pv0_err(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x10);
        self.0 &= !0x10;
        self.0 |= value;
    }
    /// Set if BIST sub-procedure Pattern-Vertical-1 failed.
    pub fn bist_pv1_err(&self) -> u32 {
        (self.0 & 0x20) >> 5
    }
    pub fn set_bist_pv1_err(&mut self, value: u32) {
        let value = value << 5;
        assert!(value <= 0x20);
        self.0 &= !0x20;
        self.0 |= value;
    }
    /// Set if BIST sub-procedure Read-Tree failed.
    pub fn bist_rt_err(&self) -> u32 {
        (self.0 & 0x8000) >> 15
    }
    pub fn set_bist_rt_err(&mut self, value: u32) {
        let value = value << 15;
        assert!(value <= 0x8000);
        self.0 &= !0x8000;
        self.0 |= value;
    }
    /// Set when the BIST has been run. When checking the BIST result this field must be set.
    pub fn bist_run(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    pub fn set_bist_run(&mut self, value: u32) {
        let value = value << 3;
        assert!(value <= 0x8);
        self.0 &= !0x8;
        self.0 |= value;
    }
    /// Indicates the current operational state of the TCAM.
    ///
    /// '0': Busy with initialization. '1': Ready to be used.
    pub fn tcam_rdy(&self) -> u32 {
        self.0 & 0x1
    }
    pub fn set_tcam_rdy(&mut self, value: u32) {
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
}
