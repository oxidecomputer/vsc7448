// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Based on mesa-v2021.09 (https://github.com/microchip-ung/mesa/) which has
// the following copyright and license:
//
// Copyright (c) 2004-2021 Microchip Technology Inc. and its subsidiaries.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// This is an autogenerated file; do not edit by hand!
use derive_more::{From, Into};
/// PCS interrupt status register
///
/// Contains the sticky bits representing interrupts from the PCS. Set by logic. Write 1 to clear.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct PCS_INTR_STAT(u32);
impl PCS_INTR_STAT {
    /// Interrupt when an invalid Rx block is detected
    ///
    /// 0: No invalid blocks 1: Invalid block detected
    pub fn c64b66b_err_sticky(&self) -> u32 {
        (self.0 & 0x10) >> 4
    }
    pub fn set_c64b66b_err_sticky(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 4;
        self.0 &= !0x10;
        self.0 |= value;
    }
    /// Lock (loss of synchronization) changed interrupt Interrupt occurs whenever there is ANY change in the underlying status of the LOCK signal
    ///
    /// 0: Synchronization has not changed 1: Synchronization (lock) status changed
    pub fn lock_changed_sticky(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    pub fn set_lock_changed_sticky(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 3;
        self.0 &= !0x8;
        self.0 |= value;
    }
    /// Interrupt generated when the Rx signal ordered set FIFO is full or becomes not full Interrupt occurs whenever there is ANY change in the underlying status
    ///
    /// 0: Rx ordered set FIFO full status unchanged 1: Rx ordered set FIFO full status changed
    pub fn rx_fset_fifo_full_sticky(&self) -> u32 {
        (self.0 & 0x1000) >> 12
    }
    pub fn set_rx_fset_fifo_full_sticky(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 12;
        self.0 &= !0x1000;
        self.0 |= value;
    }
    /// Interrupt indicating that a signal ordered set was received and captured (||Fsig||)
    ///
    /// 0: No ordered set captured 1: Ordered set captured in FIFO
    pub fn rx_fset_sticky(&self) -> u32 {
        (self.0 & 0x800) >> 11
    }
    pub fn set_rx_fset_sticky(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 11;
        self.0 &= !0x800;
        self.0 |= value;
    }
    /// Set by the Rx BER state machine when a high bit error rate condition is detected or cleared Interrupt occurs whenever there is ANY change in the underlying status
    ///
    /// 0: High BER status unchanged 1: High BER status changed
    pub fn rx_hi_ber_sticky(&self) -> u32 {
        self.0 & 0x1
    }
    pub fn set_rx_hi_ber_sticky(&mut self, value: u32) {
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
    /// Interrupt generated when the Rx sequence ordered set FIFO is full or becomes not full Interrupt occurs whenever there is ANY change in the underlying status
    ///
    /// 0: Rx ordered set FIFO full status unchanged 1: Rx ordered set FIFO full status changed
    pub fn rx_oset_fifo_full_sticky(&self) -> u32 {
        (self.0 & 0x40) >> 6
    }
    pub fn set_rx_oset_fifo_full_sticky(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 6;
        self.0 &= !0x40;
        self.0 |= value;
    }
    /// Interrupt indicating that a sequence ordered set was received and captured (||Q||)
    ///
    /// 0: No ordered set captured 1: Ordered set captured in FIFO
    pub fn rx_oset_sticky(&self) -> u32 {
        (self.0 & 0x20) >> 5
    }
    pub fn set_rx_oset_sticky(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 5;
        self.0 &= !0x20;
        self.0 |= value;
    }
    /// Interrupt if an invalid Tx XGMII character is detected
    ///
    /// 0: No invalid character 1: Invalid character detected
    pub fn xgmii_err_sticky(&self) -> u32 {
        (self.0 & 0x400) >> 10
    }
    pub fn set_xgmii_err_sticky(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 10;
        self.0 &= !0x400;
        self.0 |= value;
    }
}
/// PCS status register
///
/// Contains status information from the PCS core
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct PCS_STATUS(u32);
impl PCS_STATUS {
    /// The block_lock status from the synchronization state machine
    ///
    /// 0: Not synchronized 1: Synchronized, lock obtained
    pub fn rx_block_lock(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    pub fn set_rx_block_lock(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 3;
        self.0 &= !0x8;
        self.0 |= value;
    }
    /// Set by the Rx BER state machine when a high bit-error-rate condition is detected
    ///
    /// 0: Normal BER 1: High BER
    pub fn rx_hi_ber(&self) -> u32 {
        self.0 & 0x1
    }
    pub fn set_rx_hi_ber(&mut self, value: u32) {
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
    /// When in test pattern check mode, this bit will read 1 if the test pattern checker detects a match. When 0, the test pattern does not match. The test pattern error counts should still be used along with this register bit to determine proper test match status. The bit will read back 1 only when the test pattern is matching. This may happen even while test pattern errors are counted on other clock cycles.
    ///
    /// 0: Test pattern mismatch 1: Test pattern match
    pub fn testpat_match(&self) -> u32 {
        (self.0 & 0x10) >> 4
    }
    pub fn set_testpat_match(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 4;
        self.0 &= !0x10;
        self.0 |= value;
    }
}
