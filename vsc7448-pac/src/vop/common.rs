// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Based on mesa-v2021.09 (https://github.com/microchip-ung/mesa/) which has
// the following copyright and license:
//
// Copyright (c) 2004-2021 Microchip Technology Inc. and its subsidiaries.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// This is an autogenerated file; do not edit by hand!
use derive_more::{From, Into};
/// VOP Multicast MAC address configuration (LSB)
///
/// Each VOE can be addressed using either a common Multicast MAC address or a VOE specific Unicast MAC address. This register configures the Multicast Address common to all the VOEs. The full MAC address is a concatenation of the following registers: 1) VOP::COMMON_MEP_MC_MAC_LSB 2) VOP::COMMON_MEP_MC_MAC_MSB The default value of this register is determined by 802.1ag. The DMAC check to be performed for each VOE is configured in the following bit field: VOP:VOE_CONF:VOE_CTRL.RX_DMAC_CHK_SEL Note that only the upper 44 bits are matched, since the lower 4 bits of the DMAC address contain the MEG level.
#[derive(Copy, Clone, Debug, Eq, PartialEq, From, Into)]
pub struct COMMON_MEP_MC_MAC_LSB(u32);
impl COMMON_MEP_MC_MAC_LSB {
    /// See register description.
    #[inline(always)]
    pub fn mep_mc_mac_lsb(&self) -> u32 {
        (self.0 & 0x7ffffff8) >> 3
    }
    #[inline(always)]
    pub fn set_mep_mc_mac_lsb(&mut self, value: u32) {
        assert!(value <= 0xfffffff);
        let value = value << 3;
        self.0 &= !0x7ffffff8;
        self.0 |= value;
    }
}
/// VOP Multicast MAC address configuration (MSB)
///
/// Each VOE can be addressed using either a common Multicast MAC address or a VOE specific Unicast MAC address. This register configures the Multicast Address common to all the VOEs. The full MAC address is a concatenation of the folliowing registers: 1) VOP::COMMON_MEP_MC_MAC_LSB 2) VOP::COMMON_MEP_MC_MAC_MSB The default value of this register is determined by 802.1ag. The DMAC check to be performed for each VOE is configured in the following bit field: VOP:VOE_CONF:VOE_CTRL.RX_DMAC_CHK_SEL Note that only the upper 44 bits are matched, since the lower 4 bits of the DMAC address contain the MEG level.
#[derive(Copy, Clone, Debug, Eq, PartialEq, From, Into)]
pub struct COMMON_MEP_MC_MAC_MSB(u32);
impl COMMON_MEP_MC_MAC_MSB {
    /// See register description.
    #[inline(always)]
    pub fn mep_mc_mac_msb(&self) -> u32 {
        self.0 & 0xffff
    }
    #[inline(always)]
    pub fn set_mep_mc_mac_msb(&mut self, value: u32) {
        assert!(value <= 0xffff);
        self.0 &= !0xffff;
        self.0 |= value;
    }
}
/// Configuring destination for frames extracted to the CPU by Ethernet VOEs
///
/// This register configures the destination for OAM frames which are extracted to CPU by the VOE for various reasons. An OAM PDU may be extracted to the CPU for various reasons: * Based on PDU type (See register: VOP:VOE_CONF:OAM_CPU_COPY_CTRL.* * OAM error condition (e.g. DMAC error) * PDU specific extraction reasons. Most HW supported OAM PDUs have their own configuration, while some related PDUs share a single configuration. The configuration for each OAM PDU consists of one bit field which indicate which of the extraction queues the relevant PDUs are extracted: *_CPU_QU OAM PDU types which do not have a specific configuration will use the default configuration: DEF_COPY_CPU_QU The details are described for each bit field.
#[derive(Copy, Clone, Debug, Eq, PartialEq, From, Into)]
pub struct CPU_EXTR_CFG(u32);
impl CPU_EXTR_CFG {
    /// Configures the CPU queue port of the CPU error queue.
    ///
    /// 0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7
    #[inline(always)]
    pub fn cpu_err_qu(&self) -> u32 {
        (self.0 & 0x7000) >> 12
    }
    #[inline(always)]
    pub fn set_cpu_err_qu(&mut self, value: u32) {
        assert!(value <= 0x7);
        let value = value << 12;
        self.0 &= !0x7000;
        self.0 |= value;
    }
    /// Configures the destination for PDUs extracted to the Default CPU queue. The default CPU extraction queue is used for extraction of PDUs which do not have a dedicated extraction queue (UNKNOWN OPCODES).
    ///
    /// 0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7
    #[inline(always)]
    pub fn def_copy_qu(&self) -> u32 {
        (self.0 & 0x38000) >> 15
    }
    #[inline(always)]
    pub fn set_def_copy_qu(&mut self, value: u32) {
        assert!(value <= 0x7);
        let value = value << 15;
        self.0 &= !0x38000;
        self.0 |= value;
    }
    /// Configures the CPU queue to which DMM frames are extracted.
    ///
    /// 0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7
    #[inline(always)]
    pub fn dmm_cpu_qu(&self) -> u32 {
        (self.0 & 0x38) >> 3
    }
    #[inline(always)]
    pub fn set_dmm_cpu_qu(&mut self, value: u32) {
        assert!(value <= 0x7);
        let value = value << 3;
        self.0 &= !0x38;
        self.0 |= value;
    }
    /// Configures the CPU queue to which DMR and 1DM frames are extracted.
    ///
    /// 0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7
    #[inline(always)]
    pub fn dmr_cpu_qu(&self) -> u32 {
        self.0 & 0x7
    }
    #[inline(always)]
    pub fn set_dmr_cpu_qu(&mut self, value: u32) {
        assert!(value <= 0x7);
        self.0 &= !0x7;
        self.0 |= value;
    }
    /// Configures the CPU queue to which LMM/SLM frames are extracted.
    ///
    /// 0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7
    #[inline(always)]
    pub fn lmm_cpu_qu(&self) -> u32 {
        (self.0 & 0xe00) >> 9
    }
    #[inline(always)]
    pub fn set_lmm_cpu_qu(&mut self, value: u32) {
        assert!(value <= 0x7);
        let value = value << 9;
        self.0 &= !0xe00;
        self.0 |= value;
    }
    /// Configures the CPU queue to which LMR / SLR / 1SL frames are extracted.
    ///
    /// 0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7
    #[inline(always)]
    pub fn lmr_cpu_qu(&self) -> u32 {
        (self.0 & 0x1c0) >> 6
    }
    #[inline(always)]
    pub fn set_lmr_cpu_qu(&mut self, value: u32) {
        assert!(value <= 0x7);
        let value = value << 6;
        self.0 &= !0x1c0;
        self.0 |= value;
    }
}
/// Configuring destination for frames extracted to the CPU.
///
/// See description for CPU_EXTR_CFG
#[derive(Copy, Clone, Debug, Eq, PartialEq, From, Into)]
pub struct CPU_EXTR_CFG_1(u32);
impl CPU_EXTR_CFG_1 {
    /// Configures the CPU queue to which CCM frames are extracted.
    ///
    /// 0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7
    #[inline(always)]
    pub fn ccm_cpu_qu(&self) -> u32 {
        (self.0 & 0x38000) >> 15
    }
    #[inline(always)]
    pub fn set_ccm_cpu_qu(&mut self, value: u32) {
        assert!(value <= 0x7);
        let value = value << 15;
        self.0 &= !0x38000;
        self.0 |= value;
    }
    /// Configures the CPU queue to which CCM-LM frames are extracted. CCM-LM frames are CCM PDUs with non-zero content of the LM counters in the PDU
    ///
    /// 0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7
    #[inline(always)]
    pub fn ccm_lm_cpu_qu(&self) -> u32 {
        (self.0 & 0x7000) >> 12
    }
    #[inline(always)]
    pub fn set_ccm_lm_cpu_qu(&mut self, value: u32) {
        assert!(value <= 0x7);
        let value = value << 12;
        self.0 &= !0x7000;
        self.0 |= value;
    }
    /// Configures the CPU queue to which LBM frames are extracted.
    ///
    /// 0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7
    #[inline(always)]
    pub fn lbm_cpu_qu(&self) -> u32 {
        (self.0 & 0xe00) >> 9
    }
    #[inline(always)]
    pub fn set_lbm_cpu_qu(&mut self, value: u32) {
        assert!(value <= 0x7);
        let value = value << 9;
        self.0 &= !0xe00;
        self.0 |= value;
    }
    /// Configures the CPU queue to which LBR and SAM_SEQ frames are extracted.
    ///
    /// 0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7
    #[inline(always)]
    pub fn lbr_cpu_qu(&self) -> u32 {
        (self.0 & 0x1c0) >> 6
    }
    #[inline(always)]
    pub fn set_lbr_cpu_qu(&mut self, value: u32) {
        assert!(value <= 0x7);
        let value = value << 6;
        self.0 &= !0x1c0;
        self.0 |= value;
    }
    /// Configures the CPU queue to which LTM/LTR frames are extracted. (Configuration is shared for LTM and LTR PDUs)
    ///
    /// 0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7
    #[inline(always)]
    pub fn lt_cpu_qu(&self) -> u32 {
        self.0 & 0x7
    }
    #[inline(always)]
    pub fn set_lt_cpu_qu(&mut self, value: u32) {
        assert!(value <= 0x7);
        self.0 &= !0x7;
        self.0 |= value;
    }
    /// Configures the CPU queue to which TST frames are extracted.
    ///
    /// 0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7
    #[inline(always)]
    pub fn tst_cpu_qu(&self) -> u32 {
        (self.0 & 0x38) >> 3
    }
    #[inline(always)]
    pub fn set_tst_cpu_qu(&mut self, value: u32) {
        assert!(value <= 0x7);
        let value = value << 3;
        self.0 &= !0x38;
        self.0 |= value;
    }
}
/// Configuring destination for frames extracted to the CPU by MPLS VOEs
///
/// See description for CPU_EXTR_CFG
#[derive(Copy, Clone, Debug, Eq, PartialEq, From, Into)]
pub struct CPU_EXTR_MPLS(u32);
impl CPU_EXTR_MPLS {
    /// Configures the CPU queue to which BFD-CC PDUs are extracted.
    ///
    /// 0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7
    #[inline(always)]
    pub fn bfd_cc_cpu_qu(&self) -> u32 {
        (self.0 & 0x38) >> 3
    }
    #[inline(always)]
    pub fn set_bfd_cc_cpu_qu(&mut self, value: u32) {
        assert!(value <= 0x7);
        let value = value << 3;
        self.0 &= !0x38;
        self.0 |= value;
    }
    /// Configures the CPU queue to which BFD-CV PDUs are extracted.
    ///
    /// 0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7
    #[inline(always)]
    pub fn bfd_cv_cpu_qu(&self) -> u32 {
        self.0 & 0x7
    }
    #[inline(always)]
    pub fn set_bfd_cv_cpu_qu(&mut self, value: u32) {
        assert!(value <= 0x7);
        self.0 &= !0x7;
        self.0 |= value;
    }
}
/// HMO slots used for forced scanning.
///
/// When a HMO scan is forced, the HMO slots used for the scan are used for the HMO scan is programmed in this register. A separate HMO slot can be programmed for each of the HMO timers. A HMO scan is forced using the following register: - VOP::LOC_CTRL.LOC_FORCE_HW_SCAN_ENA
#[derive(Copy, Clone, Debug, Eq, PartialEq, From, Into)]
pub struct HMO_FORCE_SLOT_CFG(u32);
impl HMO_FORCE_SLOT_CFG {
    /// See register description.
    #[inline(always)]
    pub fn hmo_force_slot(&self) -> u32 {
        self.0 & 0x7
    }
    #[inline(always)]
    pub fn set_hmo_force_slot(&mut self, value: u32) {
        assert!(value <= 0x7);
        self.0 &= !0x7;
        self.0 |= value;
    }
}
/// Configures the 2 different HMO scan periods
///
/// 2 independent HMO timers are implemented to be used with the auto Hit-Me-Once (HMO) scan. This register implements a separate timeout period for each of the 2 HMO timers. The timeout period is specified in the number of LOC base ticks between every HMO timer expiry. Each HMO scan timer has an associated HMO slot (0-7 i.e. 3 bit), which is increased every time the HMO scan timer expires. When a HMO scan timer expires and causes a HMO scan, the current HMO slot is part of the scan, so that only the VOEs assigned to that HMO slot are affected by the scan. This allows the distributing the VOEs assigned to a given HMO scan timer into 8 HMO slots. Hence each VOE is only affected by 1 of 8 HMO scans for a given HMO scan timer. I.e. to achieve auto HMO frame extraction every 1 second, the HMO timer must be set to expire every 125 us. For configuration of the LOC base tick, see bit field: * VOP::LOC_CTRL.LOC_BASE_TICK_CNT The default value for the LOC base tick is 200 ns. A HMO scan is initiated at half the configured HMO PERIOD, because this is the way the scans are implemented for LOC scanning. A VOE can be configured for HMO auto assertion based on one of the 2 HMO timers. The HMO timers are used only Ethernet VOEs. The HMO timers have no effect on MPLS-TP VOEs. Ethernet VOE: ----------------------- The HMO events are assigned to a specific HMO scan timer: * VOP::HMO_TIMER_CFG.* The VOE is assigned a HMO slot using the following register: * VOP:VOE_STAT:AUTO_HIT_ME_ONCE.HMO_SLOT When the HMO timer assigned to the VOE, causes a HMO scan with the HMO slot assigned to the VOE, the VOE will assert the extraction bits selected for auto HMO. The extraction bits are located in the following register: * VOP:VOE_STAT:PDU_EXTRACT The extraction bits are assigned for auto HMO in the following register: * VOP:VOE_STAT:AUTO_HIT_ME_ONCE MPLS-TP VOE: -------------------------- The HMO counters have no effect.
#[derive(Copy, Clone, Debug, Eq, PartialEq, From, Into)]
pub struct HMO_PERIOD_CFG(u32);
impl HMO_PERIOD_CFG {
    /// Configures expiry period of the 2 HMO timers as the number of BASE_TICKs between every LOC timer expiry. The BASE_TICK is configured: VOP::LOC_CTRL.LOC_BASE_TICK_CNT Default HMO timer is set to 0, which causes the HMO timer to never expire.
    ///
    /// For the default value of the LOC_BASE_TICK_CNTthe HMO scan timer will expire with the following intervals. A value of 0 disables the timeout for this counter. 50: 10us 500: 100us 5000: 1 ms 16500: 3.3ms 50000: 10ms 500000: 100ms 5000000: 1s
    #[inline(always)]
    pub fn hmo_period_val(&self) -> u32 {
        self.0
    }
    #[inline(always)]
    pub fn set_hmo_period_val(&mut self, value: u32) {
        self.0 = value;
    }
}
/// Configure HMO TIMER for HMO extraction events.
///
/// There are 2 HMO timers, which allow for Auto HMO of selected frame types. Each of the events which support HMO are assigned to one of the 2 HMO timers using this register. This setting is hence global for all VOEs. For each of the bitfields, it is configured which of the HMO timers will trigger the HMO bits to be asserted. In addition to the correct HMO timer expiring, the VOE must be configured for the correct HMO SLOT and the Auto HMO must be enabled in the VOE before the HMO bits are asserted. The is used to space the extracted frames, so the CPU does not get flooded with frames from all active VOEs at once.
#[derive(Copy, Clone, Debug, Eq, PartialEq, From, Into)]
pub struct HMO_TIMER_CFG(u32);
impl HMO_TIMER_CFG {
    /// Assign which HMO timer will trigger the following VOE Auto HMO bits: * VOP:VOE_STAT:PDU_EXTRACT.CCM_ZERO_PERIOD_RX_ERR_EXTR * VOP:VOE_STAT:PDU_EXTRACT.RX_MEL_LOW_ERR_EXTR * VOP:VOE_STAT:PDU_EXTRACT.CCM_MEGID_RX_ERR_EXTR * VOP:VOE_STAT:PDU_EXTRACT.CCM_MEPID_RX_ERR_EXTR * VOP:VOE_STAT:PDU_EXTRACT.CCM_PERIOD_RX_ERR_EXTR * VOP:VOE_STAT:PDU_EXTRACT.CCM_PRIO_RX_ERR_EXTR To trigger the Auto HMO bits, this must be enabled by the VOE: * VOP:VOE_STAT:AUTO_HIT_ME_ONCE.HMO_CCM_RX_BAD_NXT
    #[inline(always)]
    pub fn hmo_ccm_rx_bad_nxt_timer(&self) -> u32 {
        (self.0 & 0x4) >> 2
    }
    #[inline(always)]
    pub fn set_hmo_ccm_rx_bad_nxt_timer(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 2;
        self.0 &= !0x4;
        self.0 |= value;
    }
    /// Assign which HMO timer will trigger the following VOE Auto HMO bits: * VOP:VOE_STAT:PDU_EXTRACT.CCM_RX_TLV_NON_ZERO_EXTR To trigger the Auto HMO bits, this must be enabled by the VOE: * VOP:VOE_STAT:AUTO_HIT_ME_ONCE.HMO_CCM_RX_TLV_NON_ZERO
    #[inline(always)]
    pub fn hmo_ccm_rx_tlv_non_zero_timer(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    #[inline(always)]
    pub fn set_hmo_ccm_rx_tlv_non_zero_timer(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 3;
        self.0 &= !0x8;
        self.0 |= value;
    }
    /// Assign which HMO timer will trigger the following VOE Auto HMO bits: VOP:VOE_STAT:SYNLM_EXTRACT.EXTRACT_PEER_RX To trigger the Auto HMO bits, this must be enabled by the VOE: * VOP:VOE_STAT:AUTO_HIT_ME_ONCE.HMO_EXTRACT_PEER_RX
    #[inline(always)]
    pub fn hmo_extract_peer_rx_timer(&self) -> u32 {
        self.0 & 0x1
    }
    #[inline(always)]
    pub fn set_hmo_extract_peer_rx_timer(&mut self, value: u32) {
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
    /// Assign which HMO timer will trigger the following VOE Auto HMO bits: * VOP:VOE_STAT:PDU_EXTRACT.CCM_RX_CCM_NXT_EXTR To trigger the Auto HMO bits, this must be enabled by the VOE: * VOP:VOE_STAT:AUTO_HIT_ME_ONCE.HMO_CCM_RX_BAD_NXT
    #[inline(always)]
    pub fn hmo_rx_ccm_nxt_timer(&self) -> u32 {
        (self.0 & 0x10) >> 4
    }
    #[inline(always)]
    pub fn set_hmo_rx_ccm_nxt_timer(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 4;
        self.0 &= !0x10;
        self.0 |= value;
    }
    /// Assign which HMO timer will trigger the following VOE Auto HMO bits: VOP:VOE_STAT:PDU_EXTRACT.RX_TEST_FRM_NXT_EXTR To trigger the Auto HMO bits, this must be enabled by the VOE: * VOP:VOE_STAT:AUTO_HIT_ME_ONCE.HMO_RX_TEST_FRM_NXT
    #[inline(always)]
    pub fn hmo_rx_test_frm_nxt_timer(&self) -> u32 {
        (self.0 & 0x2) >> 1
    }
    #[inline(always)]
    pub fn set_hmo_rx_test_frm_nxt_timer(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 1;
        self.0 &= !0x2;
        self.0 |= value;
    }
}
/// VOE interrupts
///
/// This register contains the interrupt for each individual VOE, grouped in 32 bit registers. The interrupts are numbered according to the VOEs: 0 - 255 are the Service / Path VOEs 256 - 266 are the Port VOEs The VOE interrupts are enabled in the following registers: Ethernet: ------------------- * VOP:VOE_STAT:INTR_ENA MPLS-TP: ----------------- * VOP_MPLS:VOE_STAT_MPLS:INTR_ENA_MPLS The following register indicates with a single bit if there is an asserted interrupt in each of the registers in VOE_INTR * VOP::VOE32_INTR
#[derive(Copy, Clone, Debug, Eq, PartialEq, From, Into)]
pub struct INTR(u32);
impl INTR {
    /// Status of interrupts per VOE Ethernet: ---------------------- Interrupt is cleared by clearing the sticky causing interrupt in VOP:VOE_STAT:INTR_STICKY:* or by disabling the interrupt source in VOP:VOE_STAT:INTR_ENA.* MPLS-TP: ------------------------- Interrupt is cleared by clearing the sticky causing interrupt in VOP_MPLS:VOE_STAT_MPLS:INTR_STICKY_MPLS.* or by disabling the interrupt source in VOP_MPLS:VOE_STAT_MPLS:INTR_ENA_MPLS.*
    ///
    /// Each bit in the field indicates the interrupt from a single VOE. 0: No interrupt from VOE 1: VOE has asserted the interrupt.
    #[inline(always)]
    pub fn voe_intr(&self) -> u32 {
        self.0
    }
    #[inline(always)]
    pub fn set_voe_intr(&mut self, value: u32) {
        self.0 = value;
    }
}
/// Loss Of Continuity Controller configuration
///
/// Configures LOC Controller to increment the LOC miss counters in the VOEs.
#[derive(Copy, Clone, Debug, Eq, PartialEq, From, Into)]
pub struct LOC_CTRL(u32);
impl LOC_CTRL {
    /// Specifies the number of system clock cycles for each LOC base time tick. The system clock is: 4 ns (250 MHz). The default base tick is set to 50 = 200 ns The base tick, is the event used for incrementing the 7 LOC counters. The time at which each of the LOC timers will timeout is specified in: * VOP::LOC_PERIOD_CFG::LOC_PERIOD_VAL Ethernet VOEs: ------------------------ When a LOC timer expires it causes a LOC Scan event, which will increment the CCM miss counter (VOP:VOE_STAT:CCM_STAT.CCM_MISS_CNT) for each VOE assigned to that particular LOC timer. The CCM miss counter for each VOE (CCM_MISS_CNT) will be cleared each time the VOE receives a valid CCM or CCM-LM frame. If the CCM_MISS count reaches 7 it will optionally cause an interrupt. MPLS-TP VOEs: ------------------------ When a LOC timer expires it causes a LOC Scan event, which will increment the BFD miss counter (VOP_MPLS:VOE_STAT_MPLS:BFD_STAT.BFD_MISS_CNT) for each VOE assigned to that particular LOC timer. The LOC counter for each VOE (BFD_MISS_CNT) will be cleared each time the VOE receives a valid BFD-CC or BFD-CV PDU. If the BFD_MISS_CNT count reaches the configured Detect Multiplier it will optionally cause an interrupt.
    ///
    /// 0: Illegal value 1: One clock between interval increment ... n: n clock between interval increment
    #[inline(always)]
    pub fn loc_base_tick_cnt(&self) -> u32 {
        (self.0 & 0x7f800) >> 11
    }
    #[inline(always)]
    pub fn set_loc_base_tick_cnt(&mut self, value: u32) {
        assert!(value <= 0xff);
        let value = value << 11;
        self.0 &= !0x7f800;
        self.0 |= value;
    }
    /// When a LOC scan timer expires, the VOE will scan through all VOEs in the VOP and increment the LOC miss counter of all the VOEs assigned to that LOC timer. When a HMO scan timer expires, the VOE will scan through all VOEs in the VOP and assert the HMO extraction bits configured for the VOE. Another way to force a LOC scan / HMO is to write a mask to LOC_FORCE_HW_SCAN_ENA. Each of the bits in this register represents a LOC timer. Writing a mask to this register will force a LOC scan as if the LOC timers indicated in the mask had expired. A forced scan will start as soon as any currently active scan completes Active scan can be stopped by disabling the LOC scan controller. The width of the SCAN_MASK is 9 bits which are allocated as follows: bits 0-6: LOC scan timer 0 - 6 bits 7-8: HMO scan timer 0 - 1
    ///
    /// 0: No force bit 0 = 1: Force a scan of LOC scan timer 0 bit 1 = 1: Force a scan of LOC scan timer 1 bit 2 = 1: Force a scan of LOC scan timer 2 bit 3 = 1: Force a scan of LOC scan timer 3 bit 4 = 1: Force a scan of LOC scan timer 4 bit 5 = 1: Force a scan of LOC scan timer 5 bit 6 = 1: Force a scan of LOC scan timer 6 bit 7 = 1: Force a scan of HMO scan timer 0; (using HMO slot configured in VOP::HMO_FORCE_SLOT_CFG(0).HMO_FORCE_SLOT) bit 8 = 1: Force a scan of HMO scan timer 1; (using HMO slot configured in VOP::HMO_FORCE_SLOT_CFG(1).HMO_FORCE_SLOT)
    #[inline(always)]
    pub fn loc_force_hw_scan_ena(&self) -> u32 {
        self.0 & 0x1ff
    }
    #[inline(always)]
    pub fn set_loc_force_hw_scan_ena(&mut self, value: u32) {
        assert!(value <= 0x1ff);
        self.0 &= !0x1ff;
        self.0 |= value;
    }
    /// Specifies the number of clk cycle before another scan entry can be attempted. This can be used to space the LOC miss scanning of the VOEs. If an active SCAN is ongoing, the VOE will scan through the VOE_STAT and update the LOC miss counter of VOEs which are enabled for LOC detection. The scan will be done in 'idle cycles'. 'Idle cycles' are defined as cycles where the is no frame access and no CSR access to the VOP.
    ///
    /// 0-1: A scan is attempted at every idle cycle in the VOP 2: A scan is attempted no more often than every 2nd cycle. 3: A scan is attempted no more often than every 3rd cycle. .... 7: A scan is attempted no more often than every 7'th cycle.
    #[inline(always)]
    pub fn loc_space_between_entry_scan(&self) -> u32 {
        (self.0 & 0x600) >> 9
    }
    #[inline(always)]
    pub fn set_loc_space_between_entry_scan(&mut self, value: u32) {
        assert!(value <= 0x3);
        let value = value << 9;
        self.0 &= !0x600;
        self.0 |= value;
    }
}
/// Configures the 7 different LOC scan periods
///
/// Independent timers are implemented to be used with the Loss Of Continuity (LOC) Scan. This register implements the timout period for every one of the 7 LOC timers. The timeout period is specified in the number of LOC base ticks between every LOC timer expiry. For configuration of the LOC base tick, see bit field: * VOP::LOC_CTRL.LOC_BASE_TICK_CNT The default value for the LOC base tick is 200 ns, which means that the LOC timer counters are incremented every 200 ns. A LOC miss count scan is initiated at half the configured LOC PERIOD. A VOE can be configured for LOC checking based on one of the 7 timeout counters. The LOC Controller is used both by Ethernet VOEs and MPLS-TP VOEs for LOC detection. Ethernet VOE: --------------- A LOC event is generated at the VOE when the CCM miss count count is 7. VOP:VOE_STAT:CCM_STAT.CCM_MISS_CNT This effectively implements a LOC event at 3,5 times the configured LOC period. MPLS-TP VOE: -------------------------- A LOC event is generated at the VOE when the BFD_MISS_CNT is equal to the valid Detect Multiplier in the VOE.
#[derive(Copy, Clone, Debug, Eq, PartialEq, From, Into)]
pub struct LOC_PERIOD_CFG(u32);
impl LOC_PERIOD_CFG {
    /// Configures Expiry Period of the 7 LOC timers as the number of BASE_TICKs between every LOC timer expiry. The BASE_TICK is configured: VOP::LOC_CTRL.LOC_BASE_TICK_CNT Default LOC timer expiry time: 3.3ms.
    ///
    /// A value of 0 disables the timeout for this counter. 50: 10us 500: 100us 5000: 1 ms 16500: 3.3ms 50000: 10ms 500000: 100ms 5000000: 1s
    #[inline(always)]
    pub fn loc_period_val(&self) -> u32 {
        self.0
    }
    #[inline(always)]
    pub fn set_loc_period_val(&mut self, value: u32) {
        self.0 = value;
    }
}
/// CCM SCAN Diagnostic
///
/// Bits in this register indicate the current status of the LOC scanning. Note that the following bit field is NOT sticky: * LOC_SCAN_ONGOING_STATUS
#[derive(Copy, Clone, Debug, Eq, PartialEq, From, Into)]
pub struct LOC_SCAN_STICKY(u32);
impl LOC_SCAN_STICKY {
    /// Asserted by VOP when LOC_SCAN completes.
    ///
    /// 0: No event has occured 1: LOC scan completed Bit is cleared by writing a 1 to this position.
    #[inline(always)]
    pub fn loc_scan_completed_sticky(&self) -> u32 {
        (self.0 & 0x4) >> 2
    }
    #[inline(always)]
    pub fn set_loc_scan_completed_sticky(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 2;
        self.0 &= !0x4;
        self.0 |= value;
    }
    /// Reflects the current LOC scan mask. A bit is asserted for each of the LOC counters currently being increased. NOTE: This is not a sticky bit.
    ///
    /// 0: No event has occured 1: LOC scan ongoing. A bit is asserted for each LOC counter which is updating the LOC MISS CNT.
    #[inline(always)]
    pub fn loc_scan_ongoing_status(&self) -> u32 {
        (self.0 & 0xff8) >> 3
    }
    #[inline(always)]
    pub fn set_loc_scan_ongoing_status(&mut self, value: u32) {
        assert!(value <= 0x1ff);
        let value = value << 3;
        self.0 &= !0xff8;
        self.0 |= value;
    }
    /// Asserted by VOP when LOC_SCAN starts.
    ///
    /// 0: No event has occured 1: LOC scan started Bit is cleared by writing a 1 to this position.
    #[inline(always)]
    pub fn loc_scan_started_sticky(&self) -> u32 {
        (self.0 & 0x2) >> 1
    }
    #[inline(always)]
    pub fn set_loc_scan_started_sticky(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 1;
        self.0 &= !0x2;
        self.0 |= value;
    }
    /// Set when a LOC scan could not start because a scan is already ongoing. This is an indication that a LOC timer expired before the previous scan scheduled by the same LOC timer was initiated. This is an error condition. To fix it, the configured Period time of the LOC scan controller must be incremented.
    ///
    /// 0: No event has occured 1: Scan could not start in time Bit is cleared by writing a 1 to this position.
    #[inline(always)]
    pub fn loc_scan_start_delayed_sticky(&self) -> u32 {
        self.0 & 0x1
    }
    #[inline(always)]
    pub fn set_loc_scan_start_delayed_sticky(&mut self, value: u32) {
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
}
/// VOP interrupt control.
///
/// This is the combined interrupt output from the VOP. To determine the VOE source of the interrupt, read register: * VOP::INTR.VOE_INTR
#[derive(Copy, Clone, Debug, Eq, PartialEq, From, Into)]
pub struct MASTER_INTR_CTRL(u32);
impl MASTER_INTR_CTRL {
    /// Status of the VOP interrupt. If asserted this can optionally generate an interrupt to the CPU. * VOP::MASTER_INTR_CTRL.OAM_MEP_INTR_ENA
    ///
    /// 0: VOP Interrupt is deasserted. 1: VOP Interrupt is asserted.
    #[inline(always)]
    pub fn oam_mep_intr(&self) -> u32 {
        (self.0 & 0x100) >> 8
    }
    #[inline(always)]
    pub fn set_oam_mep_intr(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 8;
        self.0 &= !0x100;
        self.0 |= value;
    }
    /// Configures if OAM_MEP_INTR causes CPU interrupts
    ///
    /// 0: Disable interrupt 1: Enable interrupt
    #[inline(always)]
    pub fn oam_mep_intr_ena(&self) -> u32 {
        (self.0 & 0x2000000) >> 25
    }
    #[inline(always)]
    pub fn set_oam_mep_intr_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 25;
        self.0 &= !0x2000000;
        self.0 |= value;
    }
}
/// Generic OAM PDU Opcodes configuration
///
/// The VOE implements HW support for a number of dedicated MPLS-TP codepoints (BFD CC/CV) which all have dedicated control registers. In addition to the dedicated MPLS-TP Codepoints with dedicated control registers, the VOE further supports configuring 8 Generic Codepoints, which can be extracted to CPU or forwarded independently of other Codepoints. The Generic Codepoints are configured using this register. The value of each Codepoint is configured globally across all VOEs in the following bit field: * GENERIC_CODEPOINT_VAL A codepoint which is not explicitly supported and which not configured as a Generic Codepoint will be treated as an UNKNOWN Codepoint. The extraction and forwarding of Generic Codepoints can be configured individually pr. VOE using the following registers: * VOP_MPLS:VOE_CONF_MPLS:CPU_COPY_CTRL_MPLS.GENERIC_COPY_MASK * VOP_MPLS:VOE_CONF_MPLS:OAM_CNT_SEL_MPLS.GENERIC_CPT_CNT_SEL_MASK
#[derive(Copy, Clone, Debug, Eq, PartialEq, From, Into)]
pub struct MPLS_GENERIC_CODEPOINT(u32);
impl MPLS_GENERIC_CODEPOINT {
    /// Configures CPU queue to which MPLS-TP OAM PDUs with a G-ACH Channel Type configured as generic codepoints are extracted.
    #[inline(always)]
    pub fn generic_codepoint_cpu_qu(&self) -> u32 {
        (self.0 & 0x700) >> 8
    }
    #[inline(always)]
    pub fn set_generic_codepoint_cpu_qu(&mut self, value: u32) {
        assert!(value <= 0x7);
        let value = value << 8;
        self.0 &= !0x700;
        self.0 |= value;
    }
    /// This value configures the MPLS-TP G-ACH Channel Type to be processed as a Generic OpCode corresponding to this generic Index.
    #[inline(always)]
    pub fn generic_codepoint_val(&self) -> u32 {
        (self.0 & 0x7fff800) >> 11
    }
    #[inline(always)]
    pub fn set_generic_codepoint_val(&mut self, value: u32) {
        assert!(value <= 0xffff);
        let value = value << 11;
        self.0 &= !0x7fff800;
        self.0 |= value;
    }
}
/// Generic OAM PDU Opcodes configuration
///
/// The VOE implements HW support for a number of selected OAM PDUs which all have dedicated control registers. In addition to the selected OAM PDUs with dedicated control registers, the VOE further supports configuring 8 Generic Opcodes, which can be extracted to CPU or forwarded independently of other OpCodes. The value of each OpCode is configured globally across all VOEs in the following bit field: * GENERIC_OPCODE_VAL An opcode which is not explicitly supported and which not configured as a Generic OpCode will be treated as an UNKNOWN opcode. The extraction and forwarding of Generic OpCodes can be configured individually pr. VOE using the following registers: * VOP:VOE_CONF:OAM_CPU_COPY_CTRL.GENERIC_COPY_MASK * VOP:VOE_CONF:OAM_CNT_OAM_CTRL.GENERIC_OAM_CNT_MASK * VOP:VOE_CONF:OAM_CNT_DATA_CTRL.GENERIC_DATA_CNT_MASK
#[derive(Copy, Clone, Debug, Eq, PartialEq, From, Into)]
pub struct OAM_GENERIC_CFG(u32);
impl OAM_GENERIC_CFG {
    /// If this bit is asserted, the DMAC check will be disabled for this generic OpCode, regardless of the configuration of the bit field: VOP:VOE_CONF:VOE_CTRL.RX_DMAC_CHK_SEL This bit is required because some OpCodes (i.e. Ring PDU) will use a DMAC which is different from the configured Multicast and Unicast.
    ///
    /// 0: Perform DMAC check according to the value configured in VOP:VOE_CONF:VOE_CTRL.RX_DMAC_CHK_SEL 1: No DMAC check for this Generic OpCode.
    #[inline(always)]
    pub fn generic_dmac_chk_dis(&self) -> u32 {
        (self.0 & 0x20000) >> 17
    }
    #[inline(always)]
    pub fn set_generic_dmac_chk_dis(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 17;
        self.0 &= !0x20000;
        self.0 |= value;
    }
    /// Configures the CPU queue to which frames for this generic OpCode are extracted.
    ///
    /// 0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7
    #[inline(always)]
    pub fn generic_opcode_cpu_qu(&self) -> u32 {
        (self.0 & 0x700) >> 8
    }
    #[inline(always)]
    pub fn set_generic_opcode_cpu_qu(&mut self, value: u32) {
        assert!(value <= 0x7);
        let value = value << 8;
        self.0 &= !0x700;
        self.0 |= value;
    }
    /// This value configures the Y.1731 OpCode to be processed as a Generic OpCode corresponding to this generic Index.
    #[inline(always)]
    pub fn generic_opcode_val(&self) -> u32 {
        self.0 & 0xff
    }
    #[inline(always)]
    pub fn set_generic_opcode_val(&mut self, value: u32) {
        assert!(value <= 0xff);
        self.0 &= !0xff;
        self.0 |= value;
    }
}
/// Define valid y.1731 PDU version number.
///
/// This register group allows configuration of which versions of the PDU is valid for each of the Y.1731 PDUs supported by HW processing. Only the PDUs which have dedicated HW support in the VOE can be verified by the VOE. For PDUs being forwarded to the CPU the version is assumed to be verified in SW. The version is configured commonly for Message and Response of the same PDU type. For each PDU (pair) there are 8 bits, each representing a version number: 0 - 7. Asserting the bit corresponding to a given version will configure the HW to accept PDUs of this version. E.g. the following will configure VERSION = 1 as being valid for CCM(-LM) frames. * CCM_VERSION(1) = 1
#[derive(Copy, Clone, Debug, Eq, PartialEq, From, Into)]
pub struct VERSION_CTRL(u32);
impl VERSION_CTRL {
    /// Configure which version of the CCM(-LM) PDU will be processed by the VOE.
    ///
    /// CCM_VERSION(x) = '0'; Version X of the CCM(-LM) PDU is invalid. CCM_VERSION(x) = '1'; Version X of the CCM(-LM) PDU is valid.
    #[inline(always)]
    pub fn ccm_version(&self) -> u32 {
        (self.0 & 0xff000000) >> 24
    }
    #[inline(always)]
    pub fn set_ccm_version(&mut self, value: u32) {
        assert!(value <= 0xff);
        let value = value << 24;
        self.0 &= !0xff000000;
        self.0 |= value;
    }
    /// Configure which version of the DMM/DMR PDU will be processed by the VOE.
    ///
    /// DM_VERSION(x) = '0'; Version X of the DMM/DMR PDU is invalid. DM_VERSION(x) = '1'; Version X of the DMM/DMR PDU is valid.
    #[inline(always)]
    pub fn dm_version(&self) -> u32 {
        (self.0 & 0xff00) >> 8
    }
    #[inline(always)]
    pub fn set_dm_version(&mut self, value: u32) {
        assert!(value <= 0xff);
        let value = value << 8;
        self.0 &= !0xff00;
        self.0 |= value;
    }
    /// Configure which version of the LMM/LMR PDU will be processed by the VOE.
    ///
    /// LM_VERSION(x) = '0'; Version X of the LMM/LMR PDU is invalid. LM_VERSION(x) = '1'; Version X of the LMM/LMR PDU is valid.
    #[inline(always)]
    pub fn lm_version(&self) -> u32 {
        (self.0 & 0xff0000) >> 16
    }
    #[inline(always)]
    pub fn set_lm_version(&mut self, value: u32) {
        assert!(value <= 0xff);
        let value = value << 16;
        self.0 &= !0xff0000;
        self.0 |= value;
    }
    /// Configure which version of the 1DM PDU will be processed by the VOE.
    ///
    /// SDM_VERSION(x) = '0'; Version X of the 1DM PDU is invalid. SDM_VERSION(x) = '1'; Version X of the 1DM PDU is valid.
    #[inline(always)]
    pub fn sdm_version(&self) -> u32 {
        self.0 & 0xff
    }
    #[inline(always)]
    pub fn set_sdm_version(&mut self, value: u32) {
        assert!(value <= 0xff);
        self.0 &= !0xff;
        self.0 |= value;
    }
}
/// Define valid y.1731 PDU version number.
///
/// This register group allows configuration of which versions of the PDU is valid for each of the Y.1731 PDUs supported by HW processing. Only the PDUs which are being processed by VOE can be verified by the VOE. For PDUs being forwarded to the CPU the version is assumed to be verified in SW. The version is configured commonly for Message and Response of the same PDU type. For each PDU (pair) there are 8 bits, each representing a version number: 0 - 7. Asserting the bit corresponding to a given version will configure the VOE to accept PDUs of this version. E.g. the following will configure VERSION = 1 as being valid for CCM(-LM) frames. * CCM_VERSION(1) = 1
#[derive(Copy, Clone, Debug, Eq, PartialEq, From, Into)]
pub struct VERSION_CTRL_2(u32);
impl VERSION_CTRL_2 {
    /// Configure which version of the LBM/LBR PDU will be processed by the VOE.
    ///
    /// LB_VERSION(x) = '0'; Version X of the LBM/LBR PDU is invalid. LB_VERSION(x) = '1'; Version X of the LBM/LBR PDU is valid.
    #[inline(always)]
    pub fn lb_version(&self) -> u32 {
        (self.0 & 0xff0000) >> 16
    }
    #[inline(always)]
    pub fn set_lb_version(&mut self, value: u32) {
        assert!(value <= 0xff);
        let value = value << 16;
        self.0 &= !0xff0000;
        self.0 |= value;
    }
    /// Configure which version of the 1SL PDU will be processed by the VOE.
    ///
    /// SL1_VERSION(x) = '0'; Version X of the LBM/LBR PDU is invalid. SL1_VERSION(x) = '1'; Version X of the LBM/LBR PDU is valid.
    #[inline(always)]
    pub fn sl1_version(&self) -> u32 {
        self.0 & 0xff
    }
    #[inline(always)]
    pub fn set_sl1_version(&mut self, value: u32) {
        assert!(value <= 0xff);
        self.0 &= !0xff;
        self.0 |= value;
    }
    /// Configure which version of the SLM/SLR PDU will be processed by the VOE.
    ///
    /// SL_VERSION(x) = '0'; Version X of the LBM/LBR PDU is invalid. SL_VERSION(x) = '1'; Version X of the LBM/LBR PDU is valid.
    #[inline(always)]
    pub fn sl_version(&self) -> u32 {
        (self.0 & 0xff00) >> 8
    }
    #[inline(always)]
    pub fn set_sl_version(&mut self, value: u32) {
        assert!(value <= 0xff);
        let value = value << 8;
        self.0 &= !0xff00;
        self.0 |= value;
    }
    /// Configure which version of the TST PDU will be processed by the VOE.
    ///
    /// TST_VERSION(x) = '0'; Version X of the TST PDU is invalid. TST_VERSION(x) = '1'; Version X of the TST PDU is valid.
    #[inline(always)]
    pub fn tst_version(&self) -> u32 {
        (self.0 & 0xff000000) >> 24
    }
    #[inline(always)]
    pub fn set_tst_version(&mut self, value: u32) {
        assert!(value <= 0xff);
        let value = value << 24;
        self.0 &= !0xff000000;
        self.0 |= value;
    }
}
/// Version control configuration for MPLS
#[derive(Copy, Clone, Debug, Eq, PartialEq, From, Into)]
pub struct VERSION_CTRL_MPLS(u32);
impl VERSION_CTRL_MPLS {
    /// The VOE will optionally validate the version of the incoming BFD frames against the value configured in this register. If the version in the incoming frame is not as configured, the frame will be discarded. The Rx validation is configured in the following bitfields: * VOP_MPLS:VOE_CONF_MPLS:BFD_CONFIG.BFD_RX_VERIFY_*
    #[inline(always)]
    pub fn bfd_version(&self) -> u32 {
        self.0 & 0x7
    }
    #[inline(always)]
    pub fn set_bfd_version(&mut self, value: u32) {
        assert!(value <= 0x7);
        self.0 &= !0x7;
        self.0 |= value;
    }
}
/// One bit per 32 VOE interrupts.
///
/// The following register contains a bit for every VOE indicating whether VOE interrupt is asserted: * VOP::INTR.* To speed up the process of finding out which interrups are asserted, this register (INTR_VOE32) contains a single bit for every 32-bit register in the above register. Every bit in INTR_VOE32 indicates if an interrupt is asserted in the corresponding 32 bit register in VOP::INTR.* I.e. bit 0 = '1' indicates an active interrupt in VOP::INTR[0].VOE_INTR bit 1 = '1' indicates an active interrupt in VOP::INTR[1].VOE_INTR ...
#[derive(Copy, Clone, Debug, Eq, PartialEq, From, Into)]
pub struct VOE32_INTR(u32);
impl VOE32_INTR {
    /// See register description.
    #[inline(always)]
    pub fn voe32_intr(&self) -> u32 {
        self.0
    }
    #[inline(always)]
    pub fn set_voe32_intr(&mut self, value: u32) {
        self.0 = value;
    }
}
/// Miscellaneous Vitesse OAM Processor Controls
///
/// This register contains variable settings which are global to all VOEs.
#[derive(Copy, Clone, Debug, Eq, PartialEq, From, Into)]
pub struct VOP_CTRL(u32);
impl VOP_CTRL {
    /// The CCM PDU does not have a dedicated register for the RxFCf counter. However there is a reserved field which can be used to hold this value. Asserting this field enables updating reserved field for Rx CCM LM PDU with RxFCf. This is the only way to relay the RxFCf counter to the CPU.
    ///
    /// 0: Do not update CCM-LM frames with RxFC_f information 1: Update the CCM-LM Reserved field with RxFC_f information
    #[inline(always)]
    pub fn ccm_lm_upd_rsv_ena(&self) -> u32 {
        (self.0 & 0x800) >> 11
    }
    #[inline(always)]
    pub fn set_ccm_lm_upd_rsv_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 11;
        self.0 &= !0x800;
        self.0 |= value;
    }
    /// The VOE can optionally detect changes in the source port for CCM PDUs. The port on which the last valid PDU was received is saved: * VOP:VOE_STAT:CCM_RX_LAST.CCM_RX_SRC_PORT The VOE counts the number of valid CCM PDUs received on the same port as the previous in the following register: * VOP:VOE_STAT:CCM_STAT.CCM_RX_SRC_PORT_CNT If the this count reaches the value configured in this field, the following sticky bit is asserted: * VOP:VOE_STAT:INTR_STICKY.CCM_RX_SRC_PORT_DETECT_STICKY The sticky bit can optionally generate an interrupt. Note: that the VOE counts the number of frames matching the previous, hence if this bitfield is programmed to 'X', it will require 'X' + 1 consecutive frames on the same port to assert the sticky bit.
    ///
    /// 0: illegal value (Will never generate a sticky bit) 1-7: Assert sticky bit when 1-7 CCM PDUs were received on the same port as the previous.
    #[inline(always)]
    pub fn ccm_rx_src_port_detect_cnt(&self) -> u32 {
        (self.0 & 0x380) >> 7
    }
    #[inline(always)]
    pub fn set_ccm_rx_src_port_detect_cnt(&mut self, value: u32) {
        assert!(value <= 0x7);
        let value = value << 7;
        self.0 &= !0x380;
        self.0 |= value;
    }
    /// If enabled the G.8113.1 LBR Rx errors at the 'Initiator MEP' are counted in the following counters: MEPID errors: * VOP:VOE_STAT:CCM_RX_ERR_1.CCM_RX_MEPID_ERR_CNT MEGID errors: * VOP:VOE_STAT:CCM_RX_ERR_1.CCM_RX_MEGID_ERR_CNT These counters are reused from Y.1731 CCM error counters. Note that only LBR Rx due to MEP ID and MEG ID mismatch are counted. LBR Rx errors due to 'illegal ID Sub-Type' and 'illlegal Loopback Indicator' are not counted. This bit only has effect for VOEs configured for G.8113.1 OAM.
    ///
    /// 0: Do not count G.8113.1 LBR Rx errors. 1: Count G.8113.1 LBR Rx errors.
    #[inline(always)]
    pub fn g_8113_1_cnt_lbr_rx_error_ena(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    #[inline(always)]
    pub fn set_g_8113_1_cnt_lbr_rx_error_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 3;
        self.0 &= !0x8;
        self.0 |= value;
    }
    /// When the VOE is configured for G.8113.1 OAM, the 'Initiator MEP' will determine if incoming Rx LBR PDUs carry the 'Requesting MEP ID' TLV. If so the 'Initiator MEP' will determine if the 'Loopback Indicator' has been set to '1' by the 'Responder MEP'. If the 'Loopback Indicator' is not equal to '1' the frame is marked as invalid. In the VOE the 'Loopback Indicator' check is optional and can be configured using this bitfield.
    ///
    /// 0: Disable the 'Loopback Indicator' check in the 'Initiator MEP" (G.8113.1 OAM) 1: Enable the 'Loopback Indicator' check in the 'Initiator MEP" (G.8113.1 OAM)
    #[inline(always)]
    pub fn g_8113_1_lbk_indc_chk_ena(&self) -> u32 {
        (self.0 & 0x4) >> 2
    }
    #[inline(always)]
    pub fn set_g_8113_1_lbk_indc_chk_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 2;
        self.0 &= !0x4;
        self.0 |= value;
    }
    /// Asserting this bit will disable the Y.1731 MEL checking (RX / TX) in the VOE when the VOE is configured for G.8113.1 OAM. This is intended for use with G.8113.1 OAM. Since the MEL has no meaning in MPLS OAM, it is possible to disable the MEL using this bit, even if the standard specifies to set the MEL values of all OAM PDUs to the correct value.
    ///
    /// 0: MEL checking is done in the VOE as per Y.1731 1: MEL checking is disabled in the VOE. All frames are considered to have correct MEL.
    #[inline(always)]
    pub fn g_8113_1_mel_chk_dis(&self) -> u32 {
        (self.0 & 0x40) >> 6
    }
    #[inline(always)]
    pub fn set_g_8113_1_mel_chk_dis(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 6;
        self.0 &= !0x40;
        self.0 |= value;
    }
    /// The G.8113.1 standard (date: 11/2012) is not 100% clear on which MEP IDs are being exchanged and verified when two MEPs are exchanging 'LBM Target MEP ID' TLV <-> LBR 'Replying LBR MEP ID' TLV. It is therefore configurable which MEP IDs are carried in the TLVs, and from this follows which MEP IDs whill be used in the Initiator / Responder VOEs for MEP ID verification. The 4 possible scenarios are as follows: Scenario A: -------------------------------- Initiator MEP transmits 'Target MEP ID TLV' with the Initiator MEP ID (local MEP ID) Responder MEP replies with  'Replying MEP ID TLV' with the Initiator MEP ID (remote MEP ID) In this scenario the 'Responder MEP' must verify the Rx LBM Target MEP ID against the remote MEP ID (CCM_MEPID) In this scenario the 'Initiator MEP' must verify the Rx LBR Replying MEP ID against the local MEP ID (VOE_MEPID) Scenario B: -------------------------------- Initiator MEP transmits 'Target MEP ID TLV' with the Initiator MEP ID (local MEP ID) Responder MEP replies with  'Replying MEP ID TLV' with the Responder MEP ID (local MEP ID) In this scenario the 'Responder MEP' must verify the Rx LBM Target MEP ID against the remote MEP ID (CCM_MEPID) In this scenario the 'Initiator MEP' must verify the Rx LBR Replying MEP ID against the remote MEP ID (CCM_MEPID) Scenario C: -------------------------------- Initiator MEP transmits 'Target MEP ID TLV' with the Responder MEP ID (remote MEP ID) Responder MEP replies with  'Replying MEP ID TLV' with the Responder MEP ID (local MEP ID) In this scenario the 'Responder MEP' must verify the Rx LBM Target MEP ID against the local MEP ID (VOE_MEPID) In this scenario the 'Initiator MEP' must verify the Rx LBR Replying MEP ID against the remote MEP ID (CCM_MEPID) Scenario D: -------------------------------- Initiator MEP transmits 'Target MEP ID TLV' with the Responder MEP ID (remote MEP ID) Responder MEP replies with  'Replying MEP ID TLV' with the Initiator MEP ID (remote MEP ID) In this scenario the 'Responder MEP' must verify the Rx LBM Target MEP ID against the local MEP ID (VOE_MEPID) In this scenario the 'Initiator MEP' must verify the Rx LBR Replying MEP ID against the local MEP ID (VOE_MEPID)
    ///
    /// 00: Scenario A 01: Scenario B 10: Scenario C 11: Scenario D
    #[inline(always)]
    pub fn g_8113_1_mep_scenario(&self) -> u32 {
        (self.0 & 0x30) >> 4
    }
    #[inline(always)]
    pub fn set_g_8113_1_mep_scenario(&mut self, value: u32) {
        assert!(value <= 0x3);
        let value = value << 4;
        self.0 &= !0x30;
        self.0 |= value;
    }
    /// The LMR PDU does not have any fields reserved to hold the RxFCb counter upon reception of an LMR/SLR frame. For LMR: ---------------- The VOE supports adding the RxFCb counter following the other three counters in the LMR/SLR PDU. This requires extending the first TLV from 12 --> 16 bytes. Asserting this fields enables updating TLV OFFSET to 16 and setting inserting RxFCb after TxFCb. Further a new End TLV = 0 is written right after the LMR.RxFCb (at offset = 16) For SLR: -------------- The VOE supports adding the RxFCb counter following the other three counters in the SLR PDU. This requires extending the first TLV from 16 --> 20 bytes. Asserting this fields enables updating TLV OFFSET to 16 and setting inserting RxFCb after TxFCb. Further a new End TLV = 0 is written right after the SLR.RxFCb (at offset = 16) This solution is a proprietary solution, which allows forwarding the RxFCb value to an internal or external CPU. NOTE this will result in a non standards compliant frame. However, this is the only way to convey the RxFCb frame count to a CPU.
    ///
    /// 0: No modifications to LMR upon reception 1: Update LMR frames as described above.
    #[inline(always)]
    pub fn lmr_upd_rxfcl_ena(&self) -> u32 {
        (self.0 & 0x400) >> 10
    }
    #[inline(always)]
    pub fn set_lmr_upd_rxfcl_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 10;
        self.0 &= !0x400;
        self.0 |= value;
    }
    /// Enables or disables automated Loss Of Continuity (LOC) Controller to be used for LOC detection by both Ethernet and MPLS-TP VOEs. When the LOC SCAN is disabled, the LOC timers will not expire so there is no increase of the LOC counters in the VOEs. When the LOC SCAN is enabled, the LOC timers will expire and increment the VOE LOC counters. LOC timers are configured in register: VOP::LOC_CTRL.* When the LOC scan controller is disabled, the LOC scan controller is automatically reset. I.e. all internal counters are set to default values. NOTE: This does not affect the LOC miss counters in the VOE.
    #[inline(always)]
    pub fn loc_scan_ena(&self) -> u32 {
        (self.0 & 0x2) >> 1
    }
    #[inline(always)]
    pub fn set_loc_scan_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        let value = value << 1;
        self.0 &= !0x2;
        self.0 |= value;
    }
    /// Enables or disables the Vitesse OAM Processor (VOP). When the the VOP is disabled, both VOP and the single VOEs can be configured, but no frame processing is done. Further each individual VOE must be enabled to enable its functionality.
    #[inline(always)]
    pub fn vop_ena(&self) -> u32 {
        self.0 & 0x1
    }
    #[inline(always)]
    pub fn set_vop_ena(&mut self, value: u32) {
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
}
