// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Based on mesa-v2021.09 (https://github.com/microchip-ung/mesa/) which has
// the following copyright and license:
//
// Copyright (c) 2004-2021 Microchip Technology Inc. and its subsidiaries.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// This is an autogenerated file; do not edit by hand!
use derive_more::{From, Into};
/// APC common configuration register 0
///
/// Common configurations 0 for APC logic. Note: For HML error correction logic HML=000/001/011/111 are considered valid, 010 and 101 are considered correctable (010 correctable to 011; 101 correctable to 001) and 100 and 110 are considered incorrectable.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_COMMON_CFG0(u32);
impl APC_COMMON_CFG0 {
    /// Enable APC direct connections instead of local IB configuration registers.
    pub fn apc_direct_ena(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    pub fn set_apc_direct_ena(&mut self, value: u32) {
        let value = value << 3;
        assert!(value <= 0x8);
        self.0 &= !0x8;
        self.0 |= value;
    }
    /// Top-ctrl FSM recovery behavior
    ///
    /// 0: No auto-recovery 1: Auto-restart on missing input signal after Restart-Delay-Timer has expired 2: Auto-restart on missing input signal
    pub fn apc_fsm_recover_mode(&self) -> u32 {
        (self.0 & 0xc000000) >> 26
    }
    pub fn set_apc_fsm_recover_mode(&mut self, value: u32) {
        let value = value << 26;
        assert!(value <= 0xc000000);
        self.0 &= !0xc000000;
        self.0 |= value;
    }
    /// APC operation mode
    ///
    /// 0: Off 1: Manual mode 2: Perform calibrarion and run FSM1 3: Perform calibration and run FSM2 4: Perform calibration and run FSM1 and FSM2 in ping-pong operation 5: Perform calibration and then enter manual mode
    pub fn apc_mode(&self) -> u32 {
        self.0 & 0x7
    }
    pub fn set_apc_mode(&mut self, value: u32) {
        assert!(value <= 0x7);
        self.0 &= !0x7;
        self.0 |= value;
    }
    /// Select flexctrl block in order to read internal counters. Counter values readable from APC_FLEXCTRL_CNT_STATUS.
    ///
    /// 0: Offset-ctrl 1: L-ctrl 2: C-ctrl 3: AGC-ctrl 4: DFE1-ctrl 5: DFE2-ctrl 6: DFE3-ctrl 7: DFE4-ctrl 8: SAM_Offset-cal 9: Level-cal 10: HML sampling errors
    pub fn block_read_sel(&self) -> u32 {
        (self.0 & 0xf000) >> 12
    }
    pub fn set_block_read_sel(&mut self, value: u32) {
        let value = value << 12;
        assert!(value <= 0xf000);
        self.0 &= !0xf000;
        self.0 |= value;
    }
    /// Obsolete. Replaced by dedicated and independent ctrl_mode bits for each parameter control block.
    pub fn ctrl_mode(&self) -> u32 {
        (self.0 & 0x20) >> 5
    }
    pub fn set_ctrl_mode(&mut self, value: u32) {
        let value = value << 5;
        assert!(value <= 0x20);
        self.0 &= !0x20;
        self.0 |= value;
    }
    /// Freeze current state
    ///
    /// 0: Normal operation 1: Freeze APC
    pub fn freeze_apc(&self) -> u32 {
        (self.0 & 0x400) >> 10
    }
    pub fn set_freeze_apc(&mut self, value: u32) {
        let value = value << 10;
        assert!(value <= 0x400);
        self.0 &= !0x400;
        self.0 |= value;
    }
    /// Clear HML sampling error counter
    ///
    /// 1: Clear counter
    pub fn hml_clr_cnt(&self) -> u32 {
        (self.0 & 0x80000000) >> 31
    }
    pub fn set_hml_clr_cnt(&mut self, value: u32) {
        let value = value << 31;
        assert!(value <= 0x80000000);
        self.0 &= !0x80000000;
        self.0 |= value;
    }
    /// HML sampling error correction enable. Invalid samples are not used for parameter control (smart sampling).
    ///
    /// 0: Disable smart sampling 1: Enable smart sampling
    pub fn hml_errcorr_ena(&self) -> u32 {
        (self.0 & 0x20000000) >> 29
    }
    pub fn set_hml_errcorr_ena(&mut self, value: u32) {
        let value = value << 29;
        assert!(value <= 0x20000000);
        self.0 &= !0x20000000;
        self.0 |= value;
    }
    /// HML sampling error correction mode. Correctable sampling errors can be automatically corrected.
    ///
    /// 0: Disable auto-correctin 1: Enable auto-correction
    pub fn hml_errcorr_mode(&self) -> u32 {
        (self.0 & 0x40000000) >> 30
    }
    pub fn set_hml_errcorr_mode(&mut self, value: u32) {
        let value = value << 30;
        assert!(value <= 0x40000000);
        self.0 &= !0x40000000;
        self.0 |= value;
    }
    /// H/L swapping in HML sampling error correction logic
    ///
    /// 0: No H/L swapping 1: H/L swapped
    pub fn hml_swap_hl(&self) -> u32 {
        (self.0 & 0x10000000) >> 28
    }
    pub fn set_hml_swap_hl(&mut self, value: u32) {
        let value = value << 28;
        assert!(value <= 0x10000000);
        self.0 &= !0x10000000;
        self.0 |= value;
    }
    /// Interface bit-width
    ///
    /// 0: 8-bit 1: 10-bit 2: 16-bit 3: 20-bit 4: 32-bit 5: 40-bit
    pub fn if_width(&self) -> u32 {
        (self.0 & 0x1c0) >> 6
    }
    pub fn set_if_width(&mut self, value: u32) {
        let value = value << 6;
        assert!(value <= 0x1c0);
        self.0 &= !0x1c0;
        self.0 |= value;
    }
    /// Reset APC core logic (configuration registers are not reset)
    ///
    /// 1: Reset APC 0: Normal operation (mission mode)
    pub fn reset_apc(&self) -> u32 {
        (self.0 & 0x800) >> 11
    }
    pub fn set_reset_apc(&mut self, value: u32) {
        let value = value << 11;
        assert!(value <= 0x800);
        self.0 &= !0x800;
        self.0 |= value;
    }
    /// Signal detect valid configuration (Offs/AGC/L/C/DFE)
    ///
    /// 0: Signal_detect input directly used 1: Signal_detect input gated with gain_ctrl ramp-up done (EQZ_GAIN_CTRL_DONE)
    pub fn sig_det_valid_cfg(&self) -> u32 {
        (self.0 & 0x2000000) >> 25
    }
    pub fn set_sig_det_valid_cfg(&mut self, value: u32) {
        let value = value << 25;
        assert!(value <= 0x2000000);
        self.0 &= !0x2000000;
        self.0 |= value;
    }
    /// Signal lost delay timer configuration used for APC recovery. The signal lost delay time specifies the time when a missing input signal is considered a lost input signal on sig_det = 0. The delay time is T = (2^sig_lost_delay_time) * T_rx_clk_per
    pub fn sig_lost_delay_time(&self) -> u32 {
        (self.0 & 0x1f00000) >> 20
    }
    pub fn set_sig_lost_delay_time(&mut self, value: u32) {
        let value = value << 20;
        assert!(value <= 0x1f00000);
        self.0 &= !0x1f00000;
        self.0 |= value;
    }
    /// Skip calibration process in top control state machine (applies for apc_modes 2, 3 and 4)
    pub fn skip_cal(&self) -> u32 {
        (self.0 & 0x200) >> 9
    }
    pub fn set_skip_cal(&mut self, value: u32) {
        let value = value << 9;
        assert!(value <= 0x200);
        self.0 &= !0x200;
        self.0 |= value;
    }
    /// APC throttling mode
    ///
    /// 0: Disable no power reduction (continuous operation) 1: Enable power reduced operation (pulsed operation)
    pub fn throttle_mode(&self) -> u32 {
        (self.0 & 0x10) >> 4
    }
    pub fn set_throttle_mode(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x10);
        self.0 &= !0x10;
        self.0 |= value;
    }
    /// Current state of APC top control state machine
    ///
    /// 0: Off 1: Power-up 2: Power-down 3: Manual mode 4: Calibrate IS 5: Calibrate LD 6: Not used 7: Gain-control ramp-up 8: Mission mode (FSM1 controlled) 9: Mission mode (FSM2 controlled) 10-12: Debug states 13: Snooze 14-15: Not used
    pub fn top_ctrl_state(&self) -> u32 {
        (self.0 & 0xf0000) >> 16
    }
    pub fn set_top_ctrl_state(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xf0000);
        self.0 &= !0xf0000;
        self.0 |= value;
    }
}
/// APC DFE1 Control registers
///
/// General behavior control for DFE1 parameter control.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_DFE1_CTRL(u32);
impl APC_DFE1_CTRL {
    /// Parameter value (controlled/computed value)
    pub fn dfe1_actval(&self) -> u32 {
        (self.0 & 0x3ff0000) >> 16
    }
    pub fn set_dfe1_actval(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0x3ff0000);
        self.0 &= !0x3ff0000;
        self.0 |= value;
    }
    /// Parameter control state in one-time mode
    ///
    /// 1: Finished
    pub fn dfe1_ctrl_done(&self) -> u32 {
        (self.0 & 0x4000000) >> 26
    }
    pub fn set_dfe1_ctrl_done(&mut self, value: u32) {
        let value = value << 26;
        assert!(value <= 0x4000000);
        self.0 &= !0x4000000;
        self.0 |= value;
    }
    /// Parameter control mode for DFE1 parameter
    ///
    /// 0: Discrete 1: Continuous
    pub fn dfe1_ctrl_mode(&self) -> u32 {
        (self.0 & 0x400) >> 10
    }
    pub fn set_dfe1_ctrl_mode(&mut self, value: u32) {
        let value = value << 10;
        assert!(value <= 0x400);
        self.0 &= !0x400;
        self.0 |= value;
    }
    /// Alternative threshold for DFE1 parameter (controller goal: err_cnt = 0.5*DFE1_THRES)
    pub fn dfe1_ctrl_thres(&self) -> u32 {
        (self.0 & 0x3f0) >> 4
    }
    pub fn set_dfe1_ctrl_thres(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x3f0);
        self.0 &= !0x3f0;
        self.0 |= value;
    }
    /// Enable use of alternative threshold for DFE1 parameter
    ///
    /// 0: Use default threshold 1: Use alternative threshold
    pub fn dfe1_ctrl_thres_ena(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    pub fn set_dfe1_ctrl_thres_ena(&mut self, value: u32) {
        let value = value << 3;
        assert!(value <= 0x8);
        self.0 &= !0x8;
        self.0 |= value;
    }
    /// Operation mode
    ///
    /// 0: Off 1: One-time 2: Non-stop 3: Paused
    pub fn dfe1_op_mode(&self) -> u32 {
        self.0 & 0x3
    }
    pub fn set_dfe1_op_mode(&mut self, value: u32) {
        assert!(value <= 0x3);
        self.0 &= !0x3;
        self.0 |= value;
    }
    /// Select counter to be read
    ///
    /// 0: dfe1_value 1: Hit counter 2: Error counter
    pub fn dfe1_read_cnt_sel(&self) -> u32 {
        (self.0 & 0x3000) >> 12
    }
    pub fn set_dfe1_read_cnt_sel(&mut self, value: u32) {
        let value = value << 12;
        assert!(value <= 0x3000);
        self.0 &= !0x3000;
        self.0 |= value;
    }
    /// DFE1 recovery behavior
    ///
    /// 0: No auto-recovery 1: Freeze DFE1 on weak (eqz_gain > eqz_gain_freeze_thres) or missing input signal 2: Freeze DFE1 on weak signal and restart on missing input signal 3: Freeze DFE1 on missing input signal 4: Freeze DFE1 on missing input signal and auto-restart after Restart-Delay-Timer has expired 5: Auto-restart DFE1 on missing input signal 6-7: Reserved
    pub fn dfe1_recover_mode(&self) -> u32 {
        (self.0 & 0x38000000) >> 27
    }
    pub fn set_dfe1_recover_mode(&mut self, value: u32) {
        let value = value << 27;
        assert!(value <= 0x38000000);
        self.0 &= !0x38000000;
        self.0 |= value;
    }
    /// Start operation (parameter update). Should be cleared afterwards in One-time mode and stay set in Non-stop and Paused mode
    pub fn dfe1_start_ctrl(&self) -> u32 {
        (self.0 & 0x4) >> 2
    }
    pub fn set_dfe1_start_ctrl(&mut self, value: u32) {
        let value = value << 2;
        assert!(value <= 0x4);
        self.0 &= !0x4;
        self.0 |= value;
    }
    /// Synchronization mode
    ///
    /// 0: Independent 1: Attached to parctrl FSM 1 2: Attached to parctrl FSM 2 3: Attached to both parctrl FSMs
    pub fn dfe1_sync_mode(&self) -> u32 {
        (self.0 & 0xc000) >> 14
    }
    pub fn set_dfe1_sync_mode(&mut self, value: u32) {
        let value = value << 14;
        assert!(value <= 0xc000);
        self.0 &= !0xc000;
        self.0 |= value;
    }
}
/// APC DFE1 Parameter control register
///
/// Configuration register for controlled DFE1 parameter. Note, for parameters larger than 8 bits, ini/min/max values are shifted to the left. For parameters smaller than 8 bits only the lower bits of ini/min/max are used.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_DFE1_PAR_CFG(u32);
impl APC_DFE1_PAR_CFG {
    /// Parameter change mode
    ///
    /// 0: Automatic update 1: Preset (use DFE1_INI as fix value internal processing continues) 2: Freeze (internal processing stops parameter stays at current value) 3: No update (internal processing continues but parameter is not updated)
    pub fn dfe1_chg_mode(&self) -> u32 {
        (self.0 & 0x3000000) >> 24
    }
    pub fn set_dfe1_chg_mode(&mut self, value: u32) {
        let value = value << 24;
        assert!(value <= 0x3000000);
        self.0 &= !0x3000000;
        self.0 |= value;
    }
    /// Select parameter update direction
    ///
    /// 0: Normal 1: Inverted
    pub fn dfe1_dir_sel(&self) -> u32 {
        (self.0 & 0x80000000) >> 31
    }
    pub fn set_dfe1_dir_sel(&mut self, value: u32) {
        let value = value << 31;
        assert!(value <= 0x80000000);
        self.0 &= !0x80000000;
        self.0 |= value;
    }
    /// Parameter initial value
    pub fn dfe1_ini(&self) -> u32 {
        self.0 & 0xff
    }
    pub fn set_dfe1_ini(&mut self, value: u32) {
        assert!(value <= 0xff);
        self.0 &= !0xff;
        self.0 |= value;
    }
    /// Maximum value of paramter
    pub fn dfe1_max(&self) -> u32 {
        (self.0 & 0xff0000) >> 16
    }
    pub fn set_dfe1_max(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xff0000);
        self.0 &= !0xff0000;
        self.0 |= value;
    }
    /// Minimum value of paramter
    pub fn dfe1_min(&self) -> u32 {
        (self.0 & 0xff00) >> 8
    }
    pub fn set_dfe1_min(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0xff00);
        self.0 &= !0xff00;
        self.0 |= value;
    }
    /// Parameter range selection (only when CTRL_MODE = continuous). Value complies to number of left-shifts
    pub fn dfe1_range_sel(&self) -> u32 {
        (self.0 & 0x7c000000) >> 26
    }
    pub fn set_dfe1_range_sel(&mut self, value: u32) {
        let value = value << 26;
        assert!(value <= 0x7c000000);
        self.0 &= !0x7c000000;
        self.0 |= value;
    }
}
/// APC DFE1 Timer config
///
/// Configuration registers for DFE1 controller timing.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_DFE1_TIMER_CFG(u32);
impl APC_DFE1_TIMER_CFG {
    /// Operation time (in number of rx_clk cycles)
    pub fn dfe1_op_time(&self) -> u32 {
        self.0 & 0xffff
    }
    pub fn set_dfe1_op_time(&mut self, value: u32) {
        assert!(value <= 0xffff);
        self.0 &= !0xffff;
        self.0 |= value;
    }
    /// Pause time
    ///
    /// (in number of rx_clk cycles)
    pub fn dfe1_ps_time(&self) -> u32 {
        (self.0 & 0xffff0000) >> 16
    }
    pub fn set_dfe1_ps_time(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xffff0000);
        self.0 &= !0xffff0000;
        self.0 |= value;
    }
}
/// APC DFE2 Control registers
///
/// General behavior control for DFE2 parameter control.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_DFE2_CTRL(u32);
impl APC_DFE2_CTRL {
    /// Parameter value (controlled/computed value)
    pub fn dfe2_actval(&self) -> u32 {
        (self.0 & 0x3ff0000) >> 16
    }
    pub fn set_dfe2_actval(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0x3ff0000);
        self.0 &= !0x3ff0000;
        self.0 |= value;
    }
    /// Parameter control state in one-time mode
    ///
    /// 1: Finished
    pub fn dfe2_ctrl_done(&self) -> u32 {
        (self.0 & 0x4000000) >> 26
    }
    pub fn set_dfe2_ctrl_done(&mut self, value: u32) {
        let value = value << 26;
        assert!(value <= 0x4000000);
        self.0 &= !0x4000000;
        self.0 |= value;
    }
    /// Parameter control mode for DFE2 parameter
    ///
    /// 0: Discrete 1: Continuous
    pub fn dfe2_ctrl_mode(&self) -> u32 {
        (self.0 & 0x400) >> 10
    }
    pub fn set_dfe2_ctrl_mode(&mut self, value: u32) {
        let value = value << 10;
        assert!(value <= 0x400);
        self.0 &= !0x400;
        self.0 |= value;
    }
    /// Alternative threshold for DFE2 parameter (controller goal: err_cnt = 0.5*DFE2_THRES)
    pub fn dfe2_ctrl_thres(&self) -> u32 {
        (self.0 & 0x3f0) >> 4
    }
    pub fn set_dfe2_ctrl_thres(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x3f0);
        self.0 &= !0x3f0;
        self.0 |= value;
    }
    /// Enable use of alternative threshold for DFE2 parameter
    ///
    /// 0: Use default threshold 1: Use alternative threshold
    pub fn dfe2_ctrl_thres_ena(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    pub fn set_dfe2_ctrl_thres_ena(&mut self, value: u32) {
        let value = value << 3;
        assert!(value <= 0x8);
        self.0 &= !0x8;
        self.0 |= value;
    }
    /// Operation mode
    ///
    /// 0: Off 1: One-time 2: Non-stop 3: Paused
    pub fn dfe2_op_mode(&self) -> u32 {
        self.0 & 0x3
    }
    pub fn set_dfe2_op_mode(&mut self, value: u32) {
        assert!(value <= 0x3);
        self.0 &= !0x3;
        self.0 |= value;
    }
    /// Select counter to be read
    ///
    /// 0: dfe2_value 1: Hit counter 2: Error counter
    pub fn dfe2_read_cnt_sel(&self) -> u32 {
        (self.0 & 0x3000) >> 12
    }
    pub fn set_dfe2_read_cnt_sel(&mut self, value: u32) {
        let value = value << 12;
        assert!(value <= 0x3000);
        self.0 &= !0x3000;
        self.0 |= value;
    }
    /// DFE2 recovery behavior
    ///
    /// 0: No auto-recovery 1: Freeze DFE2 on weak (eqz_gain > eqz_gain_freeze_thres) or missing input signal 2: Freeze DFE2 on weak signal and restart on missing input signal 3: Freeze DFE2 on missing input signal 4: Freeze DFE2 on missing input signal and auto-restart after Restart-Delay-Timer has expired 5: Auto-restart DFE2 on missing input signal 6-7: Reserved
    pub fn dfe2_recover_mode(&self) -> u32 {
        (self.0 & 0x38000000) >> 27
    }
    pub fn set_dfe2_recover_mode(&mut self, value: u32) {
        let value = value << 27;
        assert!(value <= 0x38000000);
        self.0 &= !0x38000000;
        self.0 |= value;
    }
    /// Start operation (parameter update). Should be cleared afterwards in One-time mode and stay set in Non-stop and Paused mode
    pub fn dfe2_start_ctrl(&self) -> u32 {
        (self.0 & 0x4) >> 2
    }
    pub fn set_dfe2_start_ctrl(&mut self, value: u32) {
        let value = value << 2;
        assert!(value <= 0x4);
        self.0 &= !0x4;
        self.0 |= value;
    }
    /// Synchronization mode
    ///
    /// 0: Independent 1: Attached to parctrl FSM 1 2: Attached to parctrl FSM 2 3: Attached to both parctrl FSMs
    pub fn dfe2_sync_mode(&self) -> u32 {
        (self.0 & 0xc000) >> 14
    }
    pub fn set_dfe2_sync_mode(&mut self, value: u32) {
        let value = value << 14;
        assert!(value <= 0xc000);
        self.0 &= !0xc000;
        self.0 |= value;
    }
}
/// APC DFE2 Parameter control register
///
/// Configuration register for controlled DFE2 parameter. Note, for parameters larger than 8 bits, ini/min/max values are shifted to the left. For parameters smaller than 8 bits only the lower bits of ini/min/max are used.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_DFE2_PAR_CFG(u32);
impl APC_DFE2_PAR_CFG {
    /// Parameter change mode
    ///
    /// 0: Automatic update 1: Preset (use DFE2_INI as fix value internal processing continues) 2: Freeze (internal processing stops parameter stays at current value) 3: No update (internal processing continues but parameter is not updated)
    pub fn dfe2_chg_mode(&self) -> u32 {
        (self.0 & 0x3000000) >> 24
    }
    pub fn set_dfe2_chg_mode(&mut self, value: u32) {
        let value = value << 24;
        assert!(value <= 0x3000000);
        self.0 &= !0x3000000;
        self.0 |= value;
    }
    /// Select parameter update direction
    ///
    /// 0: Normal 1: Inverted
    pub fn dfe2_dir_sel(&self) -> u32 {
        (self.0 & 0x80000000) >> 31
    }
    pub fn set_dfe2_dir_sel(&mut self, value: u32) {
        let value = value << 31;
        assert!(value <= 0x80000000);
        self.0 &= !0x80000000;
        self.0 |= value;
    }
    /// Parameter initial value
    pub fn dfe2_ini(&self) -> u32 {
        self.0 & 0xff
    }
    pub fn set_dfe2_ini(&mut self, value: u32) {
        assert!(value <= 0xff);
        self.0 &= !0xff;
        self.0 |= value;
    }
    /// Maximum value of paramter
    pub fn dfe2_max(&self) -> u32 {
        (self.0 & 0xff0000) >> 16
    }
    pub fn set_dfe2_max(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xff0000);
        self.0 &= !0xff0000;
        self.0 |= value;
    }
    /// Minimum value of paramter
    pub fn dfe2_min(&self) -> u32 {
        (self.0 & 0xff00) >> 8
    }
    pub fn set_dfe2_min(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0xff00);
        self.0 &= !0xff00;
        self.0 |= value;
    }
    /// Parameter range selection (only when CTRL_MODE = continuous). Value complies to number of left-shifts
    pub fn dfe2_range_sel(&self) -> u32 {
        (self.0 & 0x7c000000) >> 26
    }
    pub fn set_dfe2_range_sel(&mut self, value: u32) {
        let value = value << 26;
        assert!(value <= 0x7c000000);
        self.0 &= !0x7c000000;
        self.0 |= value;
    }
}
/// APC DFE2 Timer config
///
/// Configuration registers for DFE2 controller timing.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_DFE2_TIMER_CFG(u32);
impl APC_DFE2_TIMER_CFG {
    /// Operation time (in number of rx_clk cycles)
    pub fn dfe2_op_time(&self) -> u32 {
        self.0 & 0xffff
    }
    pub fn set_dfe2_op_time(&mut self, value: u32) {
        assert!(value <= 0xffff);
        self.0 &= !0xffff;
        self.0 |= value;
    }
    /// Pause time
    ///
    /// (in number of rx_clk cycles)
    pub fn dfe2_ps_time(&self) -> u32 {
        (self.0 & 0xffff0000) >> 16
    }
    pub fn set_dfe2_ps_time(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xffff0000);
        self.0 &= !0xffff0000;
        self.0 |= value;
    }
}
/// APC DFE3 Control registers
///
/// General behavior control for DFE3 parameter control.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_DFE3_CTRL(u32);
impl APC_DFE3_CTRL {
    /// Parameter value (controlled/computed value)
    pub fn dfe3_actval(&self) -> u32 {
        (self.0 & 0x3ff0000) >> 16
    }
    pub fn set_dfe3_actval(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0x3ff0000);
        self.0 &= !0x3ff0000;
        self.0 |= value;
    }
    /// Parameter control state in one-time mode
    ///
    /// 1: Finished
    pub fn dfe3_ctrl_done(&self) -> u32 {
        (self.0 & 0x4000000) >> 26
    }
    pub fn set_dfe3_ctrl_done(&mut self, value: u32) {
        let value = value << 26;
        assert!(value <= 0x4000000);
        self.0 &= !0x4000000;
        self.0 |= value;
    }
    /// Parameter control mode for DFE3 parameter
    ///
    /// 0: Discrete 1: Continuous
    pub fn dfe3_ctrl_mode(&self) -> u32 {
        (self.0 & 0x400) >> 10
    }
    pub fn set_dfe3_ctrl_mode(&mut self, value: u32) {
        let value = value << 10;
        assert!(value <= 0x400);
        self.0 &= !0x400;
        self.0 |= value;
    }
    /// Alternative threshold for DFE3 parameter (controller goal: err_cnt = 0.5*DFE3_THRES)
    pub fn dfe3_ctrl_thres(&self) -> u32 {
        (self.0 & 0x3f0) >> 4
    }
    pub fn set_dfe3_ctrl_thres(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x3f0);
        self.0 &= !0x3f0;
        self.0 |= value;
    }
    /// Enable use of alternative threshold for DFE3 parameter
    ///
    /// 0: Use default threshold 1: Use alternative threshold
    pub fn dfe3_ctrl_thres_ena(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    pub fn set_dfe3_ctrl_thres_ena(&mut self, value: u32) {
        let value = value << 3;
        assert!(value <= 0x8);
        self.0 &= !0x8;
        self.0 |= value;
    }
    /// Operation mode
    ///
    /// 0: Off 1: One-time 2: Non-stop 3: Paused
    pub fn dfe3_op_mode(&self) -> u32 {
        self.0 & 0x3
    }
    pub fn set_dfe3_op_mode(&mut self, value: u32) {
        assert!(value <= 0x3);
        self.0 &= !0x3;
        self.0 |= value;
    }
    /// Select counter to be read
    ///
    /// 0: dfe3_value 1: Hit counter 2: Error counter
    pub fn dfe3_read_cnt_sel(&self) -> u32 {
        (self.0 & 0x3000) >> 12
    }
    pub fn set_dfe3_read_cnt_sel(&mut self, value: u32) {
        let value = value << 12;
        assert!(value <= 0x3000);
        self.0 &= !0x3000;
        self.0 |= value;
    }
    /// DFE3 recovery behavior
    ///
    /// 0: No auto-recovery 1: Freeze DFE3 on weak (eqz_gain > eqz_gain_freeze_thres) or missing input signal 2: Freeze DFE3 on weak signal and restart on missing input signal 3: Freeze DFE3 on missing input signal 4: Freeze DFE3 on missing input signal and auto-restart after Restart-Delay-Timer has expired 5: Auto-restart DFE3 on missing input signal 6-7: Reserved
    pub fn dfe3_recover_mode(&self) -> u32 {
        (self.0 & 0x38000000) >> 27
    }
    pub fn set_dfe3_recover_mode(&mut self, value: u32) {
        let value = value << 27;
        assert!(value <= 0x38000000);
        self.0 &= !0x38000000;
        self.0 |= value;
    }
    /// Start operation (parameter update). Should be cleared afterwards in One-time mode and stay set in Non-stop and Paused mode
    pub fn dfe3_start_ctrl(&self) -> u32 {
        (self.0 & 0x4) >> 2
    }
    pub fn set_dfe3_start_ctrl(&mut self, value: u32) {
        let value = value << 2;
        assert!(value <= 0x4);
        self.0 &= !0x4;
        self.0 |= value;
    }
    /// Synchronization mode
    ///
    /// 0: Independent 1: Attached to parctrl FSM 1 2: Attached to parctrl FSM 2 3: Attached to both parctrl FSMs
    pub fn dfe3_sync_mode(&self) -> u32 {
        (self.0 & 0xc000) >> 14
    }
    pub fn set_dfe3_sync_mode(&mut self, value: u32) {
        let value = value << 14;
        assert!(value <= 0xc000);
        self.0 &= !0xc000;
        self.0 |= value;
    }
}
/// APC DFE3 Parameter control register
///
/// Configuration register for controlled DFE3 parameter. Note, for parameters larger than 8 bits, ini/min/max values are shifted to the left. For parameters smaller than 8 bits only the lower bits of ini/min/max are used.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_DFE3_PAR_CFG(u32);
impl APC_DFE3_PAR_CFG {
    /// Parameter change mode
    ///
    /// 0: Automatic update 1: Preset (use DFE3_INI as fix value internal processing continues) 2: Freeze (internal processing stops parameter stays at current value) 3: No update (internal processing continues but parameter is not updated)
    pub fn dfe3_chg_mode(&self) -> u32 {
        (self.0 & 0x3000000) >> 24
    }
    pub fn set_dfe3_chg_mode(&mut self, value: u32) {
        let value = value << 24;
        assert!(value <= 0x3000000);
        self.0 &= !0x3000000;
        self.0 |= value;
    }
    /// Select parameter update direction
    ///
    /// 0: Normal 1: Inverted
    pub fn dfe3_dir_sel(&self) -> u32 {
        (self.0 & 0x80000000) >> 31
    }
    pub fn set_dfe3_dir_sel(&mut self, value: u32) {
        let value = value << 31;
        assert!(value <= 0x80000000);
        self.0 &= !0x80000000;
        self.0 |= value;
    }
    /// Parameter initial value
    pub fn dfe3_ini(&self) -> u32 {
        self.0 & 0xff
    }
    pub fn set_dfe3_ini(&mut self, value: u32) {
        assert!(value <= 0xff);
        self.0 &= !0xff;
        self.0 |= value;
    }
    /// Maximum value of paramter
    pub fn dfe3_max(&self) -> u32 {
        (self.0 & 0xff0000) >> 16
    }
    pub fn set_dfe3_max(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xff0000);
        self.0 &= !0xff0000;
        self.0 |= value;
    }
    /// Minimum value of paramter
    pub fn dfe3_min(&self) -> u32 {
        (self.0 & 0xff00) >> 8
    }
    pub fn set_dfe3_min(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0xff00);
        self.0 &= !0xff00;
        self.0 |= value;
    }
    /// Parameter range selection (only when CTRL_MODE = continuous). Value complies to number of left-shifts
    pub fn dfe3_range_sel(&self) -> u32 {
        (self.0 & 0x7c000000) >> 26
    }
    pub fn set_dfe3_range_sel(&mut self, value: u32) {
        let value = value << 26;
        assert!(value <= 0x7c000000);
        self.0 &= !0x7c000000;
        self.0 |= value;
    }
}
/// APC DFE3 Timer config
///
/// Configuration registers for DFE3 controller timing.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_DFE3_TIMER_CFG(u32);
impl APC_DFE3_TIMER_CFG {
    /// Operation time (in number of rx_clk cycles)
    pub fn dfe3_op_time(&self) -> u32 {
        self.0 & 0xffff
    }
    pub fn set_dfe3_op_time(&mut self, value: u32) {
        assert!(value <= 0xffff);
        self.0 &= !0xffff;
        self.0 |= value;
    }
    /// Pause time
    ///
    /// (in number of rx_clk cycles)
    pub fn dfe3_ps_time(&self) -> u32 {
        (self.0 & 0xffff0000) >> 16
    }
    pub fn set_dfe3_ps_time(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xffff0000);
        self.0 &= !0xffff0000;
        self.0 |= value;
    }
}
/// APC DFE4 Control registers
///
/// General behavior control for DFE4 parameter control.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_DFE4_CTRL(u32);
impl APC_DFE4_CTRL {
    /// Parameter value (controlled/computed value)
    pub fn dfe4_actval(&self) -> u32 {
        (self.0 & 0x3ff0000) >> 16
    }
    pub fn set_dfe4_actval(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0x3ff0000);
        self.0 &= !0x3ff0000;
        self.0 |= value;
    }
    /// Parameter control state in one-time mode
    ///
    /// 1: Finished
    pub fn dfe4_ctrl_done(&self) -> u32 {
        (self.0 & 0x4000000) >> 26
    }
    pub fn set_dfe4_ctrl_done(&mut self, value: u32) {
        let value = value << 26;
        assert!(value <= 0x4000000);
        self.0 &= !0x4000000;
        self.0 |= value;
    }
    /// Parameter control mode for DFE4 parameter
    ///
    /// 0: Discrete 1: Continuous
    pub fn dfe4_ctrl_mode(&self) -> u32 {
        (self.0 & 0x400) >> 10
    }
    pub fn set_dfe4_ctrl_mode(&mut self, value: u32) {
        let value = value << 10;
        assert!(value <= 0x400);
        self.0 &= !0x400;
        self.0 |= value;
    }
    /// Alternative threshold for DFE4 parameter (controller goal: err_cnt = 0.5*DFE4_THRES)
    pub fn dfe4_ctrl_thres(&self) -> u32 {
        (self.0 & 0x3f0) >> 4
    }
    pub fn set_dfe4_ctrl_thres(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x3f0);
        self.0 &= !0x3f0;
        self.0 |= value;
    }
    /// Enable use of alternative threshold for DFE4 parameter
    ///
    /// 0: Use default threshold 1: Use alternative threshold
    pub fn dfe4_ctrl_thres_ena(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    pub fn set_dfe4_ctrl_thres_ena(&mut self, value: u32) {
        let value = value << 3;
        assert!(value <= 0x8);
        self.0 &= !0x8;
        self.0 |= value;
    }
    /// Operation mode
    ///
    /// 0: Off 1: One-time 2: Non-stop 3: Paused
    pub fn dfe4_op_mode(&self) -> u32 {
        self.0 & 0x3
    }
    pub fn set_dfe4_op_mode(&mut self, value: u32) {
        assert!(value <= 0x3);
        self.0 &= !0x3;
        self.0 |= value;
    }
    /// Select counter to be read
    ///
    /// 0: dfe4_value 1: Hit counter 2: Error counter
    pub fn dfe4_read_cnt_sel(&self) -> u32 {
        (self.0 & 0x3000) >> 12
    }
    pub fn set_dfe4_read_cnt_sel(&mut self, value: u32) {
        let value = value << 12;
        assert!(value <= 0x3000);
        self.0 &= !0x3000;
        self.0 |= value;
    }
    /// DFE4 recovery behavior
    ///
    /// 0: No auto-recovery 1: Freeze DFE4 on weak (eqz_gain > eqz_gain_freeze_thres) or missing input signal 2: Freeze DFE4 on weak signal and restart on missing input signal 3: Freeze DFE4 on missing input signal 4: Freeze DFE4 on missing input signal and auto-restart after Restart-Delay-Timer has expired 5: Auto-restart DFE4 on missing input signal 6-7: Reserved
    pub fn dfe4_recover_mode(&self) -> u32 {
        (self.0 & 0x38000000) >> 27
    }
    pub fn set_dfe4_recover_mode(&mut self, value: u32) {
        let value = value << 27;
        assert!(value <= 0x38000000);
        self.0 &= !0x38000000;
        self.0 |= value;
    }
    /// Start operation (parameter update). Should be cleared afterwards in One-time mode and stay set in Non-stop and Paused mode
    pub fn dfe4_start_ctrl(&self) -> u32 {
        (self.0 & 0x4) >> 2
    }
    pub fn set_dfe4_start_ctrl(&mut self, value: u32) {
        let value = value << 2;
        assert!(value <= 0x4);
        self.0 &= !0x4;
        self.0 |= value;
    }
    /// Synchronization mode
    ///
    /// 0: Independent 1: Attached to parctrl FSM 1 2: Attached to parctrl FSM 2 3: Attached to both parctrl FSMs
    pub fn dfe4_sync_mode(&self) -> u32 {
        (self.0 & 0xc000) >> 14
    }
    pub fn set_dfe4_sync_mode(&mut self, value: u32) {
        let value = value << 14;
        assert!(value <= 0xc000);
        self.0 &= !0xc000;
        self.0 |= value;
    }
}
/// APC DFE4 Parameter control register
///
/// Configuration register for controlled DFE4 parameter. Note, for parameters larger than 8 bits, ini/min/max values are shifted to the left. For parameters smaller than 8 bits only the lower bits of ini/min/max are used.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_DFE4_PAR_CFG(u32);
impl APC_DFE4_PAR_CFG {
    /// Parameter change mode
    ///
    /// 0: Automatic update 1: Preset (use DFE4_INI as fix value internal processing continues) 2: Freeze (internal processing stops parameter stays at current value) 3: No update (internal processing continues but parameter is not updated)
    pub fn dfe4_chg_mode(&self) -> u32 {
        (self.0 & 0x3000000) >> 24
    }
    pub fn set_dfe4_chg_mode(&mut self, value: u32) {
        let value = value << 24;
        assert!(value <= 0x3000000);
        self.0 &= !0x3000000;
        self.0 |= value;
    }
    /// Select parameter update direction
    ///
    /// 0: Normal 1: Inverted
    pub fn dfe4_dir_sel(&self) -> u32 {
        (self.0 & 0x80000000) >> 31
    }
    pub fn set_dfe4_dir_sel(&mut self, value: u32) {
        let value = value << 31;
        assert!(value <= 0x80000000);
        self.0 &= !0x80000000;
        self.0 |= value;
    }
    /// Parameter initial value
    pub fn dfe4_ini(&self) -> u32 {
        self.0 & 0xff
    }
    pub fn set_dfe4_ini(&mut self, value: u32) {
        assert!(value <= 0xff);
        self.0 &= !0xff;
        self.0 |= value;
    }
    /// Maximum value of paramter
    pub fn dfe4_max(&self) -> u32 {
        (self.0 & 0xff0000) >> 16
    }
    pub fn set_dfe4_max(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xff0000);
        self.0 &= !0xff0000;
        self.0 |= value;
    }
    /// Minimum value of paramter
    pub fn dfe4_min(&self) -> u32 {
        (self.0 & 0xff00) >> 8
    }
    pub fn set_dfe4_min(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0xff00);
        self.0 &= !0xff00;
        self.0 |= value;
    }
    /// Parameter range selection (only when CTRL_MODE = continuous). Value complies to number of left-shifts
    pub fn dfe4_range_sel(&self) -> u32 {
        (self.0 & 0x7c000000) >> 26
    }
    pub fn set_dfe4_range_sel(&mut self, value: u32) {
        let value = value << 26;
        assert!(value <= 0x7c000000);
        self.0 &= !0x7c000000;
        self.0 |= value;
    }
}
/// APC DFE4 Timer config
///
/// Configuration registers for DFE4 controller timing.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_DFE4_TIMER_CFG(u32);
impl APC_DFE4_TIMER_CFG {
    /// Operation time (in number of rx_clk cycles)
    pub fn dfe4_op_time(&self) -> u32 {
        self.0 & 0xffff
    }
    pub fn set_dfe4_op_time(&mut self, value: u32) {
        assert!(value <= 0xffff);
        self.0 &= !0xffff;
        self.0 |= value;
    }
    /// Pause time
    ///
    /// (in number of rx_clk cycles)
    pub fn dfe4_ps_time(&self) -> u32 {
        (self.0 & 0xffff0000) >> 16
    }
    pub fn set_dfe4_ps_time(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xffff0000);
        self.0 &= !0xffff0000;
        self.0 |= value;
    }
}
/// APC EQZ_AGC Control registers
///
/// General behavior control for EQZ_AGC parameter control.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_EQZ_AGC_CTRL(u32);
impl APC_EQZ_AGC_CTRL {
    /// Parameter value (controlled/computed value)
    pub fn eqz_agc_actval(&self) -> u32 {
        (self.0 & 0x3ff0000) >> 16
    }
    pub fn set_eqz_agc_actval(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0x3ff0000);
        self.0 &= !0x3ff0000;
        self.0 |= value;
    }
    /// Parameter control state in one-time mode
    ///
    /// 1: Finished
    pub fn eqz_agc_ctrl_done(&self) -> u32 {
        (self.0 & 0x4000000) >> 26
    }
    pub fn set_eqz_agc_ctrl_done(&mut self, value: u32) {
        let value = value << 26;
        assert!(value <= 0x4000000);
        self.0 &= !0x4000000;
        self.0 |= value;
    }
    /// Parameter control mode for EQZ_AGC parameter
    ///
    /// 0: Discrete 1: Continuous
    pub fn eqz_agc_ctrl_mode(&self) -> u32 {
        (self.0 & 0x400) >> 10
    }
    pub fn set_eqz_agc_ctrl_mode(&mut self, value: u32) {
        let value = value << 10;
        assert!(value <= 0x400);
        self.0 &= !0x400;
        self.0 |= value;
    }
    /// Alternative threshold for EQZ_AGC parameter (controller goal: err_cnt = 0.5*EQZ_AGC_THRES)
    pub fn eqz_agc_ctrl_thres(&self) -> u32 {
        (self.0 & 0x3f0) >> 4
    }
    pub fn set_eqz_agc_ctrl_thres(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x3f0);
        self.0 &= !0x3f0;
        self.0 |= value;
    }
    /// Enable use of alternative threshold for EQZ_AGC parameter
    ///
    /// 0: Use default threshold 1: Use alternative threshold
    pub fn eqz_agc_ctrl_thres_ena(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    pub fn set_eqz_agc_ctrl_thres_ena(&mut self, value: u32) {
        let value = value << 3;
        assert!(value <= 0x8);
        self.0 &= !0x8;
        self.0 |= value;
    }
    /// Operation mode
    ///
    /// 0: Off 1: One-time 2: Non-stop 3: Paused
    pub fn eqz_agc_op_mode(&self) -> u32 {
        self.0 & 0x3
    }
    pub fn set_eqz_agc_op_mode(&mut self, value: u32) {
        assert!(value <= 0x3);
        self.0 &= !0x3;
        self.0 |= value;
    }
    /// Select counter to be read
    ///
    /// 0: eqz_agc_value 1: Hit counter 2: Error counter
    pub fn eqz_agc_read_cnt_sel(&self) -> u32 {
        (self.0 & 0x3000) >> 12
    }
    pub fn set_eqz_agc_read_cnt_sel(&mut self, value: u32) {
        let value = value << 12;
        assert!(value <= 0x3000);
        self.0 &= !0x3000;
        self.0 |= value;
    }
    /// EQZ_AGC recovery behavior
    ///
    /// 0: No auto-recovery 1: Freeze EQZ_AGC on weak (eqz_gain > eqz_gain_freeze_thres) or missing input signal 2: Freeze EQZ_AGC on weak signal and restart on missing input signal 3: Freeze EQZ_AGC on missing input signal 4: Freeze EQZ_AGC on missing input signal and auto-restart after Restart-Delay-Timer has expired 5: Auto-restart EQZ_AGC on missing input signal 6-7: Reserved
    pub fn eqz_agc_recover_mode(&self) -> u32 {
        (self.0 & 0x38000000) >> 27
    }
    pub fn set_eqz_agc_recover_mode(&mut self, value: u32) {
        let value = value << 27;
        assert!(value <= 0x38000000);
        self.0 &= !0x38000000;
        self.0 |= value;
    }
    /// Start operation (parameter update). Should be cleared afterwards in One-time mode and stay set in Non-stop and Paused mode
    pub fn eqz_agc_start_ctrl(&self) -> u32 {
        (self.0 & 0x4) >> 2
    }
    pub fn set_eqz_agc_start_ctrl(&mut self, value: u32) {
        let value = value << 2;
        assert!(value <= 0x4);
        self.0 &= !0x4;
        self.0 |= value;
    }
    /// Synchronization mode
    ///
    /// 0: Independent 1: Attached to parctrl FSM 1 2: Attached to parctrl FSM 2 3: Attached to both parctrl FSMs
    pub fn eqz_agc_sync_mode(&self) -> u32 {
        (self.0 & 0xc000) >> 14
    }
    pub fn set_eqz_agc_sync_mode(&mut self, value: u32) {
        let value = value << 14;
        assert!(value <= 0xc000);
        self.0 &= !0xc000;
        self.0 |= value;
    }
}
/// APC EQZ_AGC Parameter control register
///
/// Configuration register for controlled EQZ_AGC parameter. Note, for parameters larger than 8 bits, ini/min/max values are shifted to the left. For parameters smaller than 8 bits only the lower bits of ini/min/max are used.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_EQZ_AGC_PAR_CFG(u32);
impl APC_EQZ_AGC_PAR_CFG {
    /// Parameter change mode
    ///
    /// 0: Automatic update 1: Preset (use EQZ_AGC_INI as fix value internal processing continues) 2: Freeze (internal processing stops parameter stays at current value) 3: No update (internal processing continues but parameter is not updated)
    pub fn eqz_agc_chg_mode(&self) -> u32 {
        (self.0 & 0x3000000) >> 24
    }
    pub fn set_eqz_agc_chg_mode(&mut self, value: u32) {
        let value = value << 24;
        assert!(value <= 0x3000000);
        self.0 &= !0x3000000;
        self.0 |= value;
    }
    /// Select parameter update direction
    ///
    /// 0: Normal 1: Inverted
    pub fn eqz_agc_dir_sel(&self) -> u32 {
        (self.0 & 0x80000000) >> 31
    }
    pub fn set_eqz_agc_dir_sel(&mut self, value: u32) {
        let value = value << 31;
        assert!(value <= 0x80000000);
        self.0 &= !0x80000000;
        self.0 |= value;
    }
    /// Parameter initial value
    pub fn eqz_agc_ini(&self) -> u32 {
        self.0 & 0xff
    }
    pub fn set_eqz_agc_ini(&mut self, value: u32) {
        assert!(value <= 0xff);
        self.0 &= !0xff;
        self.0 |= value;
    }
    /// Maximum value of paramter
    pub fn eqz_agc_max(&self) -> u32 {
        (self.0 & 0xff0000) >> 16
    }
    pub fn set_eqz_agc_max(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xff0000);
        self.0 &= !0xff0000;
        self.0 |= value;
    }
    /// Minimum value of paramter
    pub fn eqz_agc_min(&self) -> u32 {
        (self.0 & 0xff00) >> 8
    }
    pub fn set_eqz_agc_min(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0xff00);
        self.0 &= !0xff00;
        self.0 |= value;
    }
    /// Parameter range selection (only when CTRL_MODE = continuous). Value complies to number of left-shifts
    pub fn eqz_agc_range_sel(&self) -> u32 {
        (self.0 & 0x7c000000) >> 26
    }
    pub fn set_eqz_agc_range_sel(&mut self, value: u32) {
        let value = value << 26;
        assert!(value <= 0x7c000000);
        self.0 &= !0x7c000000;
        self.0 |= value;
    }
}
/// APC EQZ_AGC Timer config
///
/// Configuration registers for EQZ_AGC controller timing.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_EQZ_AGC_TIMER_CFG(u32);
impl APC_EQZ_AGC_TIMER_CFG {
    /// Operation time (in number of rx_clk cycles)
    pub fn eqz_agc_op_time(&self) -> u32 {
        self.0 & 0xffff
    }
    pub fn set_eqz_agc_op_time(&mut self, value: u32) {
        assert!(value <= 0xffff);
        self.0 &= !0xffff;
        self.0 |= value;
    }
    /// Pause time
    ///
    /// (in number of rx_clk cycles)
    pub fn eqz_agc_ps_time(&self) -> u32 {
        (self.0 & 0xffff0000) >> 16
    }
    pub fn set_eqz_agc_ps_time(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xffff0000);
        self.0 &= !0xffff0000;
        self.0 |= value;
    }
}
/// APC EQZ CTRL config
///
/// Configuration register for gain control logic
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_EQZ_COMMON_CFG(u32);
impl APC_EQZ_COMMON_CFG {
    /// Stop update of gain_adj
    pub fn eqz_gain_adj_halt(&self) -> u32 {
        (self.0 & 0x400) >> 10
    }
    pub fn set_eqz_gain_adj_halt(&mut self, value: u32) {
        let value = value << 10;
        assert!(value <= 0x400);
        self.0 &= !0x400;
        self.0 |= value;
    }
    /// Start (initiate) gain_adj update process (on rising edge of cfg bit)
    pub fn eqz_gain_adj_start_update(&self) -> u32 {
        (self.0 & 0x100) >> 8
    }
    pub fn set_eqz_gain_adj_start_update(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0x100);
        self.0 &= !0x100;
        self.0 |= value;
    }
    /// Restart gain/gain_adj calibration automatically on rising edge of signal_detect
    pub fn eqz_gain_auto_restart(&self) -> u32 {
        (self.0 & 0x4) >> 2
    }
    pub fn set_eqz_gain_auto_restart(&mut self, value: u32) {
        let value = value << 2;
        assert!(value <= 0x4);
        self.0 &= !0x4;
        self.0 |= value;
    }
    /// Gain calibration mode
    ///
    /// 0: Use successive approximation to find required gain 1: use max gain and reduce linearly to find required gain
    pub fn eqz_gain_cal_mode(&self) -> u32 {
        (self.0 & 0x200) >> 9
    }
    pub fn set_eqz_gain_cal_mode(&mut self, value: u32) {
        let value = value << 9;
        assert!(value <= 0x200);
        self.0 &= !0x200;
        self.0 |= value;
    }
    /// Parameter change mode
    ///
    /// 0: Automatic update 1: Preset (use PAR_INI as fix value internal processing continues) 2: Freeze (internal processing stops parameter stays at current value) 3: No update (internal processing continues but parameter is not updated)
    pub fn eqz_gain_chg_mode(&self) -> u32 {
        self.0 & 0x3
    }
    pub fn set_eqz_gain_chg_mode(&mut self, value: u32) {
        assert!(value <= 0x3);
        self.0 &= !0x3;
        self.0 |= value;
    }
    /// Gain freeze threshold, used in APC recovery mode for low input signals
    pub fn eqz_gain_freeze_thres(&self) -> u32 {
        (self.0 & 0x7fe000) >> 13
    }
    pub fn set_eqz_gain_freeze_thres(&mut self, value: u32) {
        let value = value << 13;
        assert!(value <= 0x7fe000);
        self.0 &= !0x7fe000;
        self.0 |= value;
    }
    /// Operation mode (only when EQZ_GAIN_STOP_CTRL = 1)
    ///
    /// 0: Idle 1: Calibrate and work 2: Work
    pub fn eqz_gain_op_mode(&self) -> u32 {
        (self.0 & 0x30) >> 4
    }
    pub fn set_eqz_gain_op_mode(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x30);
        self.0 &= !0x30;
        self.0 |= value;
    }
    /// Gain recovery behavior
    ///
    /// 0: No auto-recovery 1: Freeze gain on missing input signal and auto-restart after Restart-Delay-Timer has expired 2: Auto-restart Gain control on missing input signal 3: Reserved
    pub fn eqz_gain_recover_mode(&self) -> u32 {
        (self.0 & 0x1800) >> 11
    }
    pub fn set_eqz_gain_recover_mode(&mut self, value: u32) {
        let value = value << 11;
        assert!(value <= 0x1800);
        self.0 &= !0x1800;
        self.0 |= value;
    }
    /// (Re-)start (initiate) main gain/gain_adj calibration process (on rising edge of cfg bit)
    pub fn eqz_gain_start_ctrl(&self) -> u32 {
        (self.0 & 0x40) >> 6
    }
    pub fn set_eqz_gain_start_ctrl(&mut self, value: u32) {
        let value = value << 6;
        assert!(value <= 0x40);
        self.0 &= !0x40;
        self.0 |= value;
    }
    /// Start (initiate) gain update process (on rising edge of cfg bit)
    pub fn eqz_gain_start_update(&self) -> u32 {
        (self.0 & 0x80) >> 7
    }
    pub fn set_eqz_gain_start_update(&mut self, value: u32) {
        let value = value << 7;
        assert!(value <= 0x80);
        self.0 &= !0x80;
        self.0 |= value;
    }
    /// Stop main gain control machine immediately
    pub fn eqz_gain_stop_ctrl(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    pub fn set_eqz_gain_stop_ctrl(&mut self, value: u32) {
        let value = value << 3;
        assert!(value <= 0x8);
        self.0 &= !0x8;
        self.0 |= value;
    }
}
/// APC EQZ CTRL status register
///
/// Observation register for controlled settings
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_EQZ_CTRL_STATUS(u32);
impl APC_EQZ_CTRL_STATUS {
    /// Parameter value (controlled/computed gain value)
    pub fn eqz_gain_actval(&self) -> u32 {
        (self.0 & 0xffc0) >> 6
    }
    pub fn set_eqz_gain_actval(&mut self, value: u32) {
        let value = value << 6;
        assert!(value <= 0xffc0);
        self.0 &= !0xffc0;
        self.0 |= value;
    }
    /// Parameter value (controlled/computed gain adjustment value)
    pub fn eqz_gain_adj_actval(&self) -> u32 {
        (self.0 & 0x7f0000) >> 16
    }
    pub fn set_eqz_gain_adj_actval(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0x7f0000);
        self.0 &= !0x7f0000;
        self.0 |= value;
    }
    /// Status flag indicating main gain/gain_adj ramp-up process has finished
    pub fn eqz_gain_ctrl_done(&self) -> u32 {
        (self.0 & 0x800000) >> 23
    }
    pub fn set_eqz_gain_ctrl_done(&mut self, value: u32) {
        let value = value << 23;
        assert!(value <= 0x800000);
        self.0 &= !0x800000;
        self.0 |= value;
    }
    /// Parameter value (controlled/computed level for level-detect logic)
    pub fn ld_lev_actval(&self) -> u32 {
        self.0 & 0x3f
    }
    pub fn set_ld_lev_actval(&mut self, value: u32) {
        assert!(value <= 0x3f);
        self.0 &= !0x3f;
        self.0 |= value;
    }
}
/// APC EQZ_C Control registers
///
/// General behavior control for EQZ_C parameter control.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_EQZ_C_CTRL(u32);
impl APC_EQZ_C_CTRL {
    /// Parameter value (controlled/computed value)
    pub fn eqz_c_actval(&self) -> u32 {
        (self.0 & 0x3ff0000) >> 16
    }
    pub fn set_eqz_c_actval(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0x3ff0000);
        self.0 &= !0x3ff0000;
        self.0 |= value;
    }
    /// Parameter control state in one-time mode
    ///
    /// 1: Finished
    pub fn eqz_c_ctrl_done(&self) -> u32 {
        (self.0 & 0x4000000) >> 26
    }
    pub fn set_eqz_c_ctrl_done(&mut self, value: u32) {
        let value = value << 26;
        assert!(value <= 0x4000000);
        self.0 &= !0x4000000;
        self.0 |= value;
    }
    /// Parameter control mode for EQZ_C parameter
    ///
    /// 0: Discrete 1: Continuous
    pub fn eqz_c_ctrl_mode(&self) -> u32 {
        (self.0 & 0x400) >> 10
    }
    pub fn set_eqz_c_ctrl_mode(&mut self, value: u32) {
        let value = value << 10;
        assert!(value <= 0x400);
        self.0 &= !0x400;
        self.0 |= value;
    }
    /// Alternative threshold for EQZ_C parameter (controller goal: err_cnt = 0.5*EQZ_C_THRES)
    pub fn eqz_c_ctrl_thres(&self) -> u32 {
        (self.0 & 0x3f0) >> 4
    }
    pub fn set_eqz_c_ctrl_thres(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x3f0);
        self.0 &= !0x3f0;
        self.0 |= value;
    }
    /// Enable use of alternative threshold for EQZ_C parameter
    ///
    /// 0: Use default threshold 1: Use alternative threshold
    pub fn eqz_c_ctrl_thres_ena(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    pub fn set_eqz_c_ctrl_thres_ena(&mut self, value: u32) {
        let value = value << 3;
        assert!(value <= 0x8);
        self.0 &= !0x8;
        self.0 |= value;
    }
    /// Operation mode
    ///
    /// 0: Off 1: One-time 2: Non-stop 3: Paused
    pub fn eqz_c_op_mode(&self) -> u32 {
        self.0 & 0x3
    }
    pub fn set_eqz_c_op_mode(&mut self, value: u32) {
        assert!(value <= 0x3);
        self.0 &= !0x3;
        self.0 |= value;
    }
    /// Select counter to be read
    ///
    /// 0: eqz_c_value 1: Hit counter 2: Error counter
    pub fn eqz_c_read_cnt_sel(&self) -> u32 {
        (self.0 & 0x3000) >> 12
    }
    pub fn set_eqz_c_read_cnt_sel(&mut self, value: u32) {
        let value = value << 12;
        assert!(value <= 0x3000);
        self.0 &= !0x3000;
        self.0 |= value;
    }
    /// EQZ_C recovery behavior
    ///
    /// 0: No auto-recovery 1: Freeze EQZ_C on weak (eqz_gain > eqz_gain_freeze_thres) or missing input signal 2: Freeze EQZ_C on weak signal and restart on missing input signal 3: Freeze EQZ_C on missing input signal 4: Freeze EQZ_C on missing input signal and auto-restart after Restart-Delay-Timer has expired 5: Auto-restart EQZ_C on missing input signal 6-7: Reserved
    pub fn eqz_c_recover_mode(&self) -> u32 {
        (self.0 & 0x38000000) >> 27
    }
    pub fn set_eqz_c_recover_mode(&mut self, value: u32) {
        let value = value << 27;
        assert!(value <= 0x38000000);
        self.0 &= !0x38000000;
        self.0 |= value;
    }
    /// Start operation (parameter update). Should be cleared afterwards in One-time mode and stay set in Non-stop and Paused mode
    pub fn eqz_c_start_ctrl(&self) -> u32 {
        (self.0 & 0x4) >> 2
    }
    pub fn set_eqz_c_start_ctrl(&mut self, value: u32) {
        let value = value << 2;
        assert!(value <= 0x4);
        self.0 &= !0x4;
        self.0 |= value;
    }
    /// Synchronization mode
    ///
    /// 0: Independent 1: Attached to parctrl FSM 1 2: Attached to parctrl FSM 2 3: Attached to both parctrl FSMs
    pub fn eqz_c_sync_mode(&self) -> u32 {
        (self.0 & 0xc000) >> 14
    }
    pub fn set_eqz_c_sync_mode(&mut self, value: u32) {
        let value = value << 14;
        assert!(value <= 0xc000);
        self.0 &= !0xc000;
        self.0 |= value;
    }
}
/// APC EQZ_C Parameter control register
///
/// Configuration register for controlled EQZ_C parameter. Note, for parameters larger than 8 bits, ini/min/max values are shifted to the left. For parameters smaller than 8 bits only the lower bits of ini/min/max are used.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_EQZ_C_PAR_CFG(u32);
impl APC_EQZ_C_PAR_CFG {
    /// Parameter change mode
    ///
    /// 0: Automatic update 1: Preset (use EQZ_C_INI as fix value internal processing continues) 2: Freeze (internal processing stops parameter stays at current value) 3: No update (internal processing continues but parameter is not updated)
    pub fn eqz_c_chg_mode(&self) -> u32 {
        (self.0 & 0x3000000) >> 24
    }
    pub fn set_eqz_c_chg_mode(&mut self, value: u32) {
        let value = value << 24;
        assert!(value <= 0x3000000);
        self.0 &= !0x3000000;
        self.0 |= value;
    }
    /// Select parameter update direction
    ///
    /// 0: Normal 1: Inverted
    pub fn eqz_c_dir_sel(&self) -> u32 {
        (self.0 & 0x80000000) >> 31
    }
    pub fn set_eqz_c_dir_sel(&mut self, value: u32) {
        let value = value << 31;
        assert!(value <= 0x80000000);
        self.0 &= !0x80000000;
        self.0 |= value;
    }
    /// Parameter initial value
    pub fn eqz_c_ini(&self) -> u32 {
        self.0 & 0xff
    }
    pub fn set_eqz_c_ini(&mut self, value: u32) {
        assert!(value <= 0xff);
        self.0 &= !0xff;
        self.0 |= value;
    }
    /// Maximum value of paramter
    pub fn eqz_c_max(&self) -> u32 {
        (self.0 & 0xff0000) >> 16
    }
    pub fn set_eqz_c_max(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xff0000);
        self.0 &= !0xff0000;
        self.0 |= value;
    }
    /// Minimum value of paramter
    pub fn eqz_c_min(&self) -> u32 {
        (self.0 & 0xff00) >> 8
    }
    pub fn set_eqz_c_min(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0xff00);
        self.0 &= !0xff00;
        self.0 |= value;
    }
    /// Parameter range selection (only when CTRL_MODE = continuous). Value complies to number of left-shifts
    pub fn eqz_c_range_sel(&self) -> u32 {
        (self.0 & 0x7c000000) >> 26
    }
    pub fn set_eqz_c_range_sel(&mut self, value: u32) {
        let value = value << 26;
        assert!(value <= 0x7c000000);
        self.0 &= !0x7c000000;
        self.0 |= value;
    }
}
/// APC EQZ_C Timer config
///
/// Configuration registers for EQZ_C controller timing.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_EQZ_C_TIMER_CFG(u32);
impl APC_EQZ_C_TIMER_CFG {
    /// Operation time (in number of rx_clk cycles)
    pub fn eqz_c_op_time(&self) -> u32 {
        self.0 & 0xffff
    }
    pub fn set_eqz_c_op_time(&mut self, value: u32) {
        assert!(value <= 0xffff);
        self.0 &= !0xffff;
        self.0 |= value;
    }
    /// Pause time
    ///
    /// (in number of rx_clk cycles)
    pub fn eqz_c_ps_time(&self) -> u32 {
        (self.0 & 0xffff0000) >> 16
    }
    pub fn set_eqz_c_ps_time(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xffff0000);
        self.0 &= !0xffff0000;
        self.0 |= value;
    }
}
/// APC EQZ ADJ CTRL configuration register
///
/// Configuration register for gain_adj
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_EQZ_GAIN_ADJ_CTRL_CFG(u32);
impl APC_EQZ_GAIN_ADJ_CTRL_CFG {
    /// Gain_adj initial value (used if EQZ_GAIN_CHG_MODE = 1)
    pub fn eqz_gain_adj_ini(&self) -> u32 {
        self.0 & 0x7f
    }
    pub fn set_eqz_gain_adj_ini(&mut self, value: u32) {
        assert!(value <= 0x7f);
        self.0 &= !0x7f;
        self.0 |= value;
    }
    /// Maximum gain_adj in normal operation
    pub fn eqz_gain_adj_max(&self) -> u32 {
        (self.0 & 0x7f00000) >> 20
    }
    pub fn set_eqz_gain_adj_max(&mut self, value: u32) {
        let value = value << 20;
        assert!(value <= 0x7f00000);
        self.0 &= !0x7f00000;
        self.0 |= value;
    }
    /// Minimum gain_adj in normal operation
    pub fn eqz_gain_adj_min(&self) -> u32 {
        (self.0 & 0x1fc00) >> 10
    }
    pub fn set_eqz_gain_adj_min(&mut self, value: u32) {
        let value = value << 10;
        assert!(value <= 0x1fc00);
        self.0 &= !0x1fc00;
        self.0 |= value;
    }
}
/// APC EQZ CTRL configuration register
///
/// Configuration register for gain
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_EQZ_GAIN_CTRL_CFG(u32);
impl APC_EQZ_GAIN_CTRL_CFG {
    /// Gain initial value (used if EQZ_GAIN_CHG_MODE = 1)
    pub fn eqz_gain_ini(&self) -> u32 {
        self.0 & 0x3ff
    }
    pub fn set_eqz_gain_ini(&mut self, value: u32) {
        assert!(value <= 0x3ff);
        self.0 &= !0x3ff;
        self.0 |= value;
    }
    /// Maximum gain in normal operation (should be not greater then 895 (512+3*128-1)
    pub fn eqz_gain_max(&self) -> u32 {
        (self.0 & 0x3ff00000) >> 20
    }
    pub fn set_eqz_gain_max(&mut self, value: u32) {
        let value = value << 20;
        assert!(value <= 0x3ff00000);
        self.0 &= !0x3ff00000;
        self.0 |= value;
    }
    /// Minimum gain in normal operation
    pub fn eqz_gain_min(&self) -> u32 {
        (self.0 & 0xffc00) >> 10
    }
    pub fn set_eqz_gain_min(&mut self, value: u32) {
        let value = value << 10;
        assert!(value <= 0xffc00);
        self.0 &= !0xffc00;
        self.0 |= value;
    }
}
/// APC EQZ LD control
///
/// Configuration register for level-detect (LD) control, timing and behavior (timing: number of rx_clk cycles, used for LD toggling)
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_EQZ_LD_CTRL(u32);
impl APC_EQZ_LD_CTRL {
    /// Bypass LD catch circuitry (allows capturing pulses shorter then one rx_clk cycle)
    pub fn ld_catch_bypass(&self) -> u32 {
        (self.0 & 0x20000000) >> 29
    }
    pub fn set_ld_catch_bypass(&mut self, value: u32) {
        let value = value << 29;
        assert!(value <= 0x20000000);
        self.0 &= !0x20000000;
        self.0 |= value;
    }
    /// Start (initiate) a LD-EQ toggle check (for present LD-level)
    pub fn ld_eq_start_tog_chk(&self) -> u32 {
        (self.0 & 0x80) >> 7
    }
    pub fn set_ld_eq_start_tog_chk(&mut self, value: u32) {
        let value = value << 7;
        assert!(value <= 0x80);
        self.0 &= !0x80;
        self.0 |= value;
    }
    /// Captured toggling of LD-EQ
    pub fn ld_eq_toggle(&self) -> u32 {
        (self.0 & 0x80000000) >> 31
    }
    pub fn set_ld_eq_toggle(&mut self, value: u32) {
        let value = value << 31;
        assert!(value <= 0x80000000);
        self.0 &= !0x80000000;
        self.0 |= value;
    }
    /// Start (initiate) a LD-IB toggle check (for present LD-level)
    pub fn ld_ib_start_tog_chk(&self) -> u32 {
        (self.0 & 0x40) >> 6
    }
    pub fn set_ld_ib_start_tog_chk(&mut self, value: u32) {
        let value = value << 6;
        assert!(value <= 0x40);
        self.0 &= !0x40;
        self.0 |= value;
    }
    /// Captured toggling of LD-IB
    pub fn ld_ib_toggle(&self) -> u32 {
        (self.0 & 0x40000000) >> 30
    }
    pub fn set_ld_ib_toggle(&mut self, value: u32) {
        let value = value << 30;
        assert!(value <= 0x40000000);
        self.0 &= !0x40000000;
        self.0 |= value;
    }
    /// LD_lev initial value (used as preset value if EQZ_GAIN_CHG_MODE = 1)
    pub fn ld_lev_ini(&self) -> u32 {
        self.0 & 0x3f
    }
    pub fn set_ld_lev_ini(&mut self, value: u32) {
        assert!(value <= 0x3f);
        self.0 &= !0x3f;
        self.0 |= value;
    }
    /// Update internal LD_lev value with LD_LEV_INI
    pub fn ld_lev_update(&self) -> u32 {
        (self.0 & 0x100) >> 8
    }
    pub fn set_ld_lev_update(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0x100);
        self.0 &= !0x100;
        self.0 |= value;
    }
    /// Number of required toggles before toggling is considered valid
    pub fn ld_tog_threshold(&self) -> u32 {
        (self.0 & 0x3c00000) >> 22
    }
    pub fn set_ld_tog_threshold(&mut self, value: u32) {
        let value = value << 22;
        assert!(value <= 0x3c00000);
        self.0 &= !0x3c00000;
        self.0 |= value;
    }
    /// Sensitivity deadtime between two toggles (value is multiplied by 2)
    pub fn ld_t_toggle_deadtime(&self) -> u32 {
        (self.0 & 0x3fc000) >> 14
    }
    pub fn set_ld_t_toggle_deadtime(&mut self, value: u32) {
        let value = value << 14;
        assert!(value <= 0x3fc000);
        self.0 &= !0x3fc000;
        self.0 |= value;
    }
    /// Max value for LD updates in gain_adjust (watch-dog; prevent endless loop of LD adjustment; max is 2^value - 1)
    pub fn ld_wd_cnt_max(&self) -> u32 {
        (self.0 & 0x1c000000) >> 26
    }
    pub fn set_ld_wd_cnt_max(&mut self, value: u32) {
        let value = value << 26;
        assert!(value <= 0x1c000000);
        self.0 &= !0x1c000000;
        self.0 |= value;
    }
}
/// APC EQZ LD CTRL config0
///
/// Configuration register 0 for level-detect (LD) controller timing (number of rx_clk cycles, used for operation timing). Important note: For small ld_t_* values it might be necessary to change IB configuration bit-group IB_LDSD_DIVSEL to higher values!
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_EQZ_LD_CTRL_CFG0(u32);
impl APC_EQZ_LD_CTRL_CFG0 {
    /// Minimum activity for LD in work mode (value is multiplied by 8)
    pub fn ld_t_deadtime_wrk(&self) -> u32 {
        (self.0 & 0xffff0000) >> 16
    }
    pub fn set_ld_t_deadtime_wrk(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xffff0000);
        self.0 &= !0xffff0000;
        self.0 |= value;
    }
    /// Activity timeout threshold for LD in work mode (value is multiplied by 8)
    pub fn ld_t_timeout_wrk(&self) -> u32 {
        self.0 & 0xffff
    }
    pub fn set_ld_t_timeout_wrk(&mut self, value: u32) {
        assert!(value <= 0xffff);
        self.0 &= !0xffff;
        self.0 |= value;
    }
}
/// APC EQZ LD CTRL config1
///
/// Configuration register 1 for level-detect (LD) controller timing (number of rx_clk cycles, used for calibration timing). Important note: For small ld_t_* values it might be necessary to change IB configuration bit-group IB_LDSD_DIVSEL to higher values!
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_EQZ_LD_CTRL_CFG1(u32);
impl APC_EQZ_LD_CTRL_CFG1 {
    /// Minimum activity for LD in calibration mode (value is multiplied by 8)
    pub fn ld_t_deadtime_cal(&self) -> u32 {
        (self.0 & 0xffff0000) >> 16
    }
    pub fn set_ld_t_deadtime_cal(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xffff0000);
        self.0 &= !0xffff0000;
        self.0 |= value;
    }
    /// Activity timeout threshold for LD in calibration mode (value is multiplied by 8)
    pub fn ld_t_timeout_cal(&self) -> u32 {
        self.0 & 0xffff
    }
    pub fn set_ld_t_timeout_cal(&mut self, value: u32) {
        assert!(value <= 0xffff);
        self.0 &= !0xffff;
        self.0 |= value;
    }
}
/// APC EQZ_L Control registers
///
/// General behavior control for EQZ_L parameter control.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_EQZ_L_CTRL(u32);
impl APC_EQZ_L_CTRL {
    /// Parameter value (controlled/computed value)
    pub fn eqz_l_actval(&self) -> u32 {
        (self.0 & 0x3ff0000) >> 16
    }
    pub fn set_eqz_l_actval(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0x3ff0000);
        self.0 &= !0x3ff0000;
        self.0 |= value;
    }
    /// Parameter control state in one-time mode
    ///
    /// 1: Finished
    pub fn eqz_l_ctrl_done(&self) -> u32 {
        (self.0 & 0x4000000) >> 26
    }
    pub fn set_eqz_l_ctrl_done(&mut self, value: u32) {
        let value = value << 26;
        assert!(value <= 0x4000000);
        self.0 &= !0x4000000;
        self.0 |= value;
    }
    /// Parameter control mode for EQZ_L parameter
    ///
    /// 0: Discrete 1: Continuous
    pub fn eqz_l_ctrl_mode(&self) -> u32 {
        (self.0 & 0x400) >> 10
    }
    pub fn set_eqz_l_ctrl_mode(&mut self, value: u32) {
        let value = value << 10;
        assert!(value <= 0x400);
        self.0 &= !0x400;
        self.0 |= value;
    }
    /// Alternative threshold for EQZ_L parameter (controller goal: err_cnt = 0.5*EQZ_L_THRES)
    pub fn eqz_l_ctrl_thres(&self) -> u32 {
        (self.0 & 0x3f0) >> 4
    }
    pub fn set_eqz_l_ctrl_thres(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x3f0);
        self.0 &= !0x3f0;
        self.0 |= value;
    }
    /// Enable use of alternative threshold for EQZ_L parameter
    ///
    /// 0: Use default threshold 1: Use alternative threshold
    pub fn eqz_l_ctrl_thres_ena(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    pub fn set_eqz_l_ctrl_thres_ena(&mut self, value: u32) {
        let value = value << 3;
        assert!(value <= 0x8);
        self.0 &= !0x8;
        self.0 |= value;
    }
    /// Operation mode
    ///
    /// 0: Off 1: One-time 2: Non-stop 3: Paused
    pub fn eqz_l_op_mode(&self) -> u32 {
        self.0 & 0x3
    }
    pub fn set_eqz_l_op_mode(&mut self, value: u32) {
        assert!(value <= 0x3);
        self.0 &= !0x3;
        self.0 |= value;
    }
    /// Select counter to be read
    ///
    /// 0: eqz_l_value 1: Hit counter 2: Error counter
    pub fn eqz_l_read_cnt_sel(&self) -> u32 {
        (self.0 & 0x3000) >> 12
    }
    pub fn set_eqz_l_read_cnt_sel(&mut self, value: u32) {
        let value = value << 12;
        assert!(value <= 0x3000);
        self.0 &= !0x3000;
        self.0 |= value;
    }
    /// EQZ_L recovery behavior
    ///
    /// 0: No auto-recovery 1: Freeze EQZ_L on weak (eqz_gain > eqz_gain_freeze_thres) or missing input signal 2: Freeze EQZ_L on weak signal and restart on missing input signal 3: Freeze EQZ_L on missing input signal 4: Freeze EQZ_L on missing input signal and auto-restart after Restart-Delay-Timer has expired 5: Auto-restart EQZ_L on missing input signal 6-7: Reserved
    pub fn eqz_l_recover_mode(&self) -> u32 {
        (self.0 & 0x38000000) >> 27
    }
    pub fn set_eqz_l_recover_mode(&mut self, value: u32) {
        let value = value << 27;
        assert!(value <= 0x38000000);
        self.0 &= !0x38000000;
        self.0 |= value;
    }
    /// Start operation (parameter update). Should be cleared afterwards in One-time mode and stay set in Non-stop and Paused mode
    pub fn eqz_l_start_ctrl(&self) -> u32 {
        (self.0 & 0x4) >> 2
    }
    pub fn set_eqz_l_start_ctrl(&mut self, value: u32) {
        let value = value << 2;
        assert!(value <= 0x4);
        self.0 &= !0x4;
        self.0 |= value;
    }
    /// Synchronization mode
    ///
    /// 0: Independent 1: Attached to parctrl FSM 1 2: Attached to parctrl FSM 2 3: Attached to both parctrl FSMs
    pub fn eqz_l_sync_mode(&self) -> u32 {
        (self.0 & 0xc000) >> 14
    }
    pub fn set_eqz_l_sync_mode(&mut self, value: u32) {
        let value = value << 14;
        assert!(value <= 0xc000);
        self.0 &= !0xc000;
        self.0 |= value;
    }
}
/// APC EQZ_L Parameter control register
///
/// Configuration register for controlled EQZ_L parameter. Note, for parameters larger than 8 bits, ini/min/max values are shifted to the left. For parameters smaller than 8 bits only the lower bits of ini/min/max are used.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_EQZ_L_PAR_CFG(u32);
impl APC_EQZ_L_PAR_CFG {
    /// Parameter change mode
    ///
    /// 0: Automatic update 1: Preset (use EQZ_L_INI as fix value internal processing continues) 2: Freeze (internal processing stops parameter stays at current value) 3: No update (internal processing continues but parameter is not updated)
    pub fn eqz_l_chg_mode(&self) -> u32 {
        (self.0 & 0x3000000) >> 24
    }
    pub fn set_eqz_l_chg_mode(&mut self, value: u32) {
        let value = value << 24;
        assert!(value <= 0x3000000);
        self.0 &= !0x3000000;
        self.0 |= value;
    }
    /// Select parameter update direction
    ///
    /// 0: Normal 1: Inverted
    pub fn eqz_l_dir_sel(&self) -> u32 {
        (self.0 & 0x80000000) >> 31
    }
    pub fn set_eqz_l_dir_sel(&mut self, value: u32) {
        let value = value << 31;
        assert!(value <= 0x80000000);
        self.0 &= !0x80000000;
        self.0 |= value;
    }
    /// Parameter initial value
    pub fn eqz_l_ini(&self) -> u32 {
        self.0 & 0xff
    }
    pub fn set_eqz_l_ini(&mut self, value: u32) {
        assert!(value <= 0xff);
        self.0 &= !0xff;
        self.0 |= value;
    }
    /// Maximum value of paramter
    pub fn eqz_l_max(&self) -> u32 {
        (self.0 & 0xff0000) >> 16
    }
    pub fn set_eqz_l_max(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xff0000);
        self.0 &= !0xff0000;
        self.0 |= value;
    }
    /// Minimum value of paramter
    pub fn eqz_l_min(&self) -> u32 {
        (self.0 & 0xff00) >> 8
    }
    pub fn set_eqz_l_min(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0xff00);
        self.0 &= !0xff00;
        self.0 |= value;
    }
    /// Parameter range selection (only when CTRL_MODE = continuous). Value complies to number of left-shifts
    pub fn eqz_l_range_sel(&self) -> u32 {
        (self.0 & 0x7c000000) >> 26
    }
    pub fn set_eqz_l_range_sel(&mut self, value: u32) {
        let value = value << 26;
        assert!(value <= 0x7c000000);
        self.0 &= !0x7c000000;
        self.0 |= value;
    }
}
/// APC EQZ_L Timer config
///
/// Configuration registers for EQZ_L controller timing.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_EQZ_L_TIMER_CFG(u32);
impl APC_EQZ_L_TIMER_CFG {
    /// Operation time (in number of rx_clk cycles)
    pub fn eqz_l_op_time(&self) -> u32 {
        self.0 & 0xffff
    }
    pub fn set_eqz_l_op_time(&mut self, value: u32) {
        assert!(value <= 0xffff);
        self.0 &= !0xffff;
        self.0 |= value;
    }
    /// Pause time
    ///
    /// (in number of rx_clk cycles)
    pub fn eqz_l_ps_time(&self) -> u32 {
        (self.0 & 0xffff0000) >> 16
    }
    pub fn set_eqz_l_ps_time(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xffff0000);
        self.0 &= !0xffff0000;
        self.0 |= value;
    }
}
/// APC EQZ_OFFS Control registers
///
/// General behavior control for EQZ_OFFS parameter control.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_EQZ_OFFS_CTRL(u32);
impl APC_EQZ_OFFS_CTRL {
    /// Parameter value (controlled/computed value)
    pub fn eqz_offs_actval(&self) -> u32 {
        (self.0 & 0x3ff0000) >> 16
    }
    pub fn set_eqz_offs_actval(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0x3ff0000);
        self.0 &= !0x3ff0000;
        self.0 |= value;
    }
    /// Parameter control state in one-time mode
    ///
    /// 1: Finished
    pub fn eqz_offs_ctrl_done(&self) -> u32 {
        (self.0 & 0x4000000) >> 26
    }
    pub fn set_eqz_offs_ctrl_done(&mut self, value: u32) {
        let value = value << 26;
        assert!(value <= 0x4000000);
        self.0 &= !0x4000000;
        self.0 |= value;
    }
    /// Parameter control mode for EQZ_OFFS parameter
    ///
    /// 0: Discrete 1: Continuous
    pub fn eqz_offs_ctrl_mode(&self) -> u32 {
        (self.0 & 0x400) >> 10
    }
    pub fn set_eqz_offs_ctrl_mode(&mut self, value: u32) {
        let value = value << 10;
        assert!(value <= 0x400);
        self.0 &= !0x400;
        self.0 |= value;
    }
    /// Alternative threshold for EQZ_OFFS parameter (controller goal: err_cnt = 0.5*EQZ_OFFS_THRES)
    pub fn eqz_offs_ctrl_thres(&self) -> u32 {
        (self.0 & 0x3f0) >> 4
    }
    pub fn set_eqz_offs_ctrl_thres(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x3f0);
        self.0 &= !0x3f0;
        self.0 |= value;
    }
    /// Enable use of alternative threshold for EQZ_OFFS parameter
    ///
    /// 0: Use default threshold 1: Use alternative threshold
    pub fn eqz_offs_ctrl_thres_ena(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    pub fn set_eqz_offs_ctrl_thres_ena(&mut self, value: u32) {
        let value = value << 3;
        assert!(value <= 0x8);
        self.0 &= !0x8;
        self.0 |= value;
    }
    /// Operation mode
    ///
    /// 0: Off 1: One-time 2: Non-stop 3: Paused
    pub fn eqz_offs_op_mode(&self) -> u32 {
        self.0 & 0x3
    }
    pub fn set_eqz_offs_op_mode(&mut self, value: u32) {
        assert!(value <= 0x3);
        self.0 &= !0x3;
        self.0 |= value;
    }
    /// Select counter to be read
    ///
    /// 0: eqz_offs_value 1: Hit counter 2: Error counter
    pub fn eqz_offs_read_cnt_sel(&self) -> u32 {
        (self.0 & 0x3000) >> 12
    }
    pub fn set_eqz_offs_read_cnt_sel(&mut self, value: u32) {
        let value = value << 12;
        assert!(value <= 0x3000);
        self.0 &= !0x3000;
        self.0 |= value;
    }
    /// EQZ_OFFS recovery behavior
    ///
    /// 0: No auto-recovery 1: Freeze EQZ_OFFS on weak (eqz_gain > eqz_gain_freeze_thres) or missing input signal 2: Freeze EQZ_OFFS on weak signal and restart on missing input signal 3: Freeze EQZ_OFFS on missing input signal 4: Freeze EQZ_OFFS on missing input signal and auto-restart after Restart-Delay-Timer has expired 5: Auto-restart EQZ_OFFS on missing input signal 6-7: Reserved
    pub fn eqz_offs_recover_mode(&self) -> u32 {
        (self.0 & 0x38000000) >> 27
    }
    pub fn set_eqz_offs_recover_mode(&mut self, value: u32) {
        let value = value << 27;
        assert!(value <= 0x38000000);
        self.0 &= !0x38000000;
        self.0 |= value;
    }
    /// Start operation (parameter update). Should be cleared afterwards in One-time mode and stay set in Non-stop and Paused mode
    pub fn eqz_offs_start_ctrl(&self) -> u32 {
        (self.0 & 0x4) >> 2
    }
    pub fn set_eqz_offs_start_ctrl(&mut self, value: u32) {
        let value = value << 2;
        assert!(value <= 0x4);
        self.0 &= !0x4;
        self.0 |= value;
    }
    /// Synchronization mode
    ///
    /// 0: Independent 1: Attached to parctrl FSM 1 2: Attached to parctrl FSM 2 3: Attached to both parctrl FSMs
    pub fn eqz_offs_sync_mode(&self) -> u32 {
        (self.0 & 0xc000) >> 14
    }
    pub fn set_eqz_offs_sync_mode(&mut self, value: u32) {
        let value = value << 14;
        assert!(value <= 0xc000);
        self.0 &= !0xc000;
        self.0 |= value;
    }
}
/// APC EQZ_OFFS Parameter control register
///
/// Configuration register for controlled EQZ_OFFS parameter. Note, for parameters larger than 8 bits, ini/min/max values are shifted to the left. For parameters smaller than 8 bits only the lower bits of ini/min/max are used.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_EQZ_OFFS_PAR_CFG(u32);
impl APC_EQZ_OFFS_PAR_CFG {
    /// Parameter change mode
    ///
    /// 0: Automatic update 1: Preset (use EQZ_OFFS_INI as fix value internal processing continues) 2: Freeze (internal processing stops parameter stays at current value) 3: No update (internal processing continues but parameter is not updated)
    pub fn eqz_offs_chg_mode(&self) -> u32 {
        (self.0 & 0x3000000) >> 24
    }
    pub fn set_eqz_offs_chg_mode(&mut self, value: u32) {
        let value = value << 24;
        assert!(value <= 0x3000000);
        self.0 &= !0x3000000;
        self.0 |= value;
    }
    /// Select parameter update direction
    ///
    /// 0: Normal 1: Inverted
    pub fn eqz_offs_dir_sel(&self) -> u32 {
        (self.0 & 0x80000000) >> 31
    }
    pub fn set_eqz_offs_dir_sel(&mut self, value: u32) {
        let value = value << 31;
        assert!(value <= 0x80000000);
        self.0 &= !0x80000000;
        self.0 |= value;
    }
    /// Parameter initial value
    pub fn eqz_offs_ini(&self) -> u32 {
        self.0 & 0xff
    }
    pub fn set_eqz_offs_ini(&mut self, value: u32) {
        assert!(value <= 0xff);
        self.0 &= !0xff;
        self.0 |= value;
    }
    /// Maximum value of paramter
    pub fn eqz_offs_max(&self) -> u32 {
        (self.0 & 0xff0000) >> 16
    }
    pub fn set_eqz_offs_max(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xff0000);
        self.0 &= !0xff0000;
        self.0 |= value;
    }
    /// Minimum value of paramter
    pub fn eqz_offs_min(&self) -> u32 {
        (self.0 & 0xff00) >> 8
    }
    pub fn set_eqz_offs_min(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0xff00);
        self.0 &= !0xff00;
        self.0 |= value;
    }
    /// Parameter range selection (only when CTRL_MODE = continuous). Value complies to number of left-shifts
    pub fn eqz_offs_range_sel(&self) -> u32 {
        (self.0 & 0x7c000000) >> 26
    }
    pub fn set_eqz_offs_range_sel(&mut self, value: u32) {
        let value = value << 26;
        assert!(value <= 0x7c000000);
        self.0 &= !0x7c000000;
        self.0 |= value;
    }
}
/// APC EQZ_OFFS Timer config
///
/// Configuration registers for EQZ_OFFS controller timing.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_EQZ_OFFS_TIMER_CFG(u32);
impl APC_EQZ_OFFS_TIMER_CFG {
    /// Operation time (in number of rx_clk cycles)
    pub fn eqz_offs_op_time(&self) -> u32 {
        self.0 & 0xffff
    }
    pub fn set_eqz_offs_op_time(&mut self, value: u32) {
        assert!(value <= 0xffff);
        self.0 &= !0xffff;
        self.0 |= value;
    }
    /// Pause time
    ///
    /// (in number of rx_clk cycles)
    pub fn eqz_offs_ps_time(&self) -> u32 {
        (self.0 & 0xffff0000) >> 16
    }
    pub fn set_eqz_offs_ps_time(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xffff0000);
        self.0 &= !0xffff0000;
        self.0 |= value;
    }
}
/// APC EQZ Pattern matching cfg register0
///
/// Pattern matching configuration register for eqz_c and eqz_l control
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_EQZ_PAT_MATCH_CFG0(u32);
impl APC_EQZ_PAT_MATCH_CFG0 {
    /// EQZ-C-control pattern mask (only those bits are used for pattern matching whose mask bit is set)
    pub fn eqz_c_pat_mask(&self) -> u32 {
        (self.0 & 0xff000000) >> 24
    }
    pub fn set_eqz_c_pat_mask(&mut self, value: u32) {
        let value = value << 24;
        assert!(value <= 0xff000000);
        self.0 &= !0xff000000;
        self.0 |= value;
    }
    /// EQZ-C-control pattern used for pattern matching (corresponding mask bits must be set)
    pub fn eqz_c_pat_match(&self) -> u32 {
        (self.0 & 0xff0000) >> 16
    }
    pub fn set_eqz_c_pat_match(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xff0000);
        self.0 &= !0xff0000;
        self.0 |= value;
    }
    /// EQZ-L-control pattern mask (only those bits are used for pattern matching whose mask bit is set)
    pub fn eqz_l_pat_mask(&self) -> u32 {
        (self.0 & 0xff00) >> 8
    }
    pub fn set_eqz_l_pat_mask(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0xff00);
        self.0 &= !0xff00;
        self.0 |= value;
    }
    /// EQZ-L-control pattern used for pattern matching (corresponding mask bits must be set)
    pub fn eqz_l_pat_match(&self) -> u32 {
        self.0 & 0xff
    }
    pub fn set_eqz_l_pat_match(&mut self, value: u32) {
        assert!(value <= 0xff);
        self.0 &= !0xff;
        self.0 |= value;
    }
}
/// APC EQZ Pattern matching cfg register1
///
/// Pattern matching configuration register for eqz_offs and eqz_agc control Note, if mask is set to 0, all bits are "matching" and taken into account for parameter contol.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_EQZ_PAT_MATCH_CFG1(u32);
impl APC_EQZ_PAT_MATCH_CFG1 {
    /// EQZ-AGC-control pattern mask (only those bits are used for pattern matching whose mask bit is set)
    pub fn eqz_agc_pat_mask(&self) -> u32 {
        (self.0 & 0xff00) >> 8
    }
    pub fn set_eqz_agc_pat_mask(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0xff00);
        self.0 &= !0xff00;
        self.0 |= value;
    }
    /// EQZ-AGC-control pattern used for pattern matching (corresponding mask bits must be set)
    pub fn eqz_agc_pat_match(&self) -> u32 {
        self.0 & 0xff
    }
    pub fn set_eqz_agc_pat_match(&mut self, value: u32) {
        assert!(value <= 0xff);
        self.0 &= !0xff;
        self.0 |= value;
    }
    /// EQZ-Offset-control pattern mask (only those bits are used for pattern matching whose mask bit is set)
    pub fn eqz_offs_pat_mask(&self) -> u32 {
        (self.0 & 0xff000000) >> 24
    }
    pub fn set_eqz_offs_pat_mask(&mut self, value: u32) {
        let value = value << 24;
        assert!(value <= 0xff000000);
        self.0 &= !0xff000000;
        self.0 |= value;
    }
    /// EQZ-Offset-control pattern used for pattern matching (corresponding mask bits must be set)
    pub fn eqz_offs_pat_match(&self) -> u32 {
        (self.0 & 0xff0000) >> 16
    }
    pub fn set_eqz_offs_pat_match(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xff0000);
        self.0 &= !0xff0000;
        self.0 |= value;
    }
}
/// APC FLEXCTRL read counter register
///
/// Observation register for multiple counters. The selection is done via APC_COMMON_CFG0.BLOCK_READ_SEL (select flexctrl block to be read) and APC_XXX_CTRL.XXX_READ_CNT_SEL (counter within flexctrl block XXX) or APC_COMMON_CFG0.OFFSCAL_READ_CNT_SEL. Notice that for EQZ and DFE counters hit_cnt and err_cnt make only sense in DISCRETE control mode.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_FLEXCTRL_CNT_STATUS(u32);
impl APC_FLEXCTRL_CNT_STATUS {
    /// Current counter value
    pub fn apc_ctrl_cntval(&self) -> u32 {
        self.0
    }
    pub fn set_apc_ctrl_cntval(&mut self, value: u32) {
        self.0 = value;
    }
}
/// APC sampling stage calibration configuration register 0
///
/// Configuration register 0 for APC sampling stage calibrations logic
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_IS_CAL_CFG0(u32);
impl APC_IS_CAL_CFG0 {
    /// Initial value for CP/MD FF threshold calibration.
    pub fn cpmd_thres_init(&self) -> u32 {
        (self.0 & 0xfc000) >> 14
    }
    pub fn set_cpmd_thres_init(&mut self, value: u32) {
        let value = value << 14;
        assert!(value <= 0xfc000);
        self.0 &= !0xfc000;
        self.0 |= value;
    }
    /// Gain adjustent for DFE amplifier
    pub fn ib_dfe_gain_adj(&self) -> u32 {
        (self.0 & 0x3f00000) >> 20
    }
    pub fn set_ib_dfe_gain_adj(&mut self, value: u32) {
        let value = value << 20;
        assert!(value <= 0x3f00000);
        self.0 &= !0x3f00000;
        self.0 |= value;
    }
    /// Skip DFE buffer 0db calibration
    pub fn skip_dfe_buffer_cal(&self) -> u32 {
        self.0 & 0x1
    }
    pub fn set_skip_dfe_buffer_cal(&mut self, value: u32) {
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
    /// Skip DFE buffer 0db initialization
    pub fn skip_dfe_buffer_init(&self) -> u32 {
        (self.0 & 0x10) >> 4
    }
    pub fn set_skip_dfe_buffer_init(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x10);
        self.0 &= !0x10;
        self.0 |= value;
    }
    /// Skip observe block calibration
    pub fn skip_observe_cal(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    pub fn set_skip_observe_cal(&mut self, value: u32) {
        let value = value << 3;
        assert!(value <= 0x8);
        self.0 &= !0x8;
        self.0 |= value;
    }
    /// Skip observe block initialization
    pub fn skip_observe_init(&self) -> u32 {
        (self.0 & 0x80) >> 7
    }
    pub fn set_skip_observe_init(&mut self, value: u32) {
        let value = value << 7;
        assert!(value <= 0x80);
        self.0 &= !0x80;
        self.0 |= value;
    }
    /// Skip sample FF offset calibration
    pub fn skip_offset_cal(&self) -> u32 {
        (self.0 & 0x4) >> 2
    }
    pub fn set_skip_offset_cal(&mut self, value: u32) {
        let value = value << 2;
        assert!(value <= 0x4);
        self.0 &= !0x4;
        self.0 |= value;
    }
    /// Skip sample FF offset initialization
    pub fn skip_offset_init(&self) -> u32 {
        (self.0 & 0x40) >> 6
    }
    pub fn set_skip_offset_init(&mut self, value: u32) {
        let value = value << 6;
        assert!(value <= 0x40);
        self.0 &= !0x40;
        self.0 |= value;
    }
    /// Skip sample FF threshold calibration
    pub fn skip_threshold_cal(&self) -> u32 {
        (self.0 & 0x2) >> 1
    }
    pub fn set_skip_threshold_cal(&mut self, value: u32) {
        let value = value << 1;
        assert!(value <= 0x2);
        self.0 &= !0x2;
        self.0 |= value;
    }
    /// Skip sample FF threshold initialization
    pub fn skip_threshold_init(&self) -> u32 {
        (self.0 & 0x20) >> 5
    }
    pub fn set_skip_threshold_init(&mut self, value: u32) {
        let value = value << 5;
        assert!(value <= 0x20);
        self.0 &= !0x20;
        self.0 |= value;
    }
    /// Initial value for VScope FF threshold calibration.
    pub fn vsc_thres_init(&self) -> u32 {
        (self.0 & 0x3f00) >> 8
    }
    pub fn set_vsc_thres_init(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0x3f00);
        self.0 &= !0x3f00;
        self.0 |= value;
    }
}
/// APC sampling stage calibration configuration register 1
///
/// Configuration register 1 for APC sampling stage calibrations logic
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_IS_CAL_CFG1(u32);
impl APC_IS_CAL_CFG1 {
    /// Controls number of calibrations iterations to settle values that depend on each other (offset vs threshold). Coding number of iterations = cal_num_iterations + 1.
    pub fn cal_num_iterations(&self) -> u32 {
        (self.0 & 0xf0000) >> 16
    }
    pub fn set_cal_num_iterations(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xf0000);
        self.0 &= !0xf0000;
        self.0 |= value;
    }
    /// Selects ramp used to calculate calibration value. Coding: 0: both, 1: rising, 2: falling, 3: reserved.
    pub fn cal_ramp_sel(&self) -> u32 {
        (self.0 & 0x300000) >> 20
    }
    pub fn set_cal_ramp_sel(&mut self, value: u32) {
        let value = value << 20;
        assert!(value <= 0x300000);
        self.0 &= !0x300000;
        self.0 |= value;
    }
    /// Controls the offset calibration target of the VScope FFs. Coding: 0: calibration target is zero, 1: calibration target is the programmed VScope threshold.
    pub fn cal_vsc_offset_tgt(&self) -> u32 {
        (self.0 & 0x8000) >> 15
    }
    pub fn set_cal_vsc_offset_tgt(&mut self, value: u32) {
        let value = value << 15;
        assert!(value <= 0x8000);
        self.0 &= !0x8000;
        self.0 |= value;
    }
    /// AGC-DAC value used for DFE 0dB calibration during IB-calibration process
    pub fn eqz_agc_dac_val(&self) -> u32 {
        (self.0 & 0xff000000) >> 24
    }
    pub fn set_eqz_agc_dac_val(&mut self, value: u32) {
        let value = value << 24;
        assert!(value <= 0xff000000);
        self.0 &= !0xff000000;
        self.0 |= value;
    }
    /// Swaps disp with disn used during calibration
    pub fn offscal_dis_swap(&self) -> u32 {
        (self.0 & 0x4) >> 2
    }
    pub fn set_offscal_dis_swap(&mut self, value: u32) {
        let value = value << 2;
        assert!(value <= 0x4);
        self.0 &= !0x4;
        self.0 |= value;
    }
    /// Offset calibration state
    ///
    /// 1: finished
    pub fn offscal_done(&self) -> u32 {
        (self.0 & 0x2) >> 1
    }
    pub fn set_offscal_done(&mut self, value: u32) {
        let value = value << 1;
        assert!(value <= 0x2);
        self.0 &= !0x2;
        self.0 |= value;
    }
    /// Select offset calibration result to be read (BLOCK_READ_SEL = 8 required)
    pub fn offscal_read_cnt_sel(&self) -> u32 {
        (self.0 & 0xf8) >> 3
    }
    pub fn set_offscal_read_cnt_sel(&mut self, value: u32) {
        let value = value << 3;
        assert!(value <= 0xf8);
        self.0 &= !0xf8;
        self.0 |= value;
    }
    /// Selects the number of ones threshold when using parallel data. Value for rising ramp from zero to one. The value for the falling ramp (one -> zero) is half the interface width minus par_data_num_ones_thres.
    pub fn par_data_num_ones_thres(&self) -> u32 {
        (self.0 & 0x3e00) >> 9
    }
    pub fn set_par_data_num_ones_thres(&mut self, value: u32) {
        let value = value << 9;
        assert!(value <= 0x3e00);
        self.0 &= !0x3e00;
        self.0 |= value;
    }
    /// Controls whether the parallel data from the deserializer or the signal from the observe multiplexer in the sample stage is used. Coding: 0: observe multiplexer, 1: parallel data.
    pub fn par_data_sel(&self) -> u32 {
        (self.0 & 0x100) >> 8
    }
    pub fn set_par_data_sel(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0x100);
        self.0 &= !0x100;
        self.0 |= value;
    }
    /// Swaps the mapping of even resp. odd bits of parallel data to the every two sample FFs of the DDR sampling stage.
    pub fn par_data_swap_even_odd(&self) -> u32 {
        (self.0 & 0x4000) >> 14
    }
    pub fn set_par_data_swap_even_odd(&mut self, value: u32) {
        let value = value << 14;
        assert!(value <= 0x4000);
        self.0 &= !0x4000;
        self.0 |= value;
    }
    /// Start offset calibration process (sampling stage; only in manual mode, see apc_mode)
    pub fn start_offscal(&self) -> u32 {
        self.0 & 0x1
    }
    pub fn set_start_offscal(&mut self, value: u32) {
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
    /// Enable use of EQZ_AGC_DAC_VAL instead of EQZ_AGC_INI during DFE 0dB IB calibration
    pub fn use_agc_dac_val(&self) -> u32 {
        (self.0 & 0x800000) >> 23
    }
    pub fn set_use_agc_dac_val(&mut self, value: u32) {
        let value = value << 23;
        assert!(value <= 0x800000);
        self.0 &= !0x800000;
        self.0 |= value;
    }
}
/// APC LC softcontrol configuration register
///
/// Configuration register 0 for the LC-Softcontrol logic block. The L and C paramters can be controlled depending on DFE1 and DFE2 and EQZ_AGC parameters instead of pattern matching.
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_LC_SOFTCTRL_CFG(u32);
impl APC_LC_SOFTCTRL_CFG {
    /// EQZ_AGC threshold for mandatory increase of L and C. If EQZ_AGC > (128+LC_SC_AGC_THRESHOLD) then L and C control values are increased.
    ///
    /// 0: 128 1: 129 ... 127: 255
    pub fn lc_sc_agc_threshold(&self) -> u32 {
        (self.0 & 0xfe00) >> 9
    }
    pub fn set_lc_sc_agc_threshold(&mut self, value: u32) {
        let value = value << 9;
        assert!(value <= 0xfe00);
        self.0 &= !0xfe00;
        self.0 |= value;
    }
    /// DFE1/2 and EQZ_AGC averaging behavior. DFE/AGC parameters are averaged over 2^(8+LC_SC_AVGSHFT) input values.
    ///
    /// 0: Average over 256 values 1: Average over 512 values ...
    pub fn lc_sc_avgshft(&self) -> u32 {
        (self.0 & 0xf000000) >> 24
    }
    pub fn set_lc_sc_avgshft(&mut self, value: u32) {
        let value = value << 24;
        assert!(value <= 0xf000000);
        self.0 &= !0xf000000;
        self.0 |= value;
    }
    /// DFE1 comparison threshold for L-control used in mode 2. EQZ_L is increased/decreased if DFE1 differs from neutral value by more than LC_SC_DFE1_THRESHOLD.
    pub fn lc_sc_dfe1_threshold(&self) -> u32 {
        (self.0 & 0xf00000) >> 20
    }
    pub fn set_lc_sc_dfe1_threshold(&mut self, value: u32) {
        let value = value << 20;
        assert!(value <= 0xf00000);
        self.0 &= !0xf00000;
        self.0 |= value;
    }
    /// DFE2 comparison threshold for C-control used in mode 2. EQZ_C is increased/decreased if DFE1 differs from neutral value by more than LC_SC_DFE2_THRESHOLD.
    pub fn lc_sc_dfe2_threshold(&self) -> u32 {
        (self.0 & 0xf0000) >> 16
    }
    pub fn set_lc_sc_dfe2_threshold(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xf0000);
        self.0 &= !0xf0000;
        self.0 |= value;
    }
    /// Select divider for C-control used in mode 1 (Divider = 4+LC_SC_DIV_C)
    ///
    /// 0: Divide by 4 1: Devide by 5 ... 7: Devide by 11
    pub fn lc_sc_div_c(&self) -> u32 {
        (self.0 & 0x1c) >> 2
    }
    pub fn set_lc_sc_div_c(&mut self, value: u32) {
        let value = value << 2;
        assert!(value <= 0x1c);
        self.0 &= !0x1c;
        self.0 |= value;
    }
    /// Define DFE2 comparison parameter for EQZ_C control in mode 1
    ///
    /// 0: EQZ_L 1: EQZ_C
    pub fn lc_sc_div_c_sel(&self) -> u32 {
        (self.0 & 0x100) >> 8
    }
    pub fn set_lc_sc_div_c_sel(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0x100);
        self.0 &= !0x100;
        self.0 |= value;
    }
    /// Select divider for L-control used in mode 1 (Divider = 4+LC_SC_DIV_L)
    ///
    /// 0: Divide by 4 1: Devide by 5 ... 7: Devide by 11
    pub fn lc_sc_div_l(&self) -> u32 {
        (self.0 & 0xe0) >> 5
    }
    pub fn set_lc_sc_div_l(&mut self, value: u32) {
        let value = value << 5;
        assert!(value <= 0xe0);
        self.0 &= !0xe0;
        self.0 |= value;
    }
    /// Select LC soft-control mode. LC soft-control modes must be enabled first after INI/MIN/MAX values of all parameters have been programmed.
    ///
    /// 0: Disabled 1: Mode 1 2: Mode 2 3: Reserved
    pub fn lc_sc_mode(&self) -> u32 {
        self.0 & 0x3
    }
    pub fn set_lc_sc_mode(&mut self, value: u32) {
        assert!(value <= 0x3);
        self.0 &= !0x3;
        self.0 |= value;
    }
    /// Operation timer configuration: L/C-control operates in every 2^(2*LC_SC_TIMER)-th clock cycle.
    ///
    /// 0: Operate every clock cycle 1: Operate every 4th clock cycle 2: Operate every 16th clock cycle ...
    pub fn lc_sc_timer(&self) -> u32 {
        (self.0 & 0xf0000000) >> 28
    }
    pub fn set_lc_sc_timer(&mut self, value: u32) {
        let value = value << 28;
        assert!(value <= 0xf0000000);
        self.0 &= !0xf0000000;
        self.0 |= value;
    }
}
/// APC level detect calibration configuration register
///
/// Configuration register for APC level detect calibrations logic
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_LD_CAL_CFG(u32);
impl APC_LD_CAL_CFG {
    /// Calibration clock divider. Clock used in calibration blocks is divided by 2^(2*CAL_CLK_DIV)
    ///
    /// 0: No clock division 1: Clock is divided by 4 2: Clock is divided by 16 ... 7: Clock is divided by 16384
    pub fn cal_clk_div(&self) -> u32 {
        (self.0 & 0x70000000) >> 28
    }
    pub fn set_cal_clk_div(&mut self, value: u32) {
        let value = value << 28;
        assert!(value <= 0x70000000);
        self.0 &= !0x70000000;
        self.0 |= value;
    }
    /// Detect level calibration state
    ///
    /// 1: finished
    pub fn detlev_cal_done(&self) -> u32 {
        (self.0 & 0x80000) >> 19
    }
    pub fn set_detlev_cal_done(&mut self, value: u32) {
        let value = value << 19;
        assert!(value <= 0x80000);
        self.0 &= !0x80000;
        self.0 |= value;
    }
    /// Timer for calibration process
    ///
    /// 14: Use for 400MHz rx_clk
    pub fn detlvl_timer(&self) -> u32 {
        (self.0 & 0x1e) >> 1
    }
    pub fn set_detlvl_timer(&mut self, value: u32) {
        let value = value << 1;
        assert!(value <= 0x1e);
        self.0 &= !0x1e;
        self.0 |= value;
    }
    /// Level for IE signal detect (when controlled by APC)
    ///
    /// 0: 20mV
    pub fn ie_sdet_level(&self) -> u32 {
        (self.0 & 0x7e0) >> 5
    }
    pub fn set_ie_sdet_level(&mut self, value: u32) {
        let value = value << 5;
        assert!(value <= 0x7e0);
        self.0 &= !0x7e0;
        self.0 |= value;
    }
    /// Skip level detect calibration
    pub fn skip_ld_cal(&self) -> u32 {
        (self.0 & 0x800) >> 11
    }
    pub fn set_skip_ld_cal(&mut self, value: u32) {
        let value = value << 11;
        assert!(value <= 0x800);
        self.0 &= !0x800;
        self.0 |= value;
    }
    /// Skip signal detect calibration
    pub fn skip_sdet_cal(&self) -> u32 {
        (self.0 & 0x1000) >> 12
    }
    pub fn set_skip_sdet_cal(&mut self, value: u32) {
        let value = value << 12;
        assert!(value <= 0x1000);
        self.0 &= !0x1000;
        self.0 |= value;
    }
    /// Start signal and level detect calibration process (sampling stage; only in manual mode, see apc_mode)
    pub fn start_detlvl_cal(&self) -> u32 {
        self.0 & 0x1
    }
    pub fn set_start_detlvl_cal(&mut self, value: u32) {
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }
}
/// APC parctrl FSM1 Timer config
///
/// Timing configuration register for common flexible parameter control FSM1
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_PARCTRL_FSM1_TIMER_CFG(u32);
impl APC_PARCTRL_FSM1_TIMER_CFG {
    /// FSM1 Operation time (in number of rx_clk cycles)
    pub fn fsm1_op_time(&self) -> u32 {
        self.0 & 0xffff
    }
    pub fn set_fsm1_op_time(&mut self, value: u32) {
        assert!(value <= 0xffff);
        self.0 &= !0xffff;
        self.0 |= value;
    }
    /// FSM1 Pause time
    ///
    /// (in number of rx_clk cycles)
    pub fn fsm1_ps_time(&self) -> u32 {
        (self.0 & 0xffff0000) >> 16
    }
    pub fn set_fsm1_ps_time(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xffff0000);
        self.0 &= !0xffff0000;
        self.0 |= value;
    }
}
/// APC parctrl FSM2 Timer config
///
/// Timing configuration register for common flexible parameter control FSM2
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_PARCTRL_FSM2_TIMER_CFG(u32);
impl APC_PARCTRL_FSM2_TIMER_CFG {
    /// FSM2 Operation time (in number of rx_clk cycles)
    pub fn fsm2_op_time(&self) -> u32 {
        self.0 & 0xffff
    }
    pub fn set_fsm2_op_time(&mut self, value: u32) {
        assert!(value <= 0xffff);
        self.0 &= !0xffff;
        self.0 |= value;
    }
    /// FSM2 Pause time
    ///
    /// (in number of rx_clk cycles)
    pub fn fsm2_ps_time(&self) -> u32 {
        (self.0 & 0xffff0000) >> 16
    }
    pub fn set_fsm2_ps_time(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xffff0000);
        self.0 &= !0xffff0000;
        self.0 |= value;
    }
}
/// APC parameter control synchronization register
///
/// Configuration register for common flexible parameter control FSMs
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_PARCTRL_SYNC_CFG(u32);
impl APC_PARCTRL_SYNC_CFG {
    /// APC spare register pool
    pub fn apc_spare_pool(&self) -> u32 {
        (self.0 & 0xf0000000) >> 28
    }
    pub fn set_apc_spare_pool(&mut self, value: u32) {
        let value = value << 28;
        assert!(value <= 0xf0000000);
        self.0 &= !0xf0000000;
        self.0 |= value;
    }
    /// Parameter control state of FSM1 in one-time mode
    ///
    /// 1: finished
    pub fn fsm1_ctrl_done(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    pub fn set_fsm1_ctrl_done(&mut self, value: u32) {
        let value = value << 3;
        assert!(value <= 0x8);
        self.0 &= !0x8;
        self.0 |= value;
    }
    /// Parameter control mode for FSM1
    ///
    /// 0: Discrete 1: Continuous
    pub fn fsm1_ctrl_mode(&self) -> u32 {
        (self.0 & 0x4000) >> 14
    }
    pub fn set_fsm1_ctrl_mode(&mut self, value: u32) {
        let value = value << 14;
        assert!(value <= 0x4000);
        self.0 &= !0x4000;
        self.0 |= value;
    }
    /// Operation mode of FSM1
    ///
    /// 0: Off 1: One-time 2: Non-stop 3: Paused
    pub fn fsm1_op_mode(&self) -> u32 {
        self.0 & 0x3
    }
    pub fn set_fsm1_op_mode(&mut self, value: u32) {
        assert!(value <= 0x3);
        self.0 &= !0x3;
        self.0 |= value;
    }
    /// FSM1 recovery behavior
    ///
    /// 0: No auto-recovery 1: Freeze FSM1 on weak (eqz_gain > eqz_gain_freeze_thres) or missing input signal 2: Freeze FSM1 on weak signal and restart on missing input signal 3: Freeze FSM1 on missing input signal 4: Freeze FSM1 on missing input signal and auto-restart after Restart-Delay-Timer has expired 5: Auto-restart FSM1 on missing input signal 6-7: Reserved
    pub fn fsm1_recover_mode(&self) -> u32 {
        (self.0 & 0x700) >> 8
    }
    pub fn set_fsm1_recover_mode(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0x700);
        self.0 &= !0x700;
        self.0 |= value;
    }
    /// Start operation of FSM1 (parameter update). Should be cleared afterwards in One-time mode and stay set in Non-stop and Paused mode
    pub fn fsm1_start_ctrl(&self) -> u32 {
        (self.0 & 0x4) >> 2
    }
    pub fn set_fsm1_start_ctrl(&mut self, value: u32) {
        let value = value << 2;
        assert!(value <= 0x4);
        self.0 &= !0x4;
        self.0 |= value;
    }
    /// Parameter control state of FSM2 in one-time mode
    ///
    /// 1: finished
    pub fn fsm2_ctrl_done(&self) -> u32 {
        (self.0 & 0x80) >> 7
    }
    pub fn set_fsm2_ctrl_done(&mut self, value: u32) {
        let value = value << 7;
        assert!(value <= 0x80);
        self.0 &= !0x80;
        self.0 |= value;
    }
    /// Parameter control mode for FSM2
    ///
    /// 0: Discrete 1: Continuous
    pub fn fsm2_ctrl_mode(&self) -> u32 {
        (self.0 & 0x8000) >> 15
    }
    pub fn set_fsm2_ctrl_mode(&mut self, value: u32) {
        let value = value << 15;
        assert!(value <= 0x8000);
        self.0 &= !0x8000;
        self.0 |= value;
    }
    /// Operation mode of FSM2
    ///
    /// 0: Off 1: One-time 2: Non-stop 3: Paused
    pub fn fsm2_op_mode(&self) -> u32 {
        (self.0 & 0x30) >> 4
    }
    pub fn set_fsm2_op_mode(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x30);
        self.0 &= !0x30;
        self.0 |= value;
    }
    /// FSM2 recovery behavior
    ///
    /// 0: No auto-recovery 1: Freeze FSM2 on weak (eqz_gain > eqz_gain_freeze_thres) or missing input signal 2: Freeze FSM2 on weak signal and restart on missing input signal 3: Freeze FSM2 on missing input signal 4: Freeze FSM2 on missing input signal and auto-restart after Restart-Delay-Timer has expired 5: Auto-restart FSM2 on missing input signal 6-7: Reserved
    pub fn fsm2_recover_mode(&self) -> u32 {
        (self.0 & 0x3800) >> 11
    }
    pub fn set_fsm2_recover_mode(&mut self, value: u32) {
        let value = value << 11;
        assert!(value <= 0x3800);
        self.0 &= !0x3800;
        self.0 |= value;
    }
    /// Start operation of FSM2 (parameter update). Should be cleared afterwards in One-time mode and stay set in Non-stop and Paused mode
    pub fn fsm2_start_ctrl(&self) -> u32 {
        (self.0 & 0x40) >> 6
    }
    pub fn set_fsm2_start_ctrl(&mut self, value: u32) {
        let value = value << 6;
        assert!(value <= 0x40);
        self.0 &= !0x40;
        self.0 |= value;
    }
}
/// APC top control configuration register
///
/// Configuration register for top control logic
#[derive(Copy, Clone, Eq, PartialEq, From, Into)]
pub struct APC_TOP_CTRL_CFG(u32);
impl APC_TOP_CTRL_CFG {
    /// Delay time required to power down auxilliary channels
    pub fn pwr_dn_time(&self) -> u32 {
        (self.0 & 0xff0000) >> 16
    }
    pub fn set_pwr_dn_time(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0xff0000);
        self.0 &= !0xff0000;
        self.0 |= value;
    }
    /// Delay time required to power up auxilliary channels
    pub fn pwr_up_time(&self) -> u32 {
        (self.0 & 0xff000000) >> 24
    }
    pub fn set_pwr_up_time(&mut self, value: u32) {
        let value = value << 24;
        assert!(value <= 0xff000000);
        self.0 &= !0xff000000;
        self.0 |= value;
    }
    /// APC top-control sleep-time (power-down). Given in number of clock cycles (typically 2.5 ... 5 ns)
    pub fn sleep_time(&self) -> u32 {
        self.0 & 0xffff
    }
    pub fn set_sleep_time(&mut self, value: u32) {
        assert!(value <= 0xffff);
        self.0 &= !0xffff;
        self.0 |= value;
    }
}
