// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Based on mesa-v2021.09 (https://github.com/microchip-ung/mesa/) which has
// the following copyright and license:
//
// Copyright (c) 2004-2021 Microchip Technology Inc. and its subsidiaries.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

// This is an autogenerated file; do not edit by hand!
use derive_more::{From, Into};

/// Register `STAT_GLOBAL_EVENT_MASK`
///
/// Event mask for counters.
#[derive(From, Into)]
pub struct STAT_GLOBAL_EVENT_MASK(u32);
impl STAT_GLOBAL_EVENT_MASK {    ///
    /// This value stores the event mask which indicates the counter of all flows to count certain events. If set to '1' the respective event is not filtered and can trigger the counter. If set to '0' the respective event is filtered and the counter will treat the frame as if no event has occurred. Which type of frame is counted is defined in: STAT_CFG, CFG_CNT_FRM_TYPE. The following events apply to port stat: bit0: Count events allowed by *_sticky_mask:0 bit1: Count events allowed by *_sticky_mask:1 ... bit3: Count events allowed by *_sticky_mask:n where n is number of counter event masks bit4: Count port policer:0 drop events bit4+1: Count port policer:1 drop events ... bit4+m: Count port policer:0 pass/active events bit4+m+1: Count port policer:1 pass/active events ... where m is number of per port policers bit4+2*m: Count storm policer drop events bit4+2*m+1: Count policer drop events bit4+2*m+3: Count lbk frame.
    ///
    /// 0: This event will not trigger counting. 1: Enable counting for frames with this event.
    pub fn global_event_mask(&self) -> u32 {
        (self.0 & 0xffff) >> 0
    }
    pub fn set_global_event_mask(&mut self, value: u32) {
        let value = value << 0;
        assert!(value <= 0xffff);
        self.0 &= !0xffff;
        self.0 |= value;
    }
}

/// Register `STICKY_MASK`
///
/// Sticky diagnostic counter masks
#[derive(From, Into)]
pub struct STICKY_MASK(u32);
impl STICKY_MASK {    ///
    /// Mask to enable counting of sticky event.
    pub fn frame_fwd_sticky_mask(&self) -> u32 {
        (self.0 & 0x10000) >> 16
    }
    pub fn set_frame_fwd_sticky_mask(&mut self, value: u32) {
        let value = value << 16;
        assert!(value <= 0x10000);
        self.0 &= !0x10000;
        self.0 |= value;
    }    ///
    /// Mask to enable counting of sticky event.
    pub fn glag_contrib_sticky_mask(&self) -> u32 {
        (self.0 & 0x200) >> 9
    }
    pub fn set_glag_contrib_sticky_mask(&mut self, value: u32) {
        let value = value << 9;
        assert!(value <= 0x200);
        self.0 &= !0x200;
        self.0 |= value;
    }    ///
    /// Mask to enable counting of sticky event.
    pub fn ip4_mc_ctrl_flood_sticky_mask(&self) -> u32 {
        (self.0 & 0x8) >> 3
    }
    pub fn set_ip4_mc_ctrl_flood_sticky_mask(&mut self, value: u32) {
        let value = value << 3;
        assert!(value <= 0x8);
        self.0 &= !0x8;
        self.0 |= value;
    }    ///
    /// Mask to enable counting of sticky event.
    ///
    /// Mask to enable counting of sticky event.
    pub fn ip4_mc_data_flood_sticky_mask(&self) -> u32 {
        (self.0 & 0x4) >> 2
    }
    pub fn set_ip4_mc_data_flood_sticky_mask(&mut self, value: u32) {
        let value = value << 2;
        assert!(value <= 0x4);
        self.0 &= !0x4;
        self.0 |= value;
    }    ///
    /// Mask to enable counting of sticky event.
    pub fn ip6_mc_ctrl_flood_sticky_mask(&self) -> u32 {
        (self.0 & 0x20) >> 5
    }
    pub fn set_ip6_mc_ctrl_flood_sticky_mask(&mut self, value: u32) {
        let value = value << 5;
        assert!(value <= 0x20);
        self.0 &= !0x20;
        self.0 |= value;
    }    ///
    /// Mask to enable counting of sticky event.
    pub fn ip6_mc_data_flood_sticky_mask(&self) -> u32 {
        (self.0 & 0x10) >> 4
    }
    pub fn set_ip6_mc_data_flood_sticky_mask(&mut self, value: u32) {
        let value = value << 4;
        assert!(value <= 0x10);
        self.0 &= !0x10;
        self.0 |= value;
    }    ///
    /// Mask to enable counting of sticky event.
    pub fn l2_mc_flood_sticky_mask(&self) -> u32 {
        (self.0 & 0x2) >> 1
    }
    pub fn set_l2_mc_flood_sticky_mask(&mut self, value: u32) {
        let value = value << 1;
        assert!(value <= 0x2);
        self.0 &= !0x2;
        self.0 |= value;
    }    ///
    /// Mask to enable counting of sticky event.
    pub fn no_l2_l3_fwd_sticky_mask(&self) -> u32 {
        (self.0 & 0x40) >> 6
    }
    pub fn set_no_l2_l3_fwd_sticky_mask(&mut self, value: u32) {
        let value = value << 6;
        assert!(value <= 0x40);
        self.0 &= !0x40;
        self.0 |= value;
    }    ///
    /// Mask to enable counting of sticky event.
    pub fn pgid_cpu_mask_sticky_mask(&self) -> u32 {
        (self.0 & 0x80) >> 7
    }
    pub fn set_pgid_cpu_mask_sticky_mask(&mut self, value: u32) {
        let value = value << 7;
        assert!(value <= 0x80);
        self.0 &= !0x80;
        self.0 |= value;
    }    ///
    /// Mask to enable counting of sticky event.
    pub fn probe_sticky_mask(&self) -> u32 {
        (self.0 & 0x700000) >> 20
    }
    pub fn set_probe_sticky_mask(&mut self, value: u32) {
        let value = value << 20;
        assert!(value <= 0x700000);
        self.0 &= !0x700000;
        self.0 |= value;
    }    ///
    /// Mask to enable counting of sticky event.
    pub fn sflow_cand_sticky_mask(&self) -> u32 {
        (self.0 & 0x8000) >> 15
    }
    pub fn set_sflow_cand_sticky_mask(&mut self, value: u32) {
        let value = value << 15;
        assert!(value <= 0x8000);
        self.0 &= !0x8000;
        self.0 |= value;
    }    ///
    /// Mask to enable counting of sticky event.
    pub fn sflow_dst_sample_sticky_mask(&self) -> u32 {
        (self.0 & 0x4000) >> 14
    }
    pub fn set_sflow_dst_sample_sticky_mask(&mut self, value: u32) {
        let value = value << 14;
        assert!(value <= 0x4000);
        self.0 &= !0x4000;
        self.0 |= value;
    }    ///
    /// Mask to enable counting of sticky event.
    pub fn sflow_sample_sticky_mask(&self) -> u32 {
        (self.0 & 0x1000) >> 12
    }
    pub fn set_sflow_sample_sticky_mask(&mut self, value: u32) {
        let value = value << 12;
        assert!(value <= 0x1000);
        self.0 &= !0x1000;
        self.0 |= value;
    }    ///
    /// Mask to enable counting of sticky event.
    pub fn sflow_src_sample_sticky_mask(&self) -> u32 {
        (self.0 & 0x2000) >> 13
    }
    pub fn set_sflow_src_sample_sticky_mask(&mut self, value: u32) {
        let value = value << 13;
        assert!(value <= 0x2000);
        self.0 &= !0x2000;
        self.0 |= value;
    }    ///
    /// Mask to enable counting of sticky event.
    pub fn src_contrib_sticky_mask(&self) -> u32 {
        (self.0 & 0x100) >> 8
    }
    pub fn set_src_contrib_sticky_mask(&mut self, value: u32) {
        let value = value << 8;
        assert!(value <= 0x100);
        self.0 &= !0x100;
        self.0 |= value;
    }    ///
    /// Mask to enable counting of sticky event.
    pub fn uc_flood_sticky_mask(&self) -> u32 {
        (self.0 & 0x1) >> 0
    }
    pub fn set_uc_flood_sticky_mask(&mut self, value: u32) {
        let value = value << 0;
        assert!(value <= 0x1);
        self.0 &= !0x1;
        self.0 |= value;
    }    ///
    /// Mask to enable counting of sticky event.
    pub fn vlan_contrib_sticky_mask(&self) -> u32 {
        (self.0 & 0x800) >> 11
    }
    pub fn set_vlan_contrib_sticky_mask(&mut self, value: u32) {
        let value = value << 11;
        assert!(value <= 0x800);
        self.0 &= !0x800;
        self.0 |= value;
    }    ///
    /// Mask to enable counting of sticky event.
    pub fn zero_dst_sticky_mask(&self) -> u32 {
        (self.0 & 0x20000) >> 17
    }
    pub fn set_zero_dst_sticky_mask(&mut self, value: u32) {
        let value = value << 17;
        assert!(value <= 0x20000);
        self.0 &= !0x20000;
        self.0 |= value;
    }
}
