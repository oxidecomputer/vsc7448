//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.
//

// This is an autogenerated file; do not edit by hand!
use std::collections::HashMap;

use lazy_static::lazy_static;
use vsc7448_types::{Address, Field, Page, Register, RegisterGroup, Target};

pub mod parse;

lazy_static! {
    /// Maps from user-facing target name to a tuple of
    /// - Name in `TARGETS` map (which may be different!)
    /// - List of instances, as tuples of `(instance id, address)`.  If there is
    ///   only one instance of this target, then this is vec![(None, ADDRESS)].
    pub static ref MEMORY_MAP: HashMap<&'static str, (&'static str, Vec<(Option<u32>, u32)>)> = {
        let mut out = HashMap::new();
        out.insert("AFI", ("AFI", vec![(None,0x71a80000),]));
        out.insert("ANA_AC", ("ANA_AC", vec![(None,0x71f00000),]));
        out.insert("ANA_ACL", ("ANA_ACL", vec![(None,0x71430000),]));
        out.insert("ANA_AC_OAM_MOD", ("ANA_AC_OAM_MOD", vec![(None,0x71b80000),]));
        out.insert("ANA_AC_POL", ("ANA_AC_POL", vec![(None,0x71980000),]));
        out.insert("ANA_CL", ("ANA_CL", vec![(None,0x71d00000),]));
        out.insert("ANA_L2", ("ANA_L2", vec![(None,0x71e00000),]));
        out.insert("ANA_L3", ("ANA_L3", vec![(None,0x71800000),]));
        out.insert("ASM", ("ASM", vec![(None,0x71410000),]));
        out.insert("DEV10G", ("DEV10G", vec![(Some(0),0x71390000),(Some(1),0x713a0000),(Some(2),0x713b0000),(Some(3),0x713c0000),]));
        out.insert("DEV1G", ("DEV1G", vec![(Some(0),0x71040000),(Some(1),0x71050000),(Some(2),0x71060000),(Some(3),0x71070000),(Some(4),0x71080000),(Some(5),0x71090000),(Some(6),0x710a0000),(Some(7),0x710b0000),(Some(8),0x710c0000),(Some(9),0x710d0000),(Some(10),0x710e0000),(Some(11),0x710f0000),(Some(12),0x71100000),(Some(13),0x71110000),(Some(14),0x71120000),(Some(15),0x71130000),(Some(16),0x71140000),(Some(17),0x71150000),(Some(18),0x71160000),(Some(19),0x71170000),(Some(20),0x71180000),(Some(21),0x71190000),(Some(22),0x711a0000),(Some(23),0x711b0000),]));
        out.insert("DEV2G5", ("DEV1G", vec![(Some(0),0x711c0000),(Some(1),0x711d0000),(Some(2),0x711e0000),(Some(3),0x711f0000),(Some(4),0x71200000),(Some(5),0x71210000),(Some(6),0x71220000),(Some(7),0x71230000),(Some(8),0x71240000),(Some(9),0x71250000),(Some(10),0x71260000),(Some(11),0x71270000),(Some(12),0x71280000),(Some(13),0x71290000),(Some(14),0x712a0000),(Some(15),0x712b0000),(Some(16),0x712c0000),(Some(17),0x712d0000),(Some(18),0x712e0000),(Some(19),0x712f0000),(Some(20),0x71300000),(Some(21),0x71310000),(Some(22),0x71320000),(Some(23),0x71330000),(Some(25),0x71350000),(Some(26),0x71360000),(Some(27),0x71370000),(Some(28),0x71380000),(Some(24),0x71340000),]));
        out.insert("DEVCPU_GCB", ("DEVCPU_GCB", vec![(None,0x71010000),]));
        out.insert("DEVCPU_ORG", ("DEVCPU_ORG", vec![(None,0x71000000),]));
        out.insert("DEVCPU_PTP", ("DEVCPU_PTP", vec![(None,0x717f0000),]));
        out.insert("DEVCPU_QS", ("DEVCPU_QS", vec![(None,0x71020000),]));
        out.insert("DSM", ("DSM", vec![(None,0x71450000),]));
        out.insert("HSCH", ("HSCH", vec![(None,0x71880000),]));
        out.insert("HSIO", ("HSIO", vec![(None,0x71460000),]));
        out.insert("ICPU_CFG", ("ICPU_CFG", vec![(None,0x70000000),]));
        out.insert("LRN", ("LRN", vec![(None,0x71420000),]));
        out.insert("PCIE", ("PCIE", vec![(None,0x70111000),]));
        out.insert("PCS10G_BR", ("PCS_10GBASE_R", vec![(Some(0),0x713d0000),(Some(1),0x713e0000),(Some(2),0x713f0000),(Some(3),0x71400000),]));
        out.insert("QFWD", ("QFWD", vec![(None,0x717d0000),]));
        out.insert("QRES", ("QRES", vec![(None,0x71900000),]));
        out.insert("QSYS", ("QSYS", vec![(None,0x717e0000),]));
        out.insert("REW", ("REW", vec![(None,0x71b00000),]));
        out.insert("SBA", ("SBA", vec![(None,0x70110000),]));
        out.insert("SIMC", ("SIMC", vec![(None,0x70101000),]));
        out.insert("TWI", ("TWI", vec![(None,0x70100400),]));
        out.insert("TWI2", ("TWI", vec![(None,0x70100c00),]));
        out.insert("UART", ("UART", vec![(None,0x70100000),]));
        out.insert("UART2", ("UART", vec![(None,0x70100800),]));
        out.insert("VAUI0", ("VAUI_CHANNEL", vec![(None,0x717b0000),]));
        out.insert("VAUI1", ("VAUI_CHANNEL", vec![(None,0x717c0000),]));
        out.insert("VCAP_ES0", ("VCAP_CORE", vec![(None,0x71470000),]));
        out.insert("VCAP_SUPER", ("VCAP_CORE", vec![(None,0x71440000),]));
        out.insert("VOP", ("VOP", vec![(None,0x71c00000),]));
        out.insert("VOP_MPLS", ("VOP_MPLS", vec![(None,0x71a00000),]));
        out.insert("XGANA", ("SD10G65", vec![(Some(0),0x71480000),(Some(1),0x71490000),(Some(2),0x714a0000),(Some(3),0x714b0000),]));
        out.insert("XGDIG", ("SD10G65_DIG", vec![(Some(0),0x714c0000),(Some(1),0x714d0000),(Some(2),0x714e0000),(Some(3),0x714f0000),]));
        out.insert("XGKR0", ("KR_DEV1", vec![(Some(0),0x71540000),(Some(1),0x71550000),(Some(2),0x71560000),(Some(3),0x71570000),]));
        out.insert("XGKR1", ("KR_DEV7", vec![(Some(0),0x71580000),(Some(1),0x71590000),(Some(2),0x715a0000),(Some(3),0x715b0000),]));
        out.insert("XGXFI", ("XFI_SHELL", vec![(Some(0),0x71500000),(Some(1),0x71510000),(Some(2),0x71520000),(Some(3),0x71530000),]));
        out.insert("XQS", ("XQS", vec![(None,0x717a0000),]));
        return out;
    };

    /// Maps from target name to `Target`, which contains a hierarchy
    /// of register groups, registers, and fields.
    pub static ref TARGETS: HashMap<&'static str, Target> = {
        let mut out = HashMap::new();

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CNT_DOWN", Field { brief: Some("Remaining number of clock cycles before next injection. May become negative while waiting for table/injection access. Two's complement encoded. Should be set to 0 when (re)starting DTI (unless an initial delay is desirable)."), details: None, lo: 0, hi: 31 });
        regs.insert("DTI_CNT_DOWN", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("DTI count down counters"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DURATION", Field { brief: Some("Duration of last DTI run in DTI Duration Ticks. Before starting a DTI, DURATION must be set to 0. When AFI:DTI_MISC:DTI_CTRL.ENA becomes 0, DURATION is updated with the duration of the DTI run. While a DTI is running DURATION holds an internal time stamp of when the DTI was started. This value is not intended for SW usage. Related parameters: AFI:MISC:DTI_DURATION_TICK_LEN.DTI_DURATION_TICK_LEN"), details: None, lo: 0, hi: 31 });
        regs.insert("DTI_DURATION", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Duration of last DTI run"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FC_CNT_DOWN", Field { brief: Some("Remaining number of clock cycles before DTI is allowed to attempt injection again after experiencing FC from FRD. This field is set to FC_POSTPONE_LEN when FC from FRD is experienced. Note: Unlike CNT_DOWN, FC_CNT_DOWN is always >=0 (so no two's complement encoding)."), details: None, lo: 0, hi: 8 });
        regs.insert("DTI_FC_CNT_DOWN", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("DTI flow control count down counters"), details: Some("When FC is experienced between AFI and FRD, then DTI an injecting DTI must \"backoff\" for FC_POSTPONE_LEN clock cycles. This is handled by this counter."), fields });
        groups.insert("DTI_MISC", RegisterGroup { addr: Address { base: 41338, count: 32, width: 3 }, desc: "Miscellaneous DTI configration and status information", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CNT", Field { brief: Some("DTI_MODE.MODE=0, 2: Number of remaining frame sequences to inject. Configured by SW, decremented by AFI. DTI_MODE.MODE=1: Number of frames injected."), details: None, lo: 0, hi: 31 });
        regs.insert("DTI_CNT", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("DTI counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FIRST_FRM_PTR", Field { brief: Some("Pointer to first frame in frame sequence."), details: None, lo: 0, hi: 12 });
        fields.insert("NEXT_FRM_PTR", Field { brief: Some("Pointer to next frame in frame sequence. Must be set to same value as FIRST_FRM_PTR when (re)starting DTI."), details: None, lo: 16, hi: 28 });
        regs.insert("DTI_FRM", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("DTI Frame Table pointers"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DTI_NEXT", Field { brief: Some("See AFI:DTI_TBL:DTI_MODE.MODE, encoding 2."), details: None, lo: 24, hi: 29 });
        fields.insert("FC_POSTPONE_LEN", Field { brief: Some("Number of clock cycles the DTI shall be postponed after experiencing flow control from FRD. Such DTIs may have to be postponed to avoid blocking frame table access for TTIs. Value should be big enough to cover situation where all active DTIs are flow controlled. The configured value is counted down in DTI_FC_CNT_DOWN and when zero is reached, another injection attempt is made. In the meantime DTI_CNT_DOWN goes negative, such that the additional delay is subtracted from the next delay in the DTI sequence."), details: None, lo: 16, hi: 24 });
        fields.insert("FC_POSTPONE_MODE", Field { brief: Some("Controls whether FC_POSTPONE_LEN is added to DTI_FC_CNT_DOWN or DTI_CNT_DOWN when flow control from FRD is encountered."), details: Some("0: Add FC_POSTPONE_LEN to DTI_FC_CNT_DOWN when FC is encountered. 1: Add FC_POSTPONE_LEN to DTI_CNT_DOWN when FC is encountered."), lo: 31, hi: 32 });
        fields.insert("FRM_INJ_CNT", Field { brief: Some("Number of remaining injections of current frame in frame sequence (NEXT_FRM_PTR). Must be set to 0 when (re)starting DTI."), details: None, lo: 8, hi: 16 });
        fields.insert("MODE", Field { brief: Some("Configuration of DTI mode."), details: Some("0: Frame sequence shall be injected DTI_CNT.CNT times. 1: Frame sequence shall be injected until stopped (DTI_CTRL.ENA=0). Number of frames injected is counted in DTI_CNT.CNT. 2: Frame sequence shall be injected DTI_CNT.CNT times. Once this is done, the DTI pointed to by AFI:DTI_TBL:DTI_MODE.DTI_NEXT will be enabled. This can be used to concatenate DTIs. 3: Reserved."), lo: 0, hi: 2 });
        fields.insert("TRAILING_DELAY_SEQ_CNT", Field { brief: Some("If the last frame table entry of a DTI sequence is a delay, then this is termed a \"trailing delay\". By setting TRAILING_DELAY_SEQ_CNT=N a trailing delay is only applied for every Nth sequence injection. This can be used to \"fine tune\" the bandwidth of a DTI sequence. TRAILING_DELAY_SEQ_CNT=0 disables this feature. If a DTI sequence (in the frame table) has no trailing delay, then TRAILING_DELAY_SEQ_CNT has no effect."), details: Some("0: Disable feature. 1: Apply trailing delay for every sequence injected. 2: Apply trailing delay for every 2nd sequence injected. 3: Apply trailing delay for every 3rd sequence injected. ..."), lo: 2, hi: 8 });
        regs.insert("DTI_MODE", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Configuration of DTI Mode."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_NUM", Field { brief: Some("Port number which injection queue transmits on. Injection queue is selected by QU_NUM."), details: None, lo: 0, hi: 6 });
        fields.insert("QU_NUM", Field { brief: Some("QU_NUM selects the queue, which the frame is injected into. For details, refer to the functional description of the queue system in the datasheet."), details: None, lo: 8, hi: 24 });
        regs.insert("DTI_PORT_QU", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Port and queue for injected frames."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PART0", Field { brief: Some("Configuration of frame or delay entry in Frame Table. Delay entries are only used for DTI. Delay entry fields: DELAY: Delay between injection of start of frames. Unit: One system clock cycle. Frame entry fields: INJ_CNT: Injection count. Number times to inject frame. Frame is ignored if INJ_CNT=0 or FRM_RM=1. Only applicable for DTI. FRM_RM: When set, next frame injection causes frame to be removed from buffer memory. This injection will not be transmitted on the destination port. Once removed, HW sets FRM_GONE=1. FRM_GONE: Set by AFI when frame has been removed from buffer memory. FRM_INFO: Frame information, ref. AFI:MISC:NEW_FRM_INFO.FRM_INFO."), details: Some("Delay entry type: Bit 0-29: DELAY Frame entry type: Bit 0-7: INJ_CNT Bit 8-10: Reserved, must be set to 0 Bit 11: FRM_RM Bit 12: FRM_GONE Bit 13-29: FRM_INFO"), lo: 0, hi: 30 });
        regs.insert("FRM_ENTRY_PART0", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Frame Table entry configuration"), details: Some("Note: Write operations to entries in the frame table, which are in the process of being removed (FRM_RM=1, see FRM_ENTRY_PART0) are not allowed."), fields });
        groups.insert("DTI_TBL", RegisterGroup { addr: Address { base: 40960, count: 32, width: 8 }, desc: "Delay Triggered Injection Table", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("DTI_DURATION_TICK_LEN", Field { brief: Some("Lenght of DTI Duration Tick in clock cycles. Default value corresponds to 0.1ms."), details: None, lo: 0, hi: 18 });
        regs.insert("DTI_DURATION_TICK_LEN", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Lenght of DTI Duration Tick"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ENTRY_TYPE", Field { brief: Some("Entry Type. Delay entries are only applicable to DTI. The Entry Type controls the use of FRM_ENTRY_PART0.PART0."), details: Some("0: Frame 1: Delay"), lo: 16, hi: 17 });
        fields.insert("NEXT_PTR", Field { brief: Some("Pointer to next Frame Table entry. Only applicable for frames used for DTI."), details: None, lo: 0, hi: 12 });
        regs.insert("FRM_NEXT_AND_TYPE", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Entry type and pointer to next Frame Table entry."), details: Some("Note: Write operations to entries in the frame table, which are in the process of being removed (FRM_RM=1, see FRM_ENTRY_PART0) are not allowed."), fields });
        groups.insert("FRM_TBL", RegisterGroup { addr: Address { base: 32768, count: 4096, width: 2 }, desc: "Frame Table", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ERR_FRM_OUT_NEG_STICKY", Field { brief: Some("FRM_OUT_CNT for a port was zero while an ack from FRD was received. If enabled in STICKY_INFO_ENA.FRM_OUT_NEG_INFO_ENA, the corresponding port number is stored in STICKY_INFO.PORT_NUM."), details: None, lo: 0, hi: 1 });
        regs.insert("ERR", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Errors from AFI block"), details: Some("These bits shall never get set."), fields });
        let mut fields = HashMap::new();
        fields.insert("AFI_ENA", Field { brief: Some("Enable AFI. Must be set to 1 before any use of AFI."), details: None, lo: 0, hi: 1 });
        regs.insert("MISC_CTRL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Miscellanous AFI control parameters"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("VLD", Field { brief: Some("Valid bit for NEW_FRM_INFO.FRM_INFO."), details: None, lo: 0, hi: 1 });
        regs.insert("NEW_FRM_CTRL", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Control information about new frame received by AFI for injection."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FRM_INFO", Field { brief: Some("Frame information for new frame received by AFI. The inforrmation must be copied to FRM_INFO bits in AFI:FRM_TBL:FRM_ENTRY_PART0.PART0. Once FRM_INFO has been copied to FRM_TBL, then NEW_FRM_CTRL.VLD must be cleared."), details: None, lo: 0, hi: 19 });
        regs.insert("NEW_FRM_INFO", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Frame information about new frame received by AFI for injection."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_NUM", Field { brief: Some("Port number corresponding to sticky bit event."), details: None, lo: 0, hi: 6 });
        fields.insert("STICKY_INFO_WR_CNT", Field { brief: Some("Number of times STICKY_INFO.PORT_NUM and  STICKY_INFO.TTI_PTR is allowed to be updated."), details: Some("0: Illegal 1: Max one update of STICKY_INFO allowed (decremented for each update). 2: Max two updates of STICKY_INFO allowed (decremented for each update). ... 15: Any number of updates of STICKY_INFO allowed (not decremented)."), lo: 28, hi: 32 });
        fields.insert("TTI_PTR", Field { brief: Some("TTI pointer corresponding to sticky bit event."), details: None, lo: 8, hi: 20 });
        regs.insert("STICKY_INFO", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Additional information about sticky bit events."), details: Some("The information is updated if a) Enabled in STICKY_INFO_ENA and b) STICKY_INFO_WR_CNT is > 0"), fields });
        let mut fields = HashMap::new();
        fields.insert("ENQ_STOP_INFO_ENA", Field { brief: Some("Enable updating of STICKY_INFO.PORT_NUM for WARN_ENQ_STOP_STICKY."), details: None, lo: 2, hi: 3 });
        fields.insert("FRM_OUT_MAX_INFO_ENA", Field { brief: Some("Enable updating of STICKY_INFO.PORT_NUM for WARN_FRM_OUT_MAX_STICKY."), details: None, lo: 1, hi: 2 });
        fields.insert("FRM_OUT_NEG_INFO_ENA", Field { brief: Some("Enable updating of STICKY_INFO.PORT_NUM for ERR_FRM_OUT_NEG_STICKY."), details: None, lo: 0, hi: 1 });
        fields.insert("TTI_BUSY_INFO_ENA", Field { brief: Some("Enable updating of STICKY_INFO.TTI_PTR for WARN_TTI_BUSY_STICKY."), details: None, lo: 3, hi: 4 });
        regs.insert("STICKY_INFO_ENA", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Enabling of additional information about sticky bit events."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("WARN_DTI_CNT_DOWN_MAX_NEG_STICKY", Field { brief: Some("DTI_CNT_DOWN has reached its maximum negative value."), details: None, lo: 4, hi: 5 });
        fields.insert("WARN_ENQ_STOP_STICKY", Field { brief: Some("QSYS has asserted enq_stop. i.e. requested AFI to stop injecting frames. This should normally not occur. If enabled in STICKY_INFO_ENA.ENQ_STOP_INFO_ENA, the affected port number is stored in STICKY_INFO.PORT_NUM."), details: None, lo: 2, hi: 3 });
        fields.insert("WARN_FRM_OUT_MAX_STICKY", Field { brief: Some("FRM_OUT_MAX has been reached for port. This is unusual, but may occur when a large number of frames are successively injected to queues of the same port or if the port flow controlled or is shaped to a low bandwidth. The number of injections that can be outstanding (i.e. waiting to be transmitted out of QSYS) for a port\tat a time is configured in AFI:PORT_TBL:PORT_CFG.FRM_OUT_MAX. If enabled in STICKY_INFO_ENA.FRM_OUT_MAX_INFO_ENA, the corresponding port number is stored in STICKY_INFO.PORT_NUM."), details: None, lo: 1, hi: 2 });
        fields.insert("WARN_NEW_FRM_VLD_STICKY", Field { brief: Some("A new frame for injection was received by AFI, but NEW_FRM_CTRL.VLD was still 1. Check that NEW_FRM_CTRL.VLD is cleared upon copying NEW_FRM_INFO.FRM_INFO to FRM_TBL."), details: None, lo: 0, hi: 1 });
        fields.insert("WARN_TTI_BUSY_STICKY", Field { brief: Some("A TTI in TTI_TBL was elected to be processed, but was already being processed. This may indicate that the length of a calendar slot is too short (ref. AFI:TTI_MISC:TTI_CAL_SLOT_PTRS). If enabled in STICKY_INFO_ENA.TTI_BUSY_INFO_ENA, the corresponding TTI pointer is stored in STICKY_INFO.TTI_PTR."), details: None, lo: 3, hi: 4 });
        regs.insert("WARN", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Warnings from AFI block"), details: Some("These bits shall normally not get set."), fields });
        groups.insert("MISC", RegisterGroup { addr: Address { base: 41330, count: 1, width: 8 }, desc: "Miscellaneous AFI configuration", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("FRM_OUT_CNT", Field { brief: Some("Current number of injections (TTI or DTI) outstanding per port. This parameter should not be written to. If the parameter is written to and a TTI injection occurs concurrently, then the written value may get overwritten by the AFI block."), details: None, lo: 16, hi: 27 });
        regs.insert("PORT_FRM_OUT", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Number of outstanding injections per port"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TTI_FRM_OUT_MAX", Field { brief: Some("See AFI:PORT_TBL:PORT_CFG.FRM_OUT_MAX."), details: None, lo: 0, hi: 10 });
        regs.insert("TTI_PORT_FRM_OUT", Register { addr: Address { base: 16, count: 1, width: 1 }, brief: Some("Outstanding TTI injections per port"), details: None, fields });
        groups.insert("PORT_TBL", RegisterGroup { addr: Address { base: 41216, count: 57, width: 2 }, desc: "Port parameter configuration", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("SLOT_CNT", Field { brief: Some("Number of TTIs to service in slot before moving to next TTI Calendar Slot."), details: Some("0: 1 1: 1 2: 2 ..."), lo: 0, hi: 8 });
        regs.insert("TTI_CAL_SLOT_CNT", Register { addr: Address { base: 4, count: 4, width: 1 }, brief: Some("Number of TTIs to service in slot before moving to next TTI Calendar slot."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SLOT_END_PTR", Field { brief: Some("Calendar Slot's Frame Table end pointer."), details: None, lo: 16, hi: 28 });
        fields.insert("SLOT_START_PTR", Field { brief: Some("Calendar Slot's Frame Table start pointer."), details: None, lo: 0, hi: 12 });
        regs.insert("TTI_CAL_SLOT_PTRS", Register { addr: Address { base: 0, count: 4, width: 1 }, brief: Some("Start and end Frame Table pointers for Calendar Slot"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SLOT_TTI_TBL_PTR", Field { brief: Some("Current value of Calendar Slot's TTI Table Pointer."), details: None, lo: 0, hi: 12 });
        regs.insert("TTI_CAL_STATE", Register { addr: Address { base: 8, count: 4, width: 1 }, brief: Some("TTI Calendar state information"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TTI_CAL_CNT", Field { brief: Some("Number of remaining TTI Table entries to service for current Calendar Slot."), details: None, lo: 20, hi: 28 });
        fields.insert("TTI_CAL_LEN", Field { brief: Some("Length of TTI Calendar."), details: Some("0: Length=1 (Slot 0) 1: Length=2 (Slot 0-1) 2: Length=3 (Slot 0-2) 3: Length=4 (Slot 0-3)"), lo: 4, hi: 6 });
        fields.insert("TTI_CAL_PTR", Field { brief: Some("Current TTI Calendar slot."), details: None, lo: 16, hi: 18 });
        fields.insert("TTI_CSR_RSV", Field { brief: Some("Maximum number of clock cycles that CSR accesses have to wait before gaining access to TTI table. Note that writes need two accesses and may thus have to await 2x the configured number of clock cycles. Setting this parameter too low while doing excessive TTI Table CSR accesses may cause TTIs (in TTI Table) to be serviced too infrequently for their configured timer values."), details: Some("0 => CSR accesses takes precedence. 1 => 1 clock cycle ..."), lo: 8, hi: 16 });
        fields.insert("TTI_ENA", Field { brief: Some("Enable TTIs. Before enabling TTIs, TTI_INIT should be used to initialize Calendar state."), details: None, lo: 0, hi: 1 });
        fields.insert("TTI_INIT", Field { brief: Some("When set, initialize Calendar to start at Calendar Slot 0. Cleared by AFI when done."), details: None, lo: 1, hi: 2 });
        fields.insert("TTI_SERIAL_ENA", Field { brief: Some("If set only one TTI is processed at-a-time. This imposes some TTI limitations and is only intended to be used as work around for unexpected RTL bugs."), details: None, lo: 2, hi: 3 });
        regs.insert("TTI_CTRL", Register { addr: Address { base: 12, count: 1, width: 1 }, brief: Some("TTI Control"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TTI_TUPE_RSV", Field { brief: Some("Minium number of clock cycles between TUPE accessing TTI Table. TUPE access to TTI Table takes precedence over both CSR accesses and normal TTI processing. TUPE will at least consume 4 clock cycles per processed TTI, so setting TTI_TUPE_RSV<4 results in same behaviour as setting it to 4."), details: None, lo: 0, hi: 8 });
        regs.insert("TTI_CTRL2", Register { addr: Address { base: 13, count: 1, width: 1 }, brief: Some("TTI Control"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TTI_INJ_CNT", Field { brief: Some("Number of TTI frame injections. Enabled per TTI using AFI:TTI_TBL:TTI_MISC_CFG.INJ_CNT_ENA. Frames injected for removal are also counted."), details: None, lo: 0, hi: 30 });
        regs.insert("TTI_INJ_CNT", Register { addr: Address { base: 14, count: 1, width: 1 }, brief: Some("TTI Injection Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TTI_RAND_STATE", Field { brief: Some("State of random algorithm used for TTI jitter calculation. Updated by AFI for each jitter calculation. Should be initialized by SW to a random, non-zero value."), details: None, lo: 0, hi: 18 });
        regs.insert("TTI_RAND_STATE", Register { addr: Address { base: 15, count: 1, width: 1 }, brief: Some("State of random algorithm used for TTI jitter calculation"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TICK_CNT", Field { brief: Some("Tick's current counter value."), details: None, lo: 0, hi: 8 });
        fields.insert("TICK_ERA", Field { brief: Some("Tick's current era. Each tick counts up to its configured LEN. When LEN is reached TICK_ERA toggles and the tick restarts counting from 0. When a TTI in TTI_TBL is processed, then the LAST_TICK_ERA of the TTI is compared with the TICK_ERA of the tick used by the TTI and if they differ the TTI's TICK_CNT is decremented."), details: None, lo: 16, hi: 17 });
        regs.insert("TTI_TICK_STATE", Register { addr: Address { base: 3, count: 8, width: 1 }, brief: Some("Current state of TTI Tick counters"), details: Some("The TTI Tick counters are permanently running. Their current state (CNT and ERA) can be inspected and written to through these registers."), fields });
        groups.insert("TTI_MISC", RegisterGroup { addr: Address { base: 41445, count: 1, width: 17 }, desc: "Miscellaneous TTI configration", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("BW", Field { brief: Some("DTI bandwidth. Used to give arbitration precedence to high bandwidth DTIs."), details: Some("0: <5Gbps 1: >=5Gbps"), lo: 1, hi: 2 });
        fields.insert("ENA", Field { brief: Some("Enable DTI. If MODE=0 or MODE=2, then ENA is cleared by AFI when configured number of sequences have been injected. Before (re)starting a DTI the following initialization should be done: DURATION must be set to 0. NEXT_FRM_PTR should be set to FIRST_FRM_PTR. DTI_CNT_DOWN.CNT_DOWN should be set to 0. FRM_INJ_CNT should be set to 0 AFI::MISC_CTRL.AFI_ENA must be set to 1. If MODE=2, then the AFI will set ENA=1 for the DTI pointed to by DTI_NEXT once the DTI with MODE=2 completes."), details: None, lo: 0, hi: 1 });
        regs.insert("DTI_CTRL", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("DTI control"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FRM_PTR", Field { brief: Some("Pointer to the frame in Frame Table, which TTI shall inject."), details: None, lo: 0, hi: 12 });
        regs.insert("TTI_FRM", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Frame pointer for TTI"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INJ_CNT_ENA", Field { brief: Some("Enable counting of injected frames in AFI:TTI_MISC:TTI_INJ_CNT.TTI_INJ_CNT."), details: None, lo: 0, hi: 1 });
        regs.insert("TTI_MISC_CFG", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Miscellaneous TTI parameters"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_NUM", Field { brief: Some("Port number which injection queue transmits on. Injection queue is selected by QU_NUM. PORT_NUM must not be changed when timer is enabled."), details: None, lo: 0, hi: 6 });
        fields.insert("QU_NUM", Field { brief: Some("QU_NUM selects the queue, which the frame is injected into. For details, refer to the functional description of the queue system in the datasheet. QU_NUM must not be changed when timer is enabled."), details: None, lo: 8, hi: 24 });
        regs.insert("TTI_PORT_QU", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Port and queue for injected frames."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LAST_TICK_ERA", Field { brief: Some("Ticks era value last time TTI was processed."), details: None, lo: 16, hi: 17 });
        fields.insert("TICK_CNT", Field { brief: Some("Number of ticks until next injection. Frame is injected when TICK_CNT=0. Upon injection TICK_CNT gets set to TIMER_LEN. Should be set to a random value in range 1-TIMER_LEN before starting TTI."), details: None, lo: 0, hi: 9 });
        regs.insert("TTI_TICKS", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Current state of TTI's tick counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("JITTER", Field { brief: Some("Configuration of injection time jitter for TTI."), details: Some("0: No jitter 1: Timer is set to a random value in the range [TIMER_LEN*0.75; TIMER_LEN] 2: Timer is set to a random value in the range [TIMER_LEN*0.50; TIMER_LEN] 3: Timer is set to a random value in the range [1;TIMER_LEN]"), lo: 4, hi: 6 });
        fields.insert("TICK_IDX", Field { brief: Some("Timer Tick, which TTI shall use."), details: None, lo: 0, hi: 3 });
        fields.insert("TIMER_ENA", Field { brief: Some("Enable timer. Note that disabling a timer can also be achieved by setting TIMER_LEN to 0. Before enabling a timer AFI::MISC_CTRL.AFI_ENA must be set to 1."), details: None, lo: 6, hi: 7 });
        fields.insert("TIMER_LEN", Field { brief: Some("Number of ticks of configured TICK_IDX between frame injections. The period between each injection becomes tick_period x TIMER_LEN Setting TIMER_LEN to non-zero value enables TTI. 0x1FF (= Inject ASAP) is intended for removal of frame from buffer memory. Upon injection, HW sets TIMER_LEN to 0 (=Disable). Before setting TIMER_LEN, TICK_CNT should be set to a random value in range 1-TIMER_LEN (unless a specific initial timer value is desirable)."), details: Some("0 => Disable TTI. 1 => 1 tick 2 => 2 ticks ... 0x1ff => Inject ASAP, then set to TIMER_LEN=0 by AFI."), lo: 16, hi: 25 });
        regs.insert("TTI_TIMER", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("TTI Timer configuration"), details: None, fields });
        groups.insert("TTI_TBL", RegisterGroup { addr: Address { base: 0, count: 4096, width: 8 }, desc: "Timer Triggered Injection Table", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("BASE_CNT", Field { brief: Some("Current value of Base Tick counter."), details: None, lo: 16, hi: 30 });
        fields.insert("BASE_LEN", Field { brief: Some("Length of TTI Base Tick. Unit: One system clock cycle. In default configuration and a clock cycle of 6.4 ns, the tick length corresponds to 52us. If the device is uses a longer clock cycle, then the value of BASE_LEN must be reconfigured accordingly."), details: None, lo: 0, hi: 14 });
        regs.insert("TTI_TICK_BASE", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Base Tick configuration."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LEN0", Field { brief: Some("Length of TTI Tick 0. Unit: Base Ticks, as configured in TTI_TICK_BASE.BASE_LEN. In default configuration the tick length corresponds to 52us."), details: None, lo: 0, hi: 8 });
        fields.insert("LEN1", Field { brief: Some("Length of TTI Tick 1. Unit: TTI Tick 0, as configured in TTI_TICK_LEN_0_3.LEN0. In default configuration the tick length corresponds to 416us."), details: None, lo: 8, hi: 16 });
        fields.insert("LEN2", Field { brief: Some("Length of TTI Tick 2. Unit: TTI Tick 1, as configured in TTI_TICK_LEN_0_3.LEN1. In default configuration the tick length corresponds to 3.3ms."), details: None, lo: 16, hi: 24 });
        fields.insert("LEN3", Field { brief: Some("Length of TTI Tick 3. Unit: TTI Tick 2, as configured in TTI_TICK_LEN_0_3.LEN2. In default configuration the tick length corresponds to 10ms."), details: None, lo: 24, hi: 32 });
        regs.insert("TTI_TICK_LEN_0_3", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Length of TTI Ticks 0-3"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LEN4", Field { brief: Some("Length of TTI Tick 4. Unit: TTI Tick 3, as configured in TTI_TICK_LEN_0_3.LEN3. In default configuration the tick length corresponds to 100ms."), details: None, lo: 0, hi: 8 });
        fields.insert("LEN5", Field { brief: Some("Length of TTI Tick 5. Unit: TTI Tick 4, as configured in TTI_TICK_LEN_4_7.LEN4. In default configuration the tick length corresponds to 1s."), details: None, lo: 8, hi: 16 });
        fields.insert("LEN6", Field { brief: Some("Length of TTI Tick 6. Unit: TTI Tick 5, as configured in TTI_TICK_LEN_4_7.LEN5. In default configuration the tick length corresponds to 10s."), details: None, lo: 16, hi: 24 });
        fields.insert("LEN7", Field { brief: Some("Length of TTI Tick 7. Unit: TTI Tick 6, as configured in TTI_TICK_LEN_4_7.LEN6. In default configuration the tick length corresponds to 1min."), details: None, lo: 24, hi: 32 });
        regs.insert("TTI_TICK_LEN_4_7", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Length of TTI Ticks 4-7"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TUPE_CTRL", Field { brief: Some("Control value for Table UPdate Engine (TUPE). See AFI:TUPE."), details: None, lo: 0, hi: 8 });
        regs.insert("TTI_TUPE_CTRL", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("TUPE Control"), details: Some("Control value for Table UPdate Engine (TUPE). See AFI:TUPE."), fields });
        groups.insert("TTI_TICKS", RegisterGroup { addr: Address { base: 41434, count: 1, width: 11 }, desc: "TTI Tick configuration", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("FC_SKIP_TTI_INJ", Field { brief: Some("Controls what action to take if TTI injection cannot be performed due to FRM_OUT_MAX reached or injection stop from QSYS. FC_SKIP_TTI_INJ should be set when disabling a port using FRM_OUT_MAX. See PORT_CFG.FRM_OUT_MAX."), details: Some("0: Postpone injection until injection is again allowed. 1: Skip this injection."), lo: 16, hi: 17 });
        fields.insert("FRM_OUT_MAX", Field { brief: Some("Maximum number of injections that can be outstanding at a time per port. DTI injections are held back if FRM_OUT_MAX is exceeded. TTI injections are held back if FRM_OUT_MAX+TTI_FRM_OUT_MAX is exceeded. TTI_FRM_OUT_MAX ensures that TTI injections are still possible when a DTI flow is configured slightly above port speed. If FRM_OUT_MAX is set to 0 to disable injections for port, then it is recommended to first set FC_SKIP_TTI_INJ=1 to avoid a burst of injections when injections are later enabled. Upon setting FRM_OUT_MAX back to non-zero value, then FC_SKIP_TTI_INJ must be set back to its orginal value. Note that FRM_OUT_MAX must also be >0 when performing \"removal injections\" (for removing frames from buffer memory)."), details: Some("0: Injection disabled for port (both TTI and DTI injections, regardless of TTI_FRM_OUT_MAX value) 1: Maximum 1 outstanding injection. 2: Maximum 2 outstanding injections. ... 1022: Maximum 1022 outstanding injections. 1023: Illegal."), lo: 0, hi: 10 });
        fields.insert("FRM_RM_ONLY", Field { brief: Some("Only allow frame removal injections, i.e. normal injections are disallowed. If FRM_RM_ONLY is set, then it is recommended to first set FC_SKIP_TTI_INJ=1 to avoid a burst of injections when normal injections are later re-enabled. Upon setting FRM_RM_ONLY back to zero, then FC_SKIP_TTI_INJ must be set back to its orginal value."), details: Some("0: Allow both normal and removal injections. 1: Only allow removal injections."), lo: 17, hi: 18 });
        regs.insert("PORT_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Port configuration parameters"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TUPE_END_ADDR", Field { brief: Some("Last address in TTI Table for TUPE to process. Must be >= TUPE_START_ADDR."), details: None, lo: 16, hi: 28 });
        fields.insert("TUPE_START_ADDR", Field { brief: Some("First address in TTI Table for TUPE to process. Must be <= TUPE_START_ADDR."), details: None, lo: 0, hi: 12 });
        regs.insert("TUPE_ADDR", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Address range for TUPE to process"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CMD_PORT_NUM_VAL", Field { brief: Some("New value for PORT_NUM for any TTIs matching TUPE criterias. Must be enabled by AFI:TUPE:TUPE_MISC.CMD_PORT_NUM_ENA."), details: None, lo: 0, hi: 6 });
        fields.insert("CMD_QU_NUM_VAL", Field { brief: Some("New value for QU_NUM for any TTIs matching TUPE criterias. Must be enabled by AFI:TUPE:TUPE_MISC.CMD_QU_NUM_ENA."), details: None, lo: 8, hi: 24 });
        regs.insert("TUPE_CMD1", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("TUPE Command Parameters"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CRIT_PORT_NUM_VAL", Field { brief: Some("If enabled by AFI:TUPE:TUPE_MISC.CRIT_PORT_NUM_ENA, then PORT_NUM in TTIs must match this value in order to be processed by TUPE."), details: None, lo: 0, hi: 6 });
        fields.insert("CRIT_QU_NUM_VAL", Field { brief: Some("If enabled by AFI:TUPE:TUPE_MISC.CRIT_QU_NUM_ENA, then QU_NUM in TTIs must match this value in order to be processed by TUPE."), details: None, lo: 8, hi: 24 });
        regs.insert("TUPE_CRIT1", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("TUPE Criterias"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CRIT_TUPE_CTRL_MASK", Field { brief: Some("Refer to AFI:TUPE:TUPE_CRIT3.CRIT_TUPE_CTRL_VAL."), details: None, lo: 0, hi: 8 });
        regs.insert("TUPE_CRIT2", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("TUPE Criterias"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CRIT_TUPE_CTRL_VAL", Field { brief: Some("For one or more of the configured CRIT_TUPE_CTRL_VALs, TUPE_CTRL in TTIs must match the following criterias in order to be processed by TUPE: (TTI.TUPE_CTRL & CRIT_TUPE_CTRL_MASK) == CRIT_TUPE_CTRL_VAL[i]"), details: None, lo: 0, hi: 8 });
        regs.insert("TUPE_CRIT3", Register { addr: Address { base: 4, count: 2, width: 1 }, brief: Some("TUPE Criterias"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CMD_PORT_NUM_ENA", Field { brief: Some("Enable use of CMD_PORT_NUM_VAL. For further information refer to AFI:TUPE:TUPE_CMD1.CMD_PORT_NUM_VAL"), details: None, lo: 6, hi: 7 });
        fields.insert("CMD_QU_NUM_ENA", Field { brief: Some("Enable use of CMD_QU_NUM_VAL. For further information refer to AFI:TUPE:TUPE_CMD1.CMD_QU_NUM_VAL"), details: None, lo: 7, hi: 8 });
        fields.insert("CMD_TIMER_ENA_ENA", Field { brief: Some("Enable use of CMD_TIMER_ENA_VAL. For further information refer to AFI:TUPE:TUPE_MISC.CMD_TIMER_ENA_VAL"), details: None, lo: 4, hi: 5 });
        fields.insert("CMD_TIMER_ENA_VAL", Field { brief: Some("New value for TIMER_ENA for any TTIs matching TUPE criterias. Must be enabled by AFI:TUPE:TUPE_MISC.CMD_TIMER_ENA_ENA."), details: None, lo: 5, hi: 6 });
        fields.insert("CRIT_PORT_NUM_ENA", Field { brief: Some("Enable use of CRIT_PORT_NUM_VAL. For further information refer to AFI:TUPE:TUPE_CRIT1.CRIT_PORT_NUM_VAL"), details: None, lo: 1, hi: 2 });
        fields.insert("CRIT_QU_NUM_ENA", Field { brief: Some("Enable use of CRIT_QU_NUM_ENA. For further information refer to AFI:TUPE:TUPE_CRIT1.CRIT_QU_NUM_VAL"), details: None, lo: 2, hi: 3 });
        fields.insert("TUPE_START", Field { brief: Some("Start TUPE. Write 1 to start TUPE. Set to 0 by TUPE when done. Before running TUPE, AFI::MISC_CTRL.AFI_ENA must be set to 1. Note: While TUPE is running (i.e. TUPE_START=1) CPU must not write to TTI Table."), details: None, lo: 0, hi: 1 });
        regs.insert("TUPE_MISC", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Miscellaneous TUPE parameters"), details: None, fields });
        groups.insert("TUPE", RegisterGroup { addr: Address { base: 41462, count: 1, width: 7 }, desc: "AFI Table UPdata Engine (AFI TUPE)", regs });
        out.insert("AFI", Target { desc: "The Automatic Frame Injector (AFI) provides mechanisms for periodic injection of PDUs. E.g. injection of - OAM PDUs for continuity check, loss and delay measurement - OAM PDUs for high service activation test, ref. ITU Y.1564. - IEEE 1588 PDUs", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("PORT_MASK", Field { brief: Some("Aggregation port mask."), details: None, lo: 0, hi: 32 });
        regs.insert("AGGR_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Aggregation port mask"), details: Some("See ANA_AC:AGGR."), fields });
        let mut fields = HashMap::new();
        fields.insert("PROBE_PORT_MASK1", Field { brief: Some("Refer to PROBE_PORT_CFG.PROBE_PORT_MASK description."), details: None, lo: 0, hi: 21 });
        regs.insert("PROBE_PORT_CFG1", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Mirror probe port mask configuration"), details: None, fields });
        groups.insert("AGGR", RegisterGroup { addr: Address { base: 151776, count: 16, width: 2 }, desc: "Aggregation port masks", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CM_ADDR", Field { brief: Some("Address selection within selected core memory (CMID register). Address is automatically advanced at every data access."), details: None, lo: 0, hi: 22 });
        fields.insert("CM_ID", Field { brief: Some("Refer to cmid.xls in the AS1000, misc_docs folder."), details: None, lo: 22, hi: 30 });
        regs.insert("CM_ADDR", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Address selection"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RAM_ENA", Field { brief: Some("Core memory controllers are enabled when this field is set."), details: None, lo: 0, hi: 1 });
        fields.insert("RAM_INIT", Field { brief: Some("Initialize core memories. Field is automatically cleared when operation is complete ( approx. 40 us)."), details: None, lo: 1, hi: 2 });
        regs.insert("RAM_INIT", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Core reset control"), details: Some("Controls reset and initialization of the switching core. Proper startup sequence is: - Enable memories - Initialize memories - Enable core"), fields });
        groups.insert("COREMEM", RegisterGroup { addr: Address { base: 151764, count: 1, width: 2 }, desc: "Access core memory", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("UPSID_PORT_MASK1", Field { brief: Some("Refer to UPSID_CFG.UPSID_PORT_MASK."), details: None, lo: 0, hi: 21 });
        regs.insert("UPSID_CFG1", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("UPSID destination configuration"), details: Some("Refer to UPSID_CFG."), fields });
        groups.insert("GLAG", RegisterGroup { addr: Address { base: 152000, count: 32, width: 1 }, desc: "Configuration for Global Link Aggregation Groups", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("MIRROR_CPU_INJECT_ENA", Field { brief: Some("Mirror traffic from CPU,  which is set to bypass the analyzer. Traffic, which is set to bypass the analyzer, is identified by the following criteria: IFH.FWD.DST_MODE == INJECT || IFH.MISC.PIPELINE_PT >= ANA_DONE"), details: None, lo: 31, hi: 32 });
        fields.insert("PROBE_CPU_SET", Field { brief: Some("The set of CPU extraction ports from where traffic is Tx mirrored by this mirror probe. Only works when Tx mirroring is  enabled. Related parameters: ANA_AC:MIRROR_PROBE:PROBE_CFG.PROBE_DIRECTION"), details: Some("0: CPU extraction port is not Tx mirrored 1: CPU extraction port is Tx mirrored"), lo: 18, hi: 26 });
        fields.insert("PROBE_DIRECTION", Field { brief: Some("Direction of traffic that is mirrored."), details: Some("\"00\" : Mirroring is disabled. \"01\" : TX - Only traffic to destination ports in the probe port set \"10\" : RX - Only traffic from source ports in the probe port set \"11\" : RX+TX - Traffic to and from ports in the probe port set (always mirrored as RX)"), lo: 0, hi: 2 });
        fields.insert("PROBE_MAC_MODE", Field { brief: Some("Mirror probe's MAC address filtering mode, based on the mirror bit in the MAC table."), details: Some("\"00\" : No MAC filtering \"01\" : Mirror only traffic with mirror bit set for known DMAC \"10\" : Mirror only traffic with mirror bit set for known SMAC \"11\" : Mirror only traffic with mirror bit set for known DMAC and/or known SMAC"), lo: 2, hi: 4 });
        fields.insert("PROBE_PHYS_RX_PORT", Field { brief: Some("Controls whether physical or masqueraded port number will be used for lookup in PROBE_PORT_MASK. CPU injected frames with masqueraded port number are identfied by having IFH.MIWC.PIPELINE_ACT == INJ_MASQ. Frames, which have been looped back from Up-MEP can only be mirrored if masqueraded port number is used for lookup in PROBE_PORT_MASK. Related parameters: ANA_AC:MIRROR_PROBE:PROBE_PORT_CFG.PROBE_PORT_MASK."), details: Some("0: If frame is masqueraded, then use masqueraded port number for lookup in PROBE_PORT_MASK. Otherwise use physical port number for lookup in PROBE_PORT_MASK. 1: Use physical port.number for lookup in PROBE_PORT_MASK."), lo: 30, hi: 31 });
        fields.insert("PROBE_RX_CPU_AND_VD", Field { brief: Some("Mirror traffic received from CPU by this mirror probe. PROBE_RX_CPU_AND_VD works as an extension of the PROBE_PORT_MASK to cover CPU ports and VD0/VD1."), details: Some("\"0000\": No RX mirror \"xxx1\": Rx from CPU port 53 is mirrored \"xx1x\": Rx from CPU port 54 is mirrored \"x1xx\": Rx from VD0 is mirrored \"1xxx\": Rx from VD1 is mirrored Only works with RX mirror enabled. See ANA_AC:MIRROR_PROBE:PROBE_CFG.PROBE_DIRECTION."), lo: 26, hi: 30 });
        fields.insert("PROBE_VID", Field { brief: Some("The mirror probe's VLAN ID when PROBE_VLAN_MODE is 10 or 11. Probing per VLAN can also be enabled in ANA_L3:VLAN, but such configuration will affect all mirror probes. Related parameters: ANA_AC.MIRROR_PROBE.PROBE_CFG.PROBE_VLAN_MODE ANA_L3:VLAN:VLAN_CFG.VLAN_MIRROR_ENA"), details: None, lo: 6, hi: 18 });
        fields.insert("PROBE_VLAN_MODE", Field { brief: Some("Mirror probe's VLAN filtering mode. Related parameters: ANA_L3:VLAN:VLAN_CFG.VLAN_MIRROR_ENA"), details: Some("00 : No VLAN filtering 01 : Mirror only traffic in VLANs with ANA_L3:VLAN:VLAN_CFG.VLAN_MIRROR_ENA set 10 : Mirror only traffic with CL-IVID = PROBE_VID. 11 : Reserved."), lo: 4, hi: 6 });
        regs.insert("PROBE_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Mirror probe configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PROBE_PORT_MASK", Field { brief: Some("Specifies the set of ingress port(s) subject to Rx mirroring and the set of egress port(s) subject to Tx mirroring. PROBE_PHYS_RX_PORT controls whether physical or masqueraded port number is used for lookup in PROBE_PORT_MASK. PROBE_RX_CPU_AND_VD works as an extension of the PROBE_PORT_MASK to cover CPU ports and VD0/VD1. Ports enabled in PROBE_PORT_MASK are either RX mirrored (ingress mirrored) and/or TX mirrored (egress mirrored) as determined by PROBE_DIRECTION. Mirror destination port(s) are determined by QFWD:SYSTEM:FRAME_COPY_CFG For exact TX mirror, the configuration of this register must be consistent with the configuration of REW:COMMON:MIRROR_PROBE_CFG.MIRROR_TX_PORT. See also description for register group ANA_AC:MIRROR_PROBE. Related parameters: ANA_AC:MIRROR_PROBE:PROBE_CFG.PROBE_PHYS_RX_PORT ANA_AC:MIRROR_PROBE:PROBE_CFG.PROBE_RX_CPU_AND_VD ANA_AC:MIRROR_PROBE:PROBE_CFG.PROBE_DIRECTION REW:COMMON:MIRROR_PROBE_CFG.MIRROR_TX_PORT QFWD:SYSTEM:FRAME_COPY_CFG"), details: Some("0: Port is not mirrored 1: Port is mirrored"), lo: 0, hi: 32 });
        regs.insert("PROBE_PORT_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Mirror probe port mask configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CPU_QU_ZERO_DST", Field { brief: Some("If ZERO_DST_REDIR_ENA is set and the destination port set calculation for the frame results in an empty port set, then the frame gets redirected to the CPU queue configured by this parameter. Related parameters: ANA_AC::PS_DBG_CTRL.ZERO_DST_REDIR_ENA"), details: Some("0: CPU queue 0 1: CPU queue 1 ... n: CPU queue n."), lo: 4, hi: 7 });
        fields.insert("ZERO_DST_REDIR_ENA", Field { brief: Some("See ANA_AC::PS_DBG_CTRL.CPU_QU_ZERO_DST."), details: None, lo: 0, hi: 1 });
        regs.insert("PS_DBG_CTRL", Register { addr: Address { base: 68, count: 1, width: 1 }, brief: Some("CPU debug configuration"), details: None, fields });
        groups.insert("MIRROR_PROBE", RegisterGroup { addr: Address { base: 152032, count: 3, width: 8 }, desc: "Mirror probe configuration", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("GLAG_MBR_CNT", Field { brief: Some("GLAG member count. This is used to select the GLAG port mask within the GLAG part of ANA_AC:PGID. Using GLAG_MBR_CNT a GLAG_MBR_IDX is calculated as follows: GLAG_MBR_IDX = frame.ac % GLAG_MBR_CNT The frame's GLAGID and GLAG_MBR_IDX are then used for lookup in ANA_AC:PGID."), details: Some("0: One member 1: Two members ... 7: Eight members"), lo: 16, hi: 19 });
        regs.insert("MBR_CNT_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("GLAG member count configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_MASK", Field { brief: Some("PGID port mask or stack forwarding information, depending on STACK_TYPE_ENA. Related parameters: ANA_AC:PGID:PGID_MISC_CFG.STACK_TYPE_ENA"), details: Some("PGID_MISC_CFG.STACK_TYPE_ENA=0: Destination port mask. PGID_MISC_CFG.STACK_TYPE_ENA=1: Bit 4:0 VStaX destination UPSPN. Bit 5 VStaX destination port type. 0=Normal UPSPN, 1=Internal port (advanced use). Bit 10:6 VStaX destination UPSID Bit 13:11 VStaX forwarding mode. Only used if PGID origins from multicast index in MAC table. In all other cases bit 13:11 must be 0. Encoding: '001': fwd_logical. Forward to logical front port at specific UPS, using (UPSID, UPSPN). '010': fwd_physical. Forward to physical front port at specific UPS, using (UPSID, UPSPN). '101': fwd_gcpu_ups. Forward to GCPU of specific UPS (identified by UPSID). Other: Reserved. If bit 10:6 is a remote UPSID, then 20:16 must be set to 0. If bit 10:6 is the a UPSID, then 20:16 must be set to same value as bit 4:0."), lo: 0, hi: 32 });
        regs.insert("PGID_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("PGID port mask / destination configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_MASK1", Field { brief: Some("Refer to PGID_CFG.PORT_MASK description."), details: None, lo: 0, hi: 21 });
        regs.insert("PGID_CFG1", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("PGID port mask / destination configuration"), details: None, fields });
        groups.insert("PGID", RegisterGroup { addr: Address { base: 147456, count: 1077, width: 4 }, desc: "Port group ID table configurations", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CM_DATA", Field { brief: Some("Data register for core memory access. Wider memories are big endian mapped into the 32 BIT inspection space."), details: None, lo: 0, hi: 32 });
        regs.insert("CM_DATA", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Data register for core memory access."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("VSTAX2_EQUAL_STACK_LINKS_FLOOD_ENA", Field { brief: Some("Controls flooding in ring topology stacks. When set, frames to be flooded will be forwarded on only stack port A or only stack port B. TTL will be set to VSTAX2_EQUAL_STACK_LINK_TTL_VAL. This feature can be used to forward flooded frames in one or the other way around the ring, In such case VSTAX2_EQUAL_STACK_LINK_TTL_VAL must be set to the number of units in the ring minus 1. Frames with even AC will be forwarded on stack port A. Frames with odd AC will be forwarded on stack port B. Note that this feature is not related to equal cost forwarding. It is applicable to any ring topology stack regardless of whether the number of units is even or odd."), details: Some("0: Disable (flood on both stack ports using the stack port's TTL) 1: Enable (flood on one stack port using VSTAX2_EQUAL_STACK_LINK_TTL_VAL)"), lo: 8, hi: 9 });
        fields.insert("VSTAX2_EQUAL_STACK_LINK_TTL_VAL", Field { brief: Some("TTL value used for equal cost path. Only applicable for ring topology stacks with an even number of units. Must be set to number of units in the stack divided by two. Use of equal cost paths is enabled by ANA_AC:UPSID:STACK_LINK_EQUAL_COST_CFG.STACK_LINK_EQUAL_ENA"), details: None, lo: 0, hi: 5 });
        regs.insert("COMMON_EQUAL_STACK_LINK_TTL_CFG", Register { addr: Address { base: 11, count: 1, width: 1 }, brief: Some("Common stacking parameters"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("OWN_UPSID", Field { brief: Some("Specifies own UPSID This must be configured consistently across the following registers: ANA_CL::UPSID_CFG.UPSID_NUM ANA_AC::COMMON_VSTAX_CFG.OWN_UPSID ANA_L2::VSTAX_CTRL.OWN_UPSID REW::COMMON_CTRL.OWN_UPSID"), details: None, lo: 0, hi: 5 });
        fields.insert("VSTAX2_ALLOW_UPSID_CPU_OR_INT_PN_ENA", Field { brief: Some("Allow FWD_LOGICAL entries in MAC table to control internal port number in VStaX header. If MAC table entry for DMAC specifies vstax.general.fwd_mode=FWD_LOGICAL and a destination port number of type port_type_intpn, then this bit controls the outgoing destination port number in the VStaX header. If this bit is clear, then the destination port number in VStaX header is set to intpn=15, regardless of the port number specified in the MAC table entry. If this bit is set, then the destination port number in VStaX header is set to the value of the port number specified in the MAC table entry."), details: Some("0: Disable (set destination port to intpn=15) 1: Enable (set destination port to value in MAC table)"), lo: 24, hi: 25 });
        fields.insert("VSTAX2_FWD_ERR_QU", Field { brief: Some("CPU queue for VStaX frames forwarding error."), details: Some("0: CPU queue 0 1: CPU queue 1 ... n: CPU queue n."), lo: 8, hi: 11 });
        fields.insert("VSTAX2_GLAG_ENA", Field { brief: Some("This can be used to enable GLAG in a stack If enabled the upper GLAG*8 number of PGID multicast entries will be used for GLAG"), details: Some("0: Disable 1: Enable"), lo: 15, hi: 16 });
        fields.insert("VSTAX2_ISDX_STAT_DIS", Field { brief: Some("Disable counting of bytes and frames in ANA_AC:STAT_CNT_CFG_ISDX for frames received on a stack port. Related parameters: REW:COMMON:CNT_CTRL.VSTAX_STAT_ESDX_DIS"), details: None, lo: 25, hi: 26 });
        fields.insert("VSTAX2_LOGICAL_LLOOKUP_ENA", Field { brief: Some("Forward unicast frames from front ports as fwd_mode==fwd_llookup (instead of fwd_logical)"), details: Some("0: Disable 1: Enable"), lo: 16, hi: 17 });
        fields.insert("VSTAX2_MC_LLOOKUP_ENA", Field { brief: Some("Forward multicast frames as fwd_mode==fwd_llookup (instead of fwd_mc). Note that PTP frames will always be forwarded using fwd_llookup, regardless of the value of VSTAX2_MC_LLOOKUP_ENA."), details: Some("0: Disable 1: Enable"), lo: 12, hi: 13 });
        fields.insert("VSTAX2_MC_LLOOKUP_NON_FLOOD_ENA", Field { brief: Some("Forward non flooded multicast frames w. fwd_mode==fwd_llookup (instead of fwd_mc)"), details: Some("0: Disable 1: Enable"), lo: 11, hi: 12 });
        fields.insert("VSTAX2_MC_ROUTE_TO_STACK_LINK_ENA", Field { brief: Some("Configures handling of IP multicast routing on stack link. If IP multicast routing is performed in egress unit, then routed copies shall not be forwarded on the stack ports and this parameter must thus be set to 0. If IP multicast routing is performed in ingress unit (or centralized), then routed copies shall be forwarded on the stack ports and this parameter must thus be set to 3."), details: Some("0: Disable multicast on both links 1: Enable multicast routing on stack link A 2: Enable multicast routing on stack link B 3: Enable multicast routing on both links"), lo: 17, hi: 19 });
        fields.insert("VSTAX2_MISC_DSCP_ENA", Field { brief: Some("Enable putting DSCP into VStaX header in positions 73-68, provided that VStaX header contains AC (and not ISDX) in misc section, i.e. VSTAX2_MISC_ISDX_ENA=0. Related parameters: ANA_AC:PS_COMMON:COMMON_VSTAX_CFG.VSTAX2_MISC_ISDX_ENA ANA_CL:PORT:STACKING_CTRL.VSTAX_ISDX_ENA"), details: None, lo: 6, hi: 7 });
        fields.insert("VSTAX2_MISC_ISDX_ENA", Field { brief: Some("Enable putting ISDX into VStaX header. Related parameters: ANA_CL:PORT:STACKING_CTRL.VSTAX_ISDX_ENA"), details: Some("0: Disable (VSTAX MISC contains Aggregation code) 1: Enable (VSTAX MISC contains ISDX)"), lo: 5, hi: 6 });
        fields.insert("VSTAX2_RT_ALL_FWD_LOGICAL_ENA", Field { brief: Some("Allow routing of VStaX frames received on stack port with vstax.fwd_mode==FWD_LOGICAL with vstax.upsid=COMMON_VSTAX_CFG.OWN_UPSID regardless of vstax.dst.dst_port."), details: Some("0: Disable (allow only routing of FWD_LOGICAL if dst_port_type == port_type_intpn and dst_pn == intpn_dlookup or dst_pn == intpn_router) 1: Enable"), lo: 23, hi: 24 });
        fields.insert("VSTAX2_RT_MC_SRC_LRN_SKIP_ENA", Field { brief: Some("Configures value used for vstax.lrn_mode when forwarding routed IP multicast frames on stack port(s)."), details: Some("0: lrn_mode=lrn_normal 1: lrn_mode=lrn_skip"), lo: 20, hi: 21 });
        fields.insert("VSTAX2_RT_MC_SRC_UPDATE_ENA", Field { brief: Some("Allow update of vstax.src field for multicast routed frames."), details: Some("0: Disable 1: Enable"), lo: 22, hi: 23 });
        fields.insert("VSTAX2_RT_UC_SRC_LRN_SKIP_ENA", Field { brief: Some("Configures value used for vstax.lrn_mode when forwarding routed IP unicast frames on stack port(s)."), details: Some("0: lrn_mode=lrn_normal 1: lrn_mode=lrn_skip"), lo: 19, hi: 20 });
        fields.insert("VSTAX2_RT_UC_SRC_UPDATE_ENA", Field { brief: Some("Allow update of vstax.src field for unicast routed frames"), details: Some("0: Disable 1: Enable"), lo: 21, hi: 22 });
        fields.insert("VSTAX2_TTL_KEEP_ENA", Field { brief: Some("This feature is to be used in 48 port switches consisting of two units (i.e. chips) and where the CPU is disabled one of the units. Only the unit with the disabled CPU shall have vstax2_ttl_keep==1"), details: Some("0: Disable 1: Enable"), lo: 14, hi: 15 });
        fields.insert("VSTAX2_USE_CM_ENA", Field { brief: Some("Forward unicast frames from front ports taking congestion management into account"), details: Some("0: Disable 1: Enable"), lo: 13, hi: 14 });
        regs.insert("COMMON_VSTAX_CFG", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("Common stacking parameters"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ONE_CPU_COPY_ONLY_MASK", Field { brief: Some("Specifies a group of CPU queues which will only receive one frame copy in total"), details: Some("'00000000' : A frame copy will be generated for all CPU queues applicable for reception ... 'xxxxxx11' : Only one CPU copy will be generated for CPU queue 1 and 0 ... '11111111' : At most one frame copy will be generated for all CPU queues applicable for reception"), lo: 0, hi: 8 });
        regs.insert("CPU_CFG", Register { addr: Address { base: 67, count: 1, width: 1 }, brief: Some("CPU related parameters"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CMAC_FLOOD_DP_INC", Field { brief: Some("Increase DP level for flooded traffic."), details: Some("0: Disabled 1: Increase DP by 1 for flooded traffic 2: Increase DP by 2 for flooded traffic 3: Increase DP by 3 for flooded traffic"), lo: 4, hi: 6 });
        fields.insert("CPU_TO_CPU_KILL_ENA", Field { brief: Some("Avoid CPU sending back to CPU."), details: None, lo: 1, hi: 2 });
        fields.insert("USE_VID_AS_ISDX_ENA", Field { brief: Some("Enable use of VID instead of ISDX_BASE_ADDR as index to statistics in ANA_AC:STAT_CNT_CFG_ISDX. Related parameters: ANA_L2::ISDX_BASE_CFG.ISDX_BASE_ADDR REW:COMMON:CNT_CTRL.STAT_MODE."), details: None, lo: 8, hi: 9 });
        regs.insert("MISC_CTRL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Miscellaneous control parameters"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PHYS_SRC_AGGR_MASK", Field { brief: Some("Enable use of physical source port number for aggregation towards this port. This is intended to be used when interconnecting two devices using two interconnect ports, which are aggregated in a LLAG, to form a 48 port system."), details: Some("'xxx0xx': Use normal aggregation code when finding aggregation mask for this port 'xxx1xx': Use only physical source port number in aggregation code when finding aggregation mask for this port."), lo: 0, hi: 32 });
        regs.insert("PHYS_SRC_AGGR_CFG", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Enable aggregation using physical source port number"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PHYS_SRC_AGGR_MASK1", Field { brief: Some("Refer to PHYS_SRC_AGGR_CFG.PHYS_SRC_AGGR_MASK description."), details: None, lo: 0, hi: 21 });
        regs.insert("PHYS_SRC_AGGR_CFG1", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Enable aggregation using physical source port number"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SFLOW_ENA", Field { brief: Some("Enable sFlow sampling."), details: None, lo: 1, hi: 2 });
        fields.insert("SFLOW_SMPL_ID_IN_STAMP_ENA", Field { brief: Some("Enable sFlow Sampler ID in sFlow Stamp. The \"sFlow Stamp\" replaces the frame's FCS. With this bit disabled the sFlow Stamp format becomes: Bit 31:8: Frame forwarding count. Bit 7:0: Sample count. With this bit enabled the sFlow Stamp format becomes: Bit 31:26: Sampler ID Bit 25:8: Frame forwarding count. Bit 7:0: Sample count."), details: None, lo: 2, hi: 3 });
        fields.insert("SRC_LOOKUP_ENA", Field { brief: Some("Enable lookup of logical source port. If disabled, the source mask does not affect the egress port mask."), details: None, lo: 0, hi: 1 });
        regs.insert("PS_COMMON_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Various, common configuration parameters"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SFLOW_CPU_QU", Field { brief: Some("CPU queue for frames copied to the CPU by an sFlow Sampler."), details: None, lo: 12, hi: 15 });
        regs.insert("SFLOW_CFG", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("sFlow configuration"), details: Some("This register configures the sFlow sampler."), fields });
        let mut fields = HashMap::new();
        fields.insert("SFLOW_FRAME_RESET_SHOT", Field { brief: Some("When set to 1, the following counters are reset for all sFlow Samplers: ANA_AC:SFLOW:SFLOW_CNT.SFLOW_SAMPLE_CNT ANA_AC:SFLOW:SFLOW_CNT.SFLOW_SAMPLE_FWD_CNT Upon resetting the counters, the device will set the parameter back to 0."), details: Some("0: No action 1: Reset counters."), lo: 0, hi: 1 });
        regs.insert("SFLOW_RESET_CTRL", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("sFlow counter reset"), details: Some("This register configures the sFlow Sampler reset."), fields });
        let mut fields = HashMap::new();
        fields.insert("STACK_A_MASK", Field { brief: Some("Port mask with ports of stack port A. This mask is only used when forwarding to UPSIDs w. STACK_LINK_EQUAL_COST_CFG.STACK_LINK_EQUAL_ENA=1. If STACK_LINK_EQUAL_ENA is set, then the stack forwarding mask is calculated as one of the following two, depending on AC: Even AC: UPSID.UPSID_PORT_VEC* & STACK_A_CFG.STACK_A_VEC* Odd AC: UPSID.UPSID_PORT_VEC* & ~STACK_A_CFG.STACK_A_VEC*"), details: Some("'XX...XXX': Where X is '0' or '1', representing a stacking link A destination port."), lo: 0, hi: 32 });
        regs.insert("STACK_A_CFG", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("Port mask for Stack Port A"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("STACK_A_MASK1", Field { brief: Some("Refer to STACK_A_CFG.STACK_A_MASK description."), details: None, lo: 0, hi: 21 });
        regs.insert("STACK_A_CFG1", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("Port mask for Stack Port A"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("STACK_MASK", Field { brief: Some("Stack port mask. For ports used for stacking, the corresponding bit must be set in this port mask."), details: Some("'XX...XXX': Where X is '0' or '1', representing a destination port."), lo: 0, hi: 32 });
        regs.insert("STACK_CFG", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Stack port mask configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("STACK_MASK1", Field { brief: Some("Refer to STACK_CFG.STACK_MASK description."), details: None, lo: 0, hi: 21 });
        regs.insert("STACK_CFG1", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Stack port mask configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("VSTAX2_STACK_PORT_MODE", Field { brief: Some("Specify learn and forwarding operation for the port"), details: Some("0: VStaX2/BF mode (Basic Forwarding mode) 1: VStaX2/AF mode (Advanced Forwarding mode)"), lo: 0, hi: 1 });
        regs.insert("VSTAX_CTRL", Register { addr: Address { base: 12, count: 53, width: 1 }, brief: Some("Per port stack configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("GMIRROR_PORT_MASK", Field { brief: Some("The set of port(s) to which frames received on a stack port and with fwd_mode=fwd_gmirror traffic are forwarded. This is only used in VStaX context."), details: None, lo: 0, hi: 32 });
        regs.insert("VSTAX_GMIRROR_CFG", Register { addr: Address { base: 65, count: 1, width: 1 }, brief: Some("VStaX Gmirror destination configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("GMIRROR_PORT_MASK1", Field { brief: Some("Refer to VSTAX_GMIRROR_CFG.GMIRROR_PORT_MASK description."), details: None, lo: 0, hi: 21 });
        regs.insert("VSTAX_GMIRROR_CFG1", Register { addr: Address { base: 66, count: 1, width: 1 }, brief: Some("VStaX Gmirror destination configuration"), details: None, fields });
        groups.insert("PS_COMMON", RegisterGroup { addr: Address { base: 152426, count: 1, width: 69 }, desc: "Common configurations for all ports", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("PGID_CPU_COPY_ENA", Field { brief: Some("Copy frame to CPU. Related parameters: ANA_AC:PGID:PGID_MISC_CFG.PGID_CPU_QU"), details: None, lo: 0, hi: 1 });
        fields.insert("PGID_CPU_QU", Field { brief: Some("CPU queue for frames copied to CPU due to PGID_CPU_COPY_ENA. Related parameters: ANA_AC:PGID:PGID_MISC_CFG.PGID_CPU_COPY_ENA"), details: Some("0: CPU queue 0 1: CPU queue 1 ... n: CPU queue n."), lo: 4, hi: 7 });
        fields.insert("STACK_TYPE_ENA", Field { brief: Some("Encoding of PGID_CFG.PORT_MASK. Related parameters: ANA_AC:PGID[0-1076]:PGID_CFG.PORT_MASK"), details: Some("0: Port mask encoding 1: Stack forwarding encoding"), lo: 1, hi: 2 });
        regs.insert("PGID_MISC_CFG", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Miscellaneous PGID configuration"), details: None, fields });
        groups.insert("PS_STICKY", RegisterGroup { addr: Address { base: 151767, count: 1, width: 1 }, desc: "Diagnostic information", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ACL_REDIR_STICKY", Field { brief: Some("Set if frame is redirected due to VCAP IS2. Write 1 to clear this field."), details: Some("0: No redir event 1: A frame was redirected."), lo: 24, hi: 25 });
        fields.insert("FRAME_FWD_STICKY", Field { brief: Some("Set if a frame has been forwarded with a non-zero destination set. Write 1 to clear this field."), details: Some("0: No frames forwarded 1: Frame forward event"), lo: 16, hi: 17 });
        fields.insert("GLAG_CONTRIB_STICKY", Field { brief: Some("Set if the GLAG source mask has been used. Write 1 to clear this field."), details: None, lo: 9, hi: 10 });
        fields.insert("IP4_MC_CTRL_FLOOD_STICKY", Field { brief: Some("Set if ip4_mc_ctrl_flood_mask has been used. Write 1 to clear this field."), details: None, lo: 3, hi: 4 });
        fields.insert("IP4_MC_DATA_FLOOD_STICKY", Field { brief: Some("Set if ip4_mc_data_flood_mask has been used. Write 1 to clear this field."), details: None, lo: 2, hi: 3 });
        fields.insert("IP6_MC_CTRL_FLOOD_STICKY", Field { brief: Some("Set if ip6_mc_ctrl_flood_mask has been used. Write 1 to clear this field."), details: None, lo: 5, hi: 6 });
        fields.insert("IP6_MC_DATA_FLOOD_STICKY", Field { brief: Some("Set if ip6_mc_data_flood_mask has been used. Write 1 to clear this field."), details: None, lo: 4, hi: 5 });
        fields.insert("L2_MC_FLOOD_STICKY", Field { brief: Some("Set if l2_mc_flood_mask has been used. Write 1 to clear this field."), details: None, lo: 1, hi: 2 });
        fields.insert("NO_L2_L3_FWD_STICKY", Field { brief: Some("Set if the previous blocks in the Analyzer have signaled that a frame must not be forwarded. This may be done for CPU move or discard operations. Write 1 to clear this field."), details: None, lo: 6, hi: 7 });
        fields.insert("PGID_CPU_MASK_STICKY", Field { brief: Some("Set if a CPU copy operation from the PGID lookup has been done. Write 1 to clear this field."), details: None, lo: 7, hi: 8 });
        fields.insert("PROBE_STICKY", Field { brief: Some("Set if a mirror probe has been triggered. Write 1 to clear this field."), details: Some("0: Mirror probe not triggered 1: Mirror probe triggered"), lo: 20, hi: 23 });
        fields.insert("SFLOW_CAND_STICKY", Field { brief: Some("Set if a frame, candidate for sFlow sampling, was found. Write 1 to clear this field."), details: None, lo: 15, hi: 16 });
        fields.insert("SFLOW_DST_SAMPLE_STICKY", Field { brief: Some("Set if a sFlow destination sample event has taken place. Write 1 to clear this field."), details: Some("0: No event 1: A sample event has occured"), lo: 14, hi: 15 });
        fields.insert("SFLOW_SAMPLE_STICKY", Field { brief: Some("Set if a sFlow sample event has taken place. Write 1 to clear this field."), details: Some("0: No event 1: A sample event has occured"), lo: 12, hi: 13 });
        fields.insert("SFLOW_SRC_SAMPLE_STICKY", Field { brief: Some("Set if a sFlow source sample event has taken place. Write 1 to clear this field."), details: Some("0: No event 1: A sample event has occured"), lo: 13, hi: 14 });
        fields.insert("SRC_CONTRIB_STICKY", Field { brief: Some("Set if the source mask has been used. Write 1 to clear this field."), details: None, lo: 8, hi: 9 });
        fields.insert("UC_FLOOD_STICKY", Field { brief: Some("Set if the unicast flood mask has been used. Write 1 to clear this field."), details: None, lo: 0, hi: 1 });
        fields.insert("VLAN_CONTRIB_STICKY", Field { brief: Some("Set if VLAN mask has been used. Write 1 to clear this field."), details: None, lo: 11, hi: 12 });
        fields.insert("ZERO_DST_STICKY", Field { brief: Some("Set if the egress port mask for a frame was zero and the frame was not sent to the CPU. Write 1 to clear this field."), details: None, lo: 17, hi: 18 });
        regs.insert("STICKY", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Diagnostic information"), details: Some("Diagnostic sticky bits."), fields });
        groups.insert("PS_STICKY_MASK", RegisterGroup { addr: Address { base: 152495, count: 4, width: 16 }, desc: "Counter configuration for diagnostic information", regs });
        let regs = HashMap::new();
        groups.insert("RAM_CTRL", RegisterGroup { addr: Address { base: 151766, count: 1, width: 1 }, desc: "Access core memory", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("SFLOW_DIR_SEL", Field { brief: Some("Configures the sampler as an ingress, egress or dual direction sampler."), details: Some("\"00\": Disable sampler. \"01\": RX sampler (samples trafficfrom port) \"10\": TX sampler (samples traffic to port) \"11\": RX or TX sampler (samples traffic to and from port)"), lo: 15, hi: 17 });
        fields.insert("SFLOW_PRBS", Field { brief: Some("The current state of the sampler's PRBS (pseudorandom binary sequence). SFLOW_PRBS for all samplers can be reset using SFLOW_FRAME_RESET_SHOT. Related parameters: ANA_AC::SFLOW_RESET_CTRL.SFLOW_FRAME_RESET_SHOT"), details: None, lo: 17, hi: 32 });
        fields.insert("SFLOW_SAMPLE_RATE", Field { brief: Some("The probability with which the sampler copies frames to CPU. The probability can be calculated as: SFLOW_SAMPLE_RATE/32767"), details: Some("'0x0': 0 probability, i.e. sFlow sampler is disabled. '0x1': 1/32767 '0x7FFF': 100%, i.e. all frames are sampled by the sFlow sampler."), lo: 0, hi: 15 });
        regs.insert("SFLOW_CTRL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("sFlow sampler control"), details: Some("This register configures the sFlow sampler."), fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_MASK1", Field { brief: Some("Refer to description for ANA_AC:SRC."), details: None, lo: 0, hi: 21 });
        regs.insert("SRC_CFG1", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Source port mask"), details: Some("Refer to description for ANA_AC:SRC."), fields });
        groups.insert("SFLOW", RegisterGroup { addr: Address { base: 152320, count: 53, width: 2 }, desc: "sFlow sampler configuration & status per port", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("PORT_MASK1", Field { brief: Some("Refer to AGGR_CFG.PORT_MASK description."), details: None, lo: 0, hi: 21 });
        regs.insert("AGGR_CFG1", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Aggregation port mask"), details: Some("See ANA_AC:AGGR."), fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_MASK", Field { brief: Some("Refer to description for ANA_AC:SRC."), details: None, lo: 0, hi: 32 });
        regs.insert("SRC_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Source port mask"), details: Some("Refer to description for ANA_AC:SRC."), fields });
        groups.insert("SRC", RegisterGroup { addr: Address { base: 151808, count: 89, width: 2 }, desc: "Source port masks", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("GLOBAL_EVENT_MASK", Field { brief: Some("This value stores the event mask which indicates the counter of all flows to count certain events. If set to '1' the respective event is not filtered and can trigger the counter. If set to '0' the respective event is filtered and the counter will treat the frame as if no event has occurred. The following events apply to ACL stat: Bit0: Count CPU traffic applicable for CPU ACL policer but not discarded Bit1: Count front port traffic applicable for ACL policer but not discarded Bit2: Count CPU traffic discarded by ACL policer Bit3: Count front port traffic discarded by ACL policer"), details: Some("0: This event will not trigger counting. 1: Enable counting for frames with this event."), lo: 0, hi: 4 });
        regs.insert("STAT_GLOBAL_EVENT_MASK", Register { addr: Address { base: 4, count: 2, width: 1 }, brief: Some("Event mask for counters."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LSB_CNT", Field { brief: Some("This register contains the least significant 32 bits of a counter."), details: None, lo: 0, hi: 32 });
        regs.insert("STAT_LSB_CNT", Register { addr: Address { base: 0, count: 2, width: 1 }, brief: Some("The counter's least significant 32 bits."), details: None, fields });
        groups.insert("STAT_CNT_CFG_ACL", RegisterGroup { addr: Address { base: 152192, count: 32, width: 4 }, desc: "Individual configuration.", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("GLOBAL_EVENT_MASK", Field { brief: Some("This value stores the event mask which controls the counter of all bundle stats to count certain events. If set to '1' the respective event is not filtered and can trigger the counter. If set to '0' the respective event is filtered and the counter will treat the frame as if no event has occurred. Which type of frame is counted is defined in: STAT_GLOBAL_CFG. The following events apply to Bundle DLB stat: Bit0: Count GREEN traffic Bit1: Count YELLOW traffic Bit2: Count RED traffic"), details: Some("0: This event will not trigger counting. 1: Enable counting for frames with this event."), lo: 0, hi: 3 });
        regs.insert("STAT_GLOBAL_EVENT_MASK", Register { addr: Address { base: 4, count: 2, width: 1 }, brief: Some("Event mask for counters."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LSB_CNT", Field { brief: Some("This register contains the least significant 32 bits of a counter."), details: None, lo: 0, hi: 32 });
        regs.insert("STAT_LSB_CNT", Register { addr: Address { base: 0, count: 2, width: 1 }, brief: Some("The counter's least significant 32 bits."), details: None, fields });
        groups.insert("STAT_CNT_CFG_BDLB", RegisterGroup { addr: Address { base: 155648, count: 1024, width: 4 }, desc: "Individual configuration.", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("GLOBAL_EVENT_MASK", Field { brief: Some("This value stores the event mask which controls the counter of all bundle stats to count certain events. If set to '1' the respective event is not filtered and can trigger the counter. If set to '0' the respective event is filtered and the counter will treat the frame as if no event has occurred. Which type of frame is counted is defined in: STAT_GLOBAL_CFG. The following events apply to Bundle DLB stat: Bit0: Count Broadcast traffic discarded by BUM policer Bit1: Count Multicast traffic discarded by BUM policer Bit2: Count Unicast traffic discarded by BUM policer Bit3: Count Broadcast traffic applicable for BUM policer but not discarded Bit4: Count Multicast traffic applicable for BUM policer but not discarded Bit5: Count Unicast traffic applicable for BUM policer but not discarded"), details: Some("0: This event will not trigger counting. 1: Enable counting for frames with this event."), lo: 0, hi: 6 });
        regs.insert("STAT_GLOBAL_EVENT_MASK", Register { addr: Address { base: 12, count: 6, width: 1 }, brief: Some("Event mask for counters."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LSB_CNT", Field { brief: Some("This register contains the least significant 32 bits of a counter."), details: None, lo: 0, hi: 32 });
        regs.insert("STAT_LSB_CNT", Register { addr: Address { base: 0, count: 6, width: 1 }, brief: Some("The counter's least significant 32 bits."), details: None, fields });
        groups.insert("STAT_CNT_CFG_BUM", RegisterGroup { addr: Address { base: 131072, count: 1024, width: 16 }, desc: "Individual configuration.", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("GLOBAL_EVENT_MASK", Field { brief: Some("This value stores the event mask which indicates the counter of all flows to count certain events. If set to '1' the respective event is not filtered and can trigger the counter. If set to '0' the respective event is filtered and the counter will treat the frame as if no event has occurred. The following events apply to erleg stat: Bit0: Count acl_discarded traffic Bit1: Count ip_uc_routed traffic Bit2: Count ip_mc_routed traffic Bit3: Count ip_mc_switched traffic Bit4: Count ip_mc_ttl_discarded traffic"), details: Some("0: This event will not trigger counting. 1: Enable counting for frames with this event."), lo: 0, hi: 5 });
        regs.insert("STAT_GLOBAL_EVENT_MASK", Register { addr: Address { base: 16, count: 8, width: 1 }, brief: Some("Event mask for counters."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LSB_CNT", Field { brief: Some("This register contains the least significant 32 bits of a counter."), details: None, lo: 0, hi: 32 });
        regs.insert("STAT_LSB_CNT", Register { addr: Address { base: 0, count: 8, width: 1 }, brief: Some("The counter's least significant 32 bits."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MSB_CNT", Field { brief: Some("The counter's most significant 8 bits. The field stores the value in the counters of a flow from bit 32 to the most significant bit. Reading: The MSB part of the counter is latched to a shadow register, when the LSB part is read. As a result, the LSB part must always be read first, and the MSB part must be read immediately after the LSB part is read. Writing: The procedure for writing differs depending on counter group: ANA_AC:STAT_CNT_CFG_PORT: LSB part must be written first, followed by MSB part. All other counter groups: MSB part must be written first, followed by LSB part."), details: None, lo: 0, hi: 8 });
        regs.insert("STAT_MSB_CNT", Register { addr: Address { base: 8, count: 8, width: 1 }, brief: Some("The counter's most significant 8 bits."), details: None, fields });
        groups.insert("STAT_CNT_CFG_ERLEG", RegisterGroup { addr: Address { base: 163840, count: 256, width: 16 }, desc: "Individual configuration.", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("GLOBAL_EVENT_MASK", Field { brief: Some("This value stores the event mask which indicates the counter of all flows to count certain events. If set to '1' the respective event is not filtered and can trigger the counter. If set to '0' the respective event is filtered and the counter will treat the frame as if no event has occurred. Which type of frame is counted is defined in: STAT_CFG, CFG_CNT_FRM_TYPE. The following events apply to irleg stat: Bit0: Count acl_discarded traffic Bit1: Count received IP UC traffic Bit2: Count received IP MC traffic Bit3: Count ip_uc_routed traffic Bit4: Count ip_mc_routed traffic Bit5: Count ip_mc_rpf_discarded traffic Bit6: Count ip_ttl_discarded traffic"), details: Some("0: This event will not trigger counting. 1: Enable counting for frames with this event."), lo: 0, hi: 7 });
        regs.insert("STAT_GLOBAL_EVENT_MASK", Register { addr: Address { base: 16, count: 8, width: 1 }, brief: Some("Event mask for counters."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LSB_CNT", Field { brief: Some("This register contains the least significant 32 bits of a counter."), details: None, lo: 0, hi: 32 });
        regs.insert("STAT_LSB_CNT", Register { addr: Address { base: 0, count: 8, width: 1 }, brief: Some("The counter's least significant 32 bits."), details: None, fields });
        groups.insert("STAT_CNT_CFG_IRLEG", RegisterGroup { addr: Address { base: 159744, count: 256, width: 16 }, desc: "Individual configuration.", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("GLOBAL_EVENT_MASK", Field { brief: Some("This value stores the event mask which indicates the counter of all flows to count certain events. If set to '1' the respective event is not filtered and can trigger the counter. If set to '0' the respective event is filtered and the counter will treat the frame as if no event has occurred. Which type of frame is counted is defined in: STAT_GLOBAL_CFG. The following events apply to ISDX stat: For CE: Bit0: Count GREEN traffic Bit1: Count YELLOW traffic Bit2: Count RED traffic For SME: Bit3: Count unicast traffic Bit4: Count multicast traffic Bit5: Count flooded traffic Bit6: Count broadcast traffic"), details: Some("0: This event will not trigger counting. 1: Enable counting for frames with this event."), lo: 0, hi: 7 });
        regs.insert("STAT_GLOBAL_EVENT_MASK", Register { addr: Address { base: 12, count: 6, width: 1 }, brief: Some("Event mask for counters."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LSB_CNT", Field { brief: Some("This register contains the least significant 32 bits of a counter."), details: None, lo: 0, hi: 32 });
        regs.insert("STAT_LSB_CNT", Register { addr: Address { base: 0, count: 6, width: 1 }, brief: Some("The counter's least significant 32 bits."), details: None, fields });
        groups.insert("STAT_CNT_CFG_ISDX", RegisterGroup { addr: Address { base: 0, count: 8192, width: 16 }, desc: "Individual configuration.", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CFG_CNT_BYTE", Field { brief: Some("Configure whether to count frames or bytes."), details: Some("'0': Count frames. '1': Count bytes."), lo: 0, hi: 1 });
        fields.insert("CFG_CNT_FRM_TYPE", Field { brief: Some("Selects which frames to count."), details: Some("\"000\": The frames without any event signal or frame error signal asserted are counted. \"001\": The frames with unmasked (enabled) events asserted but with no error indications are counted. \"010\": The frames with both event signal and the error signal asserted are counted. \"011\": The frames with event signal asserted are counted in spite of the error indications. \"100\": The frames with the error signal asserted, but with no event signal are counted. \"101\": The frames with error signal asserted are counted in spite of the accompied event indications. | Error | Event -----+-------+------ 000 |   N\t|   N -----+-------+------ 001 |   N\t|   Y -----+-------+------ 010 |   Y\t|   Y -----+-------+------ 011 |   -\t|   Y -----+-------+------ 100 |   Y\t|   N -----+-------+------ 101 |   Y\t|   - -----+-------+------"), lo: 1, hi: 4 });
        fields.insert("CFG_PRIO_MASK", Field { brief: Some("This field is to configure the counters of a flow to count frames with certain priorities. The field contains one bit per priority. Note that with the default value of this field, counting is disabled for all priorities."), details: Some("0: Do not count frames with this priority. 1: Count frames with this priority."), lo: 4, hi: 12 });
        regs.insert("STAT_CFG", Register { addr: Address { base: 1, count: 4, width: 1 }, brief: Some("Event handling configuration."), details: Some("This register group defines how to handle the incoming events."), fields });
        let mut fields = HashMap::new();
        fields.insert("STICKY_BITS", Field { brief: Some("These are the sticky bits of events. There is a sticky bit for an event for each flow."), details: Some("'1': The corresponding event is triggered since it is cleared last time. '0': No such event is triggered since it is cleared last time."), lo: 0, hi: 16 });
        regs.insert("STAT_EVENTS_STICKY", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Sticky bits for events."), details: Some("It is the sticky bits of events. If one event is triggered, the corresponding bit is set to '1' before it is cleared. To write '1' into this bit will clear the sticky bit."), fields });
        let mut fields = HashMap::new();
        fields.insert("LSB_CNT", Field { brief: Some("This register contains the least significant 32 bits of a counter."), details: None, lo: 0, hi: 32 });
        regs.insert("STAT_LSB_CNT", Register { addr: Address { base: 5, count: 4, width: 1 }, brief: Some("The counter's least significant 32 bits."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RESET", Field { brief: Some("Write '1' to this field to reset all counters and configuration for this stat group. The device will set the bit back to '0' when reset has completed."), details: None, lo: 0, hi: 1 });
        regs.insert("STAT_RESET", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Reset all counters."), details: None, fields });
        groups.insert("STAT_CNT_CFG_PORT", RegisterGroup { addr: Address { base: 152576, count: 57, width: 16 }, desc: "Individual configuration.", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("GLOBAL_EVENT_MASK", Field { brief: Some("This value stores the event mask which indicates the counter of all flows to count certain events. If set to '1' the respective event is not filtered and can trigger the counter. If set to '0' the respective event is filtered and the counter will treat the frame as if no event has occurred. The following events apply to queue stat: Bit0: Count traffic applicable for queue policer but not discarded Bit1: Count traffic discarded by queue policer"), details: Some("0: This event will not trigger counting. 1: Enable counting for frames with this event."), lo: 0, hi: 2 });
        regs.insert("STAT_GLOBAL_EVENT_MASK", Register { addr: Address { base: 4, count: 2, width: 1 }, brief: Some("Event mask for counters."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LSB_CNT", Field { brief: Some("This register contains the least significant 32 bits of a counter."), details: None, lo: 0, hi: 32 });
        regs.insert("STAT_LSB_CNT", Register { addr: Address { base: 0, count: 2, width: 1 }, brief: Some("The counter's least significant 32 bits."), details: None, fields });
        groups.insert("STAT_CNT_CFG_QUEUE", RegisterGroup { addr: Address { base: 153600, count: 456, width: 4 }, desc: "Individual configuration.", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("GLOBAL_CFG_CNT_FRM_TYPE", Field { brief: Some("Configures which frames is counted in relation to FCS error and configured event mask (GLOBAL_EVENT_MASK)."), details: Some("\"000\": Frames without any event signal or FCS errored frames are counted. \"001\": Frames with unmasked (enabled) events without FCS error are counted. \"010\": Frames with unmasked (enabled) events with FCS error are counted. \"011\": Frames with unmasked (enabled) events independent of FCS error are counted. \"100\": Frames with FCS error but with no event signal are counted. \"101\": Frames with FCS error are unconditionally counted."), lo: 0, hi: 3 });
        regs.insert("GLOBAL_CNT_FRM_TYPE_CFG", Register { addr: Address { base: 0, count: 2, width: 1 }, brief: Some("Common frame type configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("GLOBAL_CFG_CNT_BYTE", Field { brief: Some("This field is to configure the counters of all flows to count the byte number or the frame number."), details: Some("'0': Count frames. '1': Count bytes."), lo: 0, hi: 1 });
        regs.insert("STAT_GLOBAL_CFG", Register { addr: Address { base: 2, count: 2, width: 1 }, brief: Some("Global configuration register"), details: Some("Global configuration register"), fields });
        let mut fields = HashMap::new();
        fields.insert("MSB_CNT", Field { brief: Some("The counter's most significant 8 bits. The field stores the value in the counters of a flow from bit 32 to the most significant bit. Reading: The MSB part of the counter is latched to a shadow register, when the LSB part is read. As a result, the LSB part must always be read first, and the MSB part must be read immediately after the LSB part is read. Writing: The procedure for writing differs depending on counter group: ANA_AC:STAT_CNT_CFG_PORT: LSB part must be written first, followed by MSB part. All other counter groups: MSB part must be written first, followed by LSB part."), details: None, lo: 0, hi: 8 });
        regs.insert("STAT_MSB_CNT", Register { addr: Address { base: 9, count: 4, width: 1 }, brief: Some("The counter's most significant 8 bits."), details: None, fields });
        groups.insert("STAT_GLOBAL_CFG_ACL", RegisterGroup { addr: Address { base: 151986, count: 1, width: 6 }, desc: "Common counter configuration.", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("GLOBAL_CFG_CNT_FRM_TYPE", Field { brief: Some("Configures which frames is counted in relation to FCS error and configured event mask (GLOBAL_EVENT_MASK)."), details: Some("\"000\": Frames without any event signal or FCS errored frames are counted. \"001\": Frames with unmasked (enabled) events without FCS error are counted. \"010\": Frames with unmasked (enabled) events with FCS error are counted. \"011\": Frames with unmasked (enabled) events independent of FCS error are counted. \"100\": Frames with FCS error but with no event signal are counted. \"101\": Frames with FCS error are unconditionally counted."), lo: 0, hi: 3 });
        regs.insert("GLOBAL_CNT_FRM_TYPE_CFG", Register { addr: Address { base: 0, count: 2, width: 1 }, brief: Some("Common frame type configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("GLOBAL_CFG_CNT_BYTE", Field { brief: Some("This field is to configure the counters of all flows to count the byte number or the frame number."), details: Some("'0': Count frames. '1': Count bytes."), lo: 0, hi: 1 });
        regs.insert("STAT_GLOBAL_CFG", Register { addr: Address { base: 2, count: 2, width: 1 }, brief: Some("Global configuration register"), details: Some("Global configuration register"), fields });
        let mut fields = HashMap::new();
        fields.insert("MSB_CNT", Field { brief: Some("The counter's most significant 8 bits. The field stores the value in the counters of a flow from bit 32 to the most significant bit. Reading: The MSB part of the counter is latched to a shadow register, when the LSB part is read. As a result, the LSB part must always be read first, and the MSB part must be read immediately after the LSB part is read. Writing: The procedure for writing differs depending on counter group: ANA_AC:STAT_CNT_CFG_PORT: LSB part must be written first, followed by MSB part. All other counter groups: MSB part must be written first, followed by LSB part."), details: None, lo: 0, hi: 8 });
        regs.insert("STAT_MSB_CNT", Register { addr: Address { base: 6, count: 3, width: 1 }, brief: Some("The counter's most significant 8 bits."), details: None, fields });
        groups.insert("STAT_GLOBAL_CFG_BDLB", RegisterGroup { addr: Address { base: 152056, count: 1, width: 6 }, desc: "Common counter configuration.", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("GLOBAL_CFG_CNT_FRM_TYPE", Field { brief: Some("Configures which frames is counted in relation to FCS error and configured event mask (GLOBAL_EVENT_MASK)."), details: Some("\"000\": Frames without any event signal or FCS errored frames are counted. \"001\": Frames with unmasked (enabled) events without FCS error are counted. \"010\": Frames with unmasked (enabled) events with FCS error are counted. \"011\": Frames with unmasked (enabled) events independent of FCS error are counted. \"100\": Frames with FCS error but with no event signal are counted. \"101\": Frames with FCS error are unconditionally counted."), lo: 0, hi: 3 });
        regs.insert("GLOBAL_CNT_FRM_TYPE_CFG", Register { addr: Address { base: 0, count: 6, width: 1 }, brief: Some("Common frame type configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("GLOBAL_CFG_CNT_BYTE", Field { brief: Some("This field is to configure the counters of all flows to count the byte number or the frame number."), details: Some("'0': Count frames. '1': Count bytes."), lo: 0, hi: 1 });
        regs.insert("STAT_GLOBAL_CFG", Register { addr: Address { base: 6, count: 6, width: 1 }, brief: Some("Global configuration register"), details: Some("Global configuration register"), fields });
        let mut fields = HashMap::new();
        fields.insert("MSB_CNT", Field { brief: Some("The counter's most significant 8 bits. The field stores the value in the counters of a flow from bit 32 to the most significant bit. Reading: The MSB part of the counter is latched to a shadow register, when the LSB part is read. As a result, the LSB part must always be read first, and the MSB part must be read immediately after the LSB part is read. Writing: The procedure for writing differs depending on counter group: ANA_AC:STAT_CNT_CFG_PORT: LSB part must be written first, followed by MSB part. All other counter groups: MSB part must be written first, followed by LSB part."), details: None, lo: 0, hi: 8 });
        regs.insert("STAT_MSB_CNT", Register { addr: Address { base: 2, count: 2, width: 1 }, brief: Some("The counter's most significant 8 bits."), details: None, fields });
        groups.insert("STAT_GLOBAL_CFG_BUM", RegisterGroup { addr: Address { base: 153506, count: 1, width: 18 }, desc: "Common counter configuration.", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("GLOBAL_CFG_CNT_FRM_TYPE", Field { brief: Some("Configures which frames is counted in relation to FCS error and configured event mask (GLOBAL_EVENT_MASK)."), details: Some("\"000\": Frames without any event signal or FCS errored frames are counted. \"001\": Frames with unmasked (enabled) events without FCS error are counted. \"010\": Frames with unmasked (enabled) events with FCS error are counted. \"011\": Frames with unmasked (enabled) events independent of FCS error are counted. \"100\": Frames with FCS error but with no event signal are counted. \"101\": Frames with FCS error are unconditionally counted."), lo: 0, hi: 3 });
        regs.insert("GLOBAL_CNT_FRM_TYPE_CFG", Register { addr: Address { base: 0, count: 8, width: 1 }, brief: Some("Common frame type configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("GLOBAL_CFG_CNT_BYTE", Field { brief: Some("This field is to configure the counters of all flows to count the byte number or the frame number."), details: Some("'0': Count frames. '1': Count bytes."), lo: 0, hi: 1 });
        regs.insert("STAT_GLOBAL_CFG", Register { addr: Address { base: 8, count: 8, width: 1 }, brief: Some("Global configuration register"), details: Some("Global configuration register"), fields });
        let mut fields = HashMap::new();
        fields.insert("MSB_CNT", Field { brief: Some("The counter's most significant 8 bits. The field stores the value in the counters of a flow from bit 32 to the most significant bit. Reading: The MSB part of the counter is latched to a shadow register, when the LSB part is read. As a result, the LSB part must always be read first, and the MSB part must be read immediately after the LSB part is read. Writing: The procedure for writing differs depending on counter group: ANA_AC:STAT_CNT_CFG_PORT: LSB part must be written first, followed by MSB part. All other counter groups: MSB part must be written first, followed by LSB part."), details: None, lo: 0, hi: 8 });
        regs.insert("STAT_MSB_CNT", Register { addr: Address { base: 8, count: 8, width: 1 }, brief: Some("The counter's most significant 8 bits."), details: None, fields });
        groups.insert("STAT_GLOBAL_CFG_ERLEG", RegisterGroup { addr: Address { base: 153548, count: 1, width: 24 }, desc: "Common counter configuration.", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("GLOBAL_CFG_CNT_FRM_TYPE", Field { brief: Some("Configures which frames is counted in relation to FCS error and configured event mask (GLOBAL_EVENT_MASK)."), details: Some("\"000\": Frames without any event signal or FCS errored frames are counted. \"001\": Frames with unmasked (enabled) events without FCS error are counted. \"010\": Frames with unmasked (enabled) events with FCS error are counted. \"011\": Frames with unmasked (enabled) events independent of FCS error are counted. \"100\": Frames with FCS error but with no event signal are counted. \"101\": Frames with FCS error are unconditionally counted."), lo: 0, hi: 3 });
        regs.insert("GLOBAL_CNT_FRM_TYPE_CFG", Register { addr: Address { base: 0, count: 8, width: 1 }, brief: Some("Common frame type configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("GLOBAL_CFG_CNT_BYTE", Field { brief: Some("This field is to configure the counters of all flows to count the byte number or the frame number."), details: Some("'0': Count frames. '1': Count bytes."), lo: 0, hi: 1 });
        regs.insert("STAT_GLOBAL_CFG", Register { addr: Address { base: 8, count: 8, width: 1 }, brief: Some("Global configuration register"), details: Some("Global configuration register"), fields });
        let mut fields = HashMap::new();
        fields.insert("MSB_CNT", Field { brief: Some("The counter's most significant 8 bits. The field stores the value in the counters of a flow from bit 32 to the most significant bit. Reading: The MSB part of the counter is latched to a shadow register, when the LSB part is read. As a result, the LSB part must always be read first, and the MSB part must be read immediately after the LSB part is read. Writing: The procedure for writing differs depending on counter group: ANA_AC:STAT_CNT_CFG_PORT: LSB part must be written first, followed by MSB part. All other counter groups: MSB part must be written first, followed by LSB part."), details: None, lo: 0, hi: 8 });
        regs.insert("STAT_MSB_CNT", Register { addr: Address { base: 6, count: 6, width: 1 }, brief: Some("The counter's most significant 8 bits."), details: None, fields });
        groups.insert("STAT_GLOBAL_CFG_IRLEG", RegisterGroup { addr: Address { base: 153524, count: 1, width: 24 }, desc: "Common counter configuration.", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("GLOBAL_CFG_CNT_FRM_TYPE", Field { brief: Some("Configures which frames is counted in relation to FCS error and configured event mask (GLOBAL_EVENT_MASK)."), details: Some("\"000\": Frames without any event signal or FCS errored frames are counted. \"001\": Frames with unmasked (enabled) events without FCS error are counted. \"010\": Frames with unmasked (enabled) events with FCS error are counted. \"011\": Frames with unmasked (enabled) events independent of FCS error are counted. \"100\": Frames with FCS error but with no event signal are counted. \"101\": Frames with FCS error are unconditionally counted."), lo: 0, hi: 3 });
        regs.insert("GLOBAL_CNT_FRM_TYPE_CFG", Register { addr: Address { base: 0, count: 6, width: 1 }, brief: Some("Common frame type configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("GLOBAL_CFG_CNT_BYTE", Field { brief: Some("This field is to configure the counters of all flows to count the byte number or the frame number."), details: Some("'0': Count frames. '1': Count bytes."), lo: 0, hi: 1 });
        regs.insert("STAT_GLOBAL_CFG", Register { addr: Address { base: 6, count: 6, width: 1 }, brief: Some("Global configuration register"), details: Some("Global configuration register"), fields });
        let mut fields = HashMap::new();
        fields.insert("MSB_CNT", Field { brief: Some("The counter's most significant 8 bits. The field stores the value in the counters of a flow from bit 32 to the most significant bit. Reading: The MSB part of the counter is latched to a shadow register, when the LSB part is read. As a result, the LSB part must always be read first, and the MSB part must be read immediately after the LSB part is read. Writing: The procedure for writing differs depending on counter group: ANA_AC:STAT_CNT_CFG_PORT: LSB part must be written first, followed by MSB part. All other counter groups: MSB part must be written first, followed by LSB part."), details: None, lo: 0, hi: 8 });
        regs.insert("STAT_MSB_CNT", Register { addr: Address { base: 2, count: 2, width: 1 }, brief: Some("The counter's most significant 8 bits."), details: None, fields });
        groups.insert("STAT_GLOBAL_CFG_ISDX", RegisterGroup { addr: Address { base: 153488, count: 1, width: 18 }, desc: "Common counter configuration.", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("GLOBAL_EVENT_MASK", Field { brief: Some("This value stores the event mask which indicates the counter of all flows to count certain events. If set to '1' the respective event is not filtered and can trigger the counter. If set to '0' the respective event is filtered and the counter will treat the frame as if no event has occurred. Which type of frame is counted is defined in: STAT_CFG, CFG_CNT_FRM_TYPE. The following events apply to port stat: bit0: Count events allowed by *_sticky_mask:0 bit1: Count events allowed by *_sticky_mask:1 ... bit3: Count events allowed by *_sticky_mask:n where n is number of counter event masks bit4: Count port policer:0 drop events bit4+1: Count port policer:1 drop events ... bit4+m: Count port policer:0 pass/active events bit4+m+1: Count port policer:1 pass/active events ... where m is number of per port policers bit4+2*m: Count storm policer drop events bit4+2*m+1: Count policer drop events bit4+2*m+3: Count lbk frame."), details: Some("0: This event will not trigger counting. 1: Enable counting for frames with this event."), lo: 0, hi: 16 });
        regs.insert("STAT_GLOBAL_EVENT_MASK", Register { addr: Address { base: 0, count: 4, width: 1 }, brief: Some("Event mask for counters."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FRAME_FWD_STICKY_MASK", Field { brief: Some("Mask to enable counting of sticky event."), details: None, lo: 16, hi: 17 });
        fields.insert("GLAG_CONTRIB_STICKY_MASK", Field { brief: Some("Mask to enable counting of sticky event."), details: None, lo: 9, hi: 10 });
        fields.insert("IP4_MC_CTRL_FLOOD_STICKY_MASK", Field { brief: Some("Mask to enable counting of sticky event."), details: None, lo: 3, hi: 4 });
        fields.insert("IP4_MC_DATA_FLOOD_STICKY_MASK", Field { brief: Some("Mask to enable counting of sticky event."), details: Some("Mask to enable counting of sticky event."), lo: 2, hi: 3 });
        fields.insert("IP6_MC_CTRL_FLOOD_STICKY_MASK", Field { brief: Some("Mask to enable counting of sticky event."), details: None, lo: 5, hi: 6 });
        fields.insert("IP6_MC_DATA_FLOOD_STICKY_MASK", Field { brief: Some("Mask to enable counting of sticky event."), details: None, lo: 4, hi: 5 });
        fields.insert("L2_MC_FLOOD_STICKY_MASK", Field { brief: Some("Mask to enable counting of sticky event."), details: None, lo: 1, hi: 2 });
        fields.insert("NO_L2_L3_FWD_STICKY_MASK", Field { brief: Some("Mask to enable counting of sticky event."), details: None, lo: 6, hi: 7 });
        fields.insert("PGID_CPU_MASK_STICKY_MASK", Field { brief: Some("Mask to enable counting of sticky event."), details: None, lo: 7, hi: 8 });
        fields.insert("PROBE_STICKY_MASK", Field { brief: Some("Mask to enable counting of sticky event."), details: None, lo: 20, hi: 23 });
        fields.insert("SFLOW_CAND_STICKY_MASK", Field { brief: Some("Mask to enable counting of sticky event."), details: None, lo: 15, hi: 16 });
        fields.insert("SFLOW_DST_SAMPLE_STICKY_MASK", Field { brief: Some("Mask to enable counting of sticky event."), details: None, lo: 14, hi: 15 });
        fields.insert("SFLOW_SAMPLE_STICKY_MASK", Field { brief: Some("Mask to enable counting of sticky event."), details: None, lo: 12, hi: 13 });
        fields.insert("SFLOW_SRC_SAMPLE_STICKY_MASK", Field { brief: Some("Mask to enable counting of sticky event."), details: None, lo: 13, hi: 14 });
        fields.insert("SRC_CONTRIB_STICKY_MASK", Field { brief: Some("Mask to enable counting of sticky event."), details: None, lo: 8, hi: 9 });
        fields.insert("UC_FLOOD_STICKY_MASK", Field { brief: Some("Mask to enable counting of sticky event."), details: None, lo: 0, hi: 1 });
        fields.insert("VLAN_CONTRIB_STICKY_MASK", Field { brief: Some("Mask to enable counting of sticky event."), details: None, lo: 11, hi: 12 });
        fields.insert("ZERO_DST_STICKY_MASK", Field { brief: Some("Mask to enable counting of sticky event."), details: None, lo: 17, hi: 18 });
        regs.insert("STICKY_MASK", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Sticky diagnostic counter masks"), details: None, fields });
        groups.insert("STAT_GLOBAL_CFG_PORT", RegisterGroup { addr: Address { base: 151768, count: 1, width: 5 }, desc: "Common counter configuration.", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("GLOBAL_CFG_CNT_FRM_TYPE", Field { brief: Some("Configures which frames is counted in relation to FCS error and configured event mask (GLOBAL_EVENT_MASK)."), details: Some("\"000\": Frames without any event signal or FCS errored frames are counted. \"001\": Frames with unmasked (enabled) events without FCS error are counted. \"010\": Frames with unmasked (enabled) events with FCS error are counted. \"011\": Frames with unmasked (enabled) events independent of FCS error are counted. \"100\": Frames with FCS error but with no event signal are counted. \"101\": Frames with FCS error are unconditionally counted."), lo: 0, hi: 3 });
        regs.insert("GLOBAL_CNT_FRM_TYPE_CFG", Register { addr: Address { base: 0, count: 2, width: 1 }, brief: Some("Common frame type configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("GLOBAL_CFG_CNT_BYTE", Field { brief: Some("This field is to configure the counters of all flows to count the byte number or the frame number."), details: Some("'0': Count frames. '1': Count bytes."), lo: 0, hi: 1 });
        regs.insert("STAT_GLOBAL_CFG", Register { addr: Address { base: 2, count: 2, width: 1 }, brief: Some("Global configuration register"), details: Some("Global configuration register"), fields });
        let mut fields = HashMap::new();
        fields.insert("MSB_CNT", Field { brief: Some("The counter's most significant 8 bits. The field stores the value in the counters of a flow from bit 32 to the most significant bit. Reading: The MSB part of the counter is latched to a shadow register, when the LSB part is read. As a result, the LSB part must always be read first, and the MSB part must be read immediately after the LSB part is read. Writing: The procedure for writing differs depending on counter group: ANA_AC:STAT_CNT_CFG_PORT: LSB part must be written first, followed by MSB part. All other counter groups: MSB part must be written first, followed by LSB part."), details: None, lo: 0, hi: 8 });
        regs.insert("STAT_MSB_CNT", Register { addr: Address { base: 2, count: 2, width: 1 }, brief: Some("The counter's most significant 8 bits."), details: None, fields });
        groups.insert("STAT_GLOBAL_CFG_QUEUE", RegisterGroup { addr: Address { base: 151992, count: 1, width: 6 }, desc: "Common counter configuration.", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("SFLOW_FRAME_FWD_CNT", Field { brief: Some("The number of forwarded frames. The counter is free running (wraps around when reaching max value). This counter can be reset using ANA_AC::SFLOW_RESET_CTRL.SFLOW_FRAME_RESET_SHOT."), details: Some("0 : no entries"), lo: 0, hi: 24 });
        fields.insert("SFLOW_SAMPLE_CNT", Field { brief: Some("The number of frames sampled. The counter is free running (wraps around when reaching max value). The counter can be reset using ANA_AC::SFLOW_RESET_CTRL.SFLOW_FRAME_RESET_SHOT."), details: None, lo: 24, hi: 32 });
        regs.insert("SFLOW_CNT", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("sFlow status counts"), details: Some("This register configures the sFlow sampler."), fields });
        let mut fields = HashMap::new();
        fields.insert("STACK_LINK_EQUAL_ENA", Field { brief: Some("Enable equal cost forwarding to UPSID. I.e. both stack ports (A and B) are used for forwarding to UPSID. If STACK_LINK_EQUAL_ENA is set, then the stack forwarding mask is calculated as one of the following two, depending on AC: Even AC: UPSID_PORT_MASK &  STACK_A_MASK Odd AC: UPSID_PORT_MASK & ~STACK_A_MASK Furthermore when STACK_LINK_EQUAL_ENA is set, the TTL value is set to VSTAX2_EQUAL_STACK_LINK_TTL_VAL (instead of REW::VSTAX_PORT_GRP_CFG.VSTAX_TTL). Related parameters: ANA_AC:UPSID:UPSID_CFG.UPSID_PORT_MASK ANA_AC:PS_COMMON:STACK_A_CFG.STACK_A_MASK ANA_AC:PS_COMMON:COMMON_EQUAL_STACK_LINK_TTL_CFG.VSTAX2_EQUAL_STACK_LINK _TTL_VAL REW:COMMON:VSTAX_PORT_GRP_CFG.VSTAX_TTL"), details: None, lo: 0, hi: 1 });
        regs.insert("STACK_LINK_EQUAL_COST_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Equal cost UPSID destination configuration"), details: Some("Used for configuring equal distance to UPSID"), fields });
        let mut fields = HashMap::new();
        fields.insert("UPSID_PORT_MASK", Field { brief: Some("UPSID port mask."), details: None, lo: 0, hi: 32 });
        regs.insert("UPSID_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("UPSID destination configuration"), details: Some("Configures which physical ports to be used for reaching a given UPSID."), fields });
        groups.insert("UPSID", RegisterGroup { addr: Address { base: 152064, count: 32, width: 4 }, desc: "UPSID table (one entry per UPS)", regs });
        out.insert("ANA_AC", Target { desc: "Controls mask handling etc.", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("SEC_TYPE_ARP_STICKY", Field { brief: Some("This sticky bit signals an ARP lookup was performed."), details: None, lo: 3, hi: 4 });
        fields.insert("SEC_TYPE_CUSTOM1_STICKY", Field { brief: Some("This sticky bit signals a CUSTOM1 lookup was performed."), details: None, lo: 12, hi: 13 });
        fields.insert("SEC_TYPE_CUSTOM2_STICKY", Field { brief: Some("This sticky bit signals a CUSTOM2 lookup was performed."), details: None, lo: 13, hi: 14 });
        fields.insert("SEC_TYPE_IP4_OTHER_STICKY", Field { brief: Some("This sticky bit signals an IP4_OTHER lookup was performed."), details: None, lo: 4, hi: 5 });
        fields.insert("SEC_TYPE_IP4_TCPUDP_STICKY", Field { brief: Some("This sticky bit signals an IP4_TCPUDP lookup was performed."), details: None, lo: 5, hi: 6 });
        fields.insert("SEC_TYPE_IP4_VID_STICKY", Field { brief: Some("This sticky bit signals an IP4_VID lookup was performed."), details: None, lo: 6, hi: 7 });
        fields.insert("SEC_TYPE_IP6_STD_STICKY", Field { brief: Some("This sticky bit signals IP6_STD lookup was performed."), details: None, lo: 9, hi: 10 });
        fields.insert("SEC_TYPE_IP6_TCPUDP_STICKY", Field { brief: Some("This sticky bit signals IP6_TCPUDP lookup was performed."), details: None, lo: 8, hi: 9 });
        fields.insert("SEC_TYPE_IP6_VID_STICKY", Field { brief: Some("This sticky bit signals an IP6_VID lookup was performed."), details: None, lo: 10, hi: 11 });
        fields.insert("SEC_TYPE_IP_7TUPLE_STICKY", Field { brief: Some("This sticky bit signals an IP_7TUPLE lookup was performed."), details: None, lo: 7, hi: 8 });
        fields.insert("SEC_TYPE_MAC_ETYPE_STICKY", Field { brief: Some("This sticky bit signals a MAC_ETYPE lookup was performed."), details: None, lo: 0, hi: 1 });
        fields.insert("SEC_TYPE_MAC_LLC_STICKY", Field { brief: Some("This sticky bit signals MAC_LLC lookup was performed."), details: None, lo: 1, hi: 2 });
        fields.insert("SEC_TYPE_MAC_SNAP_STICKY", Field { brief: Some("This sticky bit signals MAC_SNAP lookup was performed."), details: None, lo: 2, hi: 3 });
        fields.insert("SEC_TYPE_OAM_STICKY", Field { brief: Some("This sticky bit signals OAM lookup was performed."), details: None, lo: 11, hi: 12 });
        regs.insert("SEC_LOOKUP_STICKY", Register { addr: Address { base: 0, count: 2, width: 1 }, brief: Some("Sticky bits register for events generated by VCAP_IS2"), details: None, fields });
        groups.insert("CNT_TBL", RegisterGroup { addr: Address { base: 0, count: 4096, width: 1 }, desc: "VCAP_IS2 counter table", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ARP_KEY_SEL", Field { brief: Some("Applies to ARP/RARP frames."), details: Some("0: Match against MAC_ETYPE entries. 1: Match against ARP entries."), lo: 0, hi: 1 });
        fields.insert("IP4_MC_KEY_SEL", Field { brief: Some("Applies to IPv4 multicast frames."), details: Some("0: Match against MAC_ETYPE entries. 1: Match against IP4_TCP_UDP for IPv4 TCP/UDP frames and against IP4_OTHER entries for other IPv4 frames. 2: Match against IP_7TUPLE entries. 3: Match against IP4_VID entries."), lo: 6, hi: 8 });
        fields.insert("IP4_UC_KEY_SEL", Field { brief: Some("Applies to IPv4 unicast frames."), details: Some("0: Match against MAC_ETYPE entries. 1: Match against IP4_TCP_UDP for IPv4 TCP/UDP frames and against IP4_OTHER entries for other IPv4 frames. 2: Match against IP_7TUPLE entries."), lo: 4, hi: 6 });
        fields.insert("IP6_MC_KEY_SEL", Field { brief: Some("Applies to IPv6 multicast frames."), details: Some("0: Match against MAC_ETYPE entries. 1: Match against IP_7TUPLE entries. 2: Match against IP6_VID entries."), lo: 2, hi: 4 });
        fields.insert("IP6_UC_KEY_SEL", Field { brief: Some("Applies to IPv6 unicast frames."), details: Some("0: Match against MAC_ETYPE entries. 1: Match against IP_7TUPLE entries."), lo: 1, hi: 2 });
        fields.insert("NON_ETH_KEY_SEL", Field { brief: Some("Applies to frames where frame_type is set to non Ethernet (CW or MPLS)."), details: Some("0: Match against MAC_ETYPE entries. 1: match against CUSTOM_1 entries. 2: match against CUSTOM_2 entries. 3: No lookup."), lo: 8, hi: 10 });
        regs.insert("VCAP_S2_KEY_SEL", Register { addr: Address { base: 0, count: 2, width: 1 }, brief: Some("VCAP_IS2 key selection"), details: Some("Key selection for VCAP_IS2 lookups. Replicated per lookup."), fields });
        groups.insert("PORT", RegisterGroup { addr: Address { base: 4096, count: 57, width: 3 }, desc: "VCAP_IS2 configuration per port", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CNT", Field { brief: Some("VCAP_IS2 counter value."), details: None, lo: 0, hi: 32 });
        regs.insert("CNT", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VCAP_IS2 counter"), details: Some("The CNT_TBL counters count number of hits in VCAP_IS2. For each of the two VCAP_IS2 lookups, a VCAP match results in the associated counter being incremented using the VCAP_IS2 action CNT_ID as index."), fields });
        let mut fields = HashMap::new();
        fields.insert("CLOCK_ID_LSB", Field { brief: Some("Bits 31:0 of clockIdentifier used in portIdentity."), details: None, lo: 0, hi: 32 });
        regs.insert("PTP_CLOCK_ID_LSB", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("PTP clock identifier LSB"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CLOCK_ID_MSB", Field { brief: Some("Bits 63:32 of clockIdentifier used in portIdentity."), details: None, lo: 0, hi: 32 });
        regs.insert("PTP_CLOCK_ID_MSB", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("PTP clock identifier MSB"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FLAG_FIELD", Field { brief: Some("New values for byte 0 in flagField. Only bits with the corresponding bits set in FLAG_FIELD_MASK, are used."), details: None, lo: 0, hi: 8 });
        fields.insert("FLAG_FIELD_MASK", Field { brief: Some("Mask used to configure which bits in flagField, byte 0, are overwriteen with value configured in PTP_MISC_CFG.FLAG_FIELD."), details: Some("Bit x=0: Do not overwrite bit x in flagField, byte 0. Bit x=1: Overwrite bit x in flagField, byte 0, with FLAG_FIELD, bit x."), lo: 8, hi: 16 });
        regs.insert("PTP_MISC_CFG", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Miscellaneous PTP domain configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_NUM", Field { brief: Some("Port number used in portIdentity."), details: None, lo: 0, hi: 16 });
        fields.insert("PORT_NUM_SEL", Field { brief: Some("If set, lowest 6 bits in portIdentity is taken from ANA_ACL:PORT:PTP_CFG.PTP_PORT_NUM. Otherwise, portIdentity is taken from PTP_SRC_PORT_CFG.PORT_NUM."), details: None, lo: 16, hi: 17 });
        regs.insert("PTP_SRC_PORT_CFG", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("PTP domain configuration used in sourcePortIdentity"), details: None, fields });
        groups.insert("PTP_DOM", RegisterGroup { addr: Address { base: 4379, count: 3, width: 4 }, desc: "PTP domain configuration", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("VOE_LOOP_PGID_ENA", Field { brief: Some("Controls how loopback port is selected."), details: Some("0: Loop to req.port_num 1: Loop to logical port found in ANA_AC:PGID[req.port_num+VOE_LOOP_PGID_OFFSET]"), lo: 0, hi: 1 });
        regs.insert("VOE_LOOPBACK_CFG", Register { addr: Address { base: 109, count: 1, width: 1 }, brief: Some("Configuration of how VOE loopback is performed"), details: None, fields });
        groups.insert("STICKY", RegisterGroup { addr: Address { base: 4377, count: 1, width: 2 }, desc: "Sticky diagnostic status", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("PTP_DOMAIN", Field { brief: Some("Selects the PTP time domain to use when updating receiveTimestamp in Delay_Resp frames."), details: Some("0: Use time domain 0 1: Use time domain 1 2: Use time domain 2 3: Reserved."), lo: 0, hi: 2 });
        fields.insert("PTP_PORT_NUM", Field { brief: Some("Part of portNumber used in portIdentity when ANA_ACL:PTP_DOM:PTP_SRC_PORT_CFG.PORT_NUM_SEL is set. PTP_PORT_NUM specifies bits 5:0 in portNumber. Remaining bits 15:6 in portNumber are taken from ANA_ACL:PTP_DOM:PTP_SRC_PORT_CFG.PORT_NUM"), details: None, lo: 2, hi: 8 });
        regs.insert("PTP_CFG", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("PTP port configuration"), details: Some("Clock domain selection and mapping of ingress port number."), fields });
        let mut fields = HashMap::new();
        fields.insert("PTP_ALLOW_ACL_REW_ENA", Field { brief: Some("If set, and VCAP_IS2 action REW_CMD[5] is set, ANA_ACL rewrites Delay_Req frames. The following PTP fields can be modified in ANA_ACL depending on configuration in PTP_MISC_CTRL and ANA_ACL:PTP_DOM: - messageType (set to Delay_Resp) - messageLength - flagField - sourcePortIdentity - controlField - logMessageInterval - receiveTimestamp - requestingPortIdentity"), details: None, lo: 0, hi: 1 });
        fields.insert("PTP_DELAY_IP6_SEL", Field { brief: Some("IP6 PTP operation."), details: Some("0: No IP6 PTP updates. 1: IP6 PTP updates with UDP chksum updates. 2: IP6 PTP updates with UDP chksum updates, redirect frame to CPU using extraction queue PTP_DELAY_REDIR_QU. 3: IP6 PTP updates with UDP chksum clear."), lo: 2, hi: 4 });
        fields.insert("PTP_DELAY_REDIR_QU", Field { brief: Some("CPU extraction queue for PTP Delay_Resp frames redirected to the CPU."), details: None, lo: 7, hi: 10 });
        fields.insert("PTP_DELAY_REDIR_TOO_BIG_REDIR", Field { brief: Some("If set, PTP Delay_resp frames expanded beyond one cell is redirected to the CPU. If cleared, such frames are discarded."), details: None, lo: 6, hi: 7 });
        fields.insert("PTP_DELAY_REQ_CHG_LEN_ENA", Field { brief: Some("Allow length of Delay_resp with requestingPortIdentity If set, Delay_Req frames are made 10 bytes longer to include requestingPortIdentity. Appropriate header lengths (PTP, UDP, IP) are increased with 10 bytes."), details: None, lo: 4, hi: 5 });
        fields.insert("PTP_DELAY_REQ_MC_UPD_ENA", Field { brief: Some("If set, logMessageInterval in multicast Delay_Resp frames is updated with VCAP_S2 action: SWAP_MAC_ENA & DLB_OFFSET."), details: None, lo: 5, hi: 6 });
        fields.insert("PTP_DELAY_REQ_UDP_LEN52", Field { brief: Some("Require received UDP length to be 44 before PTP_DELAY_REQ_CHG_LEN_ENA takes action. Frames with UDP len different from 44 are either discarded or optional redirected by means of PTP_DELAY_REDIR_TOO_BIG_REDIR."), details: None, lo: 1, hi: 2 });
        regs.insert("PTP_MISC_CTRL", Register { addr: Address { base: 89, count: 1, width: 1 }, brief: Some("Configuration of various ACL PTP features"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DMAC_REPL_OFFSET_VAL", Field { brief: Some("Number of bits in frame's DMAC counting from LSB which are not replaced if replacing the DMAC (IS2 action ACL_RT_MODE) and reduced DMAC is enabled (IS2 action SAM_SEQ_ENA). New DMAC is provided by IS2 action ACL_MAC. For example, if set to 16, the 16 LSB bits in the frame's DMAC are not replaced while the 32 MSB bits are replaced with corresponding 32 bits from ACL_MAC."), details: None, lo: 18, hi: 24 });
        fields.insert("IP_SWAP_IP4_TTL_ENA", Field { brief: Some("Replace TTL with value configured in IP_SWAP_IP4_TTL_VAL when swapping IPv4 addresses."), details: None, lo: 0, hi: 1 });
        fields.insert("IP_SWAP_IP4_TTL_VAL", Field { brief: Some("New TTL value when swapping IPv4 addresses."), details: None, lo: 2, hi: 10 });
        fields.insert("IP_SWAP_IP6_HOPC_ENA", Field { brief: Some("Replace hop count with value configured in IP_SWAP_IP6_HOPC_VAL when swapping IPv6 addresses."), details: None, lo: 1, hi: 2 });
        fields.insert("IP_SWAP_IP6_HOPC_VAL", Field { brief: Some("New hop count value when swapping IPv6 addresses."), details: None, lo: 10, hi: 18 });
        regs.insert("SWAP_IP_CTRL", Register { addr: Address { base: 90, count: 1, width: 1 }, brief: Some("Configuration of various swap features"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SIP", Field { brief: Some("New source IP address used when frame's IP addresses are swapped and the original destination IP address was a multicast address. IP address swapping is enabled in VCAP_IS2 action ACL_RT_MODE. IPv4: Each entry configures one IPv4 address. IPv6: Four consecutive entries configures one IPv6 address. Entries must start at 4 x n, n=0, 1, ..., 7. First entry encodes bits 31:0 of IPv6 address, second entry encoded bits 63:32, and so on."), details: None, lo: 0, hi: 32 });
        regs.insert("SWAP_SIP", Register { addr: Address { base: 57, count: 32, width: 1 }, brief: Some("Source IP table used for multicast IP address swapping"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SEC_ENA", Field { brief: Some("Enable/disable VCAP_IS2 lookups. Bit[0]: Relates to first lookup in VCAP_IS2 Bit[1]: Relates to second lookup in VCAP_IS2"), details: Some("0: Disable 1: Enable."), lo: 0, hi: 2 });
        fields.insert("SEC_ROUTE_HANDLING_ENA", Field { brief: Some("For frames to be routed, enable/disable the use of IRLEG VID and ERLEG VID as the value for the VID field in the VCAP_IS2 keys. First VCAP_IS2 lookup uses IRLEG VID, second lookup uses ERLEG VID."), details: Some("0: Disable 1: Enable."), lo: 26, hi: 27 });
        fields.insert("SEC_TYPE_ARP_ENA", Field { brief: Some("For ARP frames (EtherType 0x0806), enable matching against control entries of type ARP in VCAP_IS2. Otherwise, ARP frames are matched against control entries of type MAC_ETYPE. Bit[0]: Relates to first lookup in VCAP_IS2 Bit[1]: Relates to second lookup in VCAP_IS2"), details: Some("0: Disable 1: Enable."), lo: 6, hi: 8 });
        fields.insert("SEC_TYPE_IP4_OTHER_ENA", Field { brief: Some("For IPv4 frames, enable matching against control entries of type IP4_OTHER in VCAP_IS2. Otherwise, IPv4 frames are matched against control entries of type MAC_ETYPE. Bit[0]: Relates to first lookup in VCAP_IS2 Bit[1]: Relates to second lookup in VCAP_IS2"), details: Some("0: Disable 1: Enable."), lo: 8, hi: 10 });
        fields.insert("SEC_TYPE_IP4_TCPUDP_ENA", Field { brief: Some("For IPv4 TCP/UDP frames, enable matching against control entries of type IP_TCP_UDP in VCAP_IS2. Otherwise, IPv4 TCP/UDP frames are handled as IPv4 Other frames, see SEC_TYPE_IP4_OTHER_ENA. Bit[0]: Relates to first lookup in VCAP_IS2 Bit[1]: Relates to second lookup in VCAP_IS2"), details: Some("0: Disable 1: Enable."), lo: 10, hi: 12 });
        fields.insert("SEC_TYPE_IP4_VID_ENA", Field { brief: Some("For IPv4 multicast frames, enable matching against control entries of type IP4_VID in VCAP_IS2. Otherwise, IPv4 multicast frames are handled as either IPv4 TCP/UDP frames or IPv4 Other frames, see SEC_TYPE_IP4_TCPUDP_ENA and SEC_TYPE_IP4_OTHER_ENA. Bit[0]: Relates to first lookup in VCAP_IS2 Bit[1]: Relates to second lookup in VCAP_IS2"), details: Some("0: Disable 1: Enable."), lo: 12, hi: 14 });
        fields.insert("SEC_TYPE_IP6_OTHER_ENA", Field { brief: Some("For IPv6 frames, enable matching against control entries of type IP6_OTHER in VCAP_IS2. Otherwise, IPv6 Other frames are handled as IPv6 standard frames, SEC_TYPE_IP6_STD_ENA. Bit[0]: Relates to first lookup in VCAP_IS2 Bit[1]: Relates to second lookup in VCAP_IS2"), details: Some("0: Disable 1: Enable."), lo: 14, hi: 16 });
        fields.insert("SEC_TYPE_IP6_STD_ENA", Field { brief: Some("For IPv6 frames, enable matching against control entries of type IP6_STD in VCAP_IS2. Otherwise, IPv6 frames are handled as IPv4 frames, see SEC_TYPE_IP6_TCPUDP_OTHER_ENA. Bit[0]: Relates to first lookup in VCAP_IS2 Bit[1]: Relates to second lookup in VCAP_IS2"), details: Some("0: Disable 1: Enable."), lo: 18, hi: 20 });
        fields.insert("SEC_TYPE_IP6_TCPUDP_ENA", Field { brief: Some("For IPv6 TCP/UDP frames, enable matching against control entries of type IP6_TCP_UDP in VCAP_IS2. Otherwise, IPv6 TCP/UDP frames are handled as IPv6 standard frames, SEC_TYPE_IP6_STD_ENA. Bit[0]: Relates to first lookup in VCAP_IS2 Bit[1]: Relates to second lookup in VCAP_IS2"), details: Some("0: Disable 1: Enable."), lo: 16, hi: 18 });
        fields.insert("SEC_TYPE_IP6_TCPUDP_OTHER_ENA", Field { brief: Some("For IPv6 frames, enable matching against control entries of types IP4_TCP_UDP and IP4_OTHER in VCAP_IS2. The SIP and DIP fields of IP4_TCP_UDP and IP4_OTHER control entries are used to match against bits 63:0 of IPv6 SIP. Bit[0]: Relates to first lookup in VCAP_IS2 Bit[1]: Relates to second lookup in VCAP_IS2"), details: Some("0: Disable the classification. 1: Enable the classification."), lo: 22, hi: 24 });
        fields.insert("SEC_TYPE_IP6_VID_ENA", Field { brief: Some("For IPv6 multicast frames, enable matching against control entries of type IP6_VID in VCAP_IS2. Otherwise, IPv6 multicast frames are handled as either IPv6 TCP/UDP frames or IPv6 Other frames, see SEC_TYPE_IP6_TCPUDP_ENA and SEC_TYPE_IP6_OTHER_ENA. Bit[0]: Relates to first lookup in VCAP_IS2 Bit[1]: Relates to second lookup in VCAP_IS2"), details: Some("0: Disable 1: Enable."), lo: 20, hi: 22 });
        fields.insert("SEC_TYPE_MAC_LLC_ENA", Field { brief: Some("For LLC frames, enable matching against control entries of type MAC_LLC in VCAP_IS2. Otherwise, LLC frames are matched against control entries of type MAC_ETYPE. LLC frames are identified as frames with EtherType < 0x0600 that are not SNAP frames. Note that SNAP frames can be handled as LLC frames by disabling SEC_TYPE_MAC_SNAP_ENA. Bit[0]: Relates to first lookup in VCAP_IS2 Bit[1]: Relates to second lookup in VCAP_IS2"), details: Some("0: Disable 1: Enable."), lo: 2, hi: 4 });
        fields.insert("SEC_TYPE_MAC_SNAP_ENA", Field { brief: Some("For SNAP frames, enable matching against control entries of type MAC_SNAP in VCAP_IS2. Otherwise SNAP frames frames are handled as LLC frames, see SEC_TYPE_MAC_LLC_ENA. SNAP frames are identified by EtherType < 0x0600 DSAP = 0xAA SSAP = 0xAA CTRL = 0x03 Bit[0]: Relates to first lookup in VCAP_IS2 Bit[1]: Relates to second lookup in VCAP_IS2"), details: Some("0: Disable 1: Enable."), lo: 4, hi: 6 });
        fields.insert("SEC_TYPE_OAM_ENA", Field { brief: Some("For OAM frames (with up to three VLAN tags), enable matching against control entries of type OAM in VCAP_IS2. Otherwise, OAM frames are matched against control entries of type MAC_ETYPE. OAM frames are identified by the following EtherType values: 0x8902 - ITU-T Y.1731 0x8809 - Link Level OAM 0x88EE - MEF-16 (E-LMI) Bit[0]: Relates to first lookup in VCAP_IS2 Bit[1]: Relates to second lookup in VCAP_IS2"), details: Some("0: Disable 1: Enable."), lo: 24, hi: 26 });
        regs.insert("VCAP_S2_CFG", Register { addr: Address { base: 0, count: 57, width: 1 }, brief: Some("VCAP S2 configuration"), details: Some("Configuration of advanced classification per port. For the 2-bit fields of this register the following applies: Bit[0]: Relates to first lookup in VCAP_IS2 Bit[1]: Relates to second lookup in VCAP_IS2"), fields });
        let mut fields = HashMap::new();
        fields.insert("ACL_RT_EGR_RLEG_STAT_MODE", Field { brief: Some("Controls how to update routing statistics events for egress ACL actions."), details: Some("0: If routed frame is dropped by VCAP_IS2 rule, then clear ivmid_ip_uc_received/ivmid_ip_mc_received (as if frame never left the router) 1: If routed frame is dropped by VCAP_IS2 rule, then leave ivmid_ip_uc_received/ivmid_ip_mc_received set (as if frame did leave the router and was dropped in the L2 switch)"), lo: 11, hi: 12 });
        fields.insert("ACL_RT_FORCE_ES0_VID_ENA", Field { brief: Some("If set, force use of VID key type in VCAP_ES0 when routing in ANA_ACL."), details: Some("0: Disable 1: Enable."), lo: 10, hi: 11 });
        fields.insert("ACL_RT_IGR_RLEG_STAT_MODE", Field { brief: Some("Controls how to update routing statistics events for ingress ANA_ACL actions."), details: Some("0: UC: If frame is dropped by VCAP_IS2 rule, then clear ivmid_ip_uc_received (as if frame never reached the router) MC: If frame is dropped by VCAP_IS2 rule, then leave ivmid_ip_mc_received unchanged (as if frame may reach the router) 1: If frame is dropped by VCAP_IS2 rule, then clear ivmid_ip_uc_received/ivmid_ip_mc_received (as if frame never reached the router, but was dropped in the L2 switch)"), lo: 12, hi: 13 });
        fields.insert("ACL_RT_SEL", Field { brief: Some("Controls routing related frame edits in ANA_ACL block. By default, routing related frame edits are done in REW, but when combining routing with PTP, ANA_ACL must be configured to change DMAC to next-hop DMAC in order to allow other information to be stored in the IFH. ANA_ACL can rewrite the following routing related fields: 1) Change DMAC to next-hop MAC address (as determined by ANA_L3). 2) Set IFH.FWD.DST_MODE=ENCAP to prevent REW from doing routing related frame editting. Decrement of TTL/Hop limit is still performed by REW. When performing routing related frame edits in ANA_ACL, editing of SMAC must be performed by ANA_L3 (ANA_L3::ROUTING_CFG.RT_SMAC_UPDATE_ENA)."), details: Some("0: Disable routing in ANA_ACL block. 1: Enable routing related frame edits independently of VCAP_IS2 action ACL_RT_MODE. 2: Enable routing related frame edits if VCAP_IS2 action ACL_RT_MODE allows routing."), lo: 5, hi: 7 });
        fields.insert("ACL_RT_UPDATE_CL_VID_ENA", Field { brief: Some("If set, classified VID is set to egress VID."), details: Some("0: Disable 1: Enable."), lo: 9, hi: 10 });
        fields.insert("ACL_RT_UPDATE_GEN_IDX_ERLEG_ENA", Field { brief: Some("If set, IFH.GEN_IDX is set to egress RLEG."), details: Some("0: Disable 1: Enable."), lo: 8, hi: 9 });
        fields.insert("ACL_RT_UPDATE_GEN_IDX_EVID_ENA", Field { brief: Some("If set, IFH.GEN_IDX is set to egress VID."), details: Some("0: Disable 1: Enable."), lo: 7, hi: 8 });
        fields.insert("CPU_IGR_MASK_ENA", Field { brief: Some("Enable VCAP_IS2 key field IGR_PORT_MASK_SEL=3 for CPU injected frames."), details: Some("0: Disable 1: Enable."), lo: 0, hi: 1 });
        fields.insert("FP_VS2_IGR_MASK_ENA", Field { brief: Some("Enable VCAP_IS2 key field IGR_PORT_MASK_SEL=3 for frames received with VStaX header."), details: Some("0: Disable 1: Enable."), lo: 2, hi: 3 });
        fields.insert("LBK_IGR_MASK_SEL3_ENA", Field { brief: Some("Force VCAP_IS2 lookup to use IGR_PORT_MASK_SEL=3 for looped frames instead of IGR_PORT_MASK_SEL=1."), details: Some("0: Disable 1: Enable."), lo: 4, hi: 5 });
        fields.insert("MASQ_IGR_MASK_ENA", Field { brief: Some("Enable VCAP_IS2 key field IGR_PORT_MASK_SEL=2 for masqueraded frames."), details: Some("0: Disable 1: Enable."), lo: 3, hi: 4 });
        fields.insert("PAG_FORCE_VID_ENA", Field { brief: Some("Controls if PAG(7) forces VID for service frames (ISDX > 0). Bit[0]: Relates to first lookup in VCAP_IS2 Bit[1]: Relates to second lookup in VCAP_IS2"), details: Some("0: Disable 1: Force VID when isdx >0"), lo: 14, hi: 16 });
        fields.insert("VD_IGR_MASK_ENA", Field { brief: Some("Enable VCAP_IS2 key field IGR_PORT_MASK_SEL=3 for frames from VD0 or VD1."), details: Some("0: Disable 1: Enable."), lo: 1, hi: 2 });
        fields.insert("VLAN_PIPELINE_ACT_ENA", Field { brief: Some("If set, PIPELINE_PT is set to ANA_VLAN and PIPELINE_ACT is set to XTR if the frame is discarded in ANA_L3."), details: None, lo: 13, hi: 14 });
        regs.insert("VCAP_S2_MISC_CTRL", Register { addr: Address { base: 91, count: 1, width: 1 }, brief: Some("Configuration of various features"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RNG_TYPE_SEL", Field { brief: Some("Selected field matched against the range"), details: Some("0: Idle (No match) 1: TCP / UDP dport value is matched against range 2: TCP / UDP sport value is matched against range 3: TCP / UDP dport or sport values are matched against range 4: Classified VIDvalue is matched against range 5: Classified DSCP value is matched against range 6: Selected value from frame is matched against range, see ANA_ACL::VCAP_S2_RNG_OFFSET_CFG for details."), lo: 0, hi: 3 });
        regs.insert("VCAP_S2_RNG_CTRL", Register { addr: Address { base: 92, count: 8, width: 1 }, brief: Some("Configuration of TCP range generation"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RNG_OFFSET_POS", Field { brief: Some("16-bit offset position of selectable range matcher input counting from the EtherType (up to three VLAN tags skipped)."), details: Some("0: EtherType 1: frame byte 0 and 1 after EtherType ... n: frame byte 2n-2 and 2n-1 after EtherType"), lo: 0, hi: 6 });
        regs.insert("VCAP_S2_RNG_OFFSET_CFG", Register { addr: Address { base: 108, count: 1, width: 1 }, brief: Some("Configuration of selected range generation"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RNG_MAX_VALUE", Field { brief: Some("Upper range value"), details: None, lo: 16, hi: 32 });
        fields.insert("RNG_MIN_VALUE", Field { brief: Some("Lower range value"), details: None, lo: 0, hi: 16 });
        regs.insert("VCAP_S2_RNG_VALUE_CFG", Register { addr: Address { base: 100, count: 8, width: 1 }, brief: Some("Configuration of  matcher range generation"), details: None, fields });
        groups.insert("VCAP_S2", RegisterGroup { addr: Address { base: 4267, count: 1, width: 110 }, desc: "Common configurations used by VCAP_IS2", regs });
        out.insert("ANA_ACL", Target { desc: "Access Control List sub block of the Analyzer", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CCM_LM_INFO_VLD", Field { brief: Some("Indicates whether this entry in the RAM contains valid CCM-LM sample values."), details: None, lo: 11, hi: 12 });
        fields.insert("CCM_LM_VOE_IDX", Field { brief: Some("The number of the VOE for which the LM information was received."), details: None, lo: 0, hi: 11 });
        regs.insert("CCM_LM_INFO_REG", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Temp CCM-LM info"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CCM_LM_TX_B", Field { brief: Some("Contains the sampled value of CCM_LM.tx_fc_b from the last valid CCM_LM frame."), details: None, lo: 0, hi: 32 });
        regs.insert("CCM_LM_TX_B_REG", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("CCM-LM sample"), details: Some("Contains the sampled value of CCM_LM.tx_fc_b from the last valid CCM_LM frame."), fields });
        let mut fields = HashMap::new();
        fields.insert("PATH_CNT_FRM", Field { brief: Some("Determines if the current frame should be counted by the Path LM counter, based on the color / mapping and possibly being killed in the ingress DLB."), details: None, lo: 0, hi: 1 });
        fields.insert("SRV_CNT_FRM", Field { brief: Some("Determines if the current frame should be counted by the Service LM counter, based on the color / mapping and possibly being killed in the ingress DLB."), details: None, lo: 1, hi: 2 });
        regs.insert("LM_CNT_FRAME", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Temp LM cnt"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_BYTE_CNT_LSB", Field { brief: Some("See Register Description."), details: None, lo: 0, hi: 32 });
        regs.insert("PORT_BYTE_CNT_LSB", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Byte count of all frames passing through the Port VOE (LSB)"), details: Some("Byte count of all frames passing through the Port VOE. Whenever this RAM is read, the value of this register will be sampled into the following register: * ANA_AC_OAM_MOD::RD_LAST_PORT_BYTE_CNT_LSB.RD_LAST_PORT_BYTE_CNT_LSB (ANA) * REW::RD_LAST_PORT_BYTE_CNT_LSB.RD_LAST_PORT_BYTE_CNT_LSB (REW)"), fields });
        let mut fields = HashMap::new();
        fields.insert("TEMP_CNT_VAL", Field { brief: None, details: None, lo: 0, hi: 16 });
        regs.insert("TEMP_CNT_REG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("LM temp count"), details: None, fields });
        groups.insert("OAM_PDU_MOD_CONT", RegisterGroup { addr: Address { base: 10240, count: 110, width: 8 }, desc: "VOE additional information", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CCM_LM_RX_B", Field { brief: Some("Contains the sampled value of CCM_LM.rx_fc_b from the last valid CCM_LM frame."), details: None, lo: 0, hi: 32 });
        regs.insert("CCM_LM_RX_B_REG", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("CCM-LM sample"), details: Some("Contains the sampled value of CCM_LM.rx_fc_b from the last valid CCM_LM frame."), fields });
        let mut fields = HashMap::new();
        fields.insert("PTP_DOMAIN", Field { brief: None, details: None, lo: 0, hi: 2 });
        regs.insert("DM_PTP_DOMAIN_CFG", Register { addr: Address { base: 0, count: 53, width: 1 }, brief: Some("Port PTP domain select"), details: Some("Jaguar2-R supports three PTP time domains. The Delay Measurements (Y.1731) uses the PTP timing for updating the DM PDUs. For this to work, each port on the switch must be configured for which PTP timedomain to use. This is done by configuring this register. The settings must be the same in the REW and the ANA_AC instatiation of the OAM_PDU_MOD block."), fields });
        let mut fields = HashMap::new();
        fields.insert("RD_LAST_PORT_BYTE_CNT_LSB", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("RD_LAST_PORT_BYTE_CNT_LSB", Register { addr: Address { base: 56, count: 1, width: 1 }, brief: Some("PORT_BYTE_CNT_LSB sample register."), details: Some("Whenever either of the bit fields the following RAM are read: * ANA_AC_OAM_MOD:VOE_SRV_LM_CNT (ANA) * REW:VOE_SRV_LM_CNT (REW) this register will sample the value of the following bit field: * ANA_AC_OAM_MOD:VOE_PORT_LM_CNT:PORT_BYTE_CNT_LSB.PORT_BYTE_CNT_LSB (ANA) * REW:VOE_PORT_LM_CNT:PORT_BYTE_CNT_LSB.PORT_BYTE_CNT_LSB (REW)"), fields });
        let mut fields = HashMap::new();
        fields.insert("RD_LAST_PORT_BYTE_CNT_MSB", Field { brief: Some("See register description."), details: None, lo: 0, hi: 8 });
        regs.insert("RD_LAST_PORT_BYTE_CNT_MSB", Register { addr: Address { base: 55, count: 1, width: 1 }, brief: Some("PORT_BYTE_CNT_MSB sample register."), details: Some("Whenever either of the bit fields the following RAM are read: * ANA_AC_OAM_MOD:VOE_SRV_LM_CNT (ANA) * REW:VOE_SRV_LM_CNT (REW) this register will sample the value of the following bit field: * ANA_AC_OAM_MOD:VOE_PORT_LM_CNT:PORT_BYTE_CNT_MSB.PORT_BYTE_CNT_MSB (ANA) * REW:VOE_PORT_LM_CNT:PORT_BYTE_CNT_MSB.PORT_BYTE_CNT_MSB (REW)"), fields });
        let mut fields = HashMap::new();
        fields.insert("RD_LAST_PORT_FRM_CNT_LSB", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("RD_LAST_PORT_FRM_CNT_LSB", Register { addr: Address { base: 54, count: 1, width: 1 }, brief: Some("PORT_NON_LM_CNT_LSB sample register."), details: Some("Whenever either of the bit fields the following RAM are read: * ANA_AC_OAM_MOD:VOE_SRV_LM_CNT (ANA) * REW:VOE_SRV_LM_CNT (REW) this register will sample the value of the following bit field: * ANA_AC_OAM_MOD:VOE_PORT_LM_CNT:PORT_FRM_CNT_LSB.PORT_FRM_CNT_LSB (ANA) * REW:VOE_PORT_LM_CNT:PORT_FRM_CNT_LSB.PORT_FRM_CNT_LSB (REW)"), fields });
        let mut fields = HashMap::new();
        fields.insert("RD_LAST_PORT_LM_CNT_LSB", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("RD_LAST_PORT_LM_CNT_LSB", Register { addr: Address { base: 53, count: 1, width: 1 }, brief: Some("PORT_LM_CNT_LSB sample register."), details: Some("Whenever either of the bit fields the following RAM are read: * ANA_AC_OAM_MOD:VOE_SRV_LM_CNT (ANA) * REW:VOE_SRV_LM_CNT (REW) this register will sample the value of the following bit field: * ANA_AC_OAM_MOD:VOE_PORT_LM_CNT:PORT_LM_CNT_LSB.PORT_LM_CNT_LSB (ANA) * REW:VOE_PORT_LM_CNT:PORT_LM_CNT_LSB.PORT_LM_CNT_LSB (REW)"), fields });
        groups.insert("PDU_MOD_CFG", RegisterGroup { addr: Address { base: 9888, count: 1, width: 57 }, desc: "OAM_PDU_MOD misc. configuration", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("PORT_BYTE_CNT_MSB", Field { brief: Some("See Register Description."), details: None, lo: 0, hi: 8 });
        regs.insert("PORT_BYTE_CNT_MSB", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Byte count of all frames passing through the Port VOE (MSB)"), details: Some("Byte count of all frames passing through the Port VOE. Whenever this RAM is read, the value of this register will be sampled into the following register: * ANA_AC_OAM_MOD::RD_LAST_PORT_BYTE_CNT_MSB.RD_LAST_PORT_BYTE_CNT_MSB (ANA) * REW::RD_LAST_PORT_BYTE_CNT_MSB.RD_LAST_PORT_BYTE_CNT_MSB (REW)"), fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_FRM_CNT_LSB", Field { brief: Some("See Register Description."), details: None, lo: 0, hi: 32 });
        regs.insert("PORT_FRM_CNT_LSB", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Count all the frames which pass through the Port VOE"), details: Some("This counter counts all the frames which pass though the Port VOE. Whenever this RAM is read, the value of this register will be sampled into the following register: * ANA_AC_OAM_MOD::RD_LAST_PORT_FRM_CNT_LSB.RD_LAST_PORT_FRM_CNT_LSB (ANA) * REW::RD_LAST_PORT_FRM_CNT_LSB.RD_LAST_PORT_FRM_CNT_LSB (REW)"), fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_LM_CNT_LSB", Field { brief: Some("See Register Description."), details: None, lo: 0, hi: 32 });
        regs.insert("PORT_LM_CNT_LSB", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Count selected OAM PDU received by MEP Counter"), details: Some("Implements the OAM VOE LM port counters. Depending on whether the OAM_PDU_MOD block is instantiated in the REW or the ANA these counters will be either egress (REW) or ingress (ANA) counters. Y.1731 LM counters count frames and are 32 bit wide. Whenever this RAM is read, the value of this register will be sampled into the following register: * ANA_AC_OAM_MOD::RD_LAST_PORT_LM_CNT_LSB.RD_LAST_PORT_LM_CNT_LSB (ANA) * REW::RD_LAST_PORT_LM_CNT_LSB.RD_LAST_PORT_LM_CNT_LSB (REW)"), fields });
        let mut fields = HashMap::new();
        fields.insert("SRV_LM_CNT_LSB", Field { brief: None, details: None, lo: 0, hi: 32 });
        regs.insert("SRV_LM_CNT_LSB", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Service LM counters pr. priority"), details: Some("Implements the OAM VOE LM counters. Depending on whether the OAM_PDU_MOD block is instantiated in the REW or the ANA these counters will be either egress (REW) or ingress (ANA) counters. Y.1731 LM counters count frames and are 32 bit wide."), fields });
        groups.insert("VOE_PORT_LM_CNT", RegisterGroup { addr: Address { base: 8192, count: 424, width: 4 }, desc: "OAM LM port counters pr. priority", regs });
        let regs = HashMap::new();
        groups.insert("VOE_SRV_LM_CNT", RegisterGroup { addr: Address { base: 0, count: 8192, width: 1 }, desc: "OAM Service LM counters pr. priority", regs });
        out.insert("ANA_AC_OAM_MOD", Target { desc: "This block os part of the Vitesse OAM MEP Processor (VOP). It is directly controlled by the VOP and performs all frame modification related OAM functions. This block is included in both the REW and the ANA_AC. The HW support for implementing an OAM MEP is implemented in a sub block, known as: Vitesse OAM Endpoint (VOE). The VOP includes the following: * 256 Service / Path VOEs * 11 Port VOEs", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CIR_INC_DP_VAL", Field { brief: Some("Configuration of the drop precedence change for green frames being remarked to yellow. For such frames, the DP level will be incremented with CIR_INC_DP_VAL."), details: Some("0: DP is not increased. n: DP is increased with n for PIR traffic."), lo: 12, hi: 14 });
        fields.insert("COLOR_AWARE_LVL", Field { brief: Some("Configuration of dual leaky bucket color awareness. Frames with DP below or equal to COLOR_AWARE_LVL is treated as green. Frames with DP above COLOR_AWARE_LVL are treated as yellow."), details: Some("0: DLB policer is color aware. Incoming frames with DP=0 are green and frames with DP>0 are yellow. 1: DLB policer is color aware. Incoming frames with DP<=1 are green and frames with DP>1 are yellow. 2: DLB policer is color aware. Incoming frames with DP<=2 are green and frames with DP>2 are yellow. 3: DLB policer is color unaware. All incoming frames are green."), lo: 14, hi: 16 });
        fields.insert("COUPLING_MODE", Field { brief: Some("Set Coupling Flag (MEF CF). Depending on the setting of COUPLING_MODE, LB_CFG[0] and LB_CFG[1] must be configured as follows: COUPLING_MODE=0: LB_CFG[0].RATE_VAL  must be configured to MEF CIR LB_CFG[0].THRES_VAL must be configured to MEF CBS LB_CFG[1].RATE_VAL  must be configured to MEF EIR LB_CFG[1].THRES_VAL must be configured to MEF EBS COUPLING_MODE=1: LB_CFG[0].RATE_VAL  must be configured to MEF CIR LB_CFG[0].THRES_VAL must be configured to MEF CBS LB_CFG[1].RATE_VAL  must be configured to MEF EIR + MEF CIR LB_CFG[1].THRES_VAL must be configured to MEF EBS + MEF CBS"), details: Some("0: CF=0 1: CF=1"), lo: 16, hi: 17 });
        fields.insert("ENCAP_DATA_DIS", Field { brief: Some("Configures if stripped encapsulation data (normalized data) is policed by the policer."), details: Some("0: Encapsulation data is counted as frame data. 1: Encapsulation data in not counted as frame data."), lo: 9, hi: 10 });
        fields.insert("GAP_VAL", Field { brief: Some("Value added to each frame before updating the bucket. Gap value range: -64 to +63 in two's complement format. Setting GAP_VALUE to 20 corresponds to a line-rate measurement, since on the line each frame will be preceded by 12 bytes of IFG and 8 bytes of preamble. Setting GAP_VALUE to 0 corresponds to a data-rate measurement."), details: Some("0x40: -64 0x41: -63 ... 0x7F: -1 0x00: 0 0x01: 1 ... 0x3F: 63"), lo: 2, hi: 9 });
        fields.insert("TIMESCALE_VAL", Field { brief: Some("TIMESCALE_VAL and BASE_TICK_CNT controls the the rate interval as well as the rate granularity available for LB rate configuration The rate granularity is calculated as follows: 8 / (BASE_TICK_CNT*1e-10 * 2^(3 * TIMESCALE_VAL) The rate granularity also becomes the smallest configurable rate. The largest configurable rate is granularity * (2**<width of RATE_VAL>-2)"), details: Some("Assuming BASE_TICK_CNT= 9765, RATE_VAL width = 11 bits: 0: Granularity: 8,192,524bps. Range: 8193kbps - 16.7Gbps 1: Granularity: 1,024,066bps. Range 1024kbps - 2Gbps 2: Granularity: 128,008bps. Range: 128kbps - 262Mbps 3: Granularity: 16,001bps. Range: 16kbps - 32Mbps"), lo: 0, hi: 2 });
        fields.insert("TIMESTAMP_VAL", Field { brief: Some("The time - in BASE_TICK_CNTs - at which last leak was performed."), details: None, lo: 17, hi: 28 });
        fields.insert("TRAFFIC_TYPE_MASK", Field { brief: Some("Configures action to be applied to policed frames."), details: Some("0: No action. 1: Remove front ports from frame's destination port set. 2: Remove CPU ports from frame's destination port set. 3: Remove both front ports and CPU ports from frame's destination port set."), lo: 10, hi: 12 });
        regs.insert("DLB_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Configuration of DLB policer"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CIR_EXCEEDED_STICKY", Field { brief: Some("Set when the frame rate is exceeding the Committed Information Rate. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occured 1: CIR exceeded"), lo: 1, hi: 2 });
        fields.insert("CIR_PIR_OPEN_STICKY", Field { brief: Some("Set when the frame rate is below both the Committed Information Rate and the Peak Information Rate. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occured 1: Traffic received without triggering CIR and PIR policing"), lo: 0, hi: 1 });
        fields.insert("LEAK_SCAN_COMPLETED_STICKY", Field { brief: Some("Set when a LB scan completes. Bit is cleared by writing a 1."), details: Some("0: No event has occured 1: Leak scan completes"), lo: 31, hi: 32 });
        fields.insert("LEAK_SCAN_STARTED_STICKY", Field { brief: Some("Set when a LB scan starts. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occured 1: Leak scan started"), lo: 30, hi: 31 });
        fields.insert("LEAK_START_DELAYED_STICKY", Field { brief: Some("Set when a LB scan could not start because a scan is already ongoing. If this occur, BASE_TICK_CNT is set too low and must be increased. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occured 1: Leak scan could not start at time"), lo: 29, hi: 30 });
        fields.insert("PIR_EXCEEDED_STICKY", Field { brief: Some("Set when the frame rate is exceeding the Peak Information Rate. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occured 1: PIR exceeded"), lo: 2, hi: 3 });
        regs.insert("DLB_STICKY", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("LB policer diagnostic"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RATE_VAL", Field { brief: Some("Specify rate in steps of configured granularity. The rate granularity is configured in TIMESCALE_VAL."), details: Some("0: Disable leak. For THRES_VAL = 0 bucket is always closed. For THRES_VAL > 0, the configured burst size is available. 1: 1 * granularity 2: 2 * granularity ... max_value-1: (max_value-1)*granularity max_value: Disable leaky bucket (always open)"), lo: 0, hi: 11 });
        fields.insert("THRES_VAL", Field { brief: Some("Policer threshold size (a.ka. burst capacity). Unit is 2048 bytes"), details: Some("0: Threshold = 0 bytes (no burst allowed) 1: Threshold = 2048 bytes n: Threshold = n x 2048 bytes"), lo: 16, hi: 23 });
        regs.insert("LB_CFG", Register { addr: Address { base: 2, count: 2, width: 1 }, brief: Some("Threshold and rate configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DP_BYPASS_LVL", Field { brief: Some("Configuration of Drop Precedence bypass level. Frames with DP below DP_BYPASS_LVL bypass the policer (frames are never policed and the bucket is not updated with the frames)."), details: Some("0: No frames bypass the policer 1: Frames with DP = 0 bypass the policer 2: Frames with DP = 0 or 1 bypass the policer 3: Frames with DP = 0, 1 or 2 bypass the policer"), lo: 1, hi: 3 });
        fields.insert("FRAME_RATE_ENA", Field { brief: Some("Enables frame rate mode for the policer, where policer rates are measured in frames per second instead of bits per second."), details: Some("0: Rates measured in bits per second 1: Rates measured in frames per second"), lo: 0, hi: 1 });
        regs.insert("MISC_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Configuration of various LB policer handles"), details: None, fields });
        groups.insert("BDLB", RegisterGroup { addr: Address { base: 40960, count: 1024, width: 8 }, desc: "Leaky bucket configuration & status", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("BUCKET_VAL", Field { brief: Some("Number of bytes in leaky bucket."), details: None, lo: 9, hi: 28 });
        fields.insert("REM_VAL", Field { brief: Some("Number of subbytes in leaky bucket."), details: None, lo: 0, hi: 9 });
        regs.insert("LB_BUCKET_VAL", Register { addr: Address { base: 5, count: 3, width: 1 }, brief: Some("Configuration of leaky bucket value"), details: Some("Configures each Single LB"), fields });
        let mut fields = HashMap::new();
        fields.insert("RATE_VAL", Field { brief: Some("Specify rate in steps of configured granularity. The rate granularity is configured in TIMESCALE_VAL."), details: Some("0: Disable leak. For THRES_VAL = 0 bucket is always closed. For THRES_VAL > 0, the configured burst size is available. 1: 1 * granularity 2: 2 * granularity ... max_value-1: (max_value-1)*granularity max_value: Disable leaky bucket (always open)"), lo: 0, hi: 11 });
        fields.insert("THRES_VAL", Field { brief: Some("Policer threshold size (a.ka. burst capacity). Unit is 2048 bytes"), details: Some("0: Threshold = 0 bytes (no burst allowed) 1: Threshold = 2048 bytes n: Threshold = n x 2048 bytes"), lo: 16, hi: 23 });
        regs.insert("LB_CFG", Register { addr: Address { base: 2, count: 3, width: 1 }, brief: Some("Threshold and rate configuration"), details: Some("Configures each Single LB"), fields });
        let mut fields = HashMap::new();
        fields.insert("FRAME_RATE_ENA", Field { brief: Some("Enables frame rate mode for the policer, where policer rates are measured in frames per second instead of bits per second."), details: Some("0: Rates measured in bits per second 1: Rates measured in frames per second"), lo: 0, hi: 1 });
        regs.insert("MISC_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Configuration of various LB policer handles"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ENCAP_DATA_DIS", Field { brief: Some("Configures if stripped encapsulation data (normalized data) is policed by the policer."), details: Some("0: Encapsulation data is counted as frame data. 1: Encapsulation data in not counted as frame data."), lo: 9, hi: 10 });
        fields.insert("GAP_VAL", Field { brief: Some("Value added to each frame before updating the bucket. Gap value range: -64 to +63 in two's complement format. Setting GAP_VALUE to 20 corresponds to a line-rate measurement, since on the line each frame will be preceded by 12 bytes of IFG and 8 bytes of preamble. Setting GAP_VALUE to 0 corresponds to a data-rate measurement."), details: Some("0x40: -64 0x41: -63 ... 0x7F: -1 0x00: 0 0x01: 1 ... 0x3F: 63"), lo: 2, hi: 9 });
        fields.insert("TIMESCALE_VAL", Field { brief: Some("TIMESCALE_VAL and BASE_TICK_CNT controls the the rate interval as well as the rate granularity available for LB rate configuration The rate granularity is calculated as follows: 8 / (BASE_TICK_CNT*1e-10 * 2^(3 * TIMESCALE_VAL) The rate granularity also becomes the smallest configurable rate. The largest configurable rate is granularity * (2**<width of RATE_VAL>-2)"), details: Some("Assuming BASE_TICK_CNT= 9765, RATE_VAL width = 11 bits: 0: Granularity: 8,192,524bps. Range: 8193kbps - 16.7Gbps 1: Granularity: 1,024,066bps. Range 1024kbps - 2Gbps 2: Granularity: 128,008bps. Range: 128kbps - 262Mbps 3: Granularity: 16,001bps. Range: 16kbps - 32Mbps"), lo: 0, hi: 2 });
        fields.insert("TIMESTAMP_VAL", Field { brief: Some("The time - in BASE_TICK_CNTs - at which last leak was performed."), details: None, lo: 10, hi: 21 });
        regs.insert("SLB_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Configuration of BUM SLB policer"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LEAK_SCAN_COMPLETED_STICKY", Field { brief: Some("Set when a LB scan completes. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occured 1: Leak scan completes"), lo: 31, hi: 32 });
        fields.insert("LEAK_SCAN_STARTED_STICKY", Field { brief: Some("Set when a LB scan starts. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occured 1: Leak scan started"), lo: 30, hi: 31 });
        fields.insert("LEAK_START_DELAYED_STICKY", Field { brief: Some("Set when a LB scan could not start because a scan is already ongoing. If this occur, BASE_TICK_CNT is set too low and must be increased. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occured 1: Leak scan could not start at time"), lo: 29, hi: 30 });
        fields.insert("SLB_CLOSED_STICKY", Field { brief: Some("Set when the frame rate is exceeding the configured rate. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occured 1: CIR exceeded"), lo: 0, hi: 3 });
        regs.insert("SLB_STICKY", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("SLB policer diagnostic"), details: None, fields });
        groups.insert("BUM_SLB", RegisterGroup { addr: Address { base: 49152, count: 1024, width: 8 }, desc: "Leaky bucket configuration & status", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("BASE_TICK_CNT", Field { brief: Some("TIMESCALE_VAL and BASE_TICK_CNT controls the the rate interval as well as the rate granularity available for LB rate configuration Refer to TIMESCALE_VAL for details."), details: None, lo: 4, hi: 19 });
        fields.insert("CLK_PERIOD_01NS", Field { brief: Some("Specifies the clock period in unit of 0.1ns."), details: Some("40: 4ns (250MHz) 64: 6,4ns (156.25MHz) 192: 19,2 ns (52.08MHz)"), lo: 19, hi: 27 });
        fields.insert("DLB_ADD_ENA", Field { brief: Some("Enables adding of frame bytes to the leaky buckets."), details: Some("0: Disable bucket addition 1: Enable bucket addition"), lo: 0, hi: 1 });
        fields.insert("LEAK_ENA", Field { brief: Some("Enables leaking from the leaky buckets."), details: Some("0: Disable bucket leaking 1: Enable bucket leaking"), lo: 1, hi: 2 });
        regs.insert("DLB_CTRL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Configuration of common leaky bucket handling"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BUCKET_VAL", Field { brief: Some("Number of bytes in leaky bucket."), details: None, lo: 9, hi: 28 });
        fields.insert("REM_VAL", Field { brief: Some("Number of subbytes in leaky bucket."), details: None, lo: 0, hi: 9 });
        regs.insert("LB_BUCKET_VAL", Register { addr: Address { base: 4, count: 2, width: 1 }, brief: Some("Configuration of leaky bucket value"), details: None, fields });
        groups.insert("COMMON_BDLB", RegisterGroup { addr: Address { base: 36343, count: 1, width: 2 }, desc: "Common LB configuration and status registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("BASE_TICK_CNT", Field { brief: Some("TIMESCALE_VAL and BASE_TICK_CNT controls the the rate interval as well as the rate granularity available for LB rate configuration Refer to TIMESCALE_VAL for details."), details: None, lo: 4, hi: 19 });
        fields.insert("CLK_PERIOD_01NS", Field { brief: Some("Specifies the clock period in unit of 0.1ns."), details: Some("40: 4ns (250MHz) 64: 6,4ns (156.25MHz) 192: 19,2 ns (52.08MHz)"), lo: 19, hi: 27 });
        fields.insert("DLB_ADD_ENA", Field { brief: Some("Enables adding of frame bytes to the leaky buckets."), details: Some("0: Disable bucket addition 1: Enable bucket addition"), lo: 0, hi: 1 });
        fields.insert("LEAK_ENA", Field { brief: Some("Enables leaking from the leaky buckets."), details: Some("0: Disable bucket leaking 1: Enable bucket leaking"), lo: 1, hi: 2 });
        regs.insert("DLB_CTRL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Configuration of common leaky bucket handling"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BUCKET_VAL", Field { brief: Some("Number of bytes in leaky bucket."), details: None, lo: 9, hi: 28 });
        fields.insert("REM_VAL", Field { brief: Some("Number of subbytes in leaky bucket."), details: None, lo: 0, hi: 9 });
        regs.insert("LB_BUCKET_VAL", Register { addr: Address { base: 4, count: 2, width: 1 }, brief: Some("Configuration of leaky bucket value"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TRAFFIC_TYPE_MASK", Field { brief: Some("Configures the frame types to be policed by the policer. Each bit in the mask enables policing of a specific frame type. Multiple frame types can be enabled at the same time and a frame can belong to multiple frame types. If a frame belongs to one or more enabled frame types, then the frame is policed."), details: Some("'xxxxxx1' : Unknown broadcast frames are policed. 'xxxxx1x' : Unknown multicast frames are policed. 'xxxx1xx' : Unknown unicast frames are policed. 'xxx1xxx' : Known broadcast frames are policed. 'xx1xxxx' : Known multicast frames are policed. 'x1xxxxx' : Known unicast frames are policed. '1xxxxxx' : Learn frames are policed."), lo: 0, hi: 7 });
        regs.insert("TRAFFIC_MASK_CFG", Register { addr: Address { base: 1, count: 3, width: 1 }, brief: Some("Frame type selection per policer"), details: None, fields });
        groups.insert("COMMON_BUM_SLB", RegisterGroup { addr: Address { base: 36345, count: 1, width: 5 }, desc: "Common LB configuration and status registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("PSTAT_DIS", Field { brief: Some("Disable port statistics."), details: None, lo: 0, hi: 1 });
        fields.insert("PVOE_DIS", Field { brief: Some("Disable Port VOE LM updates."), details: None, lo: 1, hi: 2 });
        regs.insert("ACTION_CTRL", Register { addr: Address { base: 0, count: 5, width: 1 }, brief: Some("Configures stat and policer pipeline point per pipeline action"), details: Some("Configures pipeline location for the various stat and policer entity for each pipeline action: repl:0 NONE, XTR_LATE_REW repl:1 INJ, INJ_MASQ, LBK_ASM repl:2 XTR repl:3 XTR_UPMEP repl:4 LBK_QS"), fields });
        let mut fields = HashMap::new();
        fields.insert("BASE_TICK_CNT", Field { brief: Some("TIMESCALE_VAL and BASE_TICK_CNT controls the the rate interval as well as the rate granularity available for LB rate configuration Refer to TIMESCALE_VAL for details."), details: None, lo: 4, hi: 19 });
        fields.insert("CLK_PERIOD_01NS", Field { brief: Some("Specifies the clock period in unit of 0.1ns."), details: Some("40: 4ns (250MHz) 64: 6,4ns (156.25MHz) 192: 19,2 ns (52.08MHz)"), lo: 19, hi: 27 });
        fields.insert("DLB_ADD_ENA", Field { brief: Some("Enables adding of frame bytes to the leaky buckets."), details: Some("0: Disable bucket addition 1: Enable bucket addition"), lo: 0, hi: 1 });
        fields.insert("LEAK_ENA", Field { brief: Some("Enables leaking from the leaky buckets."), details: Some("0: Disable bucket leaking 1: Enable bucket leaking"), lo: 1, hi: 2 });
        regs.insert("DLB_CTRL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Configuration of common leaky bucket handling"), details: None, fields });
        groups.insert("COMMON_SDLB", RegisterGroup { addr: Address { base: 36341, count: 1, width: 2 }, desc: "Common LB configuration and status registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ACL_PIPELINE_PT", Field { brief: Some("Configures the pipeline point per ACL policer. When injecting or looping at a pipeline point after ACL_PIPELINE_PT will not cause ACL policing. When extracting at a pipeline point before ACL_PIPELINE_PT will not cause ACL policing."), details: Some("0: NONE 1: ANA_VRAP 2: ANA_PORT_VOE 3: ANA_CL 4: ANA_CLM 5: ANA_IPT_PROT 6: ANA_OU_MIP 7: ANA_OU_SW 8: ANA_OU_PROT 9: ANA_OU_VOE 10: ANA_MID_PROT 11: ANA_IN_VOE 12: ANA_IN_PROT 13: ANA_IN_SW 14: ANA_IN_MIP 15: ANA_VLAN"), lo: 3, hi: 7 });
        fields.insert("ACL_TRAFFIC_TYPE_MASK", Field { brief: Some("Configures the frame types to be policed by the policer. Each bit in the mask enables a specific frame type. If a frame does not match any of the enabled frame types, then the frame bypasses the policer (never discarded and the bucket is not updated with the frame)."), details: Some("'00': Police frame (if policer is not bypassed by ACL_PIPELINE_PT or DP_BYPASS_LVL) '01': Only frames to front ports are triggering policer and only front port destinations are policed. '10': Frames to CPU are triggering policer and only CPU destinations are policed. '11': Frames to front ports and/or CPU are triggering policer and being policed."), lo: 1, hi: 3 });
        fields.insert("DP_BYPASS_LVL", Field { brief: Some("Configuration of Drop Precedence bypass level. Frames with DP below DP_BYPASS_LVL bypass the policer (frames are never policed and the bucket is not updated with the frames)."), details: Some("0: No frames bypass the policer 1: Frames with DP = 0 bypass the policer 2: Frames with DP = 0 or 1 bypass the policer 3: Frames with DP = 0, 1 or 2 bypass the policer"), lo: 16, hi: 18 });
        fields.insert("FRAME_RATE_ENA", Field { brief: Some("Enables frame rate mode for the ACL policer, where policer rates are measured in frames per second instead of bits per second."), details: Some("0: Rates measured in bits per second 1: Rates measured in frames per second"), lo: 0, hi: 1 });
        fields.insert("GAP_VALUE", Field { brief: Some("Value added to each frame before updating the bucket. Gap value range: -64 to +63 in two's complement format. Setting GAP_VALUE to 20 corresponds to a line-rate measurement, since on the line each frame will be preceded by 12 bytes of IFG and 8 bytes of preamble. Setting GAP_VALUE to 0 corresponds to a data-rate measurement."), details: Some("0x40: -64 0x41: -63 ... 0x7F: -1 0x00: 0 0x01: 1 ... 0x3F: 63"), lo: 8, hi: 15 });
        regs.insert("POL_ACL_CTRL", Register { addr: Address { base: 88, count: 32, width: 1 }, brief: Some("Configuration of ACL policer parameters"), details: Some("Only frames with an VCAP IS2 action with POLICE_ENA=1 are subject to ACL policing. The policer index is then controlled by the VCAP IS2 action field POLICE_IDX."), fields });
        let mut fields = HashMap::new();
        fields.insert("ACL_RATE", Field { brief: Some("ACL policer leaky bucket rate. Regarding unit, refer to POL_UPD_INT. Related parameters: ANA_AC_POL:POL_ALL_CFG:POL_UPD_INT_CFG.POL_UPD_INT ANA_AC_POL:POL_ALL_CFG:POL_ACL_CTRL.FRAME_RATE_ENA"), details: Some("When POL_ACL_CTRL.FRAME_RATE_ENA is disabled, policing is performed in bits per second (bps). 0: Open until burst capacity is used, then closed. 1: Rate = 1 x <unit> bps n: Rate = n x <unit> bps When POL_ACL_CTRL.FRAME_RATE_ENA is enabled, policing is performed in frames per second (fps). 0: Open until burst capacity is used, then closed. 1: Rate = <unit> fps n: Rate = n x <unit> fps"), lo: 0, hi: 19 });
        regs.insert("POL_ACL_RATE_CFG", Register { addr: Address { base: 24, count: 32, width: 1 }, brief: Some("Configuration of ACL policer rates"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ACL_THRES", Field { brief: Some("Policer threshold size (a.ka. burst capacity). Unit is 8192 bytes. Related parameters: ANA_AC_POL:POL_ALL_CFG:POL_ACL_CTRL.FRAME_RATE_ENA"), details: Some("When POL_ACL_CTRL.FRAME_RATE_ENA is disabled burst capacity is configured in steps of 8192 bytes. 0: Always closed 1: Burst capacity = 8192 bytes n: Burst capacity = n x 8192 bytes 63: Burst capacity = 516096 bytes When POL_ACL_CTRL.FRAME_RATE_ENA is enabled burst capacity is configured in steps of 8192/2504 frames. 0: Always closed 1: Burst capacity = 1 x 8192/2504 frames n: Burst capacity = n x 8192/2504 frames 63: Burst capacity = 206 frames"), lo: 0, hi: 6 });
        regs.insert("POL_ACL_THRES_CFG", Register { addr: Address { base: 56, count: 32, width: 1 }, brief: Some("Configuration of ACL policer thresholds"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ACL_FORCE_CLOSE", Field { brief: Some("If set, all ACL policer buckets are forced closed (all frames are policed and no buckets are updated). The bit must be cleared for normal operation."), details: Some("0: Normal operation 1: All ACL policer buckets are closed"), lo: 6, hi: 7 });
        fields.insert("ACL_FORCE_INIT", Field { brief: Some("If set, all ACL policers are initialized and buckets are open. The bit must be cleared for normal operation to resume."), details: Some("0: Normal operation 1: Initialization"), lo: 4, hi: 5 });
        fields.insert("ACL_FORCE_OPEN", Field { brief: Some("If set, all ACL policer buckets are forced open (no frames are policed and no buckets are updated). The bit must be cleared for normal operation."), details: Some("0: Normal operation 1: All ACL policer buckets are forced open"), lo: 5, hi: 6 });
        fields.insert("DBG_DP_CHG_PRIO_ENA", Field { brief: Some("Enables subtraction of the DP from the priority. This enables logging of differently colored frames in different log files when using the ANA testbench."), details: None, lo: 31, hi: 32 });
        fields.insert("DP_TO_COLOR_MAP", Field { brief: Some("Determines the mapping between internal DP value and the color used by ISDX counters. One bit for each of the four internal DP values."), details: Some("0: DP value will be counted as green. 1: DP value will be counted as yellow."), lo: 16, hi: 20 });
        fields.insert("FORCE_CLOSE", Field { brief: Some("If set, all port policer buckets are forced closed (all frames are policed and no buckets are updated). The bit must be cleared for normal operation."), details: Some("0: Normal operation 1: All port policer buckets are closed"), lo: 2, hi: 3 });
        fields.insert("FORCE_INIT", Field { brief: Some("If set, all port policers are initialized and buckets are open. The bit must be cleared for normal operation to resume."), details: Some("0: Normal operation 1: Initialization"), lo: 0, hi: 1 });
        fields.insert("FORCE_OPEN", Field { brief: Some("If set, all port policer buckets are forced open (no frames are policed and no buckets are updated). The bit must be cleared for normal operation."), details: Some("0: Normal operation 1: All port policer buckets are forced open"), lo: 3, hi: 4 });
        fields.insert("LPORT_POLICE_ENA", Field { brief: Some("If set, the port policers operate on logical port numbers instead of physical port numbers."), details: Some("0: Policing per physical port 1: Policing per logical port"), lo: 1, hi: 2 });
        fields.insert("PORT_FC_ENA", Field { brief: Some("Enables overall signaling of flow control from the port policers to DSM. Flow control is enabled for each port policer in POL_PORT_FC_CFG.FC_ENA. Related parameters: ANA_AC_POL:POL_ALL_CFG:POL_PORT_FC_CFG.FC_ENA DSM:CFG:ETH_FC_CFG.FC_ANA_ENA"), details: None, lo: 14, hi: 15 });
        fields.insert("PORT_POL_IN_PARALLEL_ENA", Field { brief: Some("Enables operation of port policers in parallel. In serial mode, each of the active port policers for a port are checked one after another. If a frame is discarded by a policer, the frame is not passed on to subsequent policers. In parallel mode, each of the active port policers for a port operate on all frames (policing and bucket updates) even though one or more of the other port policers is be closed."), details: Some("0: Port policer operates in serial mode. 1: Port policer operates in parallel mode."), lo: 13, hi: 14 });
        fields.insert("PRIO_FORCE_CLOSE", Field { brief: Some("If set, all priority policer buckets are forced closed (all frames are policed and no buckets are updated). The bit must be cleared for normal operation."), details: Some("0: Normal operation 1: All priority policer buckets are closed."), lo: 9, hi: 10 });
        fields.insert("PRIO_FORCE_INIT", Field { brief: Some("If set, all priority policers are initialized and buckets are open. The bit must be cleared for normal operation to resume."), details: Some("0: Normal operation 1: Initialization"), lo: 7, hi: 8 });
        fields.insert("PRIO_FORCE_OPEN", Field { brief: Some("If set, all priority policer buckets are forced open (no frames are policed and no buckets are updated). The bit must be cleared for normal operation."), details: Some("0: Normal operation 1: All priority policer buckets are forced open"), lo: 8, hi: 9 });
        fields.insert("STORM_FORCE_CLOSE", Field { brief: Some("If set, all storm policer buckets are forced closed (all frames are policed and no buckets are updated). The bit must be cleared for normal operation."), details: Some("0: Normal operation 1: All storm policer buckets are closed"), lo: 12, hi: 13 });
        fields.insert("STORM_FORCE_INIT", Field { brief: Some("If set, all storm policers are initialized and buckets are open. The bit must be cleared for normal operation to resume."), details: Some("0: Normal operation 1: Initialization"), lo: 10, hi: 11 });
        fields.insert("STORM_FORCE_OPEN", Field { brief: Some("If set, all storm policer buckets are forced open (no frames are policed and no buckets are updated). The bit must be cleared for normal operation."), details: Some("0: Normal operation 1: All storm policer buckets are forced open"), lo: 11, hi: 12 });
        fields.insert("STORM_GAP_VALUE", Field { brief: Some("Value added to each frame before updating the bucket. Gap value range: -64 to +63 in two's complement format. Setting STORM_GAP_VALUE to 20 corresponds to a line-rate measurement, since on the line each frame will be preceded by 12 bytes of IFG and 8 bytes of preamble. Setting STORM_GAP_VALUE to 0 corresponds to a data-rate measurement."), details: Some("0x40: -64 0x41: -63 ... 0x7F: -1 0x00: 0 0x01: 1 ... 0x3F: 63"), lo: 24, hi: 31 });
        fields.insert("USE_SDLB_COLOR_ENA", Field { brief: Some("When set, the frame color used in statistics is based only on the color determined by the SDLB policer. Related parameters: ANA_AC:STAT_CNT_CFG_ISDX"), details: Some("0: DP level determines color 1: SDLB determines color"), lo: 20, hi: 21 });
        regs.insert("POL_ALL_CFG", Register { addr: Address { base: 177, count: 1, width: 1 }, brief: Some("Miscellaneous policer parameters"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FC_ENA", Field { brief: Some("Enables flow control mode for the port policer. If set, pause frames are transmitted when the configured policer threshold is exceeded. If cleared, frames exceeding the configured policer threshold are discarded. PORT_FC_ENA must also be set to enable pause frames. Furthermore DSM must be configured for flow control. Related parameters: ANA_AC_POL:POL_ALL_CFG:POL_ALL_CFG.PORT_FC_ENA DSM:CFG:ETH_FC_CFG.FC_ANA_ENA"), details: Some("0: Discard mode 1: Flow control mode"), lo: 0, hi: 4 });
        fields.insert("FC_STATE", Field { brief: Some("Current flow control state for the port policer."), details: Some("0: Flow control is inactive 1: Flow control is active"), lo: 8, hi: 9 });
        regs.insert("POL_PORT_FC_CFG", Register { addr: Address { base: 120, count: 57, width: 1 }, brief: Some("Configuration of port policer flow control"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("POL_ACL_ACTIVE_STICKY", Field { brief: Some("Set if an ACL policer is active. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occurred 1: ACL policer is active (frames added to leaky buckets)"), lo: 12, hi: 13 });
        fields.insert("POL_ACL_BYPASS_STICKY", Field { brief: Some("Set if an ACL policer has been bypassed due to a frame's DP level. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occurred 1: ACL policer has been bypassed"), lo: 10, hi: 11 });
        fields.insert("POL_ACL_DROP_STICKY", Field { brief: Some("Set if frame has been dropped due to ACL policer. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occurred 1: ACL policer drop event has occurred"), lo: 11, hi: 12 });
        fields.insert("POL_ACL_PT_BYPASS_STICKY", Field { brief: Some("Set if an ACL policer has been bypassed due to a pipeline point. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occurred 1: policer has been bypassed"), lo: 13, hi: 14 });
        fields.insert("POL_DLB_DROP_STICKY", Field { brief: Some("Set if frame has been dropped by a SDLB policer. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occurred 1: DLB policer drop event has occurred"), lo: 18, hi: 19 });
        fields.insert("POL_DLB_PT_BYPASS_STICKY", Field { brief: Some("Set if a service policer has been bypassed due to a pipeline point. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occurred 1: policer has been bypassed"), lo: 19, hi: 20 });
        fields.insert("POL_PORT_ACTIVE_STICKY", Field { brief: Some("Set if a port policer is active. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occurred 1: Port policer is active (frames added to leaky buckets)"), lo: 5, hi: 9 });
        fields.insert("POL_PORT_BYPASS_STICKY", Field { brief: Some("Set if a port policer has been bypassed due to a frame's DP level. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occurred 1: Port policer has been bypassed"), lo: 0, hi: 1 });
        fields.insert("POL_PORT_DROP_CPU_STICKY", Field { brief: Some("Set if a port policer has removed the CPU ports from a frame's destination set due to policing. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occurred 1: A port policer has removed the CPU ports from a frame's destination set due to policing"), lo: 1, hi: 2 });
        fields.insert("POL_PORT_DROP_FWD_STICKY", Field { brief: Some("Set if a port policer has removed the front ports from a frame's destination set due to policing. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occurred 1: A port policer has removed the front ports from a frame's destination set due to policing"), lo: 2, hi: 3 });
        fields.insert("POL_PORT_FC_CLEAR_STICKY", Field { brief: Some("Set if a port policer's flow control state has been cleared. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occurred 1: Port policer flow control state has been cleared"), lo: 4, hi: 5 });
        fields.insert("POL_PORT_FC_STICKY", Field { brief: Some("Set if flow control has been active for a port policer. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occurred 1: Port policer flow control has been activated"), lo: 3, hi: 4 });
        fields.insert("POL_PORT_PT_BYPASS_STICKY", Field { brief: Some("Set if an Port policer has been bypassed due to a pipeline point. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occurred 1: policer has been bypassed"), lo: 9, hi: 10 });
        fields.insert("POL_PRIO_ACTIVE_STICKY", Field { brief: Some("Set if a priority policer is active. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occurred 1: Priority policer is active (frames added to leaky buckets)"), lo: 16, hi: 17 });
        fields.insert("POL_PRIO_BYPASS_STICKY", Field { brief: Some("Set if a priority policer has been bypassed due to a frame's DP level. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occurred 1: Priority policer has been bypassed"), lo: 14, hi: 15 });
        fields.insert("POL_PRIO_DROP_STICKY", Field { brief: Some("Set if frame has been dropped due to priority policer. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occurred 1: PRIO policer drop event has occurred"), lo: 15, hi: 16 });
        fields.insert("POL_PRIO_PT_BYPASS_STICKY", Field { brief: Some("Set if a priority policer has been bypassed due to a pipeline point. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occurred 1: policer has been bypassed"), lo: 17, hi: 18 });
        fields.insert("POL_STORM_ACTIVE_STICKY", Field { brief: Some("Set if a storm policer is active. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occurred 1: Storm policer is active (frames added to leaky buckets)"), lo: 22, hi: 30 });
        fields.insert("POL_STORM_DROP_CPU_STICKY", Field { brief: Some("Set if a storm policer has removed the CPU ports from a frame's destination set due to policing. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occurred 1: A storm policer has removed the CPU ports from a frame's destination set due to policing"), lo: 20, hi: 21 });
        fields.insert("POL_STORM_DROP_FWD_STICKY", Field { brief: Some("Set if a storm policer has removed the front ports from a frame's destination set due to policing. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occurred 1: A storm policer has removed the front ports from a frame's destination set due to policing"), lo: 21, hi: 22 });
        regs.insert("POL_STICKY", Register { addr: Address { base: 179, count: 1, width: 1 }, brief: Some("Policer diagnostic information"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("STORM_CPU_QU_MASK", Field { brief: Some("Controls policing of frames to the individual CPU queues for the storm policers. If a bit is set in this mask, frames to the corresponding CPU queue are allowed to be policed (frames may get discarded)."), details: Some("'00..00': Disable policing of frames to all CPU queues 'xx..x1 ': Allow policing of frames to CPU queue #0 ... '1x..xx' : Allow policing of frames to CPU queue #n"), lo: 10, hi: 18 });
        fields.insert("STORM_FRAME_RATE_ENA", Field { brief: Some("Enable frame rate mode for the storm policer, where policer rates are measured in frames per second instead of bits per second."), details: Some("0: Rates measured in bits per second 1: Rates measured in frames per second"), lo: 18, hi: 19 });
        fields.insert("STORM_LIMIT_CPU_TRAFFIC_ENA", Field { brief: Some("Enables removing the CPU ports from a policed frame's destination set."), details: Some("0: The policer does not remove the CPU ports from the destination set for a policed frame. 1: The policer removes the CPU ports from the destination set for a policed frame."), lo: 8, hi: 9 });
        fields.insert("STORM_LIMIT_NONCPU_TRAFFIC_ENA", Field { brief: Some("Enables removing the front ports from a policed frame's destination set."), details: Some("0: The policer does not remove the front ports from the destination set for a policed frame. 0: The policer removes the front ports from the destination set for a policed frame."), lo: 9, hi: 10 });
        fields.insert("STORM_TRAFFIC_TYPE_MASK", Field { brief: Some("Configures the frame types to be policed by the policer. Each bit in the mask enables policing of a specific frame type. Multiple frame types can be enabled at the same time and a frame can belong to multiple frame types. If a frame belongs to one or more enabled frame types, then the frame is policed. The only exception to this is if the CPU queue bit is cleared and the frame is destined to a CPU queue in the CPU_QU_MASK. In this case the frame is NOT policed (by this policer), regardless of other settings in TRAFFIC_TYPE_MASK. If a frame does not match any of the enabled frame types, then the frame bypasses the policer (never discarded and the bucket is not updated with the frame). Frame bypassing one storm policer, may be subject to policing by one of the other storm policers. Related parameters: ANA_AC_POL:POL_ALL_CFG:POL_STORM_CTRL.STORM_CPU_QU_MASK"), details: Some("'xxxxxxx1' : Known multicast frames are policed. 'xxxxxx1x' : Known broadcast frames are policed. 'xxxxx1xx' : Known unicast frames are policed. 'xxxx1xxx' : Unknown multicast frames are policed. 'xxx1xxxx' : Unknown broadcast frames are policed. 'xx1xxxxx' : Unknown unicast frames are policed. 'x0xxxxxx' : Frames to a CPU queue selected by CPU_QU_MASK bypass the policer, regardless of other criterias in TRAFFIC_TYPE_MASK. 'x1xxxxxx' : Frames to a CPU queue selected by CPU_QU_MASK are policed. '1xxxxxxx' : Learn frames are policed. '00000000': Disable policer."), lo: 0, hi: 8 });
        regs.insert("POL_STORM_CTRL", Register { addr: Address { base: 16, count: 8, width: 1 }, brief: Some("Configuration of storm policer parameters"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("STORM_RATE", Field { brief: Some("Storm policer leaky bucket rate. Regarding unit, refer to POL_UPD_INT. Related parameters: ANA_AC_POL:POL_ALL_CFG:POL_UPD_INT_CFG.POL_UPD_INT ANA_AC_POL:POL_ALL_CFG:POL_STORM_CTRL.STORM_FRAME_RATE_ENA"), details: Some("When POL_STORM_CTRL.STORM_FRAME_RATE_ENA is disabled, policing is performed in bits per second (bps). 0: Open until burst capacity is used, then closed. 1: Rate = 1 x <unit> bps n: Rate = n x <unit> bps When POL_STORM_CTRL.STORM_FRAME_RATE_ENA is enabled, policing is performed in frames per second (fps). 0: Open until burst capacity is used, then closed. 1: Rate = <unit> fps n: Rate = n x <unit> fps"), lo: 0, hi: 19 });
        regs.insert("POL_STORM_RATE_CFG", Register { addr: Address { base: 0, count: 8, width: 1 }, brief: Some("Configuration of storm policer rates"), details: Some("These registers configure the rates of the storm policers."), fields });
        let mut fields = HashMap::new();
        fields.insert("STORM_THRES", Field { brief: Some("Policer threshold size (a.ka. burst capacity). Unit is 8192 bytes. Related parameters: ANA_AC_POL:POL_ALL_CFG:POL_STORM_CTRL.STORM_FRAME_RATE_ENA"), details: Some("When POL_STORM_CTRL.STORM_FRAME_RATE_ENA is disabled burst capacity is configured in steps of 8192 bytes. 0: Always closed 1: Burst capacity = 8192 bytes n: Burst capacity = n x 8192 bytes 63: Burst capacity = 516096 bytes When POL_STORM_CTRL.STORM_FRAME_RATE_ENA is enabled burst capacity is configured in steps of 8192/2504 frames. 0: Always closed 1: Burst capacity = 1 x 8192/2504 frames n: Burst capacity = n x 8192/2504 frames 63: Burst capacity = 206 frames"), lo: 0, hi: 6 });
        regs.insert("POL_STORM_THRES_CFG", Register { addr: Address { base: 8, count: 8, width: 1 }, brief: Some("Configuration of storm policer thresholds"), details: Some("These registers configure the thresholds of the storm policers"), fields });
        let mut fields = HashMap::new();
        fields.insert("POL_UPD_INT", Field { brief: Some("This configuration will affect the policing rate unit for the storm, ACL and Port policers. The rate unit is calculated as follows: Rate unit = SYS_CLK / (POL_UPD_INT * 16) bps Recommended value and corresponding rate unit: 52.08Mhz: 130 => 25040bps 78.125Mhz: 195 => 25040bps 156.25Mhz: 390 => 25040bps 250MHz: 624 => 25040bps Frame rate mode is also affected be this setting. The default frame rate unit is 10fps (frames per second). This is scaled according to this formula: Frame rate = 10fps * (Rate unit / 25040bps)"), details: Some("0-31: Not allowed N: Update interval"), lo: 0, hi: 10 });
        regs.insert("POL_UPD_INT_CFG", Register { addr: Address { base: 178, count: 1, width: 1 }, brief: Some("Policer update interval"), details: Some("Configure the leaky bucket update interval for the ACL, storm- and port policers. This configuration affects the policing rate unit for these 3 policers. By setting this parameter to a clock frequency dependent value, the rate unit can be kept identical/similar across different system clock frequencies."), fields });
        groups.insert("POL_ALL_CFG", RegisterGroup { addr: Address { base: 36160, count: 1, width: 181 }, desc: "Various policer controls", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("PORT_THRES0", Field { brief: Some("Threshold size for port policer (burst capacity). Related parameters: ANA_AC_POL:POL_PORT_CTRL:POL_PORT_CFG.FRAME_RATE_ENA"), details: Some("When POL_PORT_CFG.FRAME_RATE_ENA is disabled burst capacity is configured in steps of 8192 bytes. 0: Always closed 1: Burst capacity = 8192 bytes n: Burst capacity = n x 8192 bytes 63: Burst capacity = 516096 bytes When POL_PORT_CFG.FRAME_RATE_ENA is enabled burst capacity is configured in steps of 8192/2504 frames. 0: Always closed 1: Burst capacity = 1 x 8192/2504 frames n: Burst capacity = n x 8192/2504 frames 63: Burst capacity = 206 frames"), lo: 0, hi: 6 });
        regs.insert("POL_PORT_THRES_CFG_0", Register { addr: Address { base: 0, count: 228, width: 1 }, brief: Some("Port policer upper threshold configuration"), details: Some("The registers are index by 4 x port number + port policer index."), fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_THRES1", Field { brief: Some("Hysteresis size for port policer. Unit is 8192 bytes. PORT_THRES1 is used when a port policer is in flow control mode. Flow control is asserted when the bucket level exceeds PORT_THRES0. Flow control is deasserted when the bucket has leaked PORT_THRES1 bytes since the assertion. PORT_THRES1 must be programmed smaller or equal to PORT_THRES0. Related parameters: ANA_AC_POL:POL_PORT_CFG:POL_PORT_THRES_CFG_0.PORT_THRES0 ANA_AC_POL:POL_ALL_CFG:POL_PORT_FC_CFG.FC_ENA"), details: Some("0 : No hysteresis 1: Deassert flow control when bucket has leaked 8192 bytes ... n: Deassert flow control when bucket has leaked n * 8192 bytes"), lo: 0, hi: 6 });
        regs.insert("POL_PORT_THRES_CFG_1", Register { addr: Address { base: 256, count: 228, width: 1 }, brief: Some("Port policer lower threshold configuration"), details: Some("The registers are index by 4 x port number + port policer index."), fields });
        let mut fields = HashMap::new();
        fields.insert("POL_BDLB_DROP_STICKY", Field { brief: Some("Set if frame has been dropped by a BDLB policer. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occurred 1: BDLB policer drop event has occurred"), lo: 0, hi: 1 });
        fields.insert("POL_BUM_SLB_ACTIVE_STICKY", Field { brief: Some("Set if BUM policer has been active. One bit per BUM policer. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occurred 1: BUM policer has been active."), lo: 2, hi: 5 });
        fields.insert("POL_BUM_SLB_DROP_STICKY", Field { brief: Some("Set if frame has been dropped by a BUM policer. One bit per BUM policer. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occurred 1: BUM policer drop event has occurred"), lo: 1, hi: 2 });
        regs.insert("POL_STICKY1", Register { addr: Address { base: 180, count: 1, width: 1 }, brief: Some("Policer diagnostic information"), details: None, fields });
        groups.insert("POL_PORT_CFG", RegisterGroup { addr: Address { base: 36864, count: 1, width: 1024 }, desc: "Rate and threshold configuration for port policers.", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("GAP_VALUE", Field { brief: Some("Value added to each frame before updating the bucket. Gap value range: -64 to +63 in two's complement format. Setting GAP_VALUE to 20 corresponds to a line-rate measurement, since on the line each frame will be preceded by 12 bytes of IFG and 8 bytes of preamble. Setting GAP_VALUE to 0 corresponds to a data-rate measurement."), details: Some("0x40: -64 0x41: -63 ... 0x7F: -1 0x00: 0 0x01: 1 ... 0x3F: 63"), lo: 0, hi: 7 });
        fields.insert("PORT_PIPELINE_PT", Field { brief: Some("Configures the pipeline point per port policer. When injecting or looping at a pipeline point after PORT_PIPELINE_PT will not cause port policing. When extracting at a pipeline point before PORT_PIPELINE_PT will not cause port policing."), details: Some("0: NONE 1: ANA_VRAP 2: ANA_PORT_VOE 3: ANA_CL 4: ANA_CLM 5: ANA_IPT_PROT 6: ANA_OU_MIP 7: ANA_OU_SW 8: ANA_OU_PROT 9: ANA_OU_VOE 10: ANA_MID_PROT 11: ANA_IN_VOE 12: ANA_IN_PROT 13: ANA_IN_SW 14: ANA_IN_MIP 15: ANA_VLAN"), lo: 7, hi: 12 });
        regs.insert("POL_PORT_GAP", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Port policer gap and pipeline point configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_RATE", Field { brief: Some("Port policer leaky bucket rate. Regarding unit, refer to POL_UPD_INT. Related parameters: ANA_AC_POL:POL_ALL_CFG:POL_UPD_INT_CFG.POL_UPD_INT ANA_AC_POL:POL_PORT_CTRL:POL_PORT_CFG.FRAME_RATE_ENA"), details: Some("When POL_PORT_CFG.FRAME_RATE_ENA is disabled, policing is performed in bits per second (bps). 0: Open until burst capacity is used, then closed. 1: Rate = 1 x <unit> bps n: Rate = n x <unit> bps When POL_PORT_CFG.FRAME_RATE_ENA is enabled, policing is performed in frames per second (fps). 0: Open until burst capacity is used, then closed. 1: Rate = <unit> fps n: Rate = n x <unit> fps"), lo: 0, hi: 19 });
        regs.insert("POL_PORT_RATE_CFG", Register { addr: Address { base: 512, count: 228, width: 1 }, brief: Some("Port policer rate configuration"), details: Some("The registers are index by 4 x port number + port policer index."), fields });
        groups.insert("POL_PORT_CTRL", RegisterGroup { addr: Address { base: 36352, count: 57, width: 8 }, desc: "Port policer configuration and status per port", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CPU_QU_MASK", Field { brief: Some("Controls policing of frames to the individual CPU queues for the port policer. If a bit is set in this mask, frames to the corresponding CPU queue are allowed to be policed (frames may get discarded and the bucket is updated with the frame)."), details: Some("'00..00': Disable policing of frames to all CPU queues 'xx..x1 ': Allow policing of frames to CPU queue #0 ... '1x..xx' : Allow policing of frames to CPU queue #n"), lo: 16, hi: 24 });
        fields.insert("DP_BYPASS_LVL", Field { brief: Some("Configuration of DP bypass level. Frames with DP below DP_BYPASS_LVL bypass the port policers (frames are never policed and the bucket is not updated with the frames)."), details: Some("0: No frames bypass the policer 1: Frames with DP = 0 bypass the policer 2: Frames with DP = 0 or 1 bypass the policer 3: Frames with DP = 0, 1 or 2 bypass the policer"), lo: 12, hi: 14 });
        fields.insert("FRAME_RATE_ENA", Field { brief: Some("Enables frame rate mode for the port policers, where policer rates are measured in frames per second instead of bits per second."), details: Some("0: Rates measured in bits per second 1: Rates measured in frames per second"), lo: 11, hi: 12 });
        fields.insert("LIMIT_CPU_TRAFFIC_ENA", Field { brief: Some("Enables removing the CPU ports from a policed frame's destination set."), details: Some("0: The policer does not remove the CPU ports from the destination set for a policed frame. 1: The policer removes the CPU ports from the destination set for a policed frame."), lo: 9, hi: 10 });
        fields.insert("LIMIT_NONCPU_TRAFFIC_ENA", Field { brief: Some("Enables removing the front ports from a policed frame's destination set."), details: Some("0: The policer does not remove the front ports from the destination set for a policed frame. 0: The policer removes the front ports from the destination set for a policed frame."), lo: 10, hi: 11 });
        fields.insert("SERVICE_BYPASS_ENA", Field { brief: Some("Configures if service frames (ISDX <> 0) bypasses the port policers."), details: Some("0: All frames are applicable for port policing 1: Only non service frames are applicable for port policing"), lo: 14, hi: 15 });
        fields.insert("TRAFFIC_TYPE_MASK", Field { brief: Some("Configures the frame types to be policed by the policer. Each bit in the mask enables policing of a specific frame type. Multiple frame types can be enabled at the same time and a frame can belong to multiple frame types. If a frame belongs to one or more enabled frame types, then the frame is policed. The only exception to this is if the CPU queue bit is cleared and the frame is destined to a CPU queue in the CPU_QU_MASK. In this case the frame is NOT policed (by this policer), regardless of other settings in TRAFFIC_TYPE_MASK. If a frame does not match any of the enabled frame types, then the frame bypasses the policer (never discarded and the bucket is not updated with the frame). Frame bypassing one port policer, may be subject to policing by one of the other port policers. Related parameters: ANA_AC_POL:POL_PORT_CTRL[0-56]:POL_PORT_CFG.CPU_QU_MASK"), details: Some("'xxxxxxx1' : Known multicast frames are policed. 'xxxxxx1x' : Known broadcast frames are policed. 'xxxxx1xx' : Known unicast frames are policed. 'xxxx1xxx' : Unknown multicast frames are policed. 'xxx1xxxx' : Unknown broadcast frames are policed. 'xx1xxxxx' : Unknown unicast frames are policed. 'x0xxxxxx' : Frames to a CPU queue selected by CPU_QU_MASK bypass the policer, regardless of other criterias in TRAFFIC_TYPE_MASK. 'x1xxxxxx' : Frames to a CPU queue selected by CPU_QU_MASK are policed. '1xxxxxxx' : Learn frames are policed. '00000000': Disable policer."), lo: 0, hi: 8 });
        regs.insert("POL_PORT_CFG", Register { addr: Address { base: 1, count: 4, width: 1 }, brief: Some("Port policer configuration"), details: None, fields });
        groups.insert("PORT_PT_CTRL", RegisterGroup { addr: Address { base: 37888, count: 64, width: 5 }, desc: "Pipeline configuration indexed per port.", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CIR_INC_DP_VAL", Field { brief: Some("Configuration of the drop precedence change for green frames being remarked to yellow. For such frames, the DP level will be incremented with CIR_INC_DP_VAL."), details: Some("0: DP is not increased. n: DP is increased with n for PIR traffic."), lo: 12, hi: 14 });
        fields.insert("COLOR_AWARE_LVL", Field { brief: Some("Configuration of dual leaky bucket color awareness. Frames with DP below or equal to COLOR_AWARE_LVL is treated as green. Frames with DP above COLOR_AWARE_LVL are treated as yellow."), details: Some("0: DLB policer is color aware. Incoming frames with DP=0 are green and frames with DP>0 are yellow. 1: DLB policer is color aware. Incoming frames with DP<=1 are green and frames with DP>1 are yellow. 2: DLB policer is color aware. Incoming frames with DP<=2 are green and frames with DP>2 are yellow. 3: DLB policer is color unaware. All incoming frames are green."), lo: 14, hi: 16 });
        fields.insert("COUPLING_MODE", Field { brief: Some("Set Coupling Flag (MEF CF). Depending on the setting of COUPLING_MODE, LB_CFG[0] and LB_CFG[1] must be configured as follows: COUPLING_MODE=0: LB_CFG[0].RATE_VAL  must be configured to MEF CIR LB_CFG[0].THRES_VAL must be configured to MEF CBS LB_CFG[1].RATE_VAL  must be configured to MEF EIR LB_CFG[1].THRES_VAL must be configured to MEF EBS COUPLING_MODE=1: LB_CFG[0].RATE_VAL  must be configured to MEF CIR LB_CFG[0].THRES_VAL must be configured to MEF CBS LB_CFG[1].RATE_VAL  must be configured to MEF EIR + MEF CIR LB_CFG[1].THRES_VAL must be configured to MEF EBS + MEF CBS"), details: Some("0: CF=0 1: CF=1"), lo: 16, hi: 17 });
        fields.insert("ENCAP_DATA_DIS", Field { brief: Some("Configures if stripped encapsulation data (normalized data) is policed by the policer."), details: Some("0: Encapsulation data is counted as frame data. 1: Encapsulation data in not counted as frame data."), lo: 9, hi: 10 });
        fields.insert("GAP_VAL", Field { brief: Some("Value added to each frame before updating the bucket. Gap value range: -64 to +63 in two's complement format. Setting GAP_VALUE to 20 corresponds to a line-rate measurement, since on the line each frame will be preceded by 12 bytes of IFG and 8 bytes of preamble. Setting GAP_VALUE to 0 corresponds to a data-rate measurement."), details: Some("0x40: -64 0x41: -63 ... 0x7F: -1 0x00: 0 0x01: 1 ... 0x3F: 63"), lo: 2, hi: 9 });
        fields.insert("TIMESCALE_VAL", Field { brief: Some("TIMESCALE_VAL and BASE_TICK_CNT controls the the rate interval as well as the rate granularity available for LB rate configuration The rate granularity is calculated as follows: 8 / (BASE_TICK_CNT*1e-10 * 2^(3 * TIMESCALE_VAL) The rate granularity also becomes the smallest configurable rate. The largest configurable rate is granularity * (2**<width of RATE_VAL>-2)"), details: Some("Assuming BASE_TICK_CNT= 9765, RATE_VAL width = 11 bits: 0: Granularity: 8,192,524bps. Range: 8193kbps - 16.7Gbps 1: Granularity: 1,024,066bps. Range 1024kbps - 2Gbps 2: Granularity: 128,008bps. Range: 128kbps - 262Mbps 3: Granularity: 16,001bps. Range: 16kbps - 32Mbps"), lo: 0, hi: 2 });
        fields.insert("TIMESTAMP_VAL", Field { brief: Some("The time - in BASE_TICK_CNTs - at which last leak was performed."), details: None, lo: 17, hi: 28 });
        fields.insert("TRAFFIC_TYPE_MASK", Field { brief: Some("Configures action to be applied to policed frames."), details: Some("0: No action. 1: Remove front ports from frame's destination port set. 2: Remove CPU ports from frame's destination port set. 3: Remove both front ports and CPU ports from frame's destination port set."), lo: 10, hi: 12 });
        regs.insert("DLB_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Configuration of DLB policer"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CIR_EXCEEDED_STICKY", Field { brief: Some("Set when the frame rate is exceeding the Committed Information Rate. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occured 1: CIR exceeded"), lo: 1, hi: 2 });
        fields.insert("CIR_PIR_OPEN_STICKY", Field { brief: Some("Set when the frame rate is below both the Committed Information Rate and the Peak Information Rate. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occured 1: Traffic received without triggering CIR and PIR policing"), lo: 0, hi: 1 });
        fields.insert("LEAK_SCAN_COMPLETED_STICKY", Field { brief: Some("Set when a LB scan completes. Bit is cleared by writing a 1."), details: Some("0: No event has occured 1: Leak scan completes"), lo: 31, hi: 32 });
        fields.insert("LEAK_SCAN_STARTED_STICKY", Field { brief: Some("Set when a LB scan starts. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occured 1: Leak scan started"), lo: 30, hi: 31 });
        fields.insert("LEAK_START_DELAYED_STICKY", Field { brief: Some("Set when a LB scan could not start because a scan is already ongoing. If this occur, BASE_TICK_CNT is set too low and must be increased. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occured 1: Leak scan could not start at time"), lo: 29, hi: 30 });
        fields.insert("PIR_EXCEEDED_STICKY", Field { brief: Some("Set when the frame rate is exceeding the Peak Information Rate. Bit is cleared by writing a 1 to this position."), details: Some("0: No event has occured 1: PIR exceeded"), lo: 2, hi: 3 });
        regs.insert("DLB_STICKY", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("LB policer diagnostic"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RATE_VAL", Field { brief: Some("Specify rate in steps of configured granularity. The rate granularity is configured in TIMESCALE_VAL."), details: Some("0: Disable leak. For THRES_VAL = 0 bucket is always closed. For THRES_VAL > 0, the configured burst size is available. 1: 1 * granularity 2: 2 * granularity ... max_value-1: (max_value-1)*granularity max_value: Disable leaky bucket (always open)"), lo: 0, hi: 11 });
        fields.insert("THRES_VAL", Field { brief: Some("Policer threshold size (a.ka. burst capacity). Unit is 2048 bytes"), details: Some("0: Threshold = 0 bytes (no burst allowed) 1: Threshold = 2048 bytes n: Threshold = n x 2048 bytes"), lo: 16, hi: 23 });
        regs.insert("LB_CFG", Register { addr: Address { base: 2, count: 2, width: 1 }, brief: Some("Threshold and rate configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DP_BYPASS_LVL", Field { brief: Some("Configuration of Drop Precedence bypass level. Frames with DP below DP_BYPASS_LVL bypass the policer (frames are never policed and the bucket is not updated with the frames)."), details: Some("0: No frames bypass the policer 1: Frames with DP = 0 bypass the policer 2: Frames with DP = 0 or 1 bypass the policer 3: Frames with DP = 0, 1 or 2 bypass the policer"), lo: 2, hi: 4 });
        fields.insert("FRAME_RATE_ENA", Field { brief: Some("Enables frame rate mode for the policer, where policer rates are measured in frames per second instead of bits per second."), details: Some("0: Rates measured in bits per second 1: Rates measured in frames per second"), lo: 1, hi: 2 });
        fields.insert("HIER_DLB_DIS", Field { brief: Some("If set, BDLB policing is disabled."), details: None, lo: 0, hi: 1 });
        regs.insert("MISC_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Configuration of various LB policer handles"), details: None, fields });
        groups.insert("SDLB", RegisterGroup { addr: Address { base: 0, count: 4520, width: 8 }, desc: "Leaky bucket configuration & status", regs });
        out.insert("ANA_AC_POL", Target { desc: "Controls the various policers.", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ETYPE_CLM_KEY_SEL", Field { brief: Some("VCAP_CLM key type used for frame types other than MPLS and IPv4/IPv6."), details: Some("0: No Lookup 1: MLL 2: SGL_MLBS 3: DBL_MLBS 4: TRI_MLBS 5: TRI_VID 6: LL_FULL 7: NORMAL with SRC information 8: NORMAL with DST information 9: NORMAL_7TUPLE 10 NORMAL_5TUPLE_IP4 11 PURE_5TUPLE_IP4 15: No Lookup other: reserved"), lo: 1, hi: 5 });
        fields.insert("IP4_CLM_KEY_SEL", Field { brief: Some("VCAP_CLM key type used for IPv4 frames."), details: Some("0: Follow ETYPE_CLM_KEY_SEL selection 1: MLL 2: SGL_MLBS 3: DBL_MLBS 4: TRI_MLBS 5: TRI_VID 6: LL_FULL 7: NORMAL with SRC information 8: NORMAL with DST information 9: NORMAL_7TUPLE 10 NORMAL_5TUPLE_IP4 11 PURE_5TUPLE_IP4 15: No Lookup other: reserved"), lo: 21, hi: 25 });
        fields.insert("IP6_CLM_KEY_SEL", Field { brief: Some("VCAP_CLM key type used for IPv6 frames."), details: Some("0: Follow ETYPE_CLM_KEY_SEL selection 1: MLL 2: SGL_MLBS 3: DBL_MLBS 4: TRI_MLBS 5: TRI_VID 6: LL_FULL 7: NORMAL with SRC information 8: NORMAL with DST information 9: NORMAL_7TUPLE 10 NORMAL_5TUPLE_IP4 11 PURE_5TUPLE_IP4 15: No Lookup other: reserved"), lo: 17, hi: 21 });
        fields.insert("LOOKUP_ENA", Field { brief: Some("Enable VCAP_CLM lookup."), details: Some("1: Enable 0: Disable"), lo: 0, hi: 1 });
        fields.insert("MLBS_CLM_KEY_SEL", Field { brief: Some("VCAP_CLM key type used when current protocol layer is MPLS label stack."), details: Some("0: Follow ETYPE_CLM_KEY_SEL selection 2: SGL_MLBS 3: DBL_MLBS 4: TRI_MLBS 15: No Lookup other: reserved"), lo: 5, hi: 9 });
        fields.insert("MPLS_MC_CLM_KEY_SEL", Field { brief: Some("VCAP_CLM key type used for multicast MPLS frames (EtherType = 0x8847)."), details: Some("0: Follow ETYPE_CLM_KEY_SEL selection 1: MLL 2: SGL_MLBS 3: DBL_MLBS 4: TRI_MLBS 5: TRI_VID 6: LL_FULL 7: NORMAL with SRC information 8: NORMAL with DST information 9: NORMAL_7TUPLE 10 NORMAL_5TUPLE_IP4 11 PURE_5TUPLE_IP4 15: No Lookup other: reserved"), lo: 9, hi: 13 });
        fields.insert("MPLS_UC_CLM_KEY_SEL", Field { brief: Some("VCAP_CLM key type used for unicast MPLS frames (EtherType = 0x8847)."), details: Some("0: Follow ETYPE_CLM_KEY_SEL selection 1: MLL 2: SGL_MLBS 3: DBL_MLBS 4: TRI_MLBS 5: TRI_VID 6: LL_FULL 7: NORMAL with SRC information 8: NORMAL with DST information 9: NORMAL_7TUPLE 10 NORMAL_5TUPLE_IP4 11 PURE_5TUPLE_IP4 15: No Lookup other: reserved"), lo: 13, hi: 17 });
        fields.insert("USE_CL_DSCP_ENA", Field { brief: Some("If set, the VCAP_CLM lookup uses the basic classified DSCP instead of the value from the frame."), details: Some("1: Enable 0: Disable"), lo: 25, hi: 26 });
        fields.insert("USE_CL_TCI0_ENA", Field { brief: Some("If set, the VCAP_CLM lookup uses the basic classified VID, DEI and PCP instead of the values from the frame."), details: Some("1: Enable 0: Disable"), lo: 26, hi: 27 });
        regs.insert("ADV_CL_CFG", Register { addr: Address { base: 45, count: 6, width: 1 }, brief: Some("VCAP_CLM configuration"), details: Some("Replicated per lookup in VCAP_CLM."), fields });
        let mut fields = HashMap::new();
        fields.insert("RNG_TYPE_SEL", Field { brief: Some("Selected frame field is matched against the range defined in ANA_CL::ADV_RNG_VALUE_CFG."), details: Some("0: Idle (no matching) 1: TCP/UDP destination port is matched against range 2: TCP/UDP source port is matched against range 3: TCP/UDP destination and source ports are matched against range. There is a match if either of them matches. 4: Basic classified VID is matched against range 5: Basic classified DSCP value is matched against range 6: EtherType is matched against range."), lo: 0, hi: 3 });
        regs.insert("ADV_RNG_CTRL", Register { addr: Address { base: 41, count: 8, width: 1 }, brief: Some("VCAP_CLM range types per range checker"), details: Some("Define range checkers used in VCAP_CLM keys."), fields });
        let mut fields = HashMap::new();
        fields.insert("RNG_MAX_VALUE", Field { brief: Some("Upper range value. Value is included in range."), details: None, lo: 16, hi: 32 });
        fields.insert("RNG_MIN_VALUE", Field { brief: Some("Lower range value. Value is included in range."), details: None, lo: 0, hi: 16 });
        regs.insert("ADV_RNG_VALUE_CFG", Register { addr: Address { base: 49, count: 8, width: 1 }, brief: Some("VCAP_CLM range values per range checker"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("AGGR_DMAC_ENA", Field { brief: Some("Allow destination MAC address to contribute to the aggregation code calculation."), details: Some("0: Disable 1: Enable."), lo: 1, hi: 2 });
        fields.insert("AGGR_DMAC_REVERSED_ENA", Field { brief: Some("Allow reversed DMAC address contribute to the aggregation code calculation."), details: Some("0: Disable 1: Enable."), lo: 8, hi: 9 });
        fields.insert("AGGR_IP4_SIPDIP_ENA", Field { brief: Some("Allow source and destination IPv4 addresses to contribute to the aggregation code calculation."), details: Some("0: Disable 1: Enable."), lo: 2, hi: 3 });
        fields.insert("AGGR_IP4_TCPUDP_PORT_ENA", Field { brief: Some("Allow IPv4 UDP/TCP destination and source port numbers to contribute to the aggregation code calculation."), details: Some("0: Disable 1: Enable."), lo: 3, hi: 4 });
        fields.insert("AGGR_IP6_FLOW_LBL_ENA", Field { brief: Some("Allow IPv6 flow label to contribute to the aggregation code calculation."), details: Some("0: Disable 1: Enable."), lo: 5, hi: 6 });
        fields.insert("AGGR_IP6_SIPDIP_ENA", Field { brief: Some("Enable source and destination IPv6 addresses to contribute to the aggregation code calculation."), details: Some("0: Disable 1: Enable."), lo: 6, hi: 7 });
        fields.insert("AGGR_IP6_TCPUDP_PORT_ENA", Field { brief: Some("Allow IPv6 UDP/TCP destination and source port numbers to contribute to the aggregation code calculation."), details: Some("0: Disable 1: Enable."), lo: 4, hi: 5 });
        fields.insert("AGGR_ISDX_ENA", Field { brief: Some("Allow the classified ISDX value to contribute to the aggregation code calculation."), details: Some("0: Disable 1: Enable"), lo: 10, hi: 11 });
        fields.insert("AGGR_RND_ENA", Field { brief: Some("Enable a randomly generated aggregation code."), details: Some("0: Disable 1: Enable."), lo: 7, hi: 8 });
        fields.insert("AGGR_SMAC_ENA", Field { brief: Some("Allow source MAC address to contribute to the aggregation code calculation."), details: Some("0: Disable 1: Enable."), lo: 0, hi: 1 });
        fields.insert("AGGR_USE_VSTAX_AC_ENA", Field { brief: Some("Use the AC code received in the VStaX header as aggregation code."), details: Some("0: Disable 1: Enable."), lo: 9, hi: 10 });
        fields.insert("RT_UPD_VSTAX_AC_ENA", Field { brief: Some("Enable routed frames to update the aggregation code."), details: Some("0: Disable 1: Enable."), lo: 12, hi: 13 });
        fields.insert("SHORT_AGGR_ENA", Field { brief: Some("Enable aggregation code calculations as in Jaguar1."), details: Some("0: Disable 1: Enable."), lo: 11, hi: 12 });
        regs.insert("AGGR_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Aggregation code calculation"), details: Some("This register determines which fields contribute to the calculation of the 4-bit aggregation code. The aggregation code is used to select the egress port if multiple ports are aggregated. Fields enabled are XOR'ed together to generate the final aggregation code."), fields });
        let mut fields = HashMap::new();
        fields.insert("CLM_TRI_VID_SEL", Field { brief: Some("Select version of TRI_VID key."), details: Some("0: Use TRI_VID 1: Use TRI_VID_IDX"), lo: 0, hi: 1 });
        regs.insert("CLM_KEY_CFG", Register { addr: Address { base: 175, count: 6, width: 1 }, brief: Some("Miscellaneous CLM configuration per lookup."), details: Some("Miscellaneous CLM configuration per lookup."), fields });
        let mut fields = HashMap::new();
        fields.insert("CLM_GIDX_DEF_SEL", Field { brief: Some("Select default value of the G_IDX field in VCAP CLM."), details: Some("0: Set G_IDX to zero 1: Set G_IDX to the frame's logical port number 2: Set G_IDX to the frame's masqueraded port number 3: Reserved"), lo: 19, hi: 21 });
        fields.insert("CPU_IGR_MASK_ENA", Field { brief: Some("Enable VCAP_CLM key field IGR_PORT_MASK_SEL=3 for CPU injected frames."), details: Some("0: Disable 1: Enable."), lo: 0, hi: 1 });
        fields.insert("FORCED_KEY_SEL", Field { brief: Some("Select VCAP_CLM key when a VCAP_CLM lookup is enforced by LBK_CLM_FORCE_ENA or IGR_PORT_CLM_FORCE_ENA."), details: Some("0: Use NORMAL key with destination information 1: Use NORMAL key with source information 2: Use NORMAL_7TUPLE key 3: Use NORMAL_5TUPLE_IP4 key"), lo: 17, hi: 19 });
        fields.insert("FORCE_NO_CLM_FOR_BASIC_DIS", Field { brief: Some("Force no VCAP_CLM lookup if frame is discarded or redirected by VCAP_CLM (this can be overruled with IGR_PORT_CLM_FORCE_ENA)."), details: Some("0: Disable 1: Enable."), lo: 21, hi: 22 });
        fields.insert("FP_VS2_IGR_MASK_ENA", Field { brief: Some("Enable VCAP_CLM key field IGR_PORT_MASK_SEL=3 for frames received with VStaX header."), details: Some("0: Disable 1: Enable."), lo: 2, hi: 3 });
        fields.insert("IGR_PORT_CLM_FORCE_ENA", Field { brief: Some("By default, frames discarded or redirected at a earlier pipeline point are not subject to further VCAP_CLM lookups. This configuration controls whether a VCAP_CLM lookup is enforced. See FORCED_KEY_SEL for key selection. When enforcing a VCAP_CLM lookup, the classified ISDX is placed in the VCAP_CLM key field G_IDX."), details: Some("Bit 0: Force VCAP_CLM lookup #0 with key selected by FORCED_KEY_SEL Bit 1: Force VCAP_CLM lookup #1 with key selected by FORCED_KEY_SEL ..."), lo: 5, hi: 11 });
        fields.insert("LBK_CLM_FORCE_ENA", Field { brief: Some("By default, looped frames are not subject to VCAP_CLM lookups. This configuration controls whether a VCAP_CLM lookup is enforced. See FORCED_KEY_SEL for key selection. When enforcing a VCAP_CLM lookup for looped frames, the classified ISDX is placed in the VCAP_CLM key field G_IDX."), details: Some("Bit 0: Force VCAP_CLM lookup #0 with key selected by FORCED_KEY_SEL Bit 1: Force VCAP_CLM lookup #1 with key selected by FORCED_KEY_SEL ..."), lo: 11, hi: 17 });
        fields.insert("LBK_IGR_MASK_SEL3_ENA", Field { brief: Some("Force VCAP_CLM lookup to use VCAP_CLM key field IGR_PORT_MASK_SEL=3 for looped frames instead of IGR_PORT_MASK_SEL=1."), details: Some("0: Disable 1: Enable."), lo: 4, hi: 5 });
        fields.insert("MASQ_IGR_MASK_ENA", Field { brief: Some("Enable VCAP_CLM key field IGR_PORT_MASK_SEL=2 for masqueraded frames."), details: Some("0: Disable 1: Enable."), lo: 3, hi: 4 });
        fields.insert("VD_IGR_MASK_ENA", Field { brief: Some("Enable VCAP_CLM key field IGR_PORT_MASK_SEL=3 for frames from VD0 or VD1."), details: Some("0: Disable 1: Enable."), lo: 1, hi: 2 });
        regs.insert("CLM_MISC_CTRL", Register { addr: Address { base: 58, count: 1, width: 1 }, brief: Some("Miscellaneous VCAP_CLM configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("VSTAX2_MISC_DSCP_ENA", Field { brief: Some("Enable / disable getting DSCP from VSTAX MISC field when encoding as AC."), details: Some("0: Disable 1: Enable (VSTAX MISC contains DSCP)"), lo: 0, hi: 1 });
        regs.insert("COMMON_VSTAX_CFG", Register { addr: Address { base: 57, count: 1, width: 1 }, brief: Some("Common stack configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BPDU_QOS", Field { brief: Some("Configures QoS class for frames with DMAC in BPDU range that are redirected to the CPU."), details: None, lo: 0, hi: 3 });
        fields.insert("GXRP_QOS", Field { brief: Some("Configures QoS class for frames with DMAC in GXRP range that are redirected to the CPU."), details: None, lo: 4, hi: 7 });
        fields.insert("Y1731_AG_QOS", Field { brief: Some("Configures QoS class for frames with DMAC in Y1731_AG protocol range that are redirected to the CPU."), details: None, lo: 8, hi: 11 });
        regs.insert("CPU_8021_QOS_CFG", Register { addr: Address { base: 22, count: 16, width: 1 }, brief: Some("QoS class per address of BPDU, GARP, and CCM frames."), details: Some("The register instance number corresponds to the address of the extracted frame. For instance: CPU_8021_QOS_CFG[4].BPDU_QOS is the QoS class used for BPDU frames with address 01-80-C2-00-00-04."), fields });
        let mut fields = HashMap::new();
        fields.insert("CPU_BPDU_QU", Field { brief: Some("CPU extraction queue for BPDU frames."), details: None, lo: 0, hi: 3 });
        fields.insert("CPU_GXRP_QU", Field { brief: Some("CPU extraction queue for GXRP frames."), details: None, lo: 3, hi: 6 });
        fields.insert("CPU_Y1731_AG_QU", Field { brief: Some("CPU extraction queue used for IEEE802.1ag and Y.1731 frames."), details: None, lo: 6, hi: 9 });
        regs.insert("CPU_8021_QU_CFG", Register { addr: Address { base: 6, count: 16, width: 1 }, brief: Some("CPU extraction queue per address of BPDU, GARP, and CCM frames."), details: Some("The register instance number corresponds to the address of the extracted frame. For instance: CPU_8021_QU_CFG[4].CPU_BPDU_QU is the CPU extraction queue used for BPDU frames with address 01-80-C2-00-00-04."), fields });
        let mut fields = HashMap::new();
        fields.insert("CPU_HOP_BY_HOP_ICMP_QU", Field { brief: Some("CPU extraction queue used for IPv6 Hop by hop and ICMP frames."), details: None, lo: 12, hi: 15 });
        fields.insert("CPU_IGMP_QU", Field { brief: Some("CPU extraction queue used for IGMP frames."), details: None, lo: 0, hi: 3 });
        fields.insert("CPU_IP4_MC_CTRL_QU", Field { brief: Some("CPU extraction queue used for IPv4 multicast control frames."), details: None, lo: 3, hi: 6 });
        fields.insert("CPU_IP6_MC_CTRL_QU", Field { brief: Some("CPU extraction queue used for IPv6 multicast control frames."), details: None, lo: 6, hi: 9 });
        fields.insert("CPU_MLD_QU", Field { brief: Some("CPU extraction queue used for MLD frames."), details: None, lo: 9, hi: 12 });
        fields.insert("CPU_VRAP_QU", Field { brief: Some("CPU extraction queue used for VRAP frames."), details: None, lo: 15, hi: 18 });
        regs.insert("CPU_PROTO_QU_CFG", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("CPU extraction queue configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DSCP_DP_VAL", Field { brief: Some("DP level for DSCP value if enabled (ANA_CL:PORT:QOS_CFG.DSCP_DP_ENA)."), details: None, lo: 2, hi: 4 });
        fields.insert("DSCP_QOS_VAL", Field { brief: Some("QoS class for DSCP value if enabled (ANA_CL:PORT:QOS_CFG.DSCP_QOS_ENA)."), details: None, lo: 4, hi: 7 });
        fields.insert("DSCP_REWR_ENA", Field { brief: Some("Set if the DSCP value is selected to be rewritten. This is controlled in ANA_CL:PORT:QOS_CFG.DSCP_REWR_MODE_SEL."), details: None, lo: 1, hi: 2 });
        fields.insert("DSCP_TRANSLATE_VAL", Field { brief: Some("Translated DSCP value if DSCP translation is enabled on the port (ANA_CL:PORT:QOS_CFG.DSCP_TRANSLATE_ENA)."), details: None, lo: 7, hi: 13 });
        fields.insert("DSCP_TRUST_ENA", Field { brief: Some("If set, the DSCP value is trusted and can be used for QoS and DP classification."), details: None, lo: 0, hi: 1 });
        regs.insert("DSCP_CFG", Register { addr: Address { base: 63, count: 64, width: 1 }, brief: Some("Various configuration per DSCP"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("HMD_PORT", Field { brief: Some("Contains the port number of the used HMD X port"), details: None, lo: 2, hi: 8 });
        fields.insert("HMD_PORT_VLD", Field { brief: Some("Enable the configured port as HMD port."), details: Some("0: Disable 1: Enable"), lo: 0, hi: 1 });
        fields.insert("HM_FORCE_MODE_ENA", Field { brief: Some("If set, VCAP_CLM action MAP_KEY = 2 uses HIH.PCP and HIH.DEI instead of PCP and DEI from the frame's third tag. This enables mapping HIH values to internal values (DP, COS ID)."), details: Some("0: Disable 1: Enable"), lo: 1, hi: 2 });
        regs.insert("HM_CFG", Register { addr: Address { base: 59, count: 4, width: 1 }, brief: Some("HMD port configurations"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CPU_MPLS_G8113_1_NON_OAM_ENA", Field { brief: Some("CPU copy of frames when channel_type check for G8113.1 (MPLS_OAM_FLAVOR) is not 0x8902."), details: None, lo: 17, hi: 18 });
        fields.insert("CPU_MPLS_G8113_1_NON_OAM_QU", Field { brief: Some("Selects CPU queue when channel type is not 0x8902 and CPU_MPLS_G8113_1_NON_OAM_ENA is set."), details: None, lo: 18, hi: 21 });
        fields.insert("CPU_MPLS_IP_TRAFFIC_QU", Field { brief: Some("Selects CPU queue for IP frames received as LSR POP (FWD_TYPE=3) with (nxt_type_after_offset = CW)."), details: None, lo: 27, hi: 30 });
        fields.insert("CPU_MPLS_MIP_QU", Field { brief: Some("CPU queue when frames are detected as MPLS MIP OAM."), details: None, lo: 21, hi: 24 });
        fields.insert("CPU_MPLS_OAM_DEF_QU", Field { brief: Some("CPU queue when frames are detected as Vccv2 or Vccv3 OAM but without (nxt_type_after_offset = CW) or incorrect ACH."), details: None, lo: 24, hi: 27 });
        fields.insert("CPU_MPLS_OAM_MEP_ERR_ENA", Field { brief: Some("CPU copy of frames when MPLS OAM MEP err occur."), details: None, lo: 13, hi: 14 });
        fields.insert("CPU_MPLS_OAM_MEP_ERR_QU", Field { brief: Some("Selects CPU queue when error occured when fwd_type = 3."), details: None, lo: 14, hi: 17 });
        fields.insert("CPU_MPLS_POP_ERR_ENA", Field { brief: Some("CPU copy of frames when MPLS POP err occur."), details: None, lo: 9, hi: 10 });
        fields.insert("CPU_MPLS_POP_ERR_QU", Field { brief: Some("Selects CPU queue when error occured when fwd_type = 3."), details: None, lo: 10, hi: 13 });
        fields.insert("CPU_MPLS_PW_ERR_ENA", Field { brief: Some("CPU copy of frames when termination PW (fwd_type = PW)."), details: None, lo: 0, hi: 1 });
        fields.insert("CPU_MPLS_PW_ERR_QU", Field { brief: Some("Selects CPU queue when error occured when fwd_type = PW."), details: None, lo: 1, hi: 4 });
        fields.insert("CPU_MPLS_PW_TTL0_REDIR_ENA", Field { brief: Some("CPU termination of frames when termination PW (fwd_type = PW) with iTTL TTL=0. Can be send to CPU controlled through CPU_MPLS_PW_ERR_ENA"), details: None, lo: 4, hi: 5 });
        fields.insert("CPU_MPLS_SWAP_ERR_ENA", Field { brief: Some("CPU copy of frames when MPLS swap err occur."), details: None, lo: 5, hi: 6 });
        fields.insert("CPU_MPLS_SWAP_ERR_QU", Field { brief: Some("Selects CPU queue when error occured when fwd_type = 2."), details: None, lo: 6, hi: 9 });
        fields.insert("MPLS_OAM_KEEP_GAL_ENA", Field { brief: Some("If set Rsvd label is kept for VCCV4, LSP and SEGMENT OAM."), details: None, lo: 31, hi: 32 });
        fields.insert("MPLS_SEL_TC_ONLY_ENA", Field { brief: Some("If set only a valid selected TC_VAL by means of VCAP_CLM action TC_LABEL / TC_ENA can be used for looking up the QoS mapping table."), details: None, lo: 30, hi: 31 });
        regs.insert("MPLS_CFG", Register { addr: Address { base: 183, count: 1, width: 1 }, brief: Some("Various MPLS configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MPLS_COMMON_ERR_LM_CNT_DIS", Field { brief: Some("Controls if profile should be part of OAM LM count."), details: None, lo: 3, hi: 4 });
        fields.insert("MPLS_G8113_1_NON_OAM_LM_CNT_DIS", Field { brief: Some("Controls if profile should be part of OAM LM count."), details: None, lo: 0, hi: 1 });
        fields.insert("MPLS_IP_ERR_LM_CNT_DIS", Field { brief: Some("Controls if profile should be part of OAM LM count."), details: None, lo: 4, hi: 5 });
        fields.insert("MPLS_OAM_DEF_LM_CNT_DIS", Field { brief: Some("Controls if profile should be part of OAM LM count."), details: None, lo: 2, hi: 3 });
        fields.insert("MPLS_OAM_ERR_LM_CNT_DIS", Field { brief: Some("Controls if profile should be part of OAM LM count."), details: None, lo: 1, hi: 2 });
        fields.insert("MPLS_PW_TERM_ERR_LM_CNT_DIS", Field { brief: Some("Controls if profile should be part of OAM LM count."), details: None, lo: 5, hi: 6 });
        regs.insert("MPLS_LM_CFG", Register { addr: Address { base: 182, count: 1, width: 1 }, brief: Some("Various MPLS OAM LM configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CLM_RSVD_LBL_SKIP_ENA", Field { brief: Some("Enable skipping of reserved label during label extract. In order for a reserved label to be skipped, either MPLS_RSV_LBL_CFG[<label>].RSVD_LBL_SKIP_ENA or MPLS_MISC_CFG.CLM_RSVD_LBL_SKIP_ENA[<clm idx>] must be set."), details: Some("Bit 0: Skip reserved label when generating MPLS label keys for VCAP_CLM lookup #0. Bit 1: Skip reserved label when generating MPLS label keys for VCAP_CLM lookup #1. ..."), lo: 0, hi: 6 });
        fields.insert("G8113_1_ACH_CH_TYPE", Field { brief: Some("G8113_1 Channel type"), details: None, lo: 16, hi: 32 });
        regs.insert("MPLS_MISC_CFG", Register { addr: Address { base: 181, count: 1, width: 1 }, brief: Some("Miscellaneous MPLS configuration."), details: Some("Miscellaneous MPLS configuration."), fields });
        let mut fields = HashMap::new();
        fields.insert("RSVD_LBL_SKIP_ENA", Field { brief: Some("Enable skipping of reserved label during label extract. In order for a reserved label to be skipped, either MPLS_RSV_LBL_CFG[<label>].RSVD_LBL_SKIP_ENA or MPLS_MISC_CFG.CLM_RSVD_LBL_SKIP_ENA[<clm idx>] must be set."), details: Some("0: Allow reserved label to be part of MPLS label keys 1: Reserved label will be skipped when generating MPLS label keys"), lo: 0, hi: 1 });
        regs.insert("MPLS_RSV_LBL_CFG", Register { addr: Address { base: 159, count: 16, width: 1 }, brief: Some("MPLS configuration per reserved MPLS label"), details: Some("This register enabling each of the 16 Reserved MPLS Labels (Label Value < 16) for Skipping. Note: Handling of reserved labels require that the reserved label is within NUM_VLD_LABELS of the CLM entry that has been hit for MLBS or FULL action or that the reserved label is first label for MLBS_REDUCED action. The RESERVED LABELS have been assigned the following meaning (RFC 3032). ------------------------------------------------------------------- 0: IPv4 Explicit NULL Label 1: Router Alert Label (RAL) 2: IPv6 Explicit NULL Label 3: Reserved (Implicit NULL Label - Never in stack) 4: (Reserved - Not yet assigned) 5: (Reserved - Not yet assigned) 6: (Reserved - Not yet assigned) 7: (Reserved - Not yet assigned) 8: (Reserved - Not yet assigned) 9: (Reserved - Not yet assigned) 10: (Reserved - Not yet assigned) 11: (Reserved - Not yet assigned) 12: (Reserved - Not yet assigned) 13: Generic Alert Label (GAL) 14: OAM Alert Label (OAL) 15: (Reserved - Not yet assigned) -------------------------------------------------------------------"), fields });
        let mut fields = HashMap::new();
        fields.insert("VCCV2_ENA", Field { brief: Some("Used to enable VCCV2 OAM signalling. If not enabled, VCCV2 signalling can not be configured."), details: Some("0: Disable VCCV2 signalling 1: Enable VCCV2 signalling"), lo: 0, hi: 1 });
        fields.insert("VCCV2_LABEL", Field { brief: Some("Reserved Label used for PW VCCV2 OAM channel. Default is to use (Router Alert Label = 1)"), details: None, lo: 1, hi: 5 });
        regs.insert("OAM_CFG", Register { addr: Address { base: 184, count: 1, width: 1 }, brief: Some("Various MPLS OAM configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DSCP_REWR_VAL", Field { brief: Some("Table values for rewriting DSCP values using DP level and QoS class if enabled. Map the frame's DP level and QoS class to a DSCP value. DSCP = QOS_MAP_CFG[8*DP level + QoS class].DSCP_REWR_VAL. This is controlled in ANA_CL:PORT:QOS_CFG.DSCP_REWR_MODE_SEL and ANA_CL::DSCP_CFG.DSCP_REWR_ENA."), details: None, lo: 4, hi: 10 });
        regs.insert("QOS_MAP_CFG", Register { addr: Address { base: 127, count: 32, width: 1 }, brief: Some("Configuration per QoS class and DP level"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("UPSID_NUM", Field { brief: Some("Configures own unit port set ID (UPSID) to be used for stacking. The configured value must be even. Port numbers below 32 will use the configured (even) UPSID, whereas port numbers >=32 will use the configured UPSID plus 1. This must be configured consistently across the following registers: ANA_CL::UPSID_CFG.UPSID_NUM ANA_AC::COMMON_VSTAX_CFG.OWN_UPSID ANA_L2::VSTAX_CTRL.OWN_UPSID REW::COMMON_CTRL.OWN_UPSID"), details: None, lo: 0, hi: 5 });
        regs.insert("UPSID_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Configure UPSID when stacking"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("STAG_ETYPE_VAL", Field { brief: Some("Configurable S-tag TPID EtherType. This value must be configured identically in REW::TPID_CFG.TPID_VAL."), details: None, lo: 0, hi: 16 });
        regs.insert("VLAN_STAG_CFG", Register { addr: Address { base: 2, count: 3, width: 1 }, brief: Some("Custom S-tag EtherTypes"), details: Some("In addition to these custom TPID values, tags with TPID = 0x88A8 are always recognized as S-tags."), fields });
        let mut fields = HashMap::new();
        fields.insert("VRAP_VID", Field { brief: Some("VID value for VRAP frames."), details: None, lo: 0, hi: 12 });
        fields.insert("VRAP_VLAN_AWARE_ENA", Field { brief: Some("If set, VRAP frames must be single VLAN tagged and the frame's VID must match ANA_CL::VRAP_CFG.VRAP_VID. If cleared, VRAP frames must be untagged."), details: None, lo: 12, hi: 13 });
        regs.insert("VRAP_CFG", Register { addr: Address { base: 38, count: 1, width: 1 }, brief: Some("VRAP classifier configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("VRAP_HDR_DATA", Field { brief: Some("A VRAP frame's VRAP header is matched against VRAP_HDR_DATA, except for bits don't cared by VRAP_HDR_MASK. The VRAP header is four bytes located in the frame after EtherType = 0x8808 and EPID = 0x0004."), details: None, lo: 0, hi: 32 });
        regs.insert("VRAP_HDR_DATA", Register { addr: Address { base: 39, count: 1, width: 1 }, brief: Some("VRAP data"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("VRAP_HDR_MASK", Field { brief: Some("Bits set in VRAP_HDR_MASK don't care the equivalent bits in VRAP_HDR_DATA."), details: None, lo: 0, hi: 32 });
        regs.insert("VRAP_HDR_MASK", Register { addr: Address { base: 40, count: 1, width: 1 }, brief: Some("VRAP mask"), details: None, fields });
        groups.insert("COMMON", RegisterGroup { addr: Address { base: 36512, count: 1, width: 186 }, desc: "Common configurations for all ports", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("L2CP_IDX", Field { brief: Some("The index selects which profile in the Layer-2 control protocol table to use (ANA_CL:L2CP_TBL)."), details: Some("0: Disable use of L2CP_IDX. Default port-based index used instead. >0: L2CP_IDX selects the L2CP profile to use."), lo: 0, hi: 6 });
        fields.insert("MIP_IDX", Field { brief: Some("MIP table index. The index is used when enabled by VCAP_CLM action MIP_SEL and selects which MIP table entry to use (ANA_CL:MIP_TBL)."), details: None, lo: 6, hi: 16 });
        regs.insert("ISDX_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("ISDX configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("COSID_VAL", Field { brief: Some("COS ID. The classified COS ID is set to COSID_VAL if SET_CTRL.COSID_ENA is set."), details: None, lo: 13, hi: 16 });
        fields.insert("DEI_VAL", Field { brief: Some("DEI value. The classified DEI is set to DEI_VAL if SET_CTRL.DEI_ENA is set."), details: None, lo: 9, hi: 10 });
        fields.insert("DP_VAL", Field { brief: Some("Drop precedence level. The classified DP level is set to DP_VAL if SET_CTRL.DP_ENA is set."), details: None, lo: 16, hi: 18 });
        fields.insert("DSCP_VAL", Field { brief: Some("DSCP value. The classified DSCP is set to DSCP_VAL if SET_CTRL.DSCP_ENA is set."), details: None, lo: 0, hi: 6 });
        fields.insert("FWD_DIS", Field { brief: Some("Disable forwarding for frames hitting this entry."), details: None, lo: 25, hi: 26 });
        fields.insert("PATH_COLOR_VAL", Field { brief: Some("Path color value used by OAM MEP."), details: None, lo: 24, hi: 25 });
        fields.insert("PATH_COSID_VAL", Field { brief: Some("Path COS ID used by OAM MEP."), details: None, lo: 21, hi: 24 });
        fields.insert("PCP_VAL", Field { brief: Some("PCP value. The classified PCP is set to PCP_VAL if SET_CTRL.PCP_ENA is set."), details: None, lo: 6, hi: 9 });
        fields.insert("QOS_VAL", Field { brief: Some("QoS class. The classified QoS class is set to QOS_VAL if SET_CTRL.QOS_ENA is set."), details: None, lo: 10, hi: 13 });
        fields.insert("TC_VAL", Field { brief: Some("TC bits. The classified TC bits are set to TC_VAL if SET_CTRL.TC_ENA is set."), details: None, lo: 18, hi: 21 });
        regs.insert("MAP_ENTRY", Register { addr: Address { base: 1, count: 8, width: 1 }, brief: Some("Entry in mapping table"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INDEPENDENT_MEL_ENA", Field { brief: Some("Force selected VOE to handle all frames as data."), details: None, lo: 0, hi: 1 });
        fields.insert("MEP_IDX", Field { brief: Some("VOE index."), details: None, lo: 2, hi: 12 });
        fields.insert("MEP_IDX_ENA", Field { brief: Some("Enable use of MEP_IDX for selecting which VOE to use for EVC OAM processing."), details: None, lo: 1, hi: 2 });
        regs.insert("OAM_MEP_CFG", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("OAM MEP configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("VSI_ENA", Field { brief: Some("Configures if learning and forwarding is based on VLAN or Virtual Switching Instance. If VSI_ENA=1, then the following entry is used for lookup in ANA_L3:VLAN: ANA_L3:VLAN[vsi_val + 4096] i.e. the upper 1K entries in ANA_L3:VLAN are \"VSI entries\"."), details: Some("0: Use classified VID for lookup in VLAN table 1: Use VSI for lookup in VLAN table"), lo: 0, hi: 1 });
        fields.insert("VSI_VAL", Field { brief: Some("Virtual Switching Instance used if VSI_ENA is set."), details: None, lo: 1, hi: 11 });
        regs.insert("VSI_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Virtual Switching Instance configuration"), details: None, fields });
        groups.insert("IPT", RegisterGroup { addr: Address { base: 0, count: 4096, width: 4 }, desc: "Ingress Protection Table", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("LBM_MAC_LOW", Field { brief: Some("Destination MAC address bit 31:0 used for LBM. See LBM_MAC_HIGH."), details: None, lo: 0, hi: 32 });
        regs.insert("LBM_MAC_LOW", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("MAC address configuration - bits 31:0"), details: None, fields });
        groups.insert("L2CP_TBL", RegisterGroup { addr: Address { base: 32768, count: 3744, width: 1 }, desc: "L2CP table", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("COSID_ENA", Field { brief: Some("Enable use of COSID_VAL as COS ID."), details: None, lo: 5, hi: 6 });
        fields.insert("COSID_VAL", Field { brief: Some("COS ID for L2CP frame."), details: None, lo: 6, hi: 9 });
        fields.insert("CPU_FWD_CFG", Field { brief: Some("CPU forward configuration for L2CP frame."), details: Some("0: Normal forward 1: Enable redirection to CPU queue 2: Enable copy to CPU queue 3: Discard the frame"), lo: 3, hi: 5 });
        fields.insert("CPU_L2CP_QU", Field { brief: Some("CPU extraction queue for L2CP frame copied or redirected to CPU by CPU_FWD_CFG."), details: None, lo: 0, hi: 3 });
        regs.insert("L2CP_ENTRY_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("L2CP table entry"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("COSID_ENA", Field { brief: Some("If set, COSID_VAL replaces the classified COS ID if the entry is matched."), details: None, lo: 4, hi: 5 });
        fields.insert("DEI_ENA", Field { brief: Some("If set, DEI_VAL replaces the classified DEI value if the entry is matched."), details: None, lo: 2, hi: 3 });
        fields.insert("DP_ENA", Field { brief: Some("If set, DP_VAL replaces the classified DP level if the entry is matched."), details: None, lo: 5, hi: 6 });
        fields.insert("DSCP_ENA", Field { brief: Some("If set, DSCP_VAL replaces the classified DSCP value if the entry is matched."), details: None, lo: 0, hi: 1 });
        fields.insert("PATH_ENA", Field { brief: Some("If set, PATH_COSID_VAL and PATH_COLOR_VAL are used if the entry is matched."), details: None, lo: 7, hi: 8 });
        fields.insert("PCP_ENA", Field { brief: Some("If set, PCP_VAL replaces the classified PCP value if the entry is matched."), details: None, lo: 1, hi: 2 });
        fields.insert("QOS_ENA", Field { brief: Some("If set, QOS_VAL replaces the classified QoS class if the entry is matched."), details: None, lo: 3, hi: 4 });
        fields.insert("TC_ENA", Field { brief: Some("If set, TC_VAL replaces the classified TC bits if the entry is matched."), details: None, lo: 6, hi: 7 });
        regs.insert("SET_CTRL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Configures which entry fields to use if row is matched"), details: None, fields });
        groups.insert("MAP_TBL", RegisterGroup { addr: Address { base: 24576, count: 512, width: 16 }, desc: "QoS mapping table", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CCM_COPY_ONCE_ENA", Field { brief: Some("Send the next received CCM frame to CPU. Cleared by HW when a CPU copy has been send to CPU"), details: None, lo: 0, hi: 1 });
        fields.insert("CCM_INTERVAL", Field { brief: Some("Interval used for setting CCM_COPY_ONCE_ENA based on ANA_CL::MIP_CTRL.MIP_CCM_HMO_SET_SHOT. CCM_COPY_ONCE_ENA are only set by hardware if MIP_CCM_INTERVAL_MASK[CCM_HMO_CTRL.CCM_INTERVAL] is set"), details: None, lo: 1, hi: 3 });
        regs.insert("CCM_HMO_CTRL", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Allows sending a single CCM frame to CPU"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LBM_MAC_HIGH", Field { brief: Some("Destination MAC address bits 47:32 used for LBM. If LBM_MAC_HIGH = 0 and LBM_MAC_LOW = 0, the MAC address check for LBM frames is disabled."), details: None, lo: 0, hi: 16 });
        regs.insert("LBM_MAC_HIGH", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("MAC address - bits 47:32"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CCM_COPY_ENA", Field { brief: Some("If set, OAM Y.1731 CCM frames with the correct encapsulation and the correct MEL are copied to the CPU."), details: None, lo: 18, hi: 19 });
        fields.insert("CPU_MIP_QU", Field { brief: Some("CPU extraction queue when frame is forwarded to CPU."), details: None, lo: 1, hi: 4 });
        fields.insert("GENERIC_OPCODE_CFG", Field { brief: Some("Handling of OAM Y.1731 frames with OpCode=GENERIC_OPCODE_VAL, correct encapsulation, and correct MEL."), details: Some("0: No handling 1: Copy to CPU 2: Redirect to CPU 3: Discard"), lo: 4, hi: 6 });
        fields.insert("GENERIC_OPCODE_VAL", Field { brief: Some("Generic Opcode. See GENERIC_OPCODE_CFG."), details: None, lo: 6, hi: 14 });
        fields.insert("LBM_REDIR_ENA", Field { brief: Some("If set, OAM Y.1731 LBM frames with the correct encapsulation, the correct MEL, and the correct destination MAC address are redirected to the CPU."), details: None, lo: 17, hi: 18 });
        fields.insert("LTM_REDIR_ENA", Field { brief: Some("If set, OAM Y.1731 LTM frames with the correct encapsulation and the correct MEL are redirected to the CPU."), details: None, lo: 16, hi: 17 });
        fields.insert("MEL_VAL", Field { brief: Some("MEL value for the MIP."), details: None, lo: 19, hi: 22 });
        fields.insert("PIPELINE_PT", Field { brief: Some("MIP location."), details: Some("0: ANA_IN_MIP 1: ANA_OU_MIP"), lo: 0, hi: 1 });
        fields.insert("RAPS_CFG", Field { brief: Some("Handling of OAM Y.1731 frames with OpCode=RAPS, correct encapsulation, and correct MEL."), details: Some("0: No handling 1: Copy to CPU 2: Redirect to CPU 3: Discard"), lo: 14, hi: 16 });
        regs.insert("MIP_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("MIP configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("VID_SEL", Field { brief: Some("Check of VID to match before frame is accepted as MIP."), details: Some("0: VID check is disabled. Frame is always accepted. 1: Accept untagged frames. Tagged frames are not accepted. 2: Accept tagged frames with outer VID = VID_VAL. Untagged frames are not accepted. 3: Accept untagged frames or tagged frames with outer VID = VID_VAL"), lo: 0, hi: 2 });
        fields.insert("VID_VAL", Field { brief: Some("Required outer VID to identify frame as MIP."), details: None, lo: 2, hi: 14 });
        regs.insert("MIP_CL_VID_CTRL", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Controls classified VID check"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CPU_QU", Field { brief: Some("If the frame is forwarded to the CPU (via PROFILE_CFG.FWD_SEL), it will be forwarded to the CPU queue configured in this field."), details: None, lo: 0, hi: 3 });
        fields.insert("CUSTOM_ACE_ENA", Field { brief: Some("Controls S2 custom rule selection."), details: Some("Bit 0: Selects custom key to use (0: CUSTOM_1, 1: CUSTOM_2) Bit 1: Enables custom key for first lookup Bit 2: Enables custom key for second lookup"), lo: 15, hi: 18 });
        fields.insert("FWD_SEL", Field { brief: Some("CPU forward configuration per profile."), details: Some("0: Normal forward 1: Enable redirection to CPU queue: PROFILE_CFG.CPU_QU 2: Enable copy to CPU queue: PROFILE_CFG.CPU_QU 3: Discard the frame"), lo: 3, hi: 5 });
        fields.insert("LM_CNT_DIS", Field { brief: Some("Controls if profile traffic should be part of OAM LM count."), details: None, lo: 19, hi: 20 });
        fields.insert("NORMALIZE_DIS", Field { brief: Some("Controls if profile traffic should be normalized according to normal action handling: nxt_normalize."), details: None, lo: 18, hi: 19 });
        fields.insert("NXT_KEY_TYPE", Field { brief: Some("Determines the next CLM lookup. Could also specify no further CLM lookups"), details: Some("0: no overrule 2: SGL_MLBS 3: DBL_MLBS 4: TRI_MLBS 12: CUSTOM1 13: CUSTOM2 14: CUSTOM4 15: No Lookup other: reserved"), lo: 5, hi: 9 });
        fields.insert("NXT_NORM_W16_OFFSET", Field { brief: Some("Determines frame pointer movement."), details: None, lo: 9, hi: 13 });
        fields.insert("NXT_TYPE_AFTER_OFFSET", Field { brief: Some("Controls Protocol layer (frame_type) at frame pointer position after update PROFILE_CFG.NXT_NORM_W16_OFFSET."), details: Some("0: ETH  - Frame pointer points to start of DMAC. 1: CW (IP / MPLS PW CW / MPLS ACH) - Frame pointer points to MPLS CW/ACH or IP version. 2: MPLS - Frame pointer points to MPLS label. 3: DATA -\"Raw\" data, i.e. unknown protocol type."), lo: 13, hi: 15 });
        regs.insert("PROFILE_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Generalized MPLS exception handling"), details: Some("This register allows exception handling of reserved MPLS labels and IP control protocols."), fields });
        groups.insert("MIP_TBL", RegisterGroup { addr: Address { base: 16384, count: 1024, width: 8 }, desc: "MIP table", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("MIP_CCM_HMO_SET_SHOT", Field { brief: Some("Set all CCM Hit me once bits. Cleared when the access completes. Ref: ANA_CL:MIP_TBL:CCM_HMO_CTRL"), details: Some("0: Idle 1: Initiate setting all ANA_CL:MIP_TBL:CCM_HMO_CTRL.CCM_COPY_ONCE_ENA where MIP_CCM_INTERVAL_MASK[CCM_HMO_CTRL.CCM_INTERVAL] is set The bit is cleared upon completion"), lo: 4, hi: 5 });
        fields.insert("MIP_CCM_INTERVAL_MASK", Field { brief: Some("Specifies which MIP CCM intervales that will have CCM_COPY_ONCE_ENA set."), details: Some("x0x: Interval is ignored x1x: ANA_CL:MIP_TBL:CCM_HMO_CTRL.CCM_COPY_ONCE_ENA is set where MIP_CCM_INTERVAL_MASK[CCM_HMO_CTRL.CCM_INTERVAL] is set."), lo: 0, hi: 4 });
        regs.insert("MIP_CTRL", Register { addr: Address { base: 185, count: 1, width: 1 }, brief: Some("MIP_TBL CCM hit me once set control"), details: None, fields });
        groups.insert("MPLS_PROFILE", RegisterGroup { addr: Address { base: 36698, count: 18, width: 1 }, desc: "Configuriong of profiles used for MPLS traffic exception handling", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CPU_BPDU_REDIR_SEL", Field { brief: Some("Control CPU redirection, copy or discard of reserved DMAC addresses in the range 01-80-C2-00-00-10 to 01-80-C2-00-00-1F. Each two bits of this fields control a DMAC addres: Bits 0 and 1 control address 01-80-C2-00-00-10, bits 2 and 3 control address 01-80-C2-00-00-11, and so on. Frames are extracted to the CPU extraction queue defined in ANA_CL::CPU_8021_QU_CFG."), details: Some("0: Normal forward 1: Enable redirection to CPU queue 2: Enable copy to CPU queue 3: Discard the frame"), lo: 0, hi: 32 });
        regs.insert("CAPTURE_BPDU_CFG", Register { addr: Address { base: 44, count: 1, width: 1 }, brief: Some("BPDU redirection control"), details: Some("Configuration of CPU capturing of BPDU frames."), fields });
        let mut fields = HashMap::new();
        fields.insert("CAPTURE_TPID_AWARE_DIS", Field { brief: Some("This configuration applies to the CPU forwarding function of the basic classifier. Each bit corresponds to one of the known TPIDs. If a bit is set, the basic classifier does not CPU forward a frame if the frame's outer VLAN tag contains the corresponding TPID."), details: Some("Bit0: TPID = 0x8100 Bit1: TPID = 0x88A8 Bit2: TPID = ANA_CL::VLAN_STAG_CFG[0] Bit3: TPID = ANA_CL::VLAN_STAG_CFG[1] Bit4: TPID = ANA_CL::VLAN_STAG_CFG[2]"), lo: 7, hi: 12 });
        fields.insert("CPU_IGMP_REDIR_ENA", Field { brief: Some("Redirect IGMP frames to the CPU extraction queue given by CPU_PROTO_QU_CFG.CPU_IGMP_QU."), details: Some("0: Disable redirection 1: Enable redirection to CPU queue"), lo: 0, hi: 1 });
        fields.insert("CPU_IP4_MC_COPY_ENA", Field { brief: Some("Copy IPv4 multicast control frames to the CPU extraction queue given by CPU_PROTO_QU_CFG.CPU_IP4_MC_CTRL_QU."), details: Some("0: Disable copy 1: Enable copy to CPU queue"), lo: 1, hi: 2 });
        fields.insert("CPU_IP6_MC_COPY_ENA", Field { brief: Some("Copy IPv6 multicast control frames (DIP equals FF02::/16) to the CPU extraction queue given by CPU_PROTO_QU_CFG.CPU_IP6_MC_CTRL_QU."), details: Some("0: Disable copy 1: Enable copy to CPU queue"), lo: 3, hi: 4 });
        fields.insert("CPU_MLD_REDIR_ENA", Field { brief: Some("Redirect MLD frames to the CPU extraction queue given by CPU_PROTO_QU_CFG.CPU_MLD_QU."), details: Some("0: Disable redirection 1: Enable redirection to CPU queue."), lo: 2, hi: 3 });
        fields.insert("CPU_VRAP_REDIR_ENA", Field { brief: Some("Redirect VRAP frames to the CPU extraction queue given by CPU_PROTO_QU_CFG.CPU_VRAP_QU."), details: Some("0: Disable 1: Enable"), lo: 6, hi: 7 });
        fields.insert("IP6_HOP_BY_HOP_REDIR_ENA", Field { brief: Some("Redirect IPv6 frames with hop by hop options to the CPU extraction queue given by CPU_PROTO_QU_CFG.CPU_HOP_BY_HOP_ICMP_QU."), details: Some("0: Disable redirection 1: Enable redirection to the CPU queue"), lo: 4, hi: 5 });
        fields.insert("IP6_ICMP_HOP_BY_HOP_REDIR_ENA", Field { brief: Some("Redirect ICMPv6 frames to the CPU extraction queue given by CPU_PROTO_QU_CFG.CPU_HOP_BY_HOP_ICMP_QU."), details: Some("0: Disable 1: Enable"), lo: 5, hi: 6 });
        regs.insert("CAPTURE_CFG", Register { addr: Address { base: 41, count: 1, width: 1 }, brief: Some("CPU forward control"), details: Some("Configuration of CPU capturing of control frames."), fields });
        let mut fields = HashMap::new();
        fields.insert("CPU_GXRP_REDIR_SEL", Field { brief: Some("Control CPU redirection, copy or discard of reserved DMAC addresses in the range 01-80-C2-00-00-20 to 01-80-C2-00-00-2F. Each two bits of this fields control a DMAC addres: Bits 0 and 1 control address 01-80-C2-00-00-20, bits 2 and 3 control address 01-80-C2-00-00-21, and so on. Frames are extracted to the CPU extraction queue defined in ANA_CL::CPU_8021_QU_CFG."), details: Some("0: Normal forward 1: Enable redirection to CPU queue 2: Enable copy to CPU queue 3: Discard the frame"), lo: 0, hi: 32 });
        regs.insert("CAPTURE_GXRP_CFG", Register { addr: Address { base: 43, count: 1, width: 1 }, brief: Some("GXRP redirection control"), details: Some("Configuration of CPU capturing of GARP frames."), fields });
        let mut fields = HashMap::new();
        fields.insert("CPU_Y1731_AG_REDIR_SEL", Field { brief: Some("Control CPU redirection, copy or discard of reserved DMAC addresses in the range 01-80-C2-00-00-30 to 01-80-C2-00-00-3F. Each two bits of this fields control a DMAC addres: Bits 0 and 1 control address 01-80-C2-00-00-30, bits 2 and 3 control address 01-80-C2-00-00-31, and so on. Frames are extracted to the CPU extraction queue defined in ANA_CL::CPU_8021_QU_CFG."), details: Some("0: Normal forward 1: Enable redirection to CPU queue 2: Enable copy to CPU queue 3: Discard the frame"), lo: 0, hi: 32 });
        regs.insert("CAPTURE_Y1731_AG_CFG", Register { addr: Address { base: 42, count: 1, width: 1 }, brief: Some("IEEE802.1ag / ITU-T Y.1731 OAM frame filtering control"), details: Some("Configuration of CPU capturing of IEEE802.1ag and Y.1731 control frames."), fields });
        let mut fields = HashMap::new();
        fields.insert("FILTER_NULL_MAC_DIS", Field { brief: Some("Discard frames with DMAC or SMAC equal to 00-00-00-00-00-00."), details: Some("0: Discard frames with a null MAC address 1: No filter"), lo: 1, hi: 2 });
        fields.insert("FILTER_SMAC_MC_DIS", Field { brief: Some("Discard frames with a multicast SMAC address."), details: Some("0: Discard frames with multicast SMAC address 1: No filter"), lo: 2, hi: 3 });
        fields.insert("FORCE_FCS_UPDATE_ENA", Field { brief: Some("Enable FCS update of all frames received on the port."), details: None, lo: 0, hi: 1 });
        regs.insert("FILTER_CTRL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Filter configuration"), details: Some("Configuration of filtering of frames not matching expected ingress properties"), fields });
        let mut fields = HashMap::new();
        fields.insert("PCP_DEI_DP_VAL", Field { brief: Some("Map DEI and PCP to a DP level: DP level = PCP_DEI_MAP_CFG[8*DEI + PCP].PCP_DEI_DP_VAL."), details: None, lo: 3, hi: 5 });
        fields.insert("PCP_DEI_QOS_VAL", Field { brief: Some("Map VLAN PCP and DEI to a QoS class: QOS class = PCP_DEI_MAP_CFG[8*DEI + PCP].PCP_DEI_QOS_VAL."), details: None, lo: 0, hi: 3 });
        regs.insert("PCP_DEI_MAP_CFG", Register { addr: Address { base: 24, count: 16, width: 1 }, brief: Some("DEI and PCP mapping table"), details: Some("Mapping of frame's DEI and PCP to classified QoS class and drop precedence level. Configuration per DEI, PCP."), fields });
        let mut fields = HashMap::new();
        fields.insert("DEI_TRANS_VAL", Field { brief: Some("Translate VLAN PCP and DEI to a classified DEI: DEI = PCP_DEI_TRANS_CFG[8*DEI + PCP].DEI_TRANS_VAL."), details: None, lo: 3, hi: 4 });
        fields.insert("PCP_TRANS_VAL", Field { brief: Some("Translate VLAN PCP and DEI to a classified PCP: PCP = PCP_DEI_TRANS_CFG[8*DEI + PCP].PCP_TRANS_VAL."), details: None, lo: 0, hi: 3 });
        regs.insert("PCP_DEI_TRANS_CFG", Register { addr: Address { base: 7, count: 16, width: 1 }, brief: Some("DEI and PCP translation table"), details: Some("Translation of frame's DEI and PCP to classified DEI and PCP. Configuration per DEI and PCP. The use of this table is enabled in VLAN_CTRL.VLAN_PCP_DEI_TRANS_ENA."), fields });
        let mut fields = HashMap::new();
        fields.insert("GLAG_NUM", Field { brief: Some("Global Link Aggregation Group (GLAG) number to be used in relation to learning and forwarding."), details: Some("PORT_IS_GLAG_ENA=0: Port does not participate in a GLAG PORT_IS_GLAG_ENA=1: 0: port is member of GLAG 0 1: port is member of GLAG 1 ... N: port is member of GLAG N"), lo: 8, hi: 13 });
        fields.insert("LPORT_NUM", Field { brief: Some("Logical port number to be used in relation to learning, forwarding and policing."), details: Some("0: Logical port 0 1: Logical port 1 ... n: Logical port n."), lo: 0, hi: 6 });
        fields.insert("PAG_VAL", Field { brief: Some("Default PAG value used as input to S2. The PAG value can be changed by CLM actions."), details: None, lo: 13, hi: 21 });
        fields.insert("PORT_IS_GLAG_ENA", Field { brief: Some("Port is part of a Global Link Aggregation Gloup (GLAG)."), details: Some("0: Port is not globally link aggregated. 1: Port is part of a GLAG."), lo: 7, hi: 8 });
        fields.insert("UPDATE_IFH_SRC_PORT_ENA", Field { brief: Some("Update IFH.SRC_PORT to LPORT_NUM to ensure frames from link aggregated ports are queued in the same queue."), details: Some("0: IFH.FWD.SRC_PORT = phys_num. 0: IFH.FWD.SRC_PORT = LPORT_NUM."), lo: 6, hi: 7 });
        regs.insert("PORT_ID_CFG", Register { addr: Address { base: 23, count: 1, width: 1 }, brief: Some("Port ID data"), details: Some("Configuration of GLAG and logical port number."), fields });
        let mut fields = HashMap::new();
        fields.insert("DEFAULT_DP_VAL", Field { brief: Some("Default port DP level."), details: Some("0: DP 0 (disable) 1: DP 1 ... n: DP n (highest drop probability)."), lo: 3, hi: 5 });
        fields.insert("DEFAULT_QOS_VAL", Field { brief: Some("Default port QoS class."), details: None, lo: 0, hi: 3 });
        fields.insert("DSCP_DP_ENA", Field { brief: Some("Allow DP classification based on DSCP for IP frames."), details: Some("0: Disable 1: Enable"), lo: 6, hi: 7 });
        fields.insert("DSCP_KEEP_ENA", Field { brief: Some("Setting this bit prevents the rewriter from remapping DSCP values for frames from this port."), details: Some("0: Allow rewriter to remap DSCP field 1: Do not allow rewriter to remap of DSCP field"), lo: 10, hi: 11 });
        fields.insert("DSCP_QOS_ENA", Field { brief: Some("Allow QoS classification based on DSCP for IP frames."), details: Some("0: Disable 1: Enable"), lo: 5, hi: 6 });
        fields.insert("DSCP_REWR_MODE_SEL", Field { brief: Some("Select which DSCP values to rewrite based on DP level and QoS class. If the DSCP value is to be rewritten, then the new DSCP = ANA_CL::QOS_MAP_CFG[8*DP level + QoS class].DSCP_REWR_VAL."), details: Some("0: Rewrite none 1: Rewrite if DSCP=0 2: Rewrite for selected values configured in ANA_CL::DSCP_CFG[DSCP].DSCP_REWR_ENA. 3: Rewrite all"), lo: 12, hi: 14 });
        fields.insert("DSCP_TRANSLATE_ENA", Field { brief: Some("Set if the DSCP value must be translated before using the DSCP value. If set, the translated DSCP value is given from ANA_CL::DSCP_CFG[DSCP].DSCP_TRANSLATE_VAL."), details: Some("0: Disable 1: Enable"), lo: 11, hi: 12 });
        fields.insert("KEEP_ENA", Field { brief: Some("Setting this bit prevents the rewriter from making any changes to frames from this port. If a frame is CPU injected, this configuration bit is overruled."), details: Some("0: Allow rewriter to change the frame 1: Do not allow rewriter to change the frame"), lo: 9, hi: 10 });
        fields.insert("PCP_DEI_DP_ENA", Field { brief: Some("Allow DP classification based on PCP and DEI for tagged frames."), details: Some("0: Disable 1: Enable"), lo: 8, hi: 9 });
        fields.insert("PCP_DEI_QOS_ENA", Field { brief: Some("Allow QoS classification based on PCP and DEI from tagged frames."), details: Some("0: Disable 1: Enable"), lo: 7, hi: 8 });
        regs.insert("QOS_CFG", Register { addr: Address { base: 40, count: 1, width: 1 }, brief: Some("QoS configuration"), details: Some("Configuration of basic QoS classification."), fields });
        let mut fields = HashMap::new();
        fields.insert("IGR_DROP_ENA", Field { brief: Some("Ingress port drop mode configuration. Applicable for front port only."), details: Some("0 : Disable drop mode for the priority 1 : Enable drop mode for the priority"), lo: 4, hi: 12 });
        fields.insert("STACKING_AWARE_ENA", Field { brief: Some("Enable usage of stacking information."), details: None, lo: 2, hi: 3 });
        fields.insert("STACKING_HEADER_DISCARD_ENA", Field { brief: Some("Enable discard of frames received with a stacking header."), details: Some("0: Disable 1: Enable"), lo: 0, hi: 1 });
        fields.insert("STACKING_NON_HEADER_DISCARD_ENA", Field { brief: Some("Enable discard of frames received without a stacking header."), details: Some("0: Disable 1: Enable"), lo: 1, hi: 2 });
        fields.insert("VSTAX_ISDX_ENA", Field { brief: Some("If set, and STACKING_AWARE_ENA=1 then any VStaX header in the frame is assumed to contain an ISDX. Otherwise the VStaX header is assumed to contain an AC. Related parameters: ANA_AC:PS_COMMON:COMMON_VSTAX_CFG.VSTAX2_MISC_ISDX_ENA"), details: Some("0: Disable 1: Enable"), lo: 3, hi: 4 });
        regs.insert("STACKING_CTRL", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Stacking configuration"), details: Some("Configure stacking awareness"), fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_DEI", Field { brief: Some("Default DEI bit for the port for untagged frames. Also used if port is VLAN unaware."), details: None, lo: 12, hi: 13 });
        fields.insert("PORT_PCP", Field { brief: Some("Default PCP value for the port for untagged frames. Also used if port is VLAN unaware."), details: None, lo: 13, hi: 16 });
        fields.insert("PORT_TAG_TYPE", Field { brief: Some("Default tag type for untagged frames. Also used if port is VLAN unaware. The tag type is carried with the frame to the rewriter where the tag type can be used when VLAN tagging the frame."), details: Some("0: Tag type equals C-tag 1: Tag type equals S-tag"), lo: 16, hi: 17 });
        fields.insert("PORT_VID", Field { brief: Some("Default VID value for the port for untagged frames. Also used if port is VLAN unaware."), details: None, lo: 0, hi: 12 });
        fields.insert("PORT_VOE_DEFAULT_DEI", Field { brief: Some("Default DEI value used by the port VOE for untagged frames or frames for which the outer tag's TPID is not accepted (see PORT_VOE_TPID_AWARE_DIS)."), details: None, lo: 22, hi: 23 });
        fields.insert("PORT_VOE_DEFAULT_PCP", Field { brief: Some("Default PCP value used by the port VOE for untagged frames or frames for which the outer tag's TPID is not accepted (see PORT_VOE_TPID_AWARE_DIS)."), details: None, lo: 23, hi: 26 });
        fields.insert("PORT_VOE_TPID_AWARE_DIS", Field { brief: Some("Configuration port VOE's VLAN awareness. Each bit corresponds to one of the known TPIDs. If the incoming frame's outer tag contains a TPID for which PORT_VOE_TPID_AWARE_DIS is set, then the port VOE sees the frame as untagged and uses the port VOE's default DEI and PCP (PORT_VOE_DEFAULT_PCP and PORT_VOE_DEFAULT_DEI) for LM updates."), details: Some("Bit0: Control TPID = 0x8100. Bit1: Control TPID = 0x88A8 Bit2: Control TPID = ANA_CL::VLAN_STAG_CFG[0] Bit3: Control TPID = ANA_CL::VLAN_STAG_CFG[1] Bit4: Control TPID = ANA_CL::VLAN_STAG_CFG[2]"), lo: 26, hi: 31 });
        fields.insert("VLAN_AWARE_ENA", Field { brief: Some("Enable VLAN awareness for port. If VLAN unaware, the frame's VLAN tags are not used for VLAN classification. Valid VLAN tags are defined in ANA_CL::VLAN_STAG_CFG[0-2] and ANA_CL:PORT:VLAN_TPID_CTRL.BASIC_TPID_AWARE_DIS."), details: Some("0: Disable (VLAN unaware) 1: Enable (VLAN aware)"), lo: 19, hi: 20 });
        fields.insert("VLAN_PCP_DEI_TRANS_ENA", Field { brief: Some("If set, the PCP_DEI_TRANS_CFG table is used for PCP and DEI classification. Otherwise, the frame's values are used directly."), details: None, lo: 21, hi: 22 });
        fields.insert("VLAN_POP_CNT", Field { brief: Some("Number of VLAN tag headers to remove from ingress frame. If the frame contains less VLAN tags than specified by register, the VLAN_POP_CNT is reduced to the number of VLAN tags in the frame."), details: Some("0: Keep all tags 1: Pop up to one tag if available 2: Pop up to two tags if available 3: Pop up to three tags if available"), lo: 17, hi: 19 });
        fields.insert("VLAN_TAG_SEL", Field { brief: Some("Select the VLAN tag used for basic VLAN and QoS classification. For VLAN classification, valid tags are defined by ANA_CL:PORT:VLAN_TPID_CTRL.BASIC_TPID_AWARE_DIS. For QoS classification, all accepted tags (ANA_CL:PORT:VLAN_FILTER_CTRL) are valid."), details: Some("0: Use first tag (outer-most tag). 1: Use second tag if present, otherwise use first tag."), lo: 20, hi: 21 });
        regs.insert("VLAN_CTRL", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("VLAN configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CTAG_DIS", Field { brief: Some("Discard frame if the investigated VLAN tag is a C-tag (TPID=0x8100) and VID>0."), details: None, lo: 8, hi: 9 });
        fields.insert("CUST1_STAG_DIS", Field { brief: Some("Discard frame if the investigated VLAN TPID equals VLAN_STAG_CFG[0].STAG_ETYPE_VAL and VID>0."), details: None, lo: 2, hi: 3 });
        fields.insert("CUST2_STAG_DIS", Field { brief: Some("Discard frame if the investigated VLAN TPID equals VLAN_STAG_CFG[1].STAG_ETYPE_VAL and VID>0."), details: None, lo: 1, hi: 2 });
        fields.insert("CUST3_STAG_DIS", Field { brief: Some("Discard frame if the investigated VLAN TPID equals VLAN_STAG_CFG[2].STAG_ETYPE_VAL and VID>0."), details: None, lo: 0, hi: 1 });
        fields.insert("PRIO_CTAG_DIS", Field { brief: Some("Discard frame if the investigated VLAN tag is a priority C-tag (TPID=0x8100 and VID=0)."), details: None, lo: 9, hi: 10 });
        fields.insert("PRIO_CUST1_STAG_DIS", Field { brief: Some("Discard frame if the investigated VLAN TPID equals VLAN_STAG_CFG[0].STAG_ETYPE_VAL and VID=0."), details: None, lo: 6, hi: 7 });
        fields.insert("PRIO_CUST2_STAG_DIS", Field { brief: Some("Discard frame if the investigated VLAN TPID equals VLAN_STAG_CFG[1].STAG_ETYPE_VAL and VID=0."), details: None, lo: 5, hi: 6 });
        fields.insert("PRIO_CUST3_STAG_DIS", Field { brief: Some("Discard frame if the investigated VLAN TPID equals VLAN_STAG_CFG[2].STAG_ETYPE_VAL and VID=0."), details: None, lo: 4, hi: 5 });
        fields.insert("PRIO_STAG_DIS", Field { brief: Some("Discard frame if the investigated VLAN tag is a priority S-tag (TPID=0x88A8 and VID=0)."), details: None, lo: 7, hi: 8 });
        fields.insert("STAG_DIS", Field { brief: Some("Discard frame if the investigated VLAN tag is an S-tag (TPID=0x88A8) and VID>0."), details: None, lo: 3, hi: 4 });
        fields.insert("TAG_REQUIRED_ENA", Field { brief: Some("Discard frame if VLAN_FILTER_CTRL[n].TAG_REQUIRED_ENA is set and the number of VLAN tags in frame is less than n+1: - If VLAN_FILTER_CTRL[0].TAG_REQUIRED_ENA is set: Discard frame if it is untagged. - If VLAN_FILTER_CTRL[1].TAG_REQUIRED_ENA is set: Discard frame if it is single tagged or untagged. - If VLAN_FILTER_CTRL[2].TAG_REQUIRED_ENA is set: Discard frame if it is single tagged, double tagged, or untagged."), details: None, lo: 10, hi: 11 });
        regs.insert("VLAN_FILTER_CTRL", Register { addr: Address { base: 1, count: 3, width: 1 }, brief: Some("VLAN acceptance filter"), details: Some("VLAN_FILTER_CTRL[0] applies to outer VLAN tag (first tag). VLAN_FILTER_CTRL[1] applies to middle VLAN tag (second tag). VLAN_FILTER_CTRL[2] applies to inner VLAN tag (third tag)."), fields });
        let mut fields = HashMap::new();
        fields.insert("BASIC_TPID_AWARE_DIS", Field { brief: Some("Control which TPID values are accepted as valid VLAN tags for L3 routing and basic VLAN classification. If an incoming frame contains a TPID for which BASIC_TPID_AWARE_DIS is set, then the TPID is treated a non-TPID EtherType and no further tags are identified."), details: Some("Bit0: First (outermost) TPID = 0x8100. Bit1: First TPID = 0x88A8 Bit2: First TPID = ANA_CL::VLAN_STAG_CFG[0] Bit3: First TPID = ANA_CL::VLAN_STAG_CFG[1] Bit4: First TPID = ANA_CL::VLAN_STAG_CFG[2] Bit5: Second TPID = 0x8100. Bit6: Second TPID = 0x88A8 Bit7: Second TPID = ANA_CL::VLAN_STAG_CFG[0] Bit8: Second TPID = ANA_CL::VLAN_STAG_CFG[1] Bit9: Second TPID = ANA_CL::VLAN_STAG_CFG[2] Bit10: Third TPID = 0x8100. Bit11: Third TPID = 0x88A8 Bit12: Third TPID = ANA_CL::VLAN_STAG_CFG[0] Bit13: Third TPID = ANA_CL::VLAN_STAG_CFG[1] Bit14: Third TPID = ANA_CL::VLAN_STAG_CFG[2]"), lo: 4, hi: 19 });
        fields.insert("RT_TAG_CTRL", Field { brief: Some("Control the number of VLAN tags, which are accepted for frames to be routed. Valid VLAN tags are defined in ANA_CL:PORT:VLAN_TPID_CTRL.BASIC_TPID_AWARE_DIS and ANA_CL::VLAN_STAG_CFG[0-2]."), details: Some("Bit0: Route untagged frames. Bit1: Route frames with one accepted tag (TPID is accepted by BASIC_TPID_AWARE_DIS) Bit2: Route frames with two accepted tags (TPID is accepted by BASIC_TPID_AWARE_DIS) Bit3: Route frames with three accepted tags (TPID is accepted by BASIC_TPID_AWARE_DIS)"), lo: 0, hi: 4 });
        regs.insert("VLAN_TPID_CTRL", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("TPID awareness configuration"), details: Some("Configuration of which TPID values are accepted as valid VLAN tags."), fields });
        groups.insert("PORT", RegisterGroup { addr: Address { base: 36864, count: 57, width: 64 }, desc: "Classification and filter configurations per port", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("IPT_CFG", Field { brief: Some("ISDX protection configuration."), details: Some("0: No protection Value applicable for forwarding from UNI to a protected NNI: 1: Set PROT_ACTIVE=1 to REW if the ISDX's protection group uses the protection entity. Values applicable for forwarding from a protected NNI to UNI: 2: Working entity. Discard received frame if the ISDX's protection group uses the protection entity, i.e. ANA_CL:PPT:PP_CFG.STATE=1 3: Protection entity: Discard received frame if the ISDX's protection group uses the working entity, i.e. ANA_CL:PPT:PP_CFG.STATE=0"), lo: 11, hi: 13 });
        fields.insert("PPT_IDX", Field { brief: Some("Pointer to protection state in ANA_CL:PPT for the protection group, which this ISDX is a member of."), details: None, lo: 0, hi: 9 });
        fields.insert("PROT_PIPELINE_PT", Field { brief: Some("Configures the protection pipeline point where ISDX protection operates at."), details: Some("0: ANA_IPT_PROT 1: ANA_OU_PROT 2: ANA_MID_PROT 3: ANA_IN_PROT"), lo: 9, hi: 11 });
        regs.insert("IPT", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Ingress Protection Configuration"), details: None, fields });
        groups.insert("PPT", RegisterGroup { addr: Address { base: 36716, count: 1, width: 16 }, desc: "Protection Programming Table", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ADV_CL_MPLS_DEF_OAM_STICKY", Field { brief: Some("This sticky bit signals frame for Default OAM qu seen."), details: None, lo: 21, hi: 22 });
        fields.insert("ADV_CL_MPLS_ERR_STICKY", Field { brief: Some("This sticky bit signals frame for MPLS err qu seen."), details: None, lo: 23, hi: 24 });
        fields.insert("ADV_CL_MPLS_G8113_1_NON_OAM_STICKY", Field { brief: Some("This sticky bit signals MPLS G8113_1 NON OAM frames."), details: None, lo: 22, hi: 23 });
        fields.insert("ADV_CL_MPLS_IP_PROFILE_STICKY", Field { brief: Some("This sticky bit signals IP frame received and handled via IP Control Profile LSR POP (FWD_TYPE=3) with (nxt_type_after_offset = CW) seen."), details: None, lo: 25, hi: 26 });
        fields.insert("ADV_CL_MPLS_IP_TRAFFIC_STICKY", Field { brief: Some("This sticky bit signals IP frame received as LSR POP (FWD_TYPE=3) with (nxt_type_after_offset = CW) seen."), details: None, lo: 24, hi: 25 });
        fields.insert("ADV_CL_MPLS_MEP_OAM_STICKY", Field { brief: Some("This sticky bit signals frame for PATH OAM MEP seen."), details: None, lo: 20, hi: 21 });
        fields.insert("ADV_CL_MPLS_POP_ERR_STICKY", Field { brief: Some("This sticky bit signals MPLS POP err when fwd_mode=3."), details: None, lo: 19, hi: 20 });
        fields.insert("ADV_CL_MPLS_RSVD_PROFILE_STICKY", Field { brief: Some("This sticky bit signals frame received and handled via Reserved Profile."), details: None, lo: 26, hi: 27 });
        fields.insert("ADV_CL_MPLS_RSV_XTR_STICKY", Field { brief: Some("This sticky bit indicate frame redirected to CPU due to reserved label seen with valid labels."), details: None, lo: 17, hi: 18 });
        fields.insert("ADV_CL_MPLS_SEGMENT_OAM_STICKY", Field { brief: Some("This sticky bit signals frame for Segment OAM seen."), details: None, lo: 27, hi: 28 });
        fields.insert("ADV_CL_MPLS_SWAP_ERR_STICKY", Field { brief: Some("This sticky bit signals MPLS SWAP err."), details: None, lo: 18, hi: 19 });
        fields.insert("ADV_CL_MPLS_TERM_MIP_LSP_STICKY", Field { brief: Some("This sticky bit signals MPLS CPU redir of MIP LSP OAM."), details: None, lo: 9, hi: 10 });
        fields.insert("ADV_CL_MPLS_TERM_MIP_NO_HW_STICKY", Field { brief: Some("This sticky bit signals MPLS CPU redir of MIP VCCv2 and VCCv3 no CW."), details: None, lo: 14, hi: 15 });
        fields.insert("ADV_CL_MPLS_TERM_MIP_SEGMENT_STICKY", Field { brief: Some("This sticky bit signals MPLS CPU redir of MIP Segment OAM."), details: None, lo: 8, hi: 9 });
        fields.insert("ADV_CL_MPLS_TERM_MIP_VCC1_STICKY", Field { brief: Some("This sticky bit signals MPLS CPU redir of MIP VCCv1 OAM."), details: None, lo: 13, hi: 14 });
        fields.insert("ADV_CL_MPLS_TERM_MIP_VCC2_STICKY", Field { brief: Some("This sticky bit signals MPLS CPU redir of MIP VCCv2 OAM."), details: None, lo: 12, hi: 13 });
        fields.insert("ADV_CL_MPLS_TERM_MIP_VCC3_STICKY", Field { brief: Some("This sticky bit signals MPLS CPU redir of MIP VCCv3 OAM."), details: None, lo: 11, hi: 12 });
        fields.insert("ADV_CL_MPLS_TERM_MIP_VCC4_STICKY", Field { brief: Some("This sticky bit signals MPLS CPU redir of MIP VCCv4 OAM."), details: None, lo: 10, hi: 11 });
        fields.insert("ADV_CL_MPLS_TERM_PW_CW_STICKY", Field { brief: Some("This sticky bit signals MPLS PW termination of data with Control Word."), details: None, lo: 16, hi: 17 });
        fields.insert("ADV_CL_MPLS_TERM_PW_ERR_STICKY", Field { brief: Some("This sticky bit signals MPLS PW termination err (frame is discarded)."), details: None, lo: 3, hi: 4 });
        fields.insert("ADV_CL_MPLS_TERM_PW_STICKY", Field { brief: Some("This sticky bit signals MPLS PW termination of data."), details: None, lo: 15, hi: 16 });
        fields.insert("ADV_CL_MPLS_TERM_PW_VCC1_STICKY", Field { brief: Some("This sticky bit signals MPLS PW termination of OAM VCCv1."), details: None, lo: 7, hi: 8 });
        fields.insert("ADV_CL_MPLS_TERM_PW_VCC2_STICKY", Field { brief: Some("This sticky bit signals MPLS PW termination of OAM VCCv2."), details: None, lo: 6, hi: 7 });
        fields.insert("ADV_CL_MPLS_TERM_PW_VCC3_STICKY", Field { brief: Some("This sticky bit signals MPLS PW termination of OAM VCCv3."), details: None, lo: 5, hi: 6 });
        fields.insert("ADV_CL_MPLS_TERM_PW_VCC4_STICKY", Field { brief: Some("This sticky bit signals MPLS PW termination of OAM VCCv4."), details: None, lo: 4, hi: 5 });
        fields.insert("ADV_CL_MPLS_TOO_FEW_VLD_LABELS_STICKY", Field { brief: Some("This sticky bit signals vld lables set to less than available."), details: None, lo: 2, hi: 3 });
        fields.insert("ADV_CL_MPLS_USE_TC_STICKY", Field { brief: Some("This sticky bit signals TC value extracted from Label stack."), details: None, lo: 0, hi: 1 });
        fields.insert("ADV_CL_MPLS_USE_TTL_STICKY", Field { brief: Some("This sticky bit signals TTL value extracted from Label stack."), details: None, lo: 1, hi: 2 });
        regs.insert("ADV_CL_MPLS_STICKY", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Sticky bits register for events generated by advanced VCAP classification when handling MPLS TP"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ADV_CL_COSID_STICKY", Field { brief: Some("This sticky bit signals COS ID from the VCAP was used."), details: None, lo: 18, hi: 19 });
        fields.insert("ADV_CL_DEI_STICKY", Field { brief: Some("This sticky bit signals DEI from the VCAP was used."), details: None, lo: 14, hi: 15 });
        fields.insert("ADV_CL_DP_STICKY", Field { brief: Some("This sticky bit signals DP from the VCAP was used."), details: None, lo: 15, hi: 16 });
        fields.insert("ADV_CL_DSCP_STICKY", Field { brief: Some("This sticky bit signals DSCP value from the VCAPs was used."), details: None, lo: 17, hi: 18 });
        fields.insert("ADV_CL_GENERIC_IDX_STICKY", Field { brief: Some("This sticky bit signals generic index was changed from the VCAP."), details: None, lo: 6, hi: 7 });
        fields.insert("ADV_CL_HIH_FORCE_MODE_USED_STICKY", Field { brief: Some("This sticky bit signals that a HIH force mode use of map index was used."), details: None, lo: 22, hi: 23 });
        fields.insert("ADV_CL_HIH_KEY_USED_STICKY", Field { brief: Some("This sticky bit signals that a HIH lookup key was used."), details: None, lo: 21, hi: 22 });
        fields.insert("ADV_CL_ISDX_STICKY", Field { brief: Some("This sticky bit signals ISDX from the VCAP was used."), details: None, lo: 8, hi: 9 });
        fields.insert("ADV_CL_MAP_TBL_IDX0_UPDATED_STICKY", Field { brief: Some("This sticky bit signals MAP table usage from the VCAP was used."), details: None, lo: 10, hi: 11 });
        fields.insert("ADV_CL_MAP_TBL_IDX1_UPDATED_STICKY", Field { brief: Some("This sticky bit signals MAP table usage from the VCAP was used."), details: None, lo: 9, hi: 10 });
        fields.insert("ADV_CL_MASQ_INJ_STICKY", Field { brief: Some("This sticky bit signals MASQ_INJ was triggered from the VCAP was used."), details: None, lo: 7, hi: 8 });
        fields.insert("ADV_CL_MAX_W16_OFFSET_FAIL_STICKY", Field { brief: Some("This sticky bit signals that a frame ways attempted to normalized beyond what is supported."), details: None, lo: 20, hi: 21 });
        fields.insert("ADV_CL_NXT_KEY_TYPE_STICKY", Field { brief: Some("This sticky bit signals NXT_KEY_TYPE from the VCAP was used."), details: None, lo: 5, hi: 6 });
        fields.insert("ADV_CL_NXT_NORMALIZE_STICKY", Field { brief: Some("This sticky bit signals NXT_NORMALIZE from the VCAP was used."), details: None, lo: 1, hi: 2 });
        fields.insert("ADV_CL_NXT_OFFSET_TOO_BIG_STICKY", Field { brief: Some("This sticky bit signals NXT_OFFSET_FROM_TYPE > 63 from the VCAP was attempted."), details: None, lo: 0, hi: 1 });
        fields.insert("ADV_CL_NXT_TYPE_CW_STICKY", Field { brief: Some("This sticky bit signals NXT_TYPE_AFTER_OFFSET = CW from the VCAP was used."), details: None, lo: 2, hi: 3 });
        fields.insert("ADV_CL_NXT_TYPE_ETH_STICKY", Field { brief: Some("This sticky bit signals NXT_TYPE_AFTER_OFFSET = ETH from the VCAP was used."), details: None, lo: 4, hi: 5 });
        fields.insert("ADV_CL_NXT_TYPE_MPLS_STICKY", Field { brief: Some("This sticky bit signals NXT_TYPE_AFTER_OFFSET = MPLS from the VCAP was used."), details: None, lo: 3, hi: 4 });
        fields.insert("ADV_CL_PCP_STICKY", Field { brief: Some("This sticky bit signals PCP from the VCAP was used."), details: None, lo: 13, hi: 14 });
        fields.insert("ADV_CL_QOS_STICKY", Field { brief: Some("This sticky bit signals QoS class from the VCAP was used."), details: None, lo: 16, hi: 17 });
        fields.insert("ADV_CL_VID_STICKY", Field { brief: Some("This sticky bit signals VID from the VCAP was used."), details: None, lo: 12, hi: 13 });
        fields.insert("ADV_CL_VLAN_POPCNT_STICKY", Field { brief: Some("This sticky bit signals VLAN pop count from the VCAP was used."), details: None, lo: 11, hi: 12 });
        fields.insert("ADV_CL_VLAN_WAS_TAGGED_STICKY", Field { brief: Some("This sticky bit signals was_tagged from the VCAP was used."), details: None, lo: 19, hi: 20 });
        regs.insert("ADV_CL_STICKY", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Sticky bits register for events generated by advanced VCAP classification"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("AG_STICKY", Field { brief: Some("This bit is set if a 802.1ag control frame  (DMAC in the range 01-80-C2-00-00-30 to 01-80-C2-00-00-3F) has been detected."), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 8, hi: 9 });
        fields.insert("BPDU_STICKY", Field { brief: Some("This bit is set if a BPDU control frame  (DMAC in the range 01-80-C2-00-00-00 to 01-80-C2-00-00-0F) has been detected."), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 7, hi: 8 });
        fields.insert("CAPTURE_TPID_DIS_STICKY", Field { brief: Some("Set if a frame has been received with a TPID disabled for CPU forwarding."), details: Some("0: The event has not occured 1: The event did occour Bit is cleared by writing a 1 to this position."), lo: 20, hi: 21 });
        fields.insert("GXRP_STICKY", Field { brief: Some("This bit is set if a GxRP frame ( DMAC in the range 01-80-C2-00-00-20 to 01-80-C2-00-00-2F) has been detected."), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 6, hi: 7 });
        fields.insert("IGMP_STICKY", Field { brief: Some("Set if an IGMP frame has been detected."), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 9, hi: 10 });
        fields.insert("IP4_MC_CTRL_STICKY", Field { brief: Some("Set if an IP Multicast control frame has been detected. - DMAC = 0x01005Exxxxxx , Ethernet Type = IP, IP Protocol != IGMP, DIP = 224.0.0.x"), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 4, hi: 5 });
        fields.insert("IP6_HOP_BY_HOP_STICKY", Field { brief: Some("Is set if an IPv6 frame with a hop by hop header and ICMPv6 was seen."), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 1, hi: 2 });
        fields.insert("IP6_ICMP_HOP_BY_HOP_STICKY", Field { brief: Some("Indicates that a IPv6 frame with hop by hop options and ICMPv6 was seen."), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 2, hi: 3 });
        fields.insert("IP6_MC_CTRL_STICKY", Field { brief: Some("Set if an IPv6 Multicast control frame has been detected. - DMAC = 0x3333xxxxxxxx , Ethernet Type = IPv6, DIP = FF02::/16"), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 5, hi: 6 });
        fields.insert("MLD_STICKY", Field { brief: Some("Set if an MLD frame has been detected."), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 3, hi: 4 });
        fields.insert("VRAP_STICKY", Field { brief: Some("Set if a VRAP frame has been detected."), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 10, hi: 11 });
        fields.insert("VSTAX2_TTL_ZERO_STICKY", Field { brief: Some("Indicates that a frame with a VStax2 TTL value of 0 was dropped."), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 11, hi: 12 });
        regs.insert("CAT_STICKY", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Sticky bits register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DSCP_QOS_REWR_STICKY", Field { brief: Some("This sticky bit indicates that the QoS class was used as index into the DSCP_REWR_VAL table to determine the DSCP value."), details: Some("0: No event 1: QoS class has been used to determine the DSCP Bit is cleared by writing a 1 to this position."), lo: 9, hi: 10 });
        fields.insert("DSCP_TRANSLATE_STICKY", Field { brief: Some("Set when the  DSCP value is based on the DSCP_TRANSLATE_VAL."), details: Some("0: No event 1: DSCP_TRANSLATE_VAL has been used. Bit is cleared by writing a 1 to this position."), lo: 8, hi: 9 });
        fields.insert("QOS_DEFAULT_STICKY", Field { brief: Some("Set when the default port QoS has been used."), details: Some("0: No event 1: Port default has been used for QoS classification Bit is cleared by writing a 1 to this position."), lo: 3, hi: 4 });
        fields.insert("QOS_DSCP_STICKY", Field { brief: Some("Set when the DSCP QoS has been used."), details: Some("0: No event 1: DSCP QoS class has been used for QoS classification Bit is cleared by writing a 1 to this position."), lo: 1, hi: 2 });
        fields.insert("QOS_PCP_DEI_STICKY", Field { brief: Some("Set when the classified PCP and DEI value is used to to determeine the QoS class."), details: Some("0: No event 1: PCP value has been used for QoS classification Bit is cleared by writing a 1 to this position."), lo: 4, hi: 5 });
        fields.insert("QOS_STACK_TAG_STICKY", Field { brief: Some("Set when the stacking QoS has been used."), details: Some("0: No event 1: Stacking header QoS class has been used for QoS classification Bit is cleared by writing a 1 to this position."), lo: 0, hi: 1 });
        fields.insert("VID_PORT_STICKY", Field { brief: Some("Set when the port VLAN has been used."), details: Some("0: The event has not occured 1: Port default value has been used for VLAN classification Bit is cleared by writing a 1 to this position."), lo: 7, hi: 8 });
        fields.insert("VID_STACK_STICKY", Field { brief: Some("Set when the VID information from Stacking TAG has been used."), details: Some("0: The event has not occured 1: Stacking Header VID has been used for VLAN classification Bit is cleared by writing a 1 to this position."), lo: 6, hi: 7 });
        fields.insert("VID_TAG_STICKY", Field { brief: Some("Set when vid from the TAG has been used."), details: Some("0: The event has not occured 1: TCI VID value has been used for VLAN classification Bit is cleared by writing a 1 to this position."), lo: 5, hi: 6 });
        regs.insert("CLASS_STICKY", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Sticky bits register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BAD_MACS_STICKY", Field { brief: Some("Set if a frame is dropped due to zero MAC addresses filtering or multicast source MAC address filtering."), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 0, hi: 1 });
        fields.insert("STACKING_FILTER_STICKY", Field { brief: Some("Set if a frame has been filtered due to wrong stacking information (e.g. not expected stacking tag etc.)."), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 1, hi: 2 });
        regs.insert("FILTER_STICKY", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Sticky bits register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MIP_CCM_COPY_STICKY", Field { brief: Some("This sticky bit signals CCM copy MIP operation."), details: None, lo: 0, hi: 1 });
        fields.insert("MIP_GENERIC_STICKY", Field { brief: Some("This sticky bit signals Generic MIP operation."), details: None, lo: 4, hi: 5 });
        fields.insert("MIP_LBM_DA_CHK_FAIL_STICKY", Field { brief: Some("This sticky bit signals MIP LBM operation failed due to faild MAC address check."), details: None, lo: 5, hi: 6 });
        fields.insert("MIP_LBM_REDIR_STICKY", Field { brief: Some("This sticky bit signals LBM redir MIP operation."), details: None, lo: 1, hi: 2 });
        fields.insert("MIP_LTM_REDIR_STICKY", Field { brief: Some("This sticky bit signals LTM redir MIP operation."), details: None, lo: 2, hi: 3 });
        fields.insert("MIP_MEL_CHK_FAIL_STICKY", Field { brief: Some("This sticky bit signals MIP operation failed due to MEL check."), details: None, lo: 6, hi: 7 });
        fields.insert("MIP_RAPS_STICKY", Field { brief: Some("This sticky bit signals  RAPS MIP operation."), details: None, lo: 3, hi: 4 });
        regs.insert("MIP_STICKY", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("Sticky bits register for events generated by MIP operation"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("STATE", Field { brief: Some("Protection state vector with one bit per protection group. The protection group, used by a given service, is configured in ANA_CL:IPT:IPT.PPT_IDX. For protection group n, the protection status bit is derived the following way: ANA_CL:PPT:PP_CFG[n DIV 32].STATE[n MOD 32]."), details: Some("0: Protection group uses working entity. 1: Protection group uses protection entity."), lo: 0, hi: 32 });
        regs.insert("PP_CFG", Register { addr: Address { base: 0, count: 16, width: 1 }, brief: Some("Protection state configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FILTER_CTAG_STICKY", Field { brief: Some("Set if a frame is dropped due to C-TAG filtering at the given tag position."), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 2, hi: 3 });
        fields.insert("FILTER_PRIO_CTAG_STICKY", Field { brief: Some("Set if a frame is dropped due to priority C-TAG filtering at the given tag position."), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 3, hi: 4 });
        fields.insert("FILTER_PRIO_STAG_STICKY", Field { brief: Some("Set if a frame is dropped due priority S-TAG filtering at the given tag position."), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 1, hi: 2 });
        fields.insert("FILTER_REQUIRED_TAG_STICKY", Field { brief: Some("Set if a frame is dropped due required tag was not found."), details: Some("0: No Event 1: Event Bit is cleared by writing a 1 to this position."), lo: 4, hi: 5 });
        fields.insert("FILTER_STAG_STICKY", Field { brief: Some("Set if a frame is dropped due to S-TAG filtering at the given tag position."), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 0, hi: 1 });
        regs.insert("VLAN_FILTER_STICKY", Register { addr: Address { base: 1, count: 3, width: 1 }, brief: Some("Sticky bits register"), details: Some("Replicated three times, once for each tag. Replication 0 is outer-most tag, 2 is inner-most tag."), fields });
        groups.insert("STICKY", RegisterGroup { addr: Address { base: 36732, count: 1, width: 10 }, desc: "Sticky diagnostic status", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("AG_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 8, hi: 9 });
        fields.insert("BPDU_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 7, hi: 8 });
        fields.insert("CAPTURE_TPID_DIS_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 20, hi: 21 });
        fields.insert("GXRP_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 6, hi: 7 });
        fields.insert("IGMP_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 9, hi: 10 });
        fields.insert("IP4_MC_CTRL_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 4, hi: 5 });
        fields.insert("IP6_HOP_BY_HOP_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 1, hi: 2 });
        fields.insert("IP6_ICMP_HOP_BY_HOP_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 2, hi: 3 });
        fields.insert("IP6_MC_CTRL_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 5, hi: 6 });
        fields.insert("MLD_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 3, hi: 4 });
        fields.insert("VRAP_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 10, hi: 11 });
        fields.insert("VSTAX2_TTL_ZERO_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 11, hi: 12 });
        regs.insert("CAT_STICKY_MASK", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Sticky counter mask register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DSCP_QOS_REWR_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 9, hi: 10 });
        fields.insert("DSCP_TRANSLATE_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 8, hi: 9 });
        fields.insert("QOS_DEFAULT_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 3, hi: 4 });
        fields.insert("QOS_DSCP_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 1, hi: 2 });
        fields.insert("QOS_PCP_DEI_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 4, hi: 5 });
        fields.insert("QOS_STACK_TAG_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 0, hi: 1 });
        fields.insert("VID_PORT_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 7, hi: 8 });
        fields.insert("VID_STACK_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 6, hi: 7 });
        fields.insert("VID_TAG_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 5, hi: 6 });
        regs.insert("CLASS_STICKY_MASK", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Sticky counter mask register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BAD_MACS_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 0, hi: 1 });
        fields.insert("STACKING_FILTER_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 1, hi: 2 });
        regs.insert("FILTER_STICKY_MASK", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Sticky counter mask register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("IP4_CHKSUM_STICKY", Field { brief: Some("Set if an IP checksum error is found."), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 0, hi: 1 });
        fields.insert("IP4_FRAGMENT_STICKY", Field { brief: Some("Set if an IP fragmented frame is found."), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 2, hi: 3 });
        fields.insert("IP4_LEN_STICKY", Field { brief: Some("Set if IP total length is less that IP header length."), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 1, hi: 2 });
        fields.insert("IP_OPTIONS_STICKY", Field { brief: Some("Set if an IP packet with options is found."), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 3, hi: 4 });
        regs.insert("IP_HDR_CHK_STICKY", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("Sticky bits register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("IP4_CHKSUM_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 0, hi: 1 });
        fields.insert("IP4_FRAGMENT_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 2, hi: 3 });
        fields.insert("IP4_LEN_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 1, hi: 2 });
        fields.insert("IP_OPTIONS_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 3, hi: 4 });
        regs.insert("IP_HDR_CHK_STICKY_MASK", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Sticky counter mask register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MIP_CCM_COPY_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 0, hi: 1 });
        fields.insert("MIP_GENERIC_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 4, hi: 5 });
        fields.insert("MIP_LBM_DA_CHK_FAIL_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 5, hi: 6 });
        fields.insert("MIP_LBM_REDIR_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 1, hi: 2 });
        fields.insert("MIP_LTM_REDIR_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 2, hi: 3 });
        fields.insert("MIP_MEL_CHK_FAIL_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 6, hi: 7 });
        fields.insert("MIP_RAPS_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 3, hi: 4 });
        regs.insert("MIP_STICKY_MASK", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Sticky counter mask register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FILTER_CTAG_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 2, hi: 3 });
        fields.insert("FILTER_PRIO_CTAG_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 3, hi: 4 });
        fields.insert("FILTER_PRIO_STAG_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enabale event count"), lo: 1, hi: 2 });
        fields.insert("FILTER_REQUIRED_TAG_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 4, hi: 5 });
        fields.insert("FILTER_STAG_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enabale event count"), lo: 0, hi: 1 });
        regs.insert("VLAN_FILTER_STICKY_MASK", Register { addr: Address { base: 1, count: 3, width: 1 }, brief: Some("Sticky counter mask register"), details: None, fields });
        groups.insert("STICKY_MASK", RegisterGroup { addr: Address { base: 36742, count: 4, width: 8 }, desc: "Sticky diagnostic global port counter event configuration", regs });
        out.insert("ANA_CL", Target { desc: "Classifier sub block of the Analyzer", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("AUTO_LRN_ENA", Field { brief: Some("Configures per port automatic learning of incoming learn frames received on this port. Forwarding to CPU is still allowed. This does not influence the port move detection in ANA_L2::MOVELOG_STICKY."), details: Some("x0x: Disable automatic learning for the port x1x: Enable automatic learning of incoming learn frames received on this port"), lo: 0, hi: 32 });
        regs.insert("AUTO_LRN_CFG", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Auto learn configuration"), details: Some("Configures automatic learning per port"), fields });
        let mut fields = HashMap::new();
        fields.insert("AUTO_LRN_ENA1", Field { brief: Some("Refer to AUTO_LRN_CFG.AUTO_LRN_ENA description."), details: Some("x0x: Disable automatic learning for the port x1x: Enable automatic learning of incoming learn frames received on this port"), lo: 0, hi: 21 });
        regs.insert("AUTO_LRN_CFG1", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Auto learn configuration"), details: Some("Configures automatic learning per port"), fields });
        let mut fields = HashMap::new();
        fields.insert("FILTER_FRONTPORT_ENA", Field { brief: Some("Configures additional front port SCAN filter for Automatic ageing and CPU scan. See LRN::SCAN_NEXT_CFG.SCAN_USE_PORT_FILTER_ENA and LRN::AUTOAGE_CFG_1.USE_PORT_FILTER_ENA."), details: Some("x0x: Handle entries associated with the front port during automatic ageing and CPU scan x1x: Ignore entries associated with the front port during automatic ageing and CPU scan"), lo: 0, hi: 32 });
        regs.insert("FILTER_LOCAL_CTRL", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Front Port scan filter configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FILTER_FRONTPORT_ENA1", Field { brief: Some("Refer to FILTER_LOCAL_CTRL.FILTER_FRONTPORT_ENA description."), details: Some("x0x: Handle entries associated with the front port during automatic ageing and CPU scan x1x: Ignore entries associated with the front port during automatic ageing and CPU scan"), lo: 0, hi: 21 });
        regs.insert("FILTER_LOCAL_CTRL1", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Front Port scan filter configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FILTER_REMOTE_ENA", Field { brief: Some("Configures additional filtering of Remote entries (i.e. entries with UPSID != ANA_L2::VSTAX_CTRL.OWN_UPSID) for automatic ageing and CPU scan. See LRN::SCAN_NEXT_CFG.SCAN_USE_PORT_FILTER_ENA and LRN::AUTOAGE_CFG_1.USE_PORT_FILTER_ENA."), details: Some("0: handle remote entries during automatic ageing and CPU scan 1: ignore remote entries during Automatic ageing and CPU scan"), lo: 0, hi: 1 });
        regs.insert("FILTER_OTHER_CTRL", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Remote scan filter configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CPU_DMAC_COPY_ENA", Field { brief: Some("Configures CPU copy of frames where (DMAC, EFID) is known in the MAC table and the entry has the CPU_COPY bit set. Frames are sent to the CPU queue configured in ANA_L2::FWD_CFG.CPU_DMAC_QU."), details: None, lo: 6, hi: 7 });
        fields.insert("CPU_DMAC_QU", Field { brief: Some("Configures the CPU queue for forwarded frames that have the CPU_COPY flag set when enabled with:\tANA_L2::FWD_CFG.CPU_DMAC_COPY_ENA. Applicable frames are sent to this CPU queue."), details: Some("0: CPU queue 0 1: CPU queue 1 ... n: CPU queue n."), lo: 8, hi: 11 });
        fields.insert("FILTER_MODE_SEL", Field { brief: Some("Configures use of LRN::MAC_ACCESS_CFG_2.MAC_ENTRY_VLAN_IGNORE FLAG from the MAC table entries as VLAN_IGNORE or as SRC_MASK_IGNORE. This also configures the use of ANA_L2::FWD_CFG.FLOOD_IGNORE_VLAN_ENA when frames are flooded."), details: Some("0: Use as VLAN ignore which means that the VLAN mask from ANA_L3:VLAN:VLAN_MASK_CFG is not applied when forwarding by means of entry with VLAN_IGNORE set. 1: Use as Source mask ignore which means that the SOURCE mask from ANA_AC:SRC:SRC_CFG is not applied when forwarding (frames can be send back to the sending port)"), lo: 4, hi: 5 });
        fields.insert("FLOOD_CPU_COPY_ENA", Field { brief: Some("Configures CPU copy operation for flooded frames. Frames are sent to the CPU queue configured in ANA_L2::FWD_CFG.CPU_DMAC_QU."), details: None, lo: 1, hi: 2 });
        fields.insert("FLOOD_IGNORE_VLAN_ENA", Field { brief: Some("Configures VLAN_IGNORE operation for flooded frames. See also ANA_L2::FWD_CFG.FILTER_MODE_SEL."), details: None, lo: 2, hi: 3 });
        fields.insert("FLOOD_MIRROR_ENA", Field { brief: Some("Configures mirroring operation for flooded frames. See ANA_AC:MIRROR_PROBE:PROBE_CFG.PROBE_MAC_MODE."), details: None, lo: 3, hi: 4 });
        fields.insert("FWD_ENA", Field { brief: Some("Configures use of MAC table for forwarding."), details: Some("0: Disable all MAC fwd related lookups. All frames are flooded. 1: Enable all MAC fwd related lookups"), lo: 0, hi: 1 });
        fields.insert("ISDX_LOOKUP_ENA", Field { brief: Some("Enables service forwarding based on lookup of ISDX in ISDX table. See ANA_L2:ISDX"), details: None, lo: 16, hi: 17 });
        fields.insert("LOOPBACK_ENA", Field { brief: Some("Configures loopback for frames with DMAC = SMAC and bit 41 in the MAC address set (= local administrated)."), details: None, lo: 7, hi: 8 });
        fields.insert("MAC_TBL_SPLIT_SEL", Field { brief: Some("Configures MAC table Size"), details: Some("\"00\": No MAC tables \"01\": 8K CMAC table \"10\": 16K CMAC table \"11\": 32K CMAC table"), lo: 20, hi: 22 });
        fields.insert("PORT_DEFAULT_BDLB_ENA", Field { brief: Some("Configures port DLB index into BDLB policers when no service policing has been selected (ISDX == 0 AND ANA_L2:ISDX:DLB_CFG.DLB_IDX == 0). Per port index configured by means of ANA_L2::PORT_DLB_CFG.PORT_DLB_IDX."), details: Some("0: Disable. ANA_L2:ISDX[0]:MISC_CFG.BDLB_IDX used for all ports. 1: Enable. ANA_L2::PORT_DLB_CFG[port_num].PORT_DLB_IDX used when ISDX_VAL==0 AND ANA_L2:ISDX:DLB_CFG.DLB_IDX == 0"), lo: 18, hi: 19 });
        fields.insert("QUEUE_DEFAULT_SDLB_ENA", Field { brief: Some("Configures queue DLB index into SDLB policers when no service has been selected (ISDX == 0 AND ANA_L2:ISDX:DLB_CFG.DLB_IDX == 0). Per queue DLB index configured by means of ANA_L2::PORT_DLB_CFG.QUEUE_DLB_IDX."), details: Some("0: Disable. ANA_L2:ISDX[0]:DLB_CFG.DLB_IDX used for all ISDX_VAL values. 1: Enable. SDLB index = ANA_L2::PORT_DLB_CFG[port_num].QUEUE_DLB_IDX + IPRIO used when ISDX_VAL==0 AND ANA_L2:ISDX:DLB_CFG.DLB_IDX == 0"), lo: 17, hi: 18 });
        regs.insert("FWD_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Forwarding configuration"), details: Some("Configure common forwarding options. Upon reception of a frame the (DMAC, EFID) is used to perform a lookup in the MAC table. If an entry is found the destination is known and forwarded according to the entry ADDR_TYPE and ADDR. Alternatively the destination is considered unknown and might be applicable for flooding."), fields });
        let mut fields = HashMap::new();
        fields.insert("FID_LIMIT_INTR", Field { brief: Some("Set if FID learn limit triggered interrupt. To enable interrupt of this events set the corresponding *_INTR_ENA"), details: Some("0: No event has occured 1: FID_LIMIT triggered inq occured Bit is cleared by writing a 1 to this position."), lo: 0, hi: 1 });
        fields.insert("LRN_ACCESS_COMPLETE_INTR", Field { brief: Some("Set if LRN CPU access triggered interrupt. To enable interrupt of this events set the corresponding *_INTR_ENA"), details: Some("0: No event has occured 1: LRN_ACCESS_COMPLETE triggered inq occured Bit is cleared by writing a 1 to this position."), lo: 3, hi: 4 });
        fields.insert("PORT_LRN_LIMIT_INTR", Field { brief: Some("Set if Port learn limit triggered interrupt. To enable interrupt of this events set the corresponding *_INTR_ENA"), details: Some("0: No event has occured 1: PORT_LRN_LIMIT triggered inq occured Bit is cleared by writing a 1 to this position."), lo: 1, hi: 2 });
        fields.insert("SUPER_VCAP_INTR", Field { brief: Some("Set if SUPER_VCAP_INTR triggered interrupt. To enable interrupt of this events set the corresponding *_INTR_ENA"), details: Some("0: No event has occured 1: SUPER_VCAP_INTR triggered inq occured Bit is cleared by writing a 1 to this position."), lo: 4, hi: 5 });
        fields.insert("VCAP_S2_INTR", Field { brief: Some("Set if VCAP_S2 triggered interrupt. To enable interrupt of this events set the corresponding *_INTR_ENA"), details: Some("0: No event has occured 1: VCAP_S2 triggered inq occured Bit is cleared by writing a 1 to this position."), lo: 2, hi: 3 });
        regs.insert("INTR", Register { addr: Address { base: 86, count: 1, width: 1 }, brief: Some("ANA_L2 Interrupt events"), details: Some("ANA_L2 Interrupt events if interrupt enable is set in ANA_L2::INTR_ENA and the corresponding event is triggered in ANA_L2::INTR_IDENT"), fields });
        let mut fields = HashMap::new();
        fields.insert("FID_LIMIT_INTR_ENA", Field { brief: Some("Configures FID_LIMIT_INTR interrupts"), details: Some("0: Disable interrupt 1: Enable interrupt"), lo: 0, hi: 1 });
        fields.insert("LRN_ACCESS_COMPLETE_INTR_ENA", Field { brief: Some("Configures LRN_ACCESS_COMPLETE_INTR interrupts"), details: Some("0: Disable interrupt 1: Enable interrupt"), lo: 3, hi: 4 });
        fields.insert("PORT_LRN_LIMIT_INTR_ENA", Field { brief: Some("Configures PORT_LRN_LIMIT interrupts"), details: Some("0: Disable interrupt 1: Enable interrupt"), lo: 1, hi: 2 });
        fields.insert("SUPER_VCAP_INTR_ENA", Field { brief: Some("Configures SUPER_VCAP_INTR interrupts"), details: Some("0: Disable interrupt 1: Enable interrupt"), lo: 4, hi: 5 });
        fields.insert("VCAP_S2_INTR_ENA", Field { brief: Some("Configures VCAP_S2_INTR interrupts"), details: Some("0: Disable interrupt 1: Enable interrupt"), lo: 2, hi: 3 });
        regs.insert("INTR_ENA", Register { addr: Address { base: 87, count: 1, width: 1 }, brief: Some("ANA_L2 interrupt enable mask"), details: Some("Controls interrupt of CPU. Events can be found in ANA_L2::INTR Identity of interrupt events can be found in ANA_L2::INTR_IDENT"), fields });
        let mut fields = HashMap::new();
        fields.insert("AGED_BEFORE_NONAGED", Field { brief: Some("Configures if aged entries are choosen before nonaged when randomly selecting a non locket entry to replace"), details: Some("0: age flags are not considered when selecting an entry 1: age flags are considered when selecting an entry."), lo: 18, hi: 19 });
        fields.insert("AGE_LOCKED_ENA", Field { brief: Some("Configures clearing of the age bit in the source entry (LRN::MAC_ACCESS_CFG_2.MAC_ENTRY_AGE_FLAG) when receiving traffic from known stations which has the  LOCKED bit (LRN::MAC_ACCESS_CFG_2.MAC_ENTRY_LOCKED) in the source entry set."), details: Some("0: LOCKED entries are not touched. 1: The AGE flag for LOCKED entries will be cleared."), lo: 3, hi: 4 });
        fields.insert("AGE_SIZE", Field { brief: Some("Configures the AGE_FLAG size"), details: Some("0: one bit ageing periods used 1: two bit ageing periods used."), lo: 17, hi: 18 });
        fields.insert("AUTO_LRN_REPLACE_DIS", Field { brief: Some("Configures how already known MAC table entries are replace of in case of hash depletion when receiving traffic from an unknown station."), details: Some("0: Non locked entries are replaced 1: Known entries are never replaced."), lo: 13, hi: 14 });
        fields.insert("AUTO_LRN_USE_MAC_CAM_ENA", Field { brief: Some("Configures auto learning use of entries in the CAM. See ANA_L2::AUTO_LRN_CFG"), details: Some("0: Auto learn is limited to CMAC table 1: Auto learn may also use MAC CAM entries."), lo: 14, hi: 15 });
        fields.insert("CPU_FID_LIMIT_QU", Field { brief: Some("Configures the CPU queue for frames copied to CPU due to FID LEARN limit check. Frames are sent to this CPU queue."), details: Some("0: CPU queue 0 1: CPU queue 1 ... n: CPU queue n."), lo: 20, hi: 23 });
        fields.insert("CPU_LRN_QU", Field { brief: Some("Configures the CPU queue for CPU based learning when enabled by means of ANA_L2::LRN_COPY_CFG. Frames are sent to this CPU queue."), details: Some("0: CPU queue 0 1: CPU queue 1 ... n: CPU queue n."), lo: 4, hi: 7 });
        fields.insert("CPU_LRN_USE_MAC_CAM_ENA", Field { brief: Some("Configures use of entries in the CAM row for CPU learning."), details: Some("0: CPU learn is limited to MAC table 1: CPU learn may also use MAC CAM entries."), lo: 12, hi: 13 });
        fields.insert("CPU_SMAC_COPY_ENA", Field { brief: Some("Configures CPU copy of frames from known stations with the CPU_COPY bit set in the SOURCE entry. Copies are sent to the CPU queue specified in MAC table by means of LRN::MAC_ACCESS_CFG_2.MAC_ENTRY_CPU_QU."), details: None, lo: 0, hi: 1 });
        fields.insert("IGNORE_MCIDX_PORTMOVE_ENA", Field { brief: Some("Configures entries learned on a multicast index to not paticipate in learning."), details: None, lo: 24, hi: 25 });
        fields.insert("LOCKED_PORTMOVE_COPY_ENA", Field { brief: Some("Configures copy of frames from known stations with changed port (LRN::MAC_ACCESS_CFG_2.MAC_ENTRY_ADDR_TYPE and LRN::MAC_ACCESS_CFG_2.MAC_ENTRY_ADDR) in the source entry and the LOCKED bit (LRN::MAC_ACCESS_CFG_2.MAC_ENTRY_LOCKED) set. Copies are sent to the CPU queue specified by ANA_L2::LRN_CFG.CPU_LRN_QU."), details: None, lo: 2, hi: 3 });
        fields.insert("LOCKED_PORTMOVE_DETECT_ENA", Field { brief: Some("Configures detection of frames from known stations with changed port (LRN::MAC_ACCESS_CFG_2.MAC_ENTRY_ADDR_TYPE and LRN::MAC_ACCESS_CFG_2.MAC_ENTRY_ADDR) in the source entry and the LOCKED bit (LRN::MAC_ACCESS_CFG_2.MAC_ENTRY_LOCKED) set. When enabled, frames from static (LOCKED) entries with changed port triggers ANA_L2::MOVELOG_STICKY .."), details: None, lo: 1, hi: 2 });
        fields.insert("LRN_MOVE_CAM_ENTRY_BACK", Field { brief: Some("Configures entries in CAM row to be moved back to MAC table when empty entries exists"), details: Some("0: Known CAM entries are not moved back to MAC table 1: Known CAM entries are moved to MAC table when empty entries exists on a hashed row."), lo: 15, hi: 16 });
        fields.insert("VSTAX_BASIC_LRN_MODE_ENA", Field { brief: Some("Configures use Basic or advanced VStaX2 learning mode."), details: Some("0: Entries are learned on UPSID and UPSPN ports (VSTAX Advanced forwarding mode) 1: Entries are learned on stacking ports (VSTAX basic forwarding mode)."), lo: 16, hi: 17 });
        fields.insert("VSTAX_LRN_SKIP_ENA", Field { brief: Some("Setting VSTAX_LRN_SKIP_ENA=1 causes the lrn_mode field in the VStaX header to be set to 1 if the auto learning is disabled for the frame. I.e. if auto learning in the local unit is not allowed for the frame, other units in the stack will not do auto learning of the forwarded frame either. Auto learning can be disabled due to ANA_L2::AUTO_LRN_CFG ANA_L3:MSTP:MSTP_LRN_CFG ANA_L3::PORT_LRN_CTRL ANA_L3:VLAN:VLAN_CFG.VLAN_LRN_DIS"), details: None, lo: 25, hi: 26 });
        regs.insert("LRN_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Learn configuration"), details: Some("Configures learn handling. Upon reception of a frame the (SMAC, IFID) is used to perform a lookup in the MAC table. If an entry is found the station sending the frame is considered known and the SOURCE entry is retrieved from the MAC table - alternatively the station is considered unknown. A comparison of the received port information and the port information known is performed for known stations to detection port move. A frame with changed or unknown station information is considered a learn frame."), fields });
        let mut fields = HashMap::new();
        fields.insert("CPU_LRN_COPY_ENA", Field { brief: Some("Configures per port copy of incoming learn frames received received on this port. Copies are sent to the CPU queue specified by ANA_L2::LRN_CFG.CPU_LRN_QU. This does not influence the port move detection in ANA_L2::MOVELOG_STICKY."), details: Some("x0x: Disable x1x: incoming learn frames received on this port are copied to the CPU."), lo: 0, hi: 32 });
        regs.insert("LRN_COPY_CFG", Register { addr: Address { base: 11, count: 1, width: 1 }, brief: Some("Learn copy configuration"), details: Some("Configures CPU copy of learn frames per port"), fields });
        let mut fields = HashMap::new();
        fields.insert("CPU_LRN_COPY_ENA1", Field { brief: Some("Refer to LRN_COPY_CFG.CPU_LRN_COPY_ENA description."), details: Some("x0x: Disable x1x: incoming learn frames received on this port are copied to the CPU."), lo: 0, hi: 21 });
        regs.insert("LRN_COPY_CFG1", Register { addr: Address { base: 12, count: 1, width: 1 }, brief: Some("Learn copy configuration"), details: Some("Configures CPU copy of learn frames per port"), fields });
        let mut fields = HashMap::new();
        fields.insert("DROP_UNKNOWN_SRC_ENA", Field { brief: Some("Configures per port discard of incoming learn frames received on this port. Forwarding to CPU is still allowed. This does not influence the port move detection in ANA_L2::MOVELOG_STICKY."), details: Some("x0x: Disable drop of incoming learn frames for the port x1x: Enable drop of incoming learn frames received on this port"), lo: 0, hi: 32 });
        regs.insert("LRN_SECUR_CFG", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Secure learn configuration"), details: Some("Configures secure forwarding per port"), fields });
        let mut fields = HashMap::new();
        fields.insert("DROP_UNKNOWN_SRC_ENA1", Field { brief: Some("Refer to LRN_SECUR_CFG.DROP_UNKNOWN_SRC_ENA description."), details: Some("x0x: Disable drop of incoming learn frames for the port x1x: Enable drop of incoming learn frames received on this port"), lo: 0, hi: 21 });
        regs.insert("LRN_SECUR_CFG1", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("Secure learn configuration"), details: Some("Configures secure forwarding per port"), fields });
        let mut fields = HashMap::new();
        fields.insert("DROP_MOVED_LOCKED_ENA", Field { brief: Some("Configures per port discard of incoming frames triggering a port move for a locked entry in the MAC table received on this port. Forwarding to CPU is still allowed. This does not influence the port move detection in ANA_L2::MOVELOG_STICKY."), details: Some("x0x: Disable x1x: Enable drop of incoming frames triggering a port move for a locked entry in the MAC table received on this port"), lo: 0, hi: 32 });
        regs.insert("LRN_SECUR_LOCKED_CFG", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("Secure learn configuration for locked entries"), details: Some("Configures secure forwarding for static (LOCKED) entries per port"), fields });
        let mut fields = HashMap::new();
        fields.insert("DROP_MOVED_LOCKED_ENA1", Field { brief: Some("Refer to LRN_SECUR_LOCKED_CFG.DROP_MOVED_LOCKED_ENA description."), details: Some("x0x: Disable x1x: Enable drop of incoming frames triggering a port move for a locked entry in the MAC table received on this port"), lo: 0, hi: 21 });
        regs.insert("LRN_SECUR_LOCKED_CFG1", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("Secure learn configuration for locked entries"), details: Some("Configures secure forwarding for static (LOCKED) entries per port"), fields });
        let mut fields = HashMap::new();
        fields.insert("PORTMOVE_LOG_STICKY", Field { brief: Some("When a known station identified by (IFID, SMAC) pair with port information (LRN::MAC_ACCESS_CFG_2.MAC_ENTRY_ADDR_TYPE and LRN::MAC_ACCESS_CFG_2.MAC_ENTRY_ADDR) is seen with changed port information, the new port is set in this mask. Write 1 to clear the corresponding bit. Notice: If operation VSTAX AF mode (ANA_L2::LRN_CFG.VSTAX_BASIC_LRN_MODE_ENA)  port move operates a little different since different types of port moves are supported see: ANA_L2::STICKY.LOCAL_TO_REMOTE_PORTMOVE_STICKY ANA_L2::STICKY.REMOTE_TO_LOCAL_PORTMOVE_STICKY ANA_L2::STICKY.REMOTE_TO_REMOTE_PORTMOVE_STICKY ANA_L2::STICKY.GLOBAL_TO_GLOBAL_PORTMOVE_STICKY ANA_L2::STICKY.GLOBAL_TO_LOCAL_PORTMOVE_STICKY ANA_L2::STICKY.LOCAL_TO_GLOBAL_PORTMOVE_STICKY ANA_L2::STICKY.LOCAL_TO_LOCAL_PORTMOVE_STICKY"), details: Some("'XX...XXX': If port X is set, at least one station has moved to logical port X."), lo: 0, hi: 32 });
        regs.insert("MOVELOG_STICKY", Register { addr: Address { base: 83, count: 1, width: 1 }, brief: Some("Sticky Portmove status"), details: Some("Identifies ports with moved stations"), fields });
        let mut fields = HashMap::new();
        fields.insert("PORTMOVE_LOG_STICKY1", Field { brief: Some("Refer to MOVELOG_STICKY.PORTMOVE_LOG_STICKY description."), details: Some("'XX...XXX': If port X is set, at least one station has moved to logical port X."), lo: 0, hi: 21 });
        regs.insert("MOVELOG_STICKY1", Register { addr: Address { base: 84, count: 1, width: 1 }, brief: Some("Sticky Portmove status"), details: Some("Identifies ports with moved stations"), fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_DLB_IDX", Field { brief: Some("Specifies the default port Dual leaky bucket index to be used for frames with ISDX=0 if ANA_L2::FWD_CFG.PORT_DEFAULT_BDLB_ENA is enabled."), details: None, lo: 0, hi: 10 });
        fields.insert("QUEUE_DLB_IDX", Field { brief: Some("Specifies the default queue Dual leaky bucket index to be used for frames with ISDX=0 if ANA_L2::FWD_CFG.QUEUE_DEFAULT_SDLB_ENA is enabled."), details: None, lo: 10, hi: 23 });
        regs.insert("PORT_DLB_CFG", Register { addr: Address { base: 13, count: 53, width: 1 }, brief: Some("Service DLB Port default configuration"), details: Some("Configures per port dual leaky bucket indexes"), fields });
        let mut fields = HashMap::new();
        fields.insert("SCAN_FID_VAL", Field { brief: Some("Configures additional FID/VID filters doing scan if LRN:COMMON:SCAN_NEXT_CFG.FID_FILTER_ENA and ANA_L2:COMMON:SCAN_FID_CTRL.SCAN_FID_ENA is set."), details: Some("0x1fff: Disable FID/VID filter"), lo: 0, hi: 13 });
        regs.insert("SCAN_FID_CFG", Register { addr: Address { base: 67, count: 16, width: 1 }, brief: Some("Configures a number of additional VID/FID to be used when doing scan"), details: Some("This is to allow faster ring protection update"), fields });
        let mut fields = HashMap::new();
        fields.insert("SCAN_FID_ENA", Field { brief: Some("Controls use of additional FID filters used during scan when LRN:COMMON:SCAN_NEXT_CFG.FID_FILTER_ENA is set."), details: Some("0: FID/VID filters only depend on LRN:COMMON:SCAN_NEXT_CFG.FID_FILTER_ENA. 1: Additional FID filter values are specified in ANA_L2:COMMON:SCAN_FID_CFG.SCAN_FID_VAL if LRN:COMMON:SCAN_NEXT_CFG.FID_FILTER_ENA is set."), lo: 0, hi: 1 });
        regs.insert("SCAN_FID_CTRL", Register { addr: Address { base: 66, count: 1, width: 1 }, brief: Some("Configures if additional VID/FID are used when doing scan"), details: Some("This is to allow faster ring protection update"), fields });
        let mut fields = HashMap::new();
        fields.insert("CPU_VSTAX_QU", Field { brief: Some("Configures CPU queue for VSTAX2 triggered events (Configurable using ANA_L2::VSTAX_CTRL)."), details: Some("0: CPU queue 0 1: CPU queue 1 ... n: CPU queue n."), lo: 12, hi: 15 });
        fields.insert("OWN_UPSID", Field { brief: Some("Configures own UPSID to be used for stacking. This must be configured consistently across the following registers: ANA_CL::UPSID_CFG.UPSID_NUM ANA_AC::COMMON_VSTAX_CFG.OWN_UPSID ANA_L2::VSTAX_CTRL.OWN_UPSID REW::COMMON_CTRL.OWN_UPSID"), details: None, lo: 16, hi: 21 });
        fields.insert("VSTAX2_LCPU_CP_ACL_RT_ENA", Field { brief: Some("Enable copy to local CPU for frames route modified in Analyzer that ought to trigger lrn_all. Copies are sent to the CPU queue specified by ANA_L2::VSTAX_CTRL.CPU_VSTAX_QU."), details: None, lo: 24, hi: 25 });
        fields.insert("VSTAX2_LCPU_CP_MOVE_FRONT_ENA", Field { brief: Some("Enable copy to local CPU for frames received on a front port with SMAC address previous learned on another port. Copies are sent to the CPU queue specified by ANA_L2::VSTAX_CTRL.CPU_VSTAX_QU. Note: No copy will be generated if learning is disabled due to VLAN learn state etc."), details: None, lo: 5, hi: 6 });
        fields.insert("VSTAX2_LCPU_CP_MOVE_STACK_ENA", Field { brief: Some("Enable copy to local CPU for frames received on a stack port with SMAC address previous learned on another port. Copies are sent to the CPU queue specified by ANA_L2::VSTAX_CTRL.CPU_VSTAX_QU. Note: No copy will be generated if learning is disabled due to VLAN learn state etc."), details: None, lo: 7, hi: 8 });
        fields.insert("VSTAX2_LCPU_CP_NEW_FRONT_ENA", Field { brief: Some("Enable copy to local CPU for frames with new SMAC address received on a front port. Copies are sent to the CPU queue specified by ANA_L2::VSTAX_CTRL.CPU_VSTAX_QU. Note: No copy will be generated if learning is disabled due to VLAN learn state etc."), details: None, lo: 4, hi: 5 });
        fields.insert("VSTAX2_LCPU_CP_NEW_STACK_ENA", Field { brief: Some("Enable copy to local CPU for frames received on a stack port with new SMAC address. Copies are sent to the CPU queue specified by ANA_L2::VSTAX_CTRL.CPU_VSTAX_QU. Note: No copy will be generated if learning is disabled due to VLAN learn state etc."), details: None, lo: 6, hi: 7 });
        fields.insert("VSTAX2_LCPU_CP_NXT_LRN_ALL_FRONT_ENA", Field { brief: Some("Enable copy to local CPU for frames received on a front port with SMAC entry nxt_lrn_all set. Copies are sent to the CPU queue specified by ANA_L2::VSTAX_CTRL.CPU_VSTAX_QU."), details: None, lo: 10, hi: 11 });
        fields.insert("VSTAX2_LCPU_CP_REFRESH_FRONT_ENA", Field { brief: Some("Enable copy to local CPU for frames received on a front port with SMAC address which causes a refresh of the age bit. Copies are sent to the CPU queue specified by ANA_L2::VSTAX_CTRL.CPU_VSTAX_QU. Note: No copy will be generated if learning is disabled due to VLAN learn state etc."), details: None, lo: 8, hi: 9 });
        fields.insert("VSTAX2_LCPU_CP_REFRESH_STACK_ENA", Field { brief: Some("Enable copy to local CPU for frames received on a stack port with SMAC address which causes a refresh of the age bit. Copies are sent to the CPU queue specified by ANA_L2::VSTAX_CTRL.CPU_VSTAX_QU. Note: No copy will be generated if learning is disabled due to VLAN learn state etc."), details: None, lo: 9, hi: 10 });
        fields.insert("VSTAX2_LCPU_CP_UNEXP_DST_PORT_ENA", Field { brief: Some("Enable copy to local CPU for frames received with different destination in VStaX2 header than specified in local MAC table or if DMAC unknown is received for a frame known in MAC table. Copies are sent to the CPU queue specified by ANA_L2::VSTAX_CTRL.CPU_VSTAX_QU."), details: None, lo: 11, hi: 12 });
        fields.insert("VSTAX2_LRN_ALL_MOVE_ENA", Field { brief: Some("Enable lrn-all generation triggered by MAC address moved to local port. Note: No copy will be generated if learning is disabled due to VLAN learn state etc."), details: None, lo: 1, hi: 2 });
        fields.insert("VSTAX2_LRN_ALL_NEW_ENA", Field { brief: Some("Enable lrn-all generation triggered by learn of new MAC address. Note: No copy will be generated if learning is disabled due to VLAN learn state etc."), details: None, lo: 0, hi: 1 });
        fields.insert("VSTAX2_LRN_ALL_REFRESH_ENA", Field { brief: Some("Enable lrn-all generation triggered by MAC entry refresh for MAC addresses learned on local port. Note: No copy will be generated if learning is disabled due to VLAN learn state etc."), details: None, lo: 2, hi: 3 });
        fields.insert("VSTAX2_LRN_ALL_UNEXP_FLOOD_ENA", Field { brief: Some("Enable lrn-all generation triggered by unexpected flooding, where MAC address is known on local port. Note: No copy will be generated if learning is disabled due to VLAN learn state etc."), details: None, lo: 3, hi: 4 });
        fields.insert("VSTAX2_NXT_LRN_ALL_RT_ACL_ENA", Field { brief: Some("Enable setting nxt_lrn_all for frames route modified in Analyzer that ought to trigger lrn_all."), details: None, lo: 25, hi: 26 });
        regs.insert("VSTAX_CTRL", Register { addr: Address { base: 85, count: 1, width: 1 }, brief: Some("VSTAX configuration"), details: Some("Configures stacking learning and forwarding operation"), fields });
        groups.insert("COMMON", RegisterGroup { addr: Address { base: 141482, count: 1, width: 89 }, desc: "Common configurations for all ports", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("DLB_IDX", Field { brief: Some("Dual leaky bucket base address."), details: None, lo: 0, hi: 13 });
        regs.insert("DLB_CFG", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Ingress service dual leaky bucket policer, base address"), details: Some("Specifies service DLB policer index. If ANA_L2::FWD_CFG.QUEUE_DEFAULT_SDLB_ENA is set some of the indeces are used for queue default DLB (see ANA_L2::PORT_DLB_CFG.QUEUE_DLB_IDX). The ingress service DLB policer is selected as DLB_IDX + DLB_COS_OFFSET[frame's classified  COS ID]."), fields });
        let mut fields = HashMap::new();
        fields.insert("DLB_COS_OFFSET", Field { brief: Some("Dual leaky bucket offset per COS ID."), details: None, lo: 0, hi: 3 });
        regs.insert("DLB_COS_CFG", Register { addr: Address { base: 6, count: 8, width: 1 }, brief: Some("Ingress service dual leaky bucket policer, offset per COS ID"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ISDX_BASE_ADDR", Field { brief: Some("Ingress service counter set base address."), details: None, lo: 0, hi: 13 });
        regs.insert("ISDX_BASE_CFG", Register { addr: Address { base: 14, count: 1, width: 1 }, brief: Some("Ingress service counter set, base address"), details: Some("The ingress service counter set is selected as ISDX_BASE_ADDR + ISDX_COS_OFFSET[frame's classified  COS ID]."), fields });
        let mut fields = HashMap::new();
        fields.insert("BDLB_IDX", Field { brief: Some("Bundle Policer Dual leaky bucket index. If ANA_L2::FWD_CFG.PORT_DEFAULT_BDLB_ENA is set some of the indeces are used for port default DLB (see ANA_L2::PORT_DLB_CFG.PORT_DLB_IDX). Related parameters: ANA_AC_POL:BDLB"), details: None, lo: 0, hi: 10 });
        fields.insert("BUM_SLB_ENA", Field { brief: Some("Controls if BUM index from VLAN table is overruled."), details: None, lo: 20, hi: 21 });
        fields.insert("BUM_SLB_IDX", Field { brief: Some("BUM policer index overrules index from VLAN table if BUM_SLB_ENA is set. Related parameters: ANA_L3:VLAN:BUM_CFG ANA_AC_POL:BUM_SLB"), details: None, lo: 10, hi: 20 });
        fields.insert("PIPELINE_PT", Field { brief: Some("Configures the pipeline point for stat and SDLB policing. When injecting or looping at a pipeline point after PIPELINE_PT will not cause SDLB policing and ISDX counter updates. When extracting at a pipeline point before PIPELINE_PT will not cause SDLB policing and ISDX counter updates."), details: Some("0: NONE 1: ANA_VRAP 2: ANA_PORT_VOE 3: ANA_CL 4: ANA_CLM 5: ANA_IPT_PROT 6: ANA_OU_MIP 7: ANA_OU_SW 8: ANA_OU_PROT 9: ANA_OU_VOE 10: ANA_MID_PROT 11: ANA_IN_VOE 12: ANA_IN_PROT 13: ANA_IN_SW 14: ANA_IN_MIP 15: ANA_VLAN"), lo: 21, hi: 25 });
        regs.insert("MISC_CFG", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Controls various indexes."), details: Some("Controls BDLB and BUM indexes and SDLB policer pipeline point."), fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_LIMIT_EXCEED_IRQ_ENA", Field { brief: Some("Allow setting PORT_LIMIT_INTR when exceeding limit on learning (happens when MAC address are supposed to be installed in the MAC table."), details: Some("0: Disable 1: allow PORT_LIMIT_INTR to be set upon trying to learn a MAC address that causes learn limit to be exeeded"), lo: 17, hi: 18 });
        fields.insert("PORT_LIMIT_EXCEED_SEL", Field { brief: Some("Action for traffic when learn limit is exceeded."), details: Some("00: Normal forward 01: Enable redirection to CPU queue 10: Enable copy to CPU queue 11: Discard the frame"), lo: 15, hi: 17 });
        fields.insert("PORT_LRN_CNT_LIMIT", Field { brief: Some("Configures the number of MAC table entries that can be used for a given PORT (through Automatic learning and CPU based learning with LOCK bit cleared and not multicast)."), details: Some("0: Disable i.e. no learn limit for the PORT 1: Only learning of one MAC address allowed for this logical port ... n: Learning of n MAC address allowed for this port"), lo: 0, hi: 15 });
        regs.insert("PORT_LIMIT_CTRL", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Controls automatic learn limits per logical port or GLAG"), details: Some("Per Port configuration of MAC table learn limits"), fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_MASK", Field { brief: Some("Configures ingress service portmask. Can be used as replacement for VLAN PORTMASK or as an further filtering of VLAN PORTMASK depending on ANA_L2:ISDX:SERVICE_CTRL.PORT_MASK_REPLACE_ENA."), details: Some("'XX...XXX': Where X is '0' or '1', representing a port mask."), lo: 0, hi: 32 });
        regs.insert("PORT_MASK_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Ingress service port mask configuration"), details: Some("Configures port mask to be used in relation to service"), fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_MASK1", Field { brief: Some("Refer to PORT_MASK_CFG.PORT_MASK description."), details: Some("'XX...XXX': Where X is '0' or '1', representing a port mask."), lo: 0, hi: 21 });
        regs.insert("PORT_MASK_CFG1", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Ingress service port mask configuration"), details: Some("Configures port mask to be used in relation to service"), fields });
        let mut fields = HashMap::new();
        fields.insert("QGRP_IDX", Field { brief: Some("Configures QSYS group"), details: None, lo: 2, hi: 12 });
        fields.insert("QGRP_OAM_TYPE", Field { brief: Some("Configures OAM type for traffic detected as OAM by Classification to be used by QSYS to determining if dropped frames should be counted or not. Ref: QFWD:QMAP_QOS_TBL:DROP_STAT_CTRL.DROP_STAT_OAM_CNT_SEL"), details: Some("0: Not OAM - Frames dropped by QSYS\tare always counted in QSYS drop stat. 1: EVC OAM - Frames dropped by QSYS which are classified as OAM will selectively be counted  in QSYS drop stat as EVC OAM. 2: OVC / PW OAM - Frames dropped by QSYS which are classified as OAM will selectively be counted\tin QSYS drop stat as OVC / PW OAM. 3: DOWN MEP OAM - Frames dropped by QSYS which are classified as OAM will never be counted  in QSYS drop stat."), lo: 0, hi: 2 });
        regs.insert("QGRP_CFG", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Controls QGRP handling"), details: Some("Controls QGRP index and QSYS OAM drop counting."), fields });
        let mut fields = HashMap::new();
        fields.insert("AGGR_REPLACE_ENA", Field { brief: Some("Overrule aggregation code from ANA_CL."), details: Some("0: Use aggregation code calculated in classifier. See AGGR_VAL for mode to disable aggregation. 1: Use SERVICE_CTRL.AGGR_VAL as aggregation code."), lo: 19, hi: 20 });
        fields.insert("AGGR_VAL", Field { brief: Some("Aggregation code value."), details: Some("If AGGR_REPLACE_ENA is set then the aggregation code is replaced with this value. If AGGR_REPLACE_ENA is cleared and AGGR_VAL != 0 then no aggregation is applied."), lo: 21, hi: 25 });
        fields.insert("CDA_FWD_ENA", Field { brief: Some("Enable forwarding based on CDA"), details: None, lo: 17, hi: 18 });
        fields.insert("ES0_ISDX_KEY_ENA", Field { brief: Some("Select ES0 key type."), details: Some("0: Use VID key in ES0. 1: Use ISDX key in ES0."), lo: 18, hi: 19 });
        fields.insert("FWD_ADDR", Field { brief: Some("Configured address when ISDX_BASED_FWD_ENA or ISDX_BASED_SRC_ENA is set. The encoding of this field is specified by FWD_TYPE"), details: Some("FWD_TYPE= UPSID_PN: FWD_ADDR(9:5) = UPSID FWD_ADDR(4:0) = UPSPN Specifies static unicast forwarding to lport FWD_TYPE = MC_IDX: Specifies static multicast forwarding to the ports indexed by MC_IDX into ANA_AC:PGID"), lo: 0, hi: 12 });
        fields.insert("FWD_TYPE", Field { brief: Some("Address type when ISDX_BASED_FWD_ENA or ISDX_BASED_SRC_ENA is set."), details: Some("0: UPSID_PN 3: MC_IDX 7: NO_ADDR other: Reserved"), lo: 12, hi: 15 });
        fields.insert("ISDX_BASED_FWD_ENA", Field { brief: Some("Controls service based forwarding. Note: Setting this bit disables use of ISDX_BASED_SRC_ENA."), details: Some("0: DMAC based forwarding. 1: SERVICE_CTRL.CDA_FWD_ENA=1: DMAC based forwarding SERVICE_CTRL.CDA_FWD_ENA=0: (forwarding not influenced by DMAC lookup): SERVICE_CTRL.FWD_TYPE = 0 (UPSID_PN): Forward to port in SERVICE_CTRL.FWD_ADDR SERVICE_CTRL.FWD_TYPE = 3 (MC_IDX): Forward by means of MC_IDX specified in SERVICE_CTRL.FWD_ADDR SERVICE_CTRL.FWD_TYPE = 7 (NO_ADDR): Flood forward."), lo: 16, hi: 17 });
        fields.insert("ISDX_BASED_SRC_ENA", Field { brief: Some("Enable service based learning. When set traffic associated with a ISDX are seen as received on the interface configured for the ISDX instead of the port interface configured in ANA_CL:PORT:PORT_ID_CFG. Note: This cannot be use together with ISDX_BASED_FWD_ENA."), details: Some("0: Traffic is learned as received on logical port (configured in ANA_CL:PORT:PORT_ID_CFG). 1: Traffic is learned as received on the interface configured in ANA_L2:ISDX:SERVICE_CTRL.FWD_TYPE and ANA_L2:ISDX:SERVICE_CTRL.FWD_ADDR)."), lo: 15, hi: 16 });
        fields.insert("PORT_MASK_REPLACE_ENA", Field { brief: Some("Configures replacement of VLAN PORTMASK with ANA_L2:ISDX:PORT_MASK_CFG"), details: None, lo: 25, hi: 26 });
        fields.insert("SRC_MASK_DIS", Field { brief: Some("Avoids applying source mask"), details: Some("0: Source port mask is applied. 1: Source mask is ignored."), lo: 20, hi: 21 });
        regs.insert("SERVICE_CTRL", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Ingress service forwarding configuration"), details: Some("Configures service based forwarding."), fields });
        groups.insert("ISDX", RegisterGroup { addr: Address { base: 0, count: 4096, width: 32 }, desc: "Ingress service table configuration", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("FID_LRN_CNT", Field { brief: Some("Contains the number of MAC table entries currently learned associated with a given FID."), details: Some("0 : no entries"), lo: 0, hi: 16 });
        fields.insert("FID_LRN_LIMIT_EXCEEDED_STICKY", Field { brief: Some("Set if specified MAX learn cnt limit is exceeded and max learn cnt was enabled. Write '1' to clear this field."), details: Some("0: Learn cnt not exceeded. 1: Learning operation has failed due to FID max learn cnt exceeded. Write '1' to clear this field."), lo: 16, hi: 17 });
        regs.insert("FID_LIMIT_STATUS", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Controls automatic learn limits"), details: Some("Per VSI configuration of autolearn limits"), fields });
        let mut fields = HashMap::new();
        fields.insert("FID_LIMIT_INTR_IDENT", Field { brief: Some("Status of FID_LIMIT_INTR interrupts"), details: Some("0: No interrupt 1: Interrupt to CPU"), lo: 0, hi: 1 });
        fields.insert("LRN_ACCESS_COMPLETE_INTR_IDENT", Field { brief: Some("Status of LRN_ACCESS_COMPLETE_INTR interrupts"), details: Some("0: No interrupt 1: Interrupt to CPU"), lo: 3, hi: 4 });
        fields.insert("PORT_LRN_LIMIT_INTR_IDENT", Field { brief: Some("Status of PORT_LRN_LIMIT_INTR interrupts"), details: Some("0: No interrupt 1: Interrupt to CPU"), lo: 1, hi: 2 });
        fields.insert("SUPER_VCAP_INTR_IDENT", Field { brief: Some("Status of SUPER_VCAP_INTR interrupts"), details: Some("0: No interrupt 1: Interrupt to CPU"), lo: 4, hi: 5 });
        fields.insert("VCAP_S2_INTR_IDENT", Field { brief: Some("Status of VCAP_S2_INTR interrupts"), details: Some("0: No interrupt 1: Interrupt to CPU"), lo: 2, hi: 3 });
        regs.insert("INTR_IDENT", Register { addr: Address { base: 88, count: 1, width: 1 }, brief: Some("ANA_L2 interrupt status"), details: None, fields });
        groups.insert("LRN_LIMIT", RegisterGroup { addr: Address { base: 131072, count: 5120, width: 2 }, desc: "Learn limits per FID", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("FID_LIMIT_EXCEED_IRQ_ENA", Field { brief: Some("Allow setting FID_LIMIT_INTR when exceeding limit on learning (happens when MAC address are supposed to be installed in the MAC table."), details: Some("0: Disable 1: allow FID_LIMIT_INTR to be set upon trying to learn a MAC address that causes learn limit to be exeeded"), lo: 17, hi: 18 });
        fields.insert("FID_LIMIT_EXCEED_SEL", Field { brief: Some("Action for traffic when learn limit is exceeded."), details: Some("00: Normal forward 01: Enable redirection to CPU queue 10: Enable copy to CPU queue 11: Discard the frame"), lo: 15, hi: 17 });
        fields.insert("FID_LRN_CNT_LIMIT", Field { brief: Some("Configures the number of MAC table entries that can be used for a given FID (through Automatic learning and CPU based learning with LOCK bit cleared and not multicast)."), details: Some("0: Disable i.e. no learn limit for the FID 1: Only learning of one MAC address allowed for this FID ... n: Learning of n MAC address allowed for this FID"), lo: 0, hi: 15 });
        regs.insert("FID_LIMIT_CTRL", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Controls automatic learn limits per FID"), details: Some("Per FID configuration of MAC table learn limits"), fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_LRN_CNT", Field { brief: Some("Contains the number of MAC table entries currently learned associated with a given logical PORT or GLAG."), details: Some("0 : no entries"), lo: 0, hi: 16 });
        fields.insert("PORT_LRN_LIMIT_EXCEEDED_STICKY", Field { brief: Some("Set if specified MAX learn cnt limit is exceeded and max learn cnt was enabled. Write '1' to clear this field."), details: Some("0: Learn cnt not exceeded. 1: Learning operation has failed due to PORT max learn cnt exceeded. Write '1' to clear this field."), lo: 16, hi: 17 });
        regs.insert("PORT_LIMIT_STATUS", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Controls automatic learn limits"), details: Some("Per port configuration of autolearn limits"), fields });
        groups.insert("PORT_LIMIT", RegisterGroup { addr: Address { base: 141312, count: 85, width: 2 }, desc: "Learn limits per PORT and GLAG", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ISDX_COS_OFFSET", Field { brief: Some("Ingress service counter set offset per COS ID."), details: None, lo: 0, hi: 3 });
        regs.insert("ISDX_COS_CFG", Register { addr: Address { base: 15, count: 8, width: 1 }, brief: Some("Ingress service counter set, offset per COS ID"), details: None, fields });
        groups.insert("STICKY", RegisterGroup { addr: Address { base: 141571, count: 1, width: 1 }, desc: "Sticky diagnostic status", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("AUTO_LRN_RATE_EXCEED_STICKY", Field { brief: Some("Set if an autonomous learning operation has failed due to specified lrn rate is exceeded and LEARN max cnt was enabled. Write '1' to clear this field."), details: Some("0: No cnt exceeded. 1: An autonomous learning operation has failed due to cnt exceeded. Write '1' to clear this field."), lo: 15, hi: 16 });
        fields.insert("DROP_UNKNOWN_SRC_STICKY", Field { brief: Some("Set if a frame has been dropped due to ANA_L2::LRN_SECUR_CFG.DROP_UNKNOWN_SRC_ENA. To enable the event as one of four counter events to the PORT STAT block set the corresponding *_STICKY_MASK"), details: Some("0: No frames have been dropped 1: A frame has been dropped. Bit is cleared by writing a 1 to this position."), lo: 2, hi: 3 });
        fields.insert("FWD_ENTRY_FOUND_STICKY", Field { brief: Some("Set if a valid (EFID, DMAC) entry was found to be used for forwarding. To enable the event as one of four counter events to the PORT STAT block set the corresponding *_STICKY_MASK"), details: Some("0: No (EFID, DMAC) entries have been found 1: An (EFID, DMAC) entry has been found. Bit is cleared by writing a 1 to this position."), lo: 3, hi: 4 });
        fields.insert("FWD_FLOOD_KILL_STICKY", Field { brief: Some("Set if flood has been removed due to indication from VLAN table. To enable the event as one of four counter events to the PORT STAT block set the corresponding *_STICKY_MASK"), details: Some("0: No event has occured 1: An integrity error has occured Bit is cleared by writing a 1 to this position."), lo: 14, hi: 15 });
        fields.insert("FWD_FLOOD_STICKY", Field { brief: Some("Set if forwarding is based on flood. To enable the event as one of four counter events to the PORT STAT block set the corresponding *_STICKY_MASK"), details: Some("0:  No flood event 1: Flood event Bit is cleared by writing a 1 to this position."), lo: 4, hi: 5 });
        fields.insert("GLOBAL_TO_GLOBAL_PORTMOVE_STICKY", Field { brief: Some("Indication of a frame received on a GLAG which was previously learned with a different GLAG. To enable the event as one of four counter events to the PORT STAT block set the corresponding *_STICKY_MASK"), details: Some("0: No event has occured 1: A GLAG to GLAG port move has been detected Bit is cleared by writing a 1 to this position."), lo: 8, hi: 9 });
        fields.insert("GLOBAL_TO_LOCAL_PORTMOVE_STICKY", Field { brief: Some("Indication of a frame received at a front local port which was previously learned with a GLAG . To enable the event as one of four counter events to the PORT STAT block set the corresponding *_STICKY_MASK"), details: Some("0: No event has occured 1: A GLAG to local port move has been detected Bit is cleared by writing a 1 to this position."), lo: 7, hi: 8 });
        fields.insert("LEARN_KNOWN_STICKY", Field { brief: Some("Set if a valid (IFID, SMAC) entry was found. To enable the event as one of four counter events to the PORT STAT block set the corresponding *_STICKY_MASK"), details: Some("0: No known source entries (IFID, SMAC) has been found 1: At least one known entry (IFID, SMAC) has been found. Write 1 to clear this field."), lo: 1, hi: 2 });
        fields.insert("LEARN_UNKNOWN_STICKY", Field { brief: Some("Set if no valid (IFID, SMAC) entry was found. To enable the event as one of four counter events to the PORT STAT block set the corresponding *_STICKY_MASK"), details: Some("0: No unknown sources (IFID, SMAC) has been found 1: At least one unknown source IFID, SMAC) has been found. Write 1 to clear this field."), lo: 0, hi: 1 });
        fields.insert("LOCAL_TO_GLOBAL_PORTMOVE_STICKY", Field { brief: Some("Indication of a frame received with GLAG which was previously learned at a front local port. To enable the event as one of four counter events to the PORT STAT block set the corresponding *_STICKY_MASK"), details: Some("0: No event has occured 1: A Local to GLAG port move has been detected Bit is cleared by writing a 1 to this position."), lo: 6, hi: 7 });
        fields.insert("LOCAL_TO_LOCAL_PORTMOVE_STICKY", Field { brief: Some("Indication of a frame received on a local front port, which was previously learned at a different local front port. To enable the event as one of four counter events to the PORT STAT block set the corresponding *_STICKY_MASK"), details: Some("0: No event has occured 1: A Local to local port move has been detected Bit is cleared by writing a 1 to this position."), lo: 5, hi: 6 });
        fields.insert("LOCAL_TO_REMOTE_PORTMOVE_STICKY", Field { brief: Some("Indication of a frame received with an UPSID != own UPSID (ANA_L2::VSTAX_CTRL.OWN_UPSID) which was previously learned on own front local port. To enable the event as one of four counter events to the PORT STAT block set the corresponding *_STICKY_MASK"), details: Some("0: No event has occured 1: A Local to remote port move has been detected Bit is cleared by writing a 1 to this position."), lo: 11, hi: 12 });
        fields.insert("REMOTE_TO_LOCAL_PORTMOVE_STICKY", Field { brief: Some("Indication of a frame received on a local front port, which was previously learned on a remote UPSID front port. To enable the event as one of four counter events to the PORT STAT block set the corresponding *_STICKY_MASK"), details: Some("0: No event has occured 1: A remote port to local port move has been detected Bit is cleared by writing a 1 to this position."), lo: 10, hi: 11 });
        fields.insert("REMOTE_TO_REMOTE_PORTMOVE_STICKY", Field { brief: Some("Indication of a frame received on a remote front port, which was previously learned on another remote UPSID front port. To enable the event as one of four counter events to the PORT STAT block set the corresponding *_STICKY_MASK"), details: Some("0: No event has occured 1: A remote port to remote port move has been detected Bit is cleared by writing a 1 to this position."), lo: 9, hi: 10 });
        fields.insert("SRC_IGNORE_STICKY", Field { brief: Some("Set if forwarding is performed without SRC contribution either because of a known Destination entry with VLAN ignore set (LRN.MAC_ACCESS_CFG_2.MAC_ENTRY_VLAN_IGNORE FLAG) set or for an unknown destination with flood VLAN ignore set (ANA_L2::FWD_CFG.FLOOD_IGNORE_VLAN_ENA) and filter_mode_sel set to SRC ignore. To enable the event as one of four counter events to the PORT STAT block set the corresponding *_STICKY_MASK"), details: Some("0: No event has occured 1: VLAN ignore as occured Bit is cleared by writing a 1 to this position."), lo: 12, hi: 13 });
        fields.insert("VLAN_IGNORE_STICKY", Field { brief: Some("Set if forwarding is performed without VLAN contribution either because of a known Destination entry with VLAN ignore set (LRN.MAC_ACCESS_CFG_2.MAC_ENTRY_VLAN_IGNORE FLAG) set or for an unknown destination with flood VLAN ignore set (ANA_L2::FWD_CFG.FLOOD_IGNORE_VLAN_ENA). To enable the event as one of four counter events to the PORT STAT block set the corresponding *_STICKY_MASK"), details: Some("0: No event has occured 1: VLAN ignore as occured Bit is cleared by writing a 1 to this position."), lo: 13, hi: 14 });
        regs.insert("STICKY", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Sticky diagnostic status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("AUTO_LRN_RATE_EXCEED_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 15, hi: 16 });
        fields.insert("DROP_UNKNOWN_SRC_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 2, hi: 3 });
        fields.insert("FWD_ENTRY_FOUND_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 3, hi: 4 });
        fields.insert("FWD_FLOOD_KILL_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 14, hi: 15 });
        fields.insert("FWD_FLOOD_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 4, hi: 5 });
        fields.insert("GLOBAL_TO_GLOBAL_PORTMOVE_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 8, hi: 9 });
        fields.insert("GLOBAL_TO_LOCAL_PORTMOVE_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 7, hi: 8 });
        fields.insert("LEARN_KNOWN_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 1, hi: 2 });
        fields.insert("LEARN_UNKNOWN_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 0, hi: 1 });
        fields.insert("LOCAL_TO_GLOBAL_PORTMOVE_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 6, hi: 7 });
        fields.insert("LOCAL_TO_LOCAL_PORTMOVE_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 5, hi: 6 });
        fields.insert("LOCAL_TO_REMOTE_PORTMOVE_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 11, hi: 12 });
        fields.insert("REMOTE_TO_LOCAL_PORTMOVE_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 10, hi: 11 });
        fields.insert("REMOTE_TO_REMOTE_PORTMOVE_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 9, hi: 10 });
        fields.insert("SRC_IGNORE_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 12, hi: 13 });
        fields.insert("VLAN_IGNORE_STICKY_MASK", Field { brief: Some("Mask count of sticky event."), details: Some("0: Disable event count 1: Enable event count"), lo: 13, hi: 14 });
        regs.insert("STICKY_MASK", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Sticky diagnostic counter mask"), details: None, fields });
        groups.insert("STICKY_MASK", RegisterGroup { addr: Address { base: 141572, count: 4, width: 1 }, desc: "Sticky diagnostic global port counter event configuration", regs });
        out.insert("ANA_L2", Target { desc: "Layer 2 sub block of the Analyzer", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ARP_ENA", Field { brief: Some("Enable entry for address resolution usage."), details: None, lo: 0, hi: 1 });
        fields.insert("ARP_VMID", Field { brief: Some("Routing lookup: Egress router leg (EVMID). Security lookup: Expected Ingress mapped VLAN ID for security lookup when SECUR_MATCH_VMID_ENA is enabled. SIP RPF: Expected ingress VMID if SIP_RPF_ENA==1 and IPv4: ANA_L3:VMID:RLEG_CTRL.RLEG_IP4_SIP_RPF_MODE==Rleg Mode IPv6: ANA_L3:VMID:RLEG_CTRL.RLEG_IP6_SIP_RPF_MODE==Rleg Mode"), details: None, lo: 8, hi: 15 });
        fields.insert("MAC_MSB", Field { brief: Some("16 most significant bits of MAC address. Used for ARP entry and/or (SMAC,SIP)/(DMAC,DIP) check. Least significant bits are configured in ARP_CFG_1.MAC_LSB. If MAC address for ARP entry is all-zeros, then the frame is redirected to CPU. CPU queue used for such frames is configured in ZERO_DMAC_CPU_QU."), details: Some("Bit 0: MAC address bit 32 ... Bit 15: MAC address bit 47"), lo: 16, hi: 32 });
        fields.insert("SECUR_MATCH_MAC_ENA", Field { brief: Some("Enable Security MAC check. SIP check: If SECUR_MATCH_MAC_ENA=1 and the frame's SMAC is not equal to the MAC in the ARP table (ARP_MAC) when looking up SIP then the L3_SMAC_SIP_MATCH input to ANA_ACL is deasserted. DIP check: If SECUR_MATCH_MAC_ENA=1 and the frame's DMAC is not equal to the MAC in the ARP table (ARP_MAC) when looking up DIP then the L3_SMAC_DIP_MATCH input to ANA_ACL is deasserted. DIP check is only performed for L2 forwarded IP unicast frames. Related parameters: ANA_L3:COMMON:SIP_SECURE_ENA ANA_L3:COMMON:DIP_SECURE_ENA"), details: None, lo: 1, hi: 2 });
        fields.insert("SECUR_MATCH_VMID_ENA", Field { brief: Some("Enable Security VMID check. SIP check: If SECUR_MATCH_VMID_ENA=1 and the IVMID is not equal to the VMID in the ARP table (ARP_VMID) when looking up SIP, then the L3_SMAC_SIP_MATCH input to ANA_ACL is deasserted. DIP check: If SECUR_MATCH_VMID_ENA=1 and the IVMID is not equal to the VMID in the ARP table (ARP_VMID) when looking up DIP, then the L3_SMAC_DIP_MATCH input to ANA_ACL is deasserted. DIP check is only performed for L2 forwarded IP unicast frames. Related parameters: ANA_L3:COMMON:SIP_SECURE_ENA ANA_L3:COMMON:DIP_SECURE_ENA"), details: None, lo: 2, hi: 3 });
        fields.insert("SIP_RPF_ENA", Field { brief: Some("Enable use for SIP RPF check. Ref. ANA_L3:VMID:RLEG_CTRL.RLEG_IP4_SIP_RPF_MODE ANA_L3:VMID:RLEG_CTRL.RLEG_IP6_SIP_RPF_MODE"), details: None, lo: 3, hi: 4 });
        fields.insert("ZERO_DMAC_CPU_QU", Field { brief: Some("CPU queue used for CPU redirect if MAC address in ARP entry is all-zeros."), details: None, lo: 4, hi: 7 });
        regs.insert("ARP_CFG_0", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("ARP table data"), details: Some("Configuration registers for ARP table"), fields });
        let mut fields = HashMap::new();
        fields.insert("ARP_PTR", Field { brief: Some("Address of ARP entry in ARP Table (ANA_L3:ARP)."), details: None, lo: 0, hi: 11 });
        fields.insert("ECMP_CNT", Field { brief: Some("Number of Equal Cost Multiple Paths. Overrules any value in LPM VCAP action."), details: Some("0: 1 path 1: 2 paths 2: 3 paths ..."), lo: 16, hi: 20 });
        regs.insert("ARP_PTR_REMAP_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("ARP Pointer Remap Configuration"), details: Some("This information is used for LPM VCAP actions of type ARP_PTR and with ARP_PTR_REMAP_ENA=1."), fields });
        groups.insert("ARP", RegisterGroup { addr: Address { base: 49152, count: 2048, width: 2 }, desc: "Next-hop table configuration", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("IP4_MAX_LEN", Field { brief: Some("Max \"Total Length\" (ref. RFC791) of IPv4 frames using this egress router leg. Related parameters: ANA_L3:COMMON:ROUTING_CFG.IP4_LEN_REDIR ANA_L3:COMMON:CPU_QU_CFG.CPU_IP_LEN_QU"), details: None, lo: 0, hi: 16 });
        fields.insert("IP6_MAX_LEN", Field { brief: Some("Max \"Payload Length\" (ref. RFC2460) of IPv6 frames using this egress router leg. Related parameters: ANA_L3:COMMON:ROUTING_CFG.IP6_LEN_REDIR ANA_L3:COMMON:CPU_QU_CFG.CPU_IP_LEN_QU"), details: None, lo: 16, hi: 32 });
        regs.insert("MAX_LEN", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Maximum length for frames routed to this router leg"), details: None, fields });
        groups.insert("ARP_PTR_REMAP", RegisterGroup { addr: Address { base: 54592, count: 64, width: 1 }, desc: "ARP Pointer Remap Table", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CPU_IP_LEN_QU", Field { brief: Some("CPU queue for IPv4/IPv6 frames failing MTU check. Related parameters: ANA_L3:COMMON:ROUTING_CFG.IP4_LEN_REDIR ANA_L3:COMMON:ROUTING_CFG.IP6_LEN_REDIR ANA_L3:VMID:MAX_LEN.IP4_MAX_LEN ANA_L3:VMID:MAX_LEN.IP6_MAX_LEN"), details: Some("0: CPU queue 0 1: CPU queue 1 ... n: CPU queue n."), lo: 12, hi: 15 });
        fields.insert("CPU_IP_TTL_FAIL_QU", Field { brief: Some("CPU queue for IP unicast frames with a TTL/HL <2 and with successful ARP lookup yielding a non-zero DMAC. CPU queue for IP multicast frames with a TTL/HL <2 and with successful VCAP lookup. Related enable bits: ANA_L3:COMMON:ROUTING_CFG.IP4_TTL_REDIR_ENA ANA_L3:COMMON:ROUTING_CFG.IP6_HC_REDIR_ENA ANA_L3:L3MC:L3MC_CTRL.IPMC_TTL_COPY_ENA"), details: Some("0: CPU queue 0 1: CPU queue 1 ... n: CPU queue n."), lo: 0, hi: 3 });
        fields.insert("CPU_MC_FAIL_QU", Field { brief: Some("CPU queue for failed IPv4/IPv6 multicast lookup or failed RPF check. Related enable bits: ANA_L3:L3MC:L3MC_CTRL.RPF_CHK_ENA"), details: Some("0: CPU queue 0 1: CPU queue 1 ... n: CPU queue n."), lo: 8, hi: 11 });
        fields.insert("CPU_RLEG_IP_HDR_FAIL_QU", Field { brief: Some("CPU queue number for IPv4 frames with IP header errors. Redirection of such frames is enabled using ROUTING_CFG.CPU_RLEG_IP_HDR_FAIL_REDIR_ENA"), details: Some("0: CPU queue 0 1: CPU queue 1 ... n: CPU queue n."), lo: 20, hi: 23 });
        fields.insert("CPU_RLEG_IP_OPT_QU", Field { brief: Some("CPU queue number for IPv4 frames with options and IPv6 frames with Hop-by-Hop option. Redirection of such frames is enabled using ROUTING_CFG.CPU_IP4_OPTIONS_REDIR_ENA ROUTING_CFG.CPU_IP6_HOPBYHOP_REDIR_ENA"), details: Some("0: CPU queue 0 1: CPU queue 1 ... n: CPU queue n."), lo: 24, hi: 27 });
        fields.insert("CPU_RLEG_QU", Field { brief: Some("CPU queue number for non-IP unicast frames matching an ingress router leg, e.g. ARP PDUs. CPU queue for IP frames with L2 broadcast DMAC, received by router leg."), details: Some("0: CPU queue 0 1: CPU queue 1 ... n: CPU queue n."), lo: 28, hi: 31 });
        fields.insert("CPU_SIP_RPF_QU", Field { brief: Some("CPU queue for frames failing SIP RPF check. Related parameters: ANA_L3:COMMON:ROUTING_CFG.RLEG_IP4_SIP_RPF_REDIR_ENA ANA_L3:COMMON:ROUTING_CFG.RLEG_IP6_SIP_RPF_REDIR_ENA ANA_L3:VMID:RLEG_CTRL.RLEG_IP4_SIP_RPF_MODE ANA_L3:VMID:RLEG_CTRL.RLEG_IP6_SIP_RPF_MODE"), details: Some("0: CPU queue 0 1: CPU queue 1 ... n: CPU queue n."), lo: 16, hi: 19 });
        fields.insert("CPU_UC_FAIL_QU", Field { brief: Some("CPU queue for failed IPv4/IPv6 unicast LPM lookup, invalid ARP entry (ARP_ENA=0) or failed ICMP redirect check. Related enable bits: ANA_L3:VMID:RLEG_CTRL.RLEG_IP4_ICMP_REDIR_ENA ANA_L3:VMID:RLEG_CTRL.RLEG_IP6_ICMP_REDIR_ENA"), details: Some("0: CPU queue 0 1: CPU queue 1 ... n: CPU queue n."), lo: 4, hi: 7 });
        regs.insert("CPU_QU_CFG", Register { addr: Address { base: 19, count: 1, width: 1 }, brief: Some("CPU Queue"), details: Some("Configuration of CPU queues relevant for routing"), fields });
        let mut fields = HashMap::new();
        fields.insert("DIP_CMP_ENA", Field { brief: Some("Lookup DIP in LPM and check that a) DMAC corresponds to MAC address in ARP table entry and/or b) Frame has been received on the router leg specified in ARP table entry. Any mismatch is signalled to ANA_ACL for use in security rules. DIP check is only performed for L2 forwarded IP unicast frames. Related parameters: ANA_L3:ARP:ARP_CFG_0.MAC_MSB ANA_L3:ARP:ARP_CFG_1.MAC_LSB ANA_L3:ARP:ARP_CFG_0.ARP_VMID ANA_L3:ARP:ARP_CFG_0.SECUR_MATCH_VMID_ENA ANA_L3:ARP:ARP_CFG_0.SECUR_MATCH_MAC_ENA ANA_L3:VLAN_ARP_L3MC_STICKY:L3_ARP_IPMC_STICKY.SECUR_DIP_FAIL_STICKY ANA_L3:VLAN_ARP_L3MC_STICKY:L3_ARP_IPMC_STICKY.SECUR_IP4_DIP_MATCH_STICK Y ANA_L3:VLAN_ARP_L3MC_STICKY:L3_ARP_IPMC_STICKY.SECUR_IP6_DIP_MATCH_STICK Y"), details: Some("0: Disable 1: Enable"), lo: 0, hi: 32 });
        regs.insert("DIP_SECURE_ENA", Register { addr: Address { base: 26, count: 1, width: 1 }, brief: Some("Enable (DIP,SMAC) / (DIP,VMID) check"), details: Some("Bit per port that enables (DIP, DMAC) and/or (DIP, VMID) check."), fields });
        let mut fields = HashMap::new();
        fields.insert("DIP_CMP_ENA1", Field { brief: Some("Refer to DIP_SECURE_ENA.DIP_CMP_ENA description."), details: None, lo: 0, hi: 21 });
        regs.insert("DIP_SECURE_ENA1", Register { addr: Address { base: 27, count: 1, width: 1 }, brief: Some("Enable (DIP,SMAC) / (DIP,VMID) check"), details: Some("Bit per port that enables (DIP, DMAC) and/or (DIP, VMID) check."), fields });
        let mut fields = HashMap::new();
        fields.insert("L3_MC_ENA", Field { brief: Some("Enable multicast routing per port. If disabled, IP multicast frames received on the port will not be routed. If disabled and L3_ENA_MODE=1, then routed IP multicast frames will not be transmitted on the port. Related parameters: ANA_L3:COMMON:ROUTING_CFG.L3_ENA_MODE."), details: None, lo: 0, hi: 32 });
        regs.insert("L3_MC_ENA", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Multicast routing control configuration"), details: Some("IP multicast traffic enable per port"), fields });
        let mut fields = HashMap::new();
        fields.insert("L3_MC_ENA1", Field { brief: Some("Refer to L3_MC_ENA.L3_MC_ENA description."), details: None, lo: 0, hi: 21 });
        regs.insert("L3_MC_ENA1", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Multicast routing control Configuration"), details: Some("IP multicast traffic enable per port"), fields });
        let mut fields = HashMap::new();
        fields.insert("L3_UC_ENA", Field { brief: Some("Enable unicast routing per port. If disabled, IP unicast frames received on the port will not be routed. If disabled and L3_ENA_MODE=1, then routed IP unicast frames will not be transmitted on the port. Related parameters: ANA_L3:COMMON:ROUTING_CFG.L3_ENA_MODE."), details: None, lo: 0, hi: 32 });
        regs.insert("L3_UC_ENA", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Unicast routing control configuration"), details: Some("Enable of L3 unicast traffic per port."), fields });
        let mut fields = HashMap::new();
        fields.insert("L3_UC_ENA1", Field { brief: Some("Refer to L3_UC_ENA.L3_UC_ENA description."), details: None, lo: 0, hi: 21 });
        regs.insert("L3_UC_ENA1", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Unicast routing control configuration"), details: Some("Enable of L3 unicast traffic per port"), fields });
        let mut fields = HashMap::new();
        fields.insert("AC_UPDATE_ENA", Field { brief: Some("Enable update of AC for routed frames."), details: None, lo: 0, hi: 1 });
        regs.insert("MISC_CTRL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Miscellanous control parameters"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_FWD_ENA", Field { brief: Some("Enable forwarding per physical port. If disabled, frames received on port are discarded and frames are not forwarded to the port. Related parameters: ANA_L3:VLAN_ARP_L3MC_STICKY:VLAN_STICKY.PORT_FWD_DENY_STICKY"), details: None, lo: 0, hi: 32 });
        regs.insert("PORT_FWD_CTRL", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Forwarding Control"), details: Some("Configuration of forwarding state per port"), fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_FWD_ENA1", Field { brief: Some("Refer to PORT_FWD_CTRL.PORT_FWD_ENA description."), details: None, lo: 0, hi: 21 });
        regs.insert("PORT_FWD_CTRL1", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Forwarding Control"), details: Some("Configuration of forwarding state per port"), fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_LRN_ENA", Field { brief: Some("Enable/disable learning per physical port. Related parameters: ANA_L3:VLAN_ARP_L3MC_STICKY:VLAN_STICKY.PORT_LRN_DENY_STICKY"), details: None, lo: 0, hi: 32 });
        regs.insert("PORT_LRN_CTRL", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("Learning Control"), details: Some("Configuration of learning state per port"), fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_LRN_ENA1", Field { brief: Some("Refer to PORT_LRN_CTRL.PORT_LRN_ENA description."), details: None, lo: 0, hi: 21 });
        regs.insert("PORT_LRN_CTRL1", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("Learning Control"), details: Some("Configuration of learning state per port"), fields });
        let mut fields = HashMap::new();
        fields.insert("RLEG_MAC_LSB", Field { brief: Some("Router leg base MAC address, least significant bits. In order to have different MAC addresses per router leg, the base address may be incremented using VID or VMID, ref. RLEG_MAC_TYPE_SEL. This must be configured consistently in REW::RLEG_CFG_0.RLEG_MAC_LSB."), details: Some("Bit 0: MAC address, bit 0 ... Bit 23: MAC address, bit 23"), lo: 8, hi: 32 });
        regs.insert("RLEG_CFG_0", Register { addr: Address { base: 17, count: 1, width: 1 }, brief: Some("Router leg base MAC address"), details: Some("Configuration of router leg base MAC address."), fields });
        let mut fields = HashMap::new();
        fields.insert("RLEG_MAC_MSB", Field { brief: Some("Router leg base MAC address, least significant bits. In order to have different MAC addresses per router leg, the base address may be incremented using VID or VMID, ref. RLEG_MAC_TYPE_SEL. This must be configured consistently in REW::RLEG_CFG_1.RLEG_MAC_MSB."), details: Some("Bit 0: MAC address, bit 24 ... Bit 23: MAC address, bit 47"), lo: 0, hi: 24 });
        fields.insert("RLEG_MAC_TYPE_SEL", Field { brief: Some("Configuration of router leg specific MAC address. This must be configured consistently in REW::RLEG_CFG_1.RLEG_MAC_TYPE_SEL."), details: Some("0: VMID used to increment base MAC address: RLEG_MAC = RLEG_MAC_MSB[23:0] . ((RLEG_MAC_LSB[23:0] + VMID[7:0]) mod 2**24) 1: VID used to increment base MAC address: RLEG_MAC = RLEG_MAC_MSB[23:0] . ((RLEG_MAC_LSB[23:0] + VID[11:0]) mod 2**24) 2: Base MAC address used for all router legs RLEG_MAC = RLEG_MAC_MSB[23:0] . RLEG_MAC_LSB[23:0] 3: Reserved 3: Reserved."), lo: 24, hi: 26 });
        regs.insert("RLEG_CFG_1", Register { addr: Address { base: 18, count: 1, width: 1 }, brief: Some("Router Leg base MAC address"), details: Some("Configuration of router leg base MAC address."), fields });
        let mut fields = HashMap::new();
        fields.insert("CPU_IP4_OPTIONS_REDIR_ENA", Field { brief: Some("Enable redirection to CPU of IPv4 frames with IP4 options. CPU queue is configured in ANA_L3:COMMON:CPU_QU_CFG.CPU_RLEG_IP_OPT_QU. Packets with IP options are not subject to routing. Related parameters: ANA_L3:COMMON:CPU_QU_CFG.CPU_RLEG_IP_OPT_QU ANA_L3:VLAN_ARP_L3MC_STICKY:L3_ARP_IPMC_STICKY.RLEG_MC_IP_OPT_REDIR_STIC KY"), details: None, lo: 2, hi: 3 });
        fields.insert("CPU_IP6_HOPBYHOP_REDIR_ENA", Field { brief: Some("Enable redirection to CPU of IPv6 frames with Hop-by-Hop options. CPU queue is configured in ANA_L3:COMMON:CPU_QU_CFG.CPU_RLEG_IP_OPT_QU. Packets with Hob-by-Hop options are not subject to routing."), details: None, lo: 3, hi: 4 });
        fields.insert("CPU_RLEG_IP_HDR_FAIL_REDIR_ENA", Field { brief: Some("Control CPU redirection of IP error frames matching a router leg. CPU queue is configured in ANA_L3:COMMON:CPU_QU_CFG.CPU_RLEG_IP_HDR_FAIL_QU. The following errors are covered: IPv4 header length error IPv4 header checksum error SIP violations, if enabled in IP4_SIP_ADDR_VIOLATION_REDIR_ENA / IP6_SIP_ADDR_VIOLATION_REDIR_ENA. DIP violations, if enabled in IP4_DIP_ADDR_VIOLATION_REDIR_ENA / IP4_DIP_ADDR_VIOLATION_REDIR_ENA. IP MC frames with unicast DMAC. Related parameters: ANA_L3:VLAN_ARP_L3MC_STICKY:L3_ARP_IPMC_STICKY.RLEG_UC_HDR_ERR_REDIR_STI CKY ANA_L3:VLAN_ARP_L3MC_STICKY:L3_ARP_IPMC_STICKY.RLEG_MC_HDR_ERR_REDIR_STI CKY"), details: Some("0: Disable redirection (errored frames are discarded) 1: Enable redirection to CPU queue"), lo: 4, hi: 5 });
        fields.insert("IP4_DIP_ADDR_VIOLATION_REDIR_ENA", Field { brief: Some("Enable DIP checks for IPv4 packets matching a router leg. If enabled and the frame's DIP falls within the given range then the frame is not routed. Bit 0: 0.0.0.0 - 0.255.255.255 Bit 1: 127.0.0.0 - 127.255.255.255 (Loopback network) Bit 2: 240.0.0.0 - 255.255.255.254 (Experimental) Frames which are not routed due to DIP check can be redirected to CPU by setting CPU_RLEG_IP_HDR_FAIL_REDIR_ENA=1."), details: Some("'0': Frame is allowed to be routed. '1': Frame is not routed. Frame is redirected to CPU if CPU_RLEG_IP_HDR_FAIL_REDIR_ENA=1."), lo: 11, hi: 14 });
        fields.insert("IP4_L2_BC_COPY_ENA", Field { brief: Some("Copy IPv4 frames with broadcast DMAC to CPU. CPU queue is configured in ANA_L3:COMMON:CPU_QU_CFG.CPU_RLEG_QU."), details: None, lo: 19, hi: 20 });
        fields.insert("IP4_LEN_REDIR", Field { brief: Some("Control handling of IPv4 frames which are otherwise to be L3 forwarded but have Total Length > ANA_L3:VMID:MAX_LEN.IP4_MAX_LEN for egress router leg. CPU queue is configured in ANA_L3:COMMON:CPU_QU_CFG.CPU_IP_LEN_QU"), details: Some("0: Drop frame 1: Redirect frame to CPU"), lo: 21, hi: 22 });
        fields.insert("IP4_MC_DIP_FWD_ENA", Field { brief: Some("Route IPv4 multicast frames based on DIP only. I.e. do LPM lookup with only DIP as key. When IP4_MC_DIP_FWD_ENA is not set LPM lookup is performed with DIP+SIP as key."), details: None, lo: 27, hi: 28 });
        fields.insert("IP4_SIP_ADDR_VIOLATION_REDIR_ENA", Field { brief: Some("Enable SIP checks for IPv4 packets matching a router leg. If enabled and the frame's SIP falls within the given range then the frame is not routed. Bit 0: 0.0.0.0 - 0.255.255.255 Bit 1: 127.0.0.0 - 127.255.255.255 (Loopback network) Bit 2: 224.0.0.0 - 255.255.255.255 (Multicast/experimental/broadcast) Frames which are not routed due to SIP check can be redirected to CPU by setting CPU_RLEG_IP_HDR_FAIL_REDIR_ENA=1."), details: Some("'0': Frame is allowed to be routed. '1': Frame is not routed. Frame is redirected to CPU if CPU_RLEG_IP_HDR_FAIL_REDIR_ENA=1."), lo: 5, hi: 8 });
        fields.insert("IP4_TTL_REDIR_ENA", Field { brief: Some("Enable redirection to CPU of IPv4 UC packets, which match a router leg and have TTL less than 2. CPU queue is configured in ANA_L3:COMMON:CPU_QU_CFG.CPU_IP_TTL_FAIL_QU."), details: Some("0: Disable redirection (errored frames are discarded) 1: Enable redirection to CPU queue"), lo: 0, hi: 1 });
        fields.insert("IP6_DIP_ADDR_VIOLATION_REDIR_ENA", Field { brief: Some("Enable DIP checks for IPv6 packets to be routed. If enabled and the frame's DIP falls within the given range then the frame is not routed. Bit 0: ::/128 (Unspecified address) Bit 1: ::1/128 (Loopback address) Frames which are not routed due to DIP check can be redirected to CPU by setting CPU_RLEG_IP_HDR_FAIL_REDIR_ENA=1."), details: Some("'0': Frame is allowed to be routed. '1': Frame is not routed. Frame is redirected to CPU if CPU_RLEG_IP_HDR_FAIL_REDIR_ENA=1."), lo: 15, hi: 17 });
        fields.insert("IP6_HC_REDIR_ENA", Field { brief: Some("Enable redirection to CPU of IPv6 UC packets, which match a router leg and have Hop Limit less than 2. CPU queue is configured in ANA_L3:COMMON:CPU_QU_CFG.CPU_IP_TTL_FAIL_QU."), details: Some("0: Disable redirection (errored frames are discarded) 1: Enable redirection to CPU queue"), lo: 1, hi: 2 });
        fields.insert("IP6_L2_BC_COPY_ENA", Field { brief: Some("Copy IPv6 frames with broadcast DMAC to CPU. CPU queue is configured in ANA_L3:COMMON:CPU_QU_CFG.CPU_RLEG_QU."), details: None, lo: 20, hi: 21 });
        fields.insert("IP6_LEN_REDIR", Field { brief: Some("Control handling of IPv6 frames which are otherwise to be L3 forwarded but have Payload Length > ANA_L3:VMID:MAX_LEN.IP6_MAX_LEN for egress router leg. CPU queue is configured in ANA_L3:COMMON:CPU_QU_CFG.CPU_IP_LEN_QU"), details: Some("0: Drop frame 1: Redirect frame to CPU"), lo: 22, hi: 23 });
        fields.insert("IP6_MC_DIP_FWD_ENA", Field { brief: Some("Route IPv6 multicast frames based on DIP only. I.e. do LPM lookup with only DIP as key. When IP6_MC_DIP_FWD_ENA is not set LPM lookup is performed with DIP+SIP as key."), details: None, lo: 28, hi: 29 });
        fields.insert("IP6_SIP_ADDR_VIOLATION_REDIR_ENA", Field { brief: Some("Enable SIP checks for IPv6 packets to be routed. If enabled and the frame's SIP falls within the given range then the frame is not routed. Bit 0: ::/128 (Unspecified address) Bit 1: ::1/128 (Loopback address) Bit 2: ff00::/8 (IPv6 multicast addresses) Frames which are not routed due to SIP check can be redirected to CPU by setting CPU_RLEG_IP_HDR_FAIL_REDIR_ENA=1."), details: Some("'0': Frame is allowed to be routed. '1': Frame is not routed. Frame is redirected to CPU if CPU_RLEG_IP_HDR_FAIL_REDIR_ENA=1."), lo: 8, hi: 11 });
        fields.insert("L3_ENA_MODE", Field { brief: Some("Controls whether L3_UC_ENA and L3_MC_ENA affects ingress or ingress+egress behaviour. Note that L3_ENA_MODE=1 does not work together with stacking, assuming routing is performed by ingress unit. Related parameters: ANA_L3:COMMON:L3_UC_ENA ANA_L3:COMMON:L3_MC_ENA"), details: Some("0: L3_UC_ENA/L3_MC_ENA is only applied on ingress. 1: L3_UC_ENA/L3_MC_ENA is applied on ingress and egress."), lo: 29, hi: 30 });
        fields.insert("RLEG_IP4_SIP_RPF_REDIR_ENA", Field { brief: Some("Redirect IPv4 frames failing SIP RPF check to CPU. CPU queue is configured in ANA_L3:COMMON:CPU_QU_CFG.CPU_SIP_RPF_QU. Related parameters: ANA_L3:VMID:RLEG_CTRL.RLEG_IP4_SIP_RPF_MODE ANA_L3:COMMON:CPU_QU_CFG.CPU_SIP_RPF_QU"), details: None, lo: 17, hi: 18 });
        fields.insert("RLEG_IP6_SIP_RPF_REDIR_ENA", Field { brief: Some("Redirect IPv6 frames failing SIP RPF check to CPU. CPU queue is configured in ANA_L3:COMMON:CPU_QU_CFG.CPU_SIP_RPF_QU. Related parameters: ANA_L3:VMID:RLEG_CTRL.RLEG_IP6_SIP_RPF_MODE ANA_L3:COMMON:CPU_QU_CFG.CPU_SIP_RPF_QU"), details: None, lo: 18, hi: 19 });
        fields.insert("RLEG_NONIP_UC_REDIR_MODE", Field { brief: Some("Control which non-IP unicast frames, matching router leg's MAC address, that shall be redirected to CPU. CPU queue is configured in CPU_QU_CFG.CPU_RLEG_QU."), details: Some("0: Redirect all frames. 1: Redirect ARP frames (Ethertype 0x0806) 2: Redirect RARP frames (Ethertype 0x8035) 3: Redirect ARP and RARP frames."), lo: 24, hi: 26 });
        fields.insert("RT_SMAC_UPDATE_ENA", Field { brief: Some("Change SMAC of routed frame to the SMAC of egress router leg. Normally SMAC is changed in REW, but if routing and PTP is to be supported concurrently , then RT_SMAC_UPDATE_ENA must be set. When RT_SMAC_UPDATE_ENA is set and ingress mirroring is used, then ingress mirrored frames get SMAC and DMAC values corresponding to the routed frame. Related parameters: ANA_ACL::VCAP_S2_MISC_CTRL.ACL_RT_SEL"), details: None, lo: 26, hi: 27 });
        regs.insert("ROUTING_CFG", Register { addr: Address { base: 16, count: 1, width: 1 }, brief: Some("Routing Configuration"), details: Some("Configuration of routing checks. Note that these checks only applies to frames matching a router leg."), fields });
        let mut fields = HashMap::new();
        fields.insert("SIP_RPF_ENA", Field { brief: Some("Enable SIP RPF check per ingress port. For more information, refer to ANA_L3:VMID:RLEG_CTRL.RLEG_IP4_SIP_RPF_MODE ANA_L3:VMID:RLEG_CTRL.RLEG_IP6_SIP_RPF_MODE"), details: None, lo: 0, hi: 32 });
        regs.insert("SIP_RPF_ENA", Register { addr: Address { base: 28, count: 1, width: 1 }, brief: Some("Enable SIP RPF check"), details: Some("Bit per port that enables SIP RPF check."), fields });
        let mut fields = HashMap::new();
        fields.insert("SIP_RPF_ENA1", Field { brief: Some("Enable SIP RPF check per ingress port. For more information, refer to ANA_L3:VMID:RLEG_CTRL.RLEG_IP4_SIP_RPF_MODE ANA_L3:VMID:RLEG_CTRL.RLEG_IP6_SIP_RPF_MODE"), details: None, lo: 0, hi: 21 });
        regs.insert("SIP_RPF_ENA1", Register { addr: Address { base: 29, count: 1, width: 1 }, brief: Some("Enable SIP RPF check"), details: Some("Bit per port that enables SIP RPF check."), fields });
        let mut fields = HashMap::new();
        fields.insert("SIP_CMP_ENA", Field { brief: Some("Lookup SIP in LPM and check that a) SMAC corresponds to MAC address in ARP table entry and/or b) Frame has been received on the router leg specified in ARP table entry. Any mismatch is signalled to ANA_ACL for use in security rules. Related parameters: ANA_L3:ARP:ARP_CFG_0.MAC_MSB ANA_L3:ARP:ARP_CFG_1.MAC_LSB ANA_L3:ARP:ARP_CFG_0.ARP_VMID ANA_L3:ARP:ARP_CFG_0.SECUR_MATCH_VMID_ENA ANA_L3:ARP:ARP_CFG_0.SECUR_MATCH_MAC_ENA ANA_L3:VLAN_ARP_L3MC_STICKY:L3_ARP_IPMC_STICKY.SECUR_DIP_FAIL_STICKY ANA_L3:VLAN_ARP_L3MC_STICKY:L3_ARP_IPMC_STICKY.SECUR_IP4_SIP_MATCH_STICK Y ANA_L3:VLAN_ARP_L3MC_STICKY:L3_ARP_IPMC_STICKY.SECUR_IP6_SIP_MATCH_STICK Y"), details: Some("0: Disable 1: Enable"), lo: 0, hi: 32 });
        regs.insert("SIP_SECURE_ENA", Register { addr: Address { base: 24, count: 1, width: 1 }, brief: Some("Enable (SIP,SMAC) / (SIP,VMID) check"), details: Some("Bit per port that enables (SIP, SMAC) and/or (SIP, VMID) check."), fields });
        let mut fields = HashMap::new();
        fields.insert("SIP_CMP_ENA1", Field { brief: Some("Refer to SIP_SECURE_ENA.SIP_CMP_ENA description."), details: None, lo: 0, hi: 21 });
        regs.insert("SIP_SECURE_ENA1", Register { addr: Address { base: 25, count: 1, width: 1 }, brief: Some("Enable (SIP,SMAC) / (SIP,VMID) check"), details: Some("Bit per port that enables (SIP, SMAC) and/or (SIP, VMID) check."), fields });
        let mut fields = HashMap::new();
        fields.insert("VLAN_COMMUNITY_MASK", Field { brief: Some("Ports marked in this mask are treated as community ports, if the VLAN is a private VLAN. Ref. ANA_L3:VLAN:VLAN_CFG.VLAN_PRIVATE_ENA"), details: Some("0: Not a Community port (i.e. Promiscuous port or Isolated port) 1: Community port."), lo: 0, hi: 32 });
        regs.insert("VLAN_COMMUNITY_CFG", Register { addr: Address { base: 14, count: 1, width: 1 }, brief: Some("VLAN Community port mask"), details: Some("Configuration of Community port mask. See description of ANA_L3:VLAN:VLAN_CFG.VLAN_PRIVATE_ENA"), fields });
        let mut fields = HashMap::new();
        fields.insert("VLAN_COMMUNITY_MASK1", Field { brief: Some("Refer to VLAN_COMMUNITY_CFG.VLAN_COMMUNITY_MASK description."), details: None, lo: 0, hi: 21 });
        regs.insert("VLAN_COMMUNITY_CFG1", Register { addr: Address { base: 15, count: 1, width: 1 }, brief: Some("VLAN Community port mask"), details: Some("Configuration of Community port mask. See description of ANA_L3:VLAN:VLAN_CFG.VLAN_PRIVATE_ENA"), fields });
        let mut fields = HashMap::new();
        fields.insert("VLAN_ENA", Field { brief: Some("Enable/disable VLAN lookup. This field must be enabled to allow VLAN and MSTP filtering. For VLAN unaware operation, this field can be disabled."), details: None, lo: 0, hi: 1 });
        regs.insert("VLAN_CTRL", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("VLAN Control"), details: Some("Basic VLAN related configuration"), fields });
        let mut fields = HashMap::new();
        fields.insert("VLAN_IGR_FILTER_ENA", Field { brief: Some("Enable VLAN ingress filtering per port. If a port is enabled in this mask, frames received on the port are discarded if the port is not a member of the classified VLAN. VLAN ingress filtering can also be enabled per VLAN. VLAN ingress filtering is performed if either enabled for ingress port or for VLAN. Related parameters: ANA_L3:VLAN:VLAN_CFG.VLAN_IGR_FILTER_ENA ANA_L3:VLAN_ARP_L3MC_STICKY:VLAN_STICKY.VLAN_IGR_FILTER_STICKY"), details: None, lo: 0, hi: 32 });
        regs.insert("VLAN_FILTER_CTRL", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("VLAN Filter Control"), details: Some("Configuration of VLAN ingress filtering per port"), fields });
        let mut fields = HashMap::new();
        fields.insert("VLAN_IGR_FILTER_ENA1", Field { brief: Some("Refer to VLAN_FILTER_CTRL.VLAN_IGR_FILTER_ENA description."), details: None, lo: 0, hi: 21 });
        regs.insert("VLAN_FILTER_CTRL1", Register { addr: Address { base: 11, count: 1, width: 1 }, brief: Some("VLAN Filter Control"), details: Some("Configuration of VLAN ingress filtering per port"), fields });
        let mut fields = HashMap::new();
        fields.insert("VLAN_ISOLATED_MASK", Field { brief: Some("Ports marked in this mask are treated as isolated ports, if the VLAN is a private VLAN. Ref. ANA_L3:VLAN:VLAN_CFG.VLAN_PRIVATE_ENA"), details: Some("0: Not an Isolated port (i.e. Promiscuous port or Community port) 1: Isolated port."), lo: 0, hi: 32 });
        regs.insert("VLAN_ISOLATED_CFG", Register { addr: Address { base: 12, count: 1, width: 1 }, brief: Some("VLAN isolated port mask"), details: Some("Configuration of isolated port mask. See description of ANA_L3:VLAN:VLAN_CFG.VLAN_PRIVATE_ENA"), fields });
        let mut fields = HashMap::new();
        fields.insert("VLAN_ISOLATED_MASK1", Field { brief: Some("Refer to VLAN_ISOLATED_CFG.VLAN_ISOLATED_MASK description."), details: None, lo: 0, hi: 21 });
        regs.insert("VLAN_ISOLATED_CFG1", Register { addr: Address { base: 13, count: 1, width: 1 }, brief: Some("VLAN isolated port mask"), details: Some("Configuration of isolated port mask. See description of ANA_L3:VLAN:VLAN_CFG.VLAN_PRIVATE_ENA"), fields });
        let mut fields = HashMap::new();
        fields.insert("VRRP_IP4_BASE_MAC_MID", Field { brief: Some("Mid part of IPv4 Virtual Router Redundancy Protocol MAC address."), details: Some("IPv4 VRRP MAC address Bit 31 downto 8."), lo: 8, hi: 32 });
        regs.insert("VRRP_IP4_CFG_0", Register { addr: Address { base: 20, count: 1, width: 1 }, brief: Some("IPv4 Virtual Router Leg Configuration"), details: Some("Configuration of VRRP MAC address for IPv4. Use of VRRP for IPv4 is enabled per router leg in ANA_L3:VMID:RLEG_CTRL.RLEG_IP4_VRID_ENA"), fields });
        let mut fields = HashMap::new();
        fields.insert("VRRP_IP4_BASE_MAC_HIGH", Field { brief: Some("Upper part of IPv4 Virtual Router Redundancy Protocol MAC address."), details: Some("IPv4 VRRP MAC address Bit 47 downto 32."), lo: 0, hi: 16 });
        regs.insert("VRRP_IP4_CFG_1", Register { addr: Address { base: 21, count: 1, width: 1 }, brief: Some("IPv4 Virtual Router Leg Configuration"), details: Some("Configuration of VRRP MAC address for IPv4. Use of VRRP for IPv4 is enabled per router leg in ANA_L3:VMID:RLEG_CTRL.RLEG_IP4_VRID_ENA"), fields });
        let mut fields = HashMap::new();
        fields.insert("VRRP_IP6_BASE_MAC_MID", Field { brief: Some("Mid part of IPv6 Virtual Router Redundancy Protocol MAC address."), details: Some("IPv6 VRRP MAC address Bit 31 downto 8."), lo: 0, hi: 24 });
        regs.insert("VRRP_IP6_CFG_0", Register { addr: Address { base: 22, count: 1, width: 1 }, brief: Some("IPv6 Virtual Router Leg Configuration"), details: Some("Configuration of VRRP MAC address for IPv6. Use of VRRP for IPv6 is enabled per router leg in ANA_L3:VMID:RLEG_CTRL.RLEG_IP6_VRID_ENA"), fields });
        let mut fields = HashMap::new();
        fields.insert("VRRP_IP6_BASE_MAC_HIGH", Field { brief: Some("Upper part of IPv6 Virtual Router Redundancy Protocol MAC address."), details: Some("IPv6 VRRP MAC address Bit 47 downto 32."), lo: 0, hi: 16 });
        regs.insert("VRRP_IP6_CFG_1", Register { addr: Address { base: 23, count: 1, width: 1 }, brief: Some("IPv6 Virtual Router Leg Configuration"), details: Some("Configuration of VRRP MAC address for IPv6. Use of VRRP for IPv6 is enabled per router leg in ANA_L3:VMID:RLEG_CTRL.RLEG_IP6_VRID_ENA"), fields });
        groups.insert("COMMON", RegisterGroup { addr: Address { base: 54536, count: 1, width: 31 }, desc: "Common configurations for all ports", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("MAC_LSB", Field { brief: Some("32 least significant bits of MAC address. Used for ARP entry and/or (SMAC,SIP)/(DMAC,DIP) check. Most significant bits are configured in ARP_CFG_0.MAC_MSB. If MAC address for ARP entry is all-zeros, then the frame is redirected to CPU. CPU queue used for such frames is configured in ZERO_DMAC_CPU_QU."), details: Some("Bit 0: MAC bit 0 ... Bit 31: MAC bit 31"), lo: 0, hi: 32 });
        regs.insert("ARP_CFG_1", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("ARP table data 1"), details: Some("Configuration registers for ARP table"), fields });
        let mut fields = HashMap::new();
        fields.insert("EVMID_MASK", Field { brief: Some("Bit mask with one bit for each router leg. If bit at position N is set, then a copy has to be sent to router leg N. If the frame has been received on router leg N, then the frame is L2 forwarded to other ports in the ingress VLAN. Else the frame is L3 fowarded to the VLAN that router leg N is attached to (ANA_L3:VMID:RLEG_CTRL.RLEG_EVID)."), details: None, lo: 0, hi: 32 });
        regs.insert("EVMID_MASK_CFG", Register { addr: Address { base: 0, count: 4, width: 1 }, brief: Some("Multicast router leg mask"), details: None, fields });
        groups.insert("L3MC", RegisterGroup { addr: Address { base: 40960, count: 1024, width: 8 }, desc: "L3 Multicast Table", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ENTRY_NOT_FOUND_STICKY", Field { brief: Some("Set if the IPv4/IPv6 DIP or (DIP,SIP) lookup failed due to - No match in LPM table - Unsupported action type in LPM table - ARP table lookup returns an invalid entry."), details: None, lo: 23, hi: 24 });
        fields.insert("IP4_SIP_RPF_FILTER_STICKY", Field { brief: Some("Set if IPv4 SIP RPF check results in a frame not being L3 forwarded. Related parameters: ANA_L3:VMID:RLEG_CTRL.RLEG_IP4_SIP_RPF_MODE"), details: None, lo: 26, hi: 27 });
        fields.insert("IP6_SIP_RPF_FILTER_STICKY", Field { brief: Some("Set if IPv6 SIP RPF check results in a frame not being L3 forwarded. Related parameters: ANA_L3:VMID:RLEG_CTRL.RLEG_IP6_SIP_RPF_MODE"), details: None, lo: 27, hi: 28 });
        fields.insert("IP_MAX_LEN_EXCEEDED_STICKY", Field { brief: Some("Set if a frame has exceeded IP4_MAX_LEN/IP6_MAX_LEN for an egress router leg. Ref. ANA_L3:VMID:MAX_LEN.IP4_MAX_LEN ANA_L3:VMID:MAX_LEN.IP6_MAX_LEN"), details: None, lo: 24, hi: 25 });
        fields.insert("L2_MC_FWD_STICKY", Field { brief: Some("Set when L2 forwarding of IPv4 multicast frame has completed."), details: None, lo: 18, hi: 19 });
        fields.insert("L3_MC_FWD_STICKY", Field { brief: Some("Set when IP multicast L3 forwarding has been completed for a frame."), details: None, lo: 20, hi: 21 });
        fields.insert("MC_LOOPED_CP_STICKY", Field { brief: Some("Set if an IP MC frame copy from VD0 does not get L3 forwarded (i.e. gets dropped)."), details: None, lo: 22, hi: 23 });
        fields.insert("MC_RPF_FILTER_STICKY", Field { brief: Some("Set if an IP MC frame has failed RPF check. Related parameters: ANA_L3:L3MC:L3MC_CTRL.RPF_CHK_ENA"), details: None, lo: 19, hi: 20 });
        fields.insert("NO_MC_FWD_STICKY", Field { brief: Some("Set if neither L2 nor L3 forwarding is performed for an IP multicast frame."), details: None, lo: 21, hi: 22 });
        fields.insert("NO_MC_VMID_AVAIL_STICKY", Field { brief: Some("Set if IPv4/IPv6 multicast forwarding fails because no there is no router leg  in ANA_L3:L3MC:EVMID_MASK_CFG.EVMID_MASK to forward to."), details: None, lo: 25, hi: 26 });
        fields.insert("RLEG_MC_HDR_ERR_REDIR_STICKY", Field { brief: Some("Set if an ingress router leg match has been found for an IP multicast frame with header errors. Refer to ANA_L3:COMMON:ROUTING_CFG.CPU_RLEG_IP_HDR_FAIL_REDIR_ENA for list of covered errors."), details: None, lo: 2, hi: 3 });
        fields.insert("RLEG_MC_HIT_STICKY", Field { brief: Some("Set if an ingress router leg match has been found for an IP multicast frame."), details: None, lo: 6, hi: 7 });
        fields.insert("RLEG_MC_IP_OPT_REDIR_STICKY", Field { brief: Some("Set if ingress router leg match has been found for an IPv4/IPv6 multicast frame with options/hop-by-hop options. Such frames may optionally be redirected to CPU, ref. ANA_L3:COMMON:ROUTING_CFG.CPU_IP4_OPTIONS_REDIR_ENA ANA_L3:COMMON:ROUTING_CFG.CPU_IP6_HOPBYHOP_REDIR_ENA A similar sticky bit is available for IP unicast frames: RLEG_UC_IP_OPT_REDIR_STICKY"), details: None, lo: 4, hi: 5 });
        fields.insert("RLEG_MC_TTL_STICKY", Field { brief: Some("Set if ingress router leg match has been found for an IP multicast frame with a TTL less than 2."), details: None, lo: 13, hi: 14 });
        fields.insert("RLEG_NONIP_UC_REDIR_STICKY", Field { brief: Some("Set if ingress router leg match has been found for a non-IP frame. Such frames are redirected to ANA_L3:COMMON:CPU_QU_CFG.CPU_RLEG_QU"), details: None, lo: 0, hi: 1 });
        fields.insert("RLEG_UC_HDR_ERR_REDIR_STICKY", Field { brief: Some("Set if an ingress router leg match has been found for an IP unicast frame with header errors. Refer to ANA_L3:COMMON:ROUTING_CFG.CPU_RLEG_IP_HDR_FAIL_REDIR_ENA for list of covered errors."), details: None, lo: 1, hi: 2 });
        fields.insert("RLEG_UC_HIT_STICKY", Field { brief: Some("Set if an ingress router leg match has been found for an IP unicast frame."), details: None, lo: 5, hi: 6 });
        fields.insert("RLEG_UC_IP_OPT_REDIR_STICKY", Field { brief: Some("Set if ingress router leg match has been found for an IPv4/IPv6 unicast frame with options/hop-by-hop options. Such frames may optionally be redirected to CPU, ref. ANA_L3:COMMON:ROUTING_CFG.CPU_IP4_OPTIONS_REDIR_ENA ANA_L3:COMMON:ROUTING_CFG.CPU_IP6_HOPBYHOP_REDIR_ENA A similar sticky bit is available for IP multicast frames: RLEG_MC_IP_OPT_REDIR_STICKY"), details: None, lo: 3, hi: 4 });
        fields.insert("SECUR_DIP_FAIL_STICKY", Field { brief: Some("Set if security lookup fails for DIP, i.e. mismatch for (DMAC,DIP) / (VMID,DIP). Related parameters: ANA_L3:COMMON:DIP_SECURE_ENA.DIP_CMP_ENA"), details: None, lo: 8, hi: 9 });
        fields.insert("SECUR_IP4_DIP_MATCH_STICKY", Field { brief: Some("Set for successful IPv4 DIP security lookup, i.e. matching for (DMAC,DIP) and/or (VMID,DIP). Related parameters: ANA_L3:COMMON:DIP_SECURE_ENA.DIP_CMP_ENA"), details: None, lo: 10, hi: 11 });
        fields.insert("SECUR_IP4_SIP_MATCH_STICKY", Field { brief: Some("Set for successful IPv4 SIP security lookup, i.e. matching for (DMAC,SIP) and/or (VMID,SIP). Related parameters: ANA_L3:COMMON:SIP_SECURE_ENA.SIP_CMP_ENA"), details: None, lo: 12, hi: 13 });
        fields.insert("SECUR_IP6_DIP_MATCH_STICKY", Field { brief: Some("Set for successful IPv6 DIP security lookup, i.e. matching for (DMAC,DIP) and/or (VMID,DIP). Related parameters: ANA_L3:COMMON:DIP_SECURE_ENA.DIP_CMP_ENA"), details: None, lo: 11, hi: 12 });
        fields.insert("SECUR_IP6_SIP_MATCH_STICKY", Field { brief: Some("Set for successful IPv6 SIP security lookup, i.e. matching for (DMAC,SIP) and/or (VMID,SIP). Related parameters: ANA_L3:COMMON:SIP_SECURE_ENA.SIP_CMP_ENA"), details: None, lo: 9, hi: 10 });
        fields.insert("SECUR_SIP_FAIL_STICKY", Field { brief: Some("Set if security lookup fails for SIP, i.e. mismatch for (DMAC,DIP) / (VMID,DIP). Related parameters: ANA_L3:COMMON:SIP_SECURE_ENA.SIP_CMP_ENA"), details: None, lo: 7, hi: 8 });
        fields.insert("UC_ENTRY_FOUND_STICKY", Field { brief: Some("Set if IP unicast routing lookup results in a valid ARP entry allowing the frame to be routed."), details: None, lo: 14, hi: 15 });
        fields.insert("UC_ICMP_REDIR_STICKY", Field { brief: Some("Set if a frame has been redirected to CPU due to ICMP Redirect check. Related parameters: ANA_L3:VMID.RLEG_CTRL.RLEG_IP4_ICMP_REDIR_ENA ANA_L3:VMID.RLEG_CTRL.RLEG_IP6_ICMP_REDIR_ENA"), details: None, lo: 17, hi: 18 });
        fields.insert("UC_TTL_FILTERING_STICKY", Field { brief: Some("Set in case of an IP unicast frame being filtered due to TTL. I.e. a frame with TTL<2 which hits a valid ARP table entry with non-zero MAC address."), details: None, lo: 15, hi: 16 });
        fields.insert("UC_ZERO_DMAC_FOUND_STICKY", Field { brief: Some("Set if a frame has been redirected to CPU due to a zero DMAC address in the ARP entry."), details: None, lo: 16, hi: 17 });
        fields.insert("WRONG_DIP_LPM_ACTION_TYPE_STICKY", Field { brief: Some("DIP or (DIP,SIP) LPM lookup has resulted in match with unsupported action type."), details: None, lo: 28, hi: 29 });
        fields.insert("WRONG_SIP_LPM_ACTION_TYPE_STICKY", Field { brief: Some("SIP LPM lookup has resulted in match with unsupported action type."), details: None, lo: 29, hi: 30 });
        regs.insert("L3_ARP_IPMC_STICKY", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("ARP and L3MC table related diagnostic registers"), details: Some("ARP and L3MC table related diagnostic registers."), fields });
        let mut fields = HashMap::new();
        fields.insert("RLEG_MC_HDR_ERR_REDIR_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 1, hi: 2 });
        fields.insert("RLEG_MC_HIT_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 2, hi: 3 });
        fields.insert("RLEG_MC_IP_OPT_REDIR_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 3, hi: 4 });
        fields.insert("RLEG_MC_TTL_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 4, hi: 5 });
        fields.insert("RLEG_NONIP_UC_REDIR_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 0, hi: 1 });
        fields.insert("RLEG_UC_HDR_ERR_REDIR_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 5, hi: 6 });
        fields.insert("RLEG_UC_HIT_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 6, hi: 7 });
        fields.insert("RLEG_UC_IP_OPT_REDIR_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 7, hi: 8 });
        regs.insert("RLEG_STICKY_MASK", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Enable per concurrent counter for each sticky bit"), details: Some("Each ANA_L3 sticky bit can be counted in each of the concurrent counters."), fields });
        let mut fields = HashMap::new();
        fields.insert("ENTRY_NOT_FOUND_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 14, hi: 15 });
        fields.insert("IP4_SIP_RPF_FILTER_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 16, hi: 17 });
        fields.insert("IP6_SIP_RPF_FILTER_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 17, hi: 18 });
        fields.insert("IP_MAX_LEN_EXCEEDED_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 4, hi: 5 });
        fields.insert("L2_MC_FWD_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 5, hi: 6 });
        fields.insert("L3_MC_FWD_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 7, hi: 8 });
        fields.insert("LPM_IP4MC_FOUND_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 0, hi: 1 });
        fields.insert("LPM_IP4UC_FOUND_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 2, hi: 3 });
        fields.insert("LPM_IP6MC_FOUND_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 1, hi: 2 });
        fields.insert("LPM_IP6UC_FOUND_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 3, hi: 4 });
        fields.insert("MC_LOOPED_CP_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 13, hi: 14 });
        fields.insert("MC_RPF_FILTER_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 6, hi: 7 });
        fields.insert("NO_MC_FWD_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 8, hi: 9 });
        fields.insert("NO_MC_VMID_AVAIL_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 15, hi: 16 });
        fields.insert("UC_ENTRY_FOUND_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 9, hi: 10 });
        fields.insert("UC_ICMP_REDIR_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 10, hi: 11 });
        fields.insert("UC_TTL_FILTERING_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 11, hi: 12 });
        fields.insert("UC_ZERO_DMAC_FOUND_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 12, hi: 13 });
        regs.insert("ROUT_STICKY_MASK", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Enable per concurrent counter for each sticky bit"), details: Some("Each ANA_L3 sticky bit can be counted in each of the concurrent counters."), fields });
        let mut fields = HashMap::new();
        fields.insert("SECUR_DIP_FAIL_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 0, hi: 1 });
        fields.insert("SECUR_IP4_DIP_MATCH_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 2, hi: 3 });
        fields.insert("SECUR_IP4_LPM_FOUND_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 1, hi: 2 });
        fields.insert("SECUR_IP4_SIP_MATCH_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 6, hi: 7 });
        fields.insert("SECUR_IP6_DIP_MATCH_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 7, hi: 8 });
        fields.insert("SECUR_IP6_LPM_FOUND_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 3, hi: 4 });
        fields.insert("SECUR_IP6_SIP_MATCH_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 4, hi: 5 });
        fields.insert("SECUR_SIP_FAIL_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 5, hi: 6 });
        regs.insert("SECUR_STICKY_MASK", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Enable per concurrent counter for each sticky bit"), details: Some("Each ANA_L3 sticky bit can be counted in each of the concurrent counters."), fields });
        let mut fields = HashMap::new();
        fields.insert("MSTP_DISCARD_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 5, hi: 6 });
        fields.insert("MSTP_FWD_ALLOWED_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 6, hi: 7 });
        fields.insert("MSTP_LRN_ALLOWED_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 2, hi: 3 });
        fields.insert("MSTP_LRN_DENY_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 3, hi: 4 });
        fields.insert("PORT_FWD_DENY_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 15, hi: 16 });
        fields.insert("PORT_LRN_DENY_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 16, hi: 17 });
        fields.insert("VLAN_IGR_FILTER_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 0, hi: 1 });
        fields.insert("VLAN_LOOKUP_INVLD_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 1, hi: 2 });
        fields.insert("VLAN_LRN_DENY_STICKY_MASK", Field { brief: Some("Enable counting of sticky event per concurrent counter."), details: None, lo: 4, hi: 5 });
        regs.insert("VLAN_MSTP_STICKY_MASK", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Enable per concurrent counter for each sticky bit"), details: Some("Each ANA_L3 sticky bit can be counted in each of the concurrent counters."), fields });
        groups.insert("L3_STICKY_MASK", RegisterGroup { addr: Address { base: 54656, count: 4, width: 4 }, desc: "Counter configuration for diagnostic information", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CPU_QU", Field { brief: Some("CPU queue used for frames redirected due to CPU_REDIR_MODE."), details: None, lo: 4, hi: 7 });
        fields.insert("CPU_REDIR_MODE", Field { brief: Some("Redirect/copy frame to CPU. CPU queue used is configured in CPU_QU."), details: Some("0b00: No CPU redirection/copy. 0b01: Copy CPU 0b10: Copy to CPU, skip L3 forwarding but preserve L2 forwarding. 0b11: Redirect to CPU, skip L2 and L3 forwarding."), lo: 2, hi: 4 });
        fields.insert("IPMC_TTL_COPY_ENA", Field { brief: Some("Enable CPU copy of frames, which are otherwise candidates for routing, but have TTL/HL<2. Such frames are not L3 forwarded, but may still be subject to L2 forwarding. CPU queue used is configured in ANA_L3:COMMON:CPU_QU_CFG.CPU_IP_TTL_FAIL_QU."), details: None, lo: 0, hi: 1 });
        fields.insert("RPF_CHK_ENA", Field { brief: Some("Enable reverse path forwarding check, i.e. only allow routing of frames received on a specific router leg (RPF_VMID), i.e. IVMID=RPF_VMID. Related parameters: ANA_L3:VLAN_ARP_L3MC_STICKY:L3_ARP_IPMC_STICKY.MC_RPF_FILTER_STICKY Note that this check is a different check than SIP RPF check, ref. ANA_L3:VMID:RLEG_CTRL.RLEG_IP4_SIP_RPF_MODE ANA_L3:VMID:RLEG_CTRL.RLEG_IP6_SIP_RPF_MODE"), details: None, lo: 1, hi: 2 });
        fields.insert("RPF_VMID", Field { brief: Some("Expected IVMID if RPF check is enabled, ref. RPF_CHK_ENA."), details: None, lo: 8, hi: 15 });
        regs.insert("L3MC_CTRL", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("L3 multicast control register"), details: Some("L3 multicast control register"), fields });
        groups.insert("LPM_REMAP_STICKY", RegisterGroup { addr: Address { base: 54580, count: 1, width: 1 }, desc: "Diagnostic information", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("MSTP_FWD_MASK", Field { brief: Some("Enable/disable forwarding per port. Ports in MSTP Forwarding state must be enabled in this port mask. If a port is disabled in this mask, frames received on the port are not forwarded, and frames are not forwarded to the port. Related parameters: ANA_L3:VLAN_ARP_L3MC_STICKY:VLAN_STICKY.MSTP_DISCARD_STICKY ANA_L3:VLAN_ARP_L3MC_STICKY:VLAN_STICKY.MSTP_FWD_ALLOWED_STICKY"), details: Some("'0': forwarding is disabled from/to respective port '1': forwarding is enabled from/to respective port"), lo: 0, hi: 32 });
        regs.insert("MSTP_FWD_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("MSTP Forwarding Control"), details: Some("Configuration of forwarding state per MSTP"), fields });
        let mut fields = HashMap::new();
        fields.insert("MSTP_FWD_MASK1", Field { brief: Some("Refer to MSTP_FWD_CFG.MSTP_FWD_MASK description."), details: None, lo: 0, hi: 21 });
        regs.insert("MSTP_FWD_CFG1", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("MSTP Forwarding Control"), details: Some("Configuration of forwarding state per MSTP"), fields });
        let mut fields = HashMap::new();
        fields.insert("MSTP_LRN_MASK", Field { brief: Some("Enable/disable learning per port. If a port is disabled in the mask, L2 learning of the (FID, SMAC) pair is not done. Ports in MSTP Learning and Forwarding state must be enabled in this mask. Related parameters: ANA_L3:VLAN_ARP_L3MC_STICKY:VLAN_STICKY.MSTP_LRN_DENY_STICKY ANA_L3:VLAN_ARP_L3MC_STICKY:VLAN_STICKY.MSTP_LRN_ALLOWED_STICKY"), details: Some("'0': Learning is disabled for frames from respective port '1': Learning is enabled for frames from respective port"), lo: 0, hi: 32 });
        regs.insert("MSTP_LRN_CFG", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("MSTP Learning Control"), details: Some("Configuration of learning state per MSTP."), fields });
        let mut fields = HashMap::new();
        fields.insert("VLAN_PORT_MASK1", Field { brief: Some("Refer to VLAN_MASK_CFG.VLAN_PORT_MASK description."), details: None, lo: 0, hi: 21 });
        regs.insert("VLAN_MASK_CFG1", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("VLAN Port Mask Configuration"), details: Some("Configuration of VLAN port mask."), fields });
        groups.insert("MSTP", RegisterGroup { addr: Address { base: 54272, count: 66, width: 4 }, desc: "MSTP table configuration", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ISDX_FORCE_MC_EFID_ENA", Field { brief: Some("Force Egress FID=ANA_L3:VLAN:VLAN_CFG.VLAN_FID when ANA_CL:IPT:VSI_CFG.VSI_ENA==1 and frame has multicast DMAC. See also SERVICE_CFG.VSI_FORCE_MC_EFID_ENA."), details: Some("0: Normal EFID behaviour for multicast  DMAC. 1: Force EFID=ANA_L3:VLAN:VLAN_CFG.VLAN_FID when VSI_ENA==1 and frame has multicast DMAC."), lo: 0, hi: 1 });
        fields.insert("VSI_FORCE_MC_EFID_ENA", Field { brief: Some("Force Egress FID=ANA_L3:VLAN:VLAN_CFG.VLAN_FID when ISDX > 0 and frame has multicast DMAC. See also SERVICE_CFG.VSI_FORCE_MC_EFID_ENA."), details: Some("0: Normal EFID behaviour for multicast  DMAC. 1: Force EFID=ANA_L3:VLAN:VLAN_CFG.VLAN_FIDfor multicast DMAC when ISDX > 0."), lo: 1, hi: 2 });
        regs.insert("SERVICE_CFG", Register { addr: Address { base: 30, count: 1, width: 1 }, brief: Some("Service Control"), details: Some("Miscellaneous service configuration."), fields });
        let mut fields = HashMap::new();
        fields.insert("TUPE_END_ADDR", Field { brief: Some("Last address in VLAN table for TUPE to process."), details: None, lo: 16, hi: 29 });
        fields.insert("TUPE_START_ADDR", Field { brief: Some("First address in VLAN table for TUPE to process."), details: None, lo: 0, hi: 13 });
        regs.insert("TUPE_ADDR", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Address range for TUPE to process"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TUPE_CMD_PORT_MASK_CLR", Field { brief: Some("Mask with ports, which shall be cleared in VLAN_PORT_MASK in VLAN table if VLAN table entry meets the critierias enabled in TUPE_MISC. If a port has its bit set in both TUPE_CMD_PORT_MASK_CLR and TUPE_CMD_PORT_MASK_SET then the value in VLAN_PORT_MASK is toggled."), details: Some("CLR=0, SET=0: No change to VLAN_PORT_MASK bit CLR=0, SET=1: VLAN_PORT_MASK bit shall be set. CLR=1, SET=0: VLAN_PORT_MASK bit shall be cleared. CLR=1, SET=1: VLAN_PORT_MASK bit shall be toggled.."), lo: 0, hi: 32 });
        regs.insert("TUPE_CMD_PORT_MASK_CLR", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("TUPE command: Port mask bits to clear"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TUPE_CMD_PORT_MASK_CLR1", Field { brief: Some("See TUPE_CMD_PORT_MASK_CLR."), details: None, lo: 0, hi: 21 });
        regs.insert("TUPE_CMD_PORT_MASK_CLR1", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("TUPE command: Port mask bits to clear"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TUPE_CMD_PORT_MASK_SET", Field { brief: Some("Mask with ports, which shall be set in VLAN_PORT_MASK in VLAN table if VLAN table entry meets the critierias enabled in TUPE_MISC. If a port has its bit set in both TUPE_CMD_PORT_MASK_CLR and TUPE_CMD_PORT_MASK_SET then the value in VLAN_PORT_MASK is toggled."), details: Some("CLR=0, SET=0: No change to VLAN_PORT_MASK bit CLR=0, SET=1: VLAN_PORT_MASK bit shall be set. CLR=1, SET=0: VLAN_PORT_MASK bit shall be cleared. CLR=1, SET=1: VLAN_PORT_MASK bit shall be toggled.."), lo: 0, hi: 32 });
        regs.insert("TUPE_CMD_PORT_MASK_SET", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("TUPE command: Port mask bits to set"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TUPE_CMD_PORT_MASK_SET1", Field { brief: Some("See TUPE_CMD_PORT_MASK_SET."), details: None, lo: 0, hi: 21 });
        regs.insert("TUPE_CMD_PORT_MASK_SET1", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("TUPE command: Port mask bits to set"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TUPE_CTRL_BIT_MASK", Field { brief: Some("If enabled by TUPE_CTRL_BIT_ENA, then the following condition must be met for TUPE to update VLAN table entry: (ANA_L3:VLAN:TUPE_CTRL & TUPE_CTRL_BIT_MASK) != 0 If enabled by TUPE_COMB_MASK_ENA, then the following condition must be met for TUPE to update VLAN table entry: ((ANA_L3:VLAN:TUPE_CTRL & TUPE_CTRL_BIT_MASK) != 0) || (ANA_L3:VLAN:VLAN_MASK_CFG.VLAN_PORT_MASK & TUPE_PORT_MASK_A) != 0"), details: None, lo: 0, hi: 16 });
        regs.insert("TUPE_CTRL_BIT_MASK", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("TUPE parameter controlling which VLAN table entries to update"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TUPE_CTRL_VAL", Field { brief: Some("If enabled by TUPE_CTRL_VAL_ENA, then the following condition must be met for TUPE to update VLAN table entry: (ANA_L3:VLAN:TUPE_CTRL & TUPE_CTRL_VAL_MASK) == TUPE_CTRL_VAL"), details: None, lo: 0, hi: 16 });
        regs.insert("TUPE_CTRL_VAL", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("TUPE parameter controlling which VLAN table entries to update"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TUPE_CTRL_VAL_MASK", Field { brief: Some("See TUPE_CTRL_VAL."), details: None, lo: 0, hi: 16 });
        regs.insert("TUPE_CTRL_VAL_MASK", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("TUPE parameter controlling which VLAN table entries to update"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TUPE_COMB_MASK_ENA", Field { brief: Some("Enable combined use of TUPE_CTRL_BIT_MASK and TUPE_PORT_MASK_A. For further information refer to TUPE_CTRL_BIT_MASK.TUPE_CTRL_BIT_MASK"), details: None, lo: 5, hi: 6 });
        fields.insert("TUPE_CTRL_BIT_ENA", Field { brief: Some("Enable use of TUPE_CTRL_BIT_MASK. For further information refer to TUPE_CTRL_BIT_MASK.TUPE_CTRL_BIT_MASK"), details: None, lo: 2, hi: 3 });
        fields.insert("TUPE_CTRL_VAL_ENA", Field { brief: Some("Enable use of TUPE_CTRL_VAL and TUPE_CTRL_VAL_MASK. For further information refer to TUPE_CTRL_VAL.TUPE_CTRL_VAL"), details: None, lo: 1, hi: 2 });
        fields.insert("TUPE_PORT_MASK_A_ENA", Field { brief: Some("Enable use of TUPE_PORT_MASK_A. For further information refer to TUPE_PORT_MASK_A.TUPE_PORT_MASK_A"), details: None, lo: 3, hi: 4 });
        fields.insert("TUPE_PORT_MASK_B_ENA", Field { brief: Some("Enable use of TUPE_PORT_MASK_B For further information refer to TUPE_PORT_MASK_B.TUPE_PORT_MASK_B"), details: None, lo: 4, hi: 5 });
        fields.insert("TUPE_START", Field { brief: Some("Start TUPE. Write 1 to start TUPE. Set to 0 by TUPE when done. Note: While TUPE is running (i.e. TUPE_START=1) CPU must not write to VLAN table."), details: None, lo: 0, hi: 1 });
        regs.insert("TUPE_MISC", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Miscellaneous TUPE parameters"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TUPE_PORT_MASK_A", Field { brief: Some("If enabled by TUPE_PORT_MASK_A_ENA, then the following condition must be met for TUPE to update VLAN table entry: (ANA_L3:VLAN:VLAN_MASK_CFG.VLAN_PORT_MASK & TUPE_PORT_MASK_A) != 0 If enabled by TUPE_COMB_MASK_ENA, then the following condition must be met for TUPE to update VLAN table entry: ((ANA_L3:VLAN:TUPE_CTRL & TUPE_CTRL_BIT_MASK) != 0) || (ANA_L3:VLAN:VLAN_MASK_CFG.VLAN_PORT_MASK & TUPE_PORT_MASK_A) != 0"), details: None, lo: 0, hi: 32 });
        regs.insert("TUPE_PORT_MASK_A", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("TUPE parameter controlling which VLAN table entries to update"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TUPE_PORT_MASK_A1", Field { brief: Some("See TUPE_PORT_MASK_A."), details: None, lo: 0, hi: 21 });
        regs.insert("TUPE_PORT_MASK_A1", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("TUPE parameter controlling which VLAN table entries to update"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TUPE_PORT_MASK_B", Field { brief: Some("If enabled by TUPE_PORT_MASK_B_ENA, then the following condition must be met for TUPE to update VLAN table entry: (ANA_L3:VLAN:VLAN_MASK_CFG.VLAN_PORT_MASK & TUPE_PORT_MASK_B) != 0"), details: None, lo: 0, hi: 32 });
        regs.insert("TUPE_PORT_MASK_B", Register { addr: Address { base: 11, count: 1, width: 1 }, brief: Some("TUPE parameter controlling which VLAN table entries to update"), details: None, fields });
        groups.insert("TUPE", RegisterGroup { addr: Address { base: 54567, count: 1, width: 13 }, desc: "Table UPdata Engine (TUPE)", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("BUM_SLB_IDX", Field { brief: Some("Broadcast, Unknown and Multicast traffic leaky bucket index This index can be overruled by index from ISDX table if ANA_L2:ISDX:MISC_CFG.BUM_SLB_ENA is set. Related parameters: ANA_AC_POL:BUM_SLB"), details: None, lo: 0, hi: 10 });
        regs.insert("BUM_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Bundle dual leaky bucket policer index"), details: Some("Specifies BUM policer index."), fields });
        let mut fields = HashMap::new();
        fields.insert("TUPE_CTRL", Field { brief: Some("Control value for Table UPdate Engine (TUPE). Note that unused bits in VLAN_PORT_MASK may also be used to control which VLAN table entries TUPE shall update. See ANA_L3:TUPE."), details: None, lo: 0, hi: 16 });
        regs.insert("TUPE_CTRL", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("TUPE Control"), details: Some("Control value for Table UPdate Engine (TUPE). See ANA_L3:TUPE."), fields });
        let mut fields = HashMap::new();
        fields.insert("TUPE_PORT_MASK_B1", Field { brief: Some("See TUPE_PORT_MASK_B."), details: None, lo: 0, hi: 21 });
        regs.insert("TUPE_PORT_MASK_B1", Register { addr: Address { base: 12, count: 1, width: 1 }, brief: Some("TUPE parameter controlling which VLAN table entries to update"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("VLAN_FID", Field { brief: Some("FID to be used for learning and forwarding."), details: None, lo: 8, hi: 21 });
        fields.insert("VLAN_FLOOD_DIS", Field { brief: Some("Disable flooding of frames with unknown DMAC on a per VLAN basis. Note that when VLAN_FLOOD_DIS=1, then frames with broadcast or multicast DMAC are only forwarded if installed in MAC table."), details: None, lo: 4, hi: 5 });
        fields.insert("VLAN_IGR_FILTER_ENA", Field { brief: Some("Enable VLAN ingress filtering per VLAN. If a enabled, frames received on a port, which is not a member of the classified VLAN, are discarded. VLAN ingress filtering can also be enabled per ingress port. VLAN ingress filtering is performed if either enabled for ingress port or for VLAN. Related parameters: ANA_L3:COMMON:VLAN_FILTER_CTRL ANA_L3:VLAN_ARP_L3MC_STICKY:VLAN_STICKY.VLAN_IGR_FILTER_STICKY"), details: None, lo: 6, hi: 7 });
        fields.insert("VLAN_LRN_DIS", Field { brief: Some("Disable learning of SMAC of frames received on this VLAN. Related parameters: ANA_L3:VLAN_ARP_L3MC_STICKY:VLAN_STICKY.VLAN_LRN_DENY_STICKY"), details: None, lo: 3, hi: 4 });
        fields.insert("VLAN_MIRROR_ENA", Field { brief: Some("VLAN mirror enable flag. If this field is set, frames classified to this ingress VLAN are mirrored."), details: None, lo: 0, hi: 1 });
        fields.insert("VLAN_MSTP_PTR", Field { brief: Some("Pointer to STP instance associated with VLAN. The value must not exceed the size of the MSTP table, ref. MSTP."), details: None, lo: 24, hi: 31 });
        fields.insert("VLAN_PRIVATE_ENA", Field { brief: Some("Enable / disable this VLAN as a Private VLAN (PVLAN). Ports within a PVLAN are categorized into three different port types: Promiscuous ports: A promiscuous port can communicate with all ports in the PVLAN, including the isolated and community ports. Isolated ports: An isolated port has complete Layer 2 separation from the other ports within the same PVLAN, but not from the promiscuous ports. PVLANs block all traffic to isolated ports except traffic from promiscuous ports. Traffic from isolated port is forwarded only to promiscuous ports. Community ports: Community ports communicate among themselves and with the PVLAN's promiscuous ports. Community ports cannot communicate with isolated ports. Related parameters: ANA_L3:COMMON:VLAN_ISOLATED_CFG ANA_L3:COMMON:VLAN_COMMUNITY_CFG"), details: None, lo: 1, hi: 2 });
        fields.insert("VLAN_RLEG_ENA", Field { brief: Some("Enable router leg in VLAN. If enabled, the ID of the router leg is configured in VMID_CFG.VMID."), details: None, lo: 2, hi: 3 });
        fields.insert("VLAN_SEC_FWD_ENA", Field { brief: Some("Enable secure forwarding on a per VLAN basis. When secure forwarding is enabled, only frames with known SMAC are forwarded."), details: Some("0: Forwarding is allowed regardless of SMAC being known or unknown. 1: Forwarding is only allowed for frames with known SMAC."), lo: 5, hi: 6 });
        regs.insert("VLAN_CFG", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("VLAN Configuration"), details: Some("Various configuration of VLAN handles"), fields });
        let mut fields = HashMap::new();
        fields.insert("VLAN_PORT_MASK", Field { brief: Some("Specify mask of ports belonging to VLAN. Note: Initialization value for addresses 0,1 and 4095 is '1...1' Initialization value for all other addresses is 0 Related parameters: ANA_L3:VLAN_ARP_L3MC_STICKY:VLAN_STICKY.VLAN_LOOKUP_INVLD_STICKY"), details: Some("0: Port does not belong to the VLAN 1: Port belongs to the VLAN"), lo: 0, hi: 32 });
        regs.insert("VLAN_MASK_CFG", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("VLAN Port Mask Configuration"), details: Some("Configuration of VLAN port mask."), fields });
        let mut fields = HashMap::new();
        fields.insert("VMID", Field { brief: Some("Routing: VMID, identifying VLAN's router leg. Security check: \"Mapped VLAN ID\"."), details: None, lo: 0, hi: 7 });
        regs.insert("VMID_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Router Leg Identification / Mapped VLAN ID"), details: None, fields });
        groups.insert("VLAN", RegisterGroup { addr: Address { base: 0, count: 5120, width: 8 }, desc: "VLAN table configuration", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("LPM_IP4MC_FOUND_STICKY", Field { brief: Some("Set if an IPv4 multicast longest prefix match has been found and the returned L3MC_IDX is less than the number of L3MC table entries."), details: None, lo: 0, hi: 1 });
        fields.insert("LPM_IP4UC_FOUND_STICKY", Field { brief: Some("Set if routing lookup found an IPv4 unicast longest prefix match."), details: None, lo: 2, hi: 3 });
        fields.insert("LPM_IP6MC_FOUND_STICKY", Field { brief: Some("Set if an IPv6 multicast longest prefix match has been found and the returned L3MC_IDX is less than the number of L3MC table entries."), details: None, lo: 1, hi: 2 });
        fields.insert("LPM_IP6UC_FOUND_STICKY", Field { brief: Some("Set if routing lookup found an IPv6 unicast longest prefix match."), details: None, lo: 3, hi: 4 });
        fields.insert("SECUR_IP4_LPM_FOUND_STICKY", Field { brief: Some("Set if an IPv4 SIP security lookup has found a match in LPM lookup. Note that this bit is not set for DIP security LPM lookups"), details: None, lo: 4, hi: 5 });
        fields.insert("SECUR_IP6_LPM_FOUND_STICKY", Field { brief: Some("Set if an IPv6 SIP security lookup has found a match in LPM lookup. Note that this bit is not set for DIP security LPM lookups"), details: None, lo: 5, hi: 6 });
        regs.insert("L3_LPM_REMAP_STICKY", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Router Leg Diagnostic"), details: Some("Diagnostic bits related to longest prefix matching."), fields });
        let mut fields = HashMap::new();
        fields.insert("MSTP_DISCARD_STICKY", Field { brief: Some("Set if a frame has been filtered due to MSTP_FWD_MASK. Related parameters: ANA_L3:MSTP:MSTP_FWD_CFG.MSTP_FWD_MASK"), details: None, lo: 5, hi: 6 });
        fields.insert("MSTP_FWD_ALLOWED_STICKY", Field { brief: Some("Set if MSTP_FWD_MASK has allowed forwarding of a frame. Related parameters: ANA_L3:MSTP:MSTP_FWD_CFG.MSTP_FWD_MASK"), details: None, lo: 6, hi: 7 });
        fields.insert("MSTP_LRN_ALLOWED_STICKY", Field { brief: Some("Set if MSTP_LRN_MASK has allowed learning for a frame. Related parameters: ANA_L3:MSTP:MSTP_LRN_CFG.MSTP_LRN_MASK"), details: None, lo: 2, hi: 3 });
        fields.insert("MSTP_LRN_DENY_STICKY", Field { brief: Some("Set if MSTP_LRN_MASK has denied learning for a frame. Related parameters: ANA_L3:MSTP:MSTP_LRN_CFG.MSTP_LRN_MASK"), details: None, lo: 3, hi: 4 });
        fields.insert("PORT_FWD_DENY_STICKY", Field { brief: Some("Set if a frame has been denied forwarding due to ANA_L3:COMMON:PORT_FWD_CTRL.PORT_FWD_ENA = 0"), details: None, lo: 15, hi: 16 });
        fields.insert("PORT_LRN_DENY_STICKY", Field { brief: Some("Set if learning has been denied for a frame due to ANA_L3:COMMON:PORT_LRN_CTRL.PORT_LRN_ENA = 0"), details: None, lo: 16, hi: 17 });
        fields.insert("VLAN_IGR_FILTER_STICKY", Field { brief: Some("Set if a frame has been filtered due to VLAN ingress filtering. Related parameters: ANA_L3:COMMON:VLAN_FILTER_CTRL.VLAN_IGR_FILTER_ENA"), details: None, lo: 0, hi: 1 });
        fields.insert("VLAN_LOOKUP_INVLD_STICKY", Field { brief: Some("Set if a frame has been classified to a VLAN with an empty port mask. Related parameters: ANA_L3:VLAN:VLAN_MASK_CFG.VLAN_PORT_MASK"), details: None, lo: 1, hi: 2 });
        fields.insert("VLAN_LRN_DENY_STICKY", Field { brief: Some("Set if VLAN_LRN_DIS has denied learning for a frame. Related parameters: ANA_L3:VLAN:VLAN_CFG.VLAN_LRN_DIS"), details: None, lo: 4, hi: 5 });
        regs.insert("VLAN_STICKY", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VLAN Diagnostic"), details: None, fields });
        groups.insert("VLAN_ARP_L3MC_STICKY", RegisterGroup { addr: Address { base: 54581, count: 1, width: 2 }, desc: "Diagnostic information", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("MSTP_LRN_MASK1", Field { brief: Some("Refer to MSTP_LRN_CFG.MSTP_LRN_MASK description."), details: None, lo: 0, hi: 21 });
        regs.insert("MSTP_LRN_CFG1", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("MSTP Learning Control"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RLEG_EVID", Field { brief: Some("VID for egress router leg. This must be configured consistently in REW:VMID:RLEG_CTRL.RLEG_EVID."), details: None, lo: 16, hi: 28 });
        fields.insert("RLEG_IP4_ICMP_REDIR_ENA", Field { brief: Some("Enable redirection to CPU of IPv4 packets with IVMID==EVMID (i.e. packets that are to be routed back to the router leg, they were received on). CPU queue is configured in ANA_L3:COMMON:CPU_QU_CFG.CPU_UC_FAIL_QU. Related parameters: ANA_L3:COMMON:CPU_QU_CFG.CPU_UC_FAIL_QU ANA_L3:VLAN_ARP_L3MC_STICKY:L3_ARP_IPMC_STICKY.UC_ICMP_REDIR_STICKY"), details: None, lo: 2, hi: 3 });
        fields.insert("RLEG_IP4_MC_ENA", Field { brief: Some("Enable IPv4 multicast routing."), details: None, lo: 4, hi: 5 });
        fields.insert("RLEG_IP4_SIP_RPF_MODE", Field { brief: Some("SIP RPF mode for IPv4. If SIP RPF check fails, then frame is not allowed to be L3 forwarded. Disabled: No SIP RPF check. RGID Mode: Verify that SIP belongs to a known subnet and verify that SIP's RGID is enabled in ingress router leg's RLEG_RGID_MASK. Rleg Mode: Verify that SIP belongs to a known subnet, and that the frame is received on the router leg through which that subnet is reached. If SIP is reached through an ECMP path then no SIP RPF check is performed. Combined Mode: Apply Rleg Mode for non ECMP paths and RGID Mode for ECMP paths. Related parameters: ANA_L3:COMMON:SIP_RPF_ENA ANA_L3:COMMON:ROUTING_CFG.RLEG_IP4_SIP_RPF_REDIR_ENA ANA_L3:COMMON:CPU_QU_CFG.CPU_SIP_RPF_QU ANA_L3:VLAN_ARP_L3MC_STICKY:L3_ARP_IPMC_STICKY.IP4_SIP_RPF_FILTER_STICKY ANA_L3:VMID:SIP_RPF.RLEG_RGID_MASK"), details: Some("0: Disabled 1: RGID Mode 2: Rleg Mode 3: Combined Mode"), lo: 8, hi: 10 });
        fields.insert("RLEG_IP4_UC_ENA", Field { brief: Some("Enable IPv4 unicast routing."), details: None, lo: 6, hi: 7 });
        fields.insert("RLEG_IP4_VRID_ENA", Field { brief: Some("Enable IPv4 virtual router leg. If enabled, the router leg can also be addressed using a MAC address constructed using the following fields: Bits 47-32: ANA_L3:COMMON:VRRP_IP4_CFG_1.VRRP_IP4_BASE_MAC_HIGH Bits 31-8: ANA_L3:COMMON:VRRP_IP4_CFG_0.VRRP_IP4_BASE_MAC_MID Bits 7-0: ANA_L3:VMID.VRRP_CFG.RLEG_IP4_VRID"), details: None, lo: 0, hi: 1 });
        fields.insert("RLEG_IP6_ICMP_REDIR_ENA", Field { brief: Some("Enable redirection to CPU of IPv6 packets with IVMID==EVMID (i.e. packets that are to be routed back to the router leg, they were received on). CPU queue is configured in ANA_L3:COMMON:CPU_QU_CFG.CPU_UC_FAIL_QU. Related parameters: ANA_L3:COMMON:CPU_QU_CFG.CPU_UC_FAIL_QU ANA_L3:VLAN_ARP_L3MC_STICKY:L3_ARP_IPMC_STICKY.UC_ICMP_REDIR_STICKY"), details: None, lo: 3, hi: 4 });
        fields.insert("RLEG_IP6_MC_ENA", Field { brief: Some("Enable IPv6 multicast routing."), details: None, lo: 5, hi: 6 });
        fields.insert("RLEG_IP6_SIP_RPF_MODE", Field { brief: Some("SIP RPF mode for IPv6. If SIP RPF check fails, then frame is not allowed to be L3 forwarded. Disabled: No SIP RPF check. RGID Mode: Verify that SIP belongs to a known subnet and verify that SIP's RGID is enabled in ingress router leg's RGID_MASK. Rleg Mode: Verify that SIP belongs to a known subnet, and that the frame is received on the router leg through which that subnet is reached. If SIP is reached through an ECMP path then no SIP RPF check is performed. Combined Mode: Apply Rleg Mode for non ECMP paths and RGID Mode for ECMP paths. Related parameters: ANA_L3:COMMON:SIP_RPF_ENA ANA_L3:COMMON:ROUTING_CFG.RLEG_IP6_SIP_RPF_REDIR_ENA ANA_L3:COMMON:CPU_QU_CFG.CPU_SIP_RPF_QU ANA_L3:VLAN_ARP_L3MC_STICKY:L3_ARP_IPMC_STICKY.IP6_SIP_RPF_FILTER_STICKY ANA_L3:VMID:SIP_RPF.RLEG_RGID_MASK"), details: Some("0: Disabled 1: RGID Mode 2: Rleg Mode 3: Combined Mode"), lo: 10, hi: 12 });
        fields.insert("RLEG_IP6_UC_ENA", Field { brief: Some("Enable IPv6 unicast routing."), details: None, lo: 7, hi: 8 });
        fields.insert("RLEG_IP6_VRID_ENA", Field { brief: Some("Enable IPv6 virtual router leg. If enabled, the router leg can also be addressed using a MAC address constructed using the following fields: Bits 47-32: ANA_L3:COMMON:VRRP_IP6_CFG_1.VRRP_IP6_BASE_MAC_HIGH Bits 31-8: ANA_L3:COMMON:VRRP_IP6_CFG_0.VRRP_IP6_BASE_MAC_MID Bits 7-0: ANA_L3:VMID.VRRP_CFG.RLEG_IP6_VRID"), details: None, lo: 1, hi: 2 });
        regs.insert("RLEG_CTRL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Router leg control"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RLEG_RGID_MASK", Field { brief: Some("Route Group IDs (RGIDs) accepted for this router leg when SIP_RPF_MODE is set to \"RGID Mode\". See description of RLEG_IP4_SIP_RPF_MODE / RLEG_IP6_SIP_RPF_MODE."), details: Some("Bit 0: Accept routes with RGID=0 Bit 1: Accept routes with RGID=1 ..."), lo: 0, hi: 8 });
        regs.insert("SIP_RPF", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("SIP RPF check parameters"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RLEG_IP4_MC_DMAC_CHK_ENA", Field { brief: Some("Enable checking of DMAC for IPv4 multicast packets. I.e. verify that DMAC[47:24] == 0x01005e DMAC[23] == 0 If the check fails, the packet is not routed."), details: None, lo: 16, hi: 17 });
        fields.insert("RLEG_IP4_MC_TTL", Field { brief: Some("IPv4 multicast TTL limit. Packets with TTL below the configured limit are not routed. TTL is checked against RLEG_IP4_MC_TTL before transmission on egress router leg. Note: Regardless of the value configured for this parameter, IPv4 MC packets with TTL<2 are not routed."), details: Some("0: Router leg based MC TTL check disabled. 1-2: N/A - such packets are not routed anyway. 3: If packet's TTL is < 3 then packet is not routed. 4: If packet's TTL is < 4 then packet is not routed. ..."), lo: 0, hi: 8 });
        fields.insert("RLEG_IP6_MC_DMAC_CHK_ENA", Field { brief: Some("Enable checking of DMAC for IPv6 multicast packets. I.e. verify that DMAC[47:32] == 0x3333 If the check fails, the packet is not routed."), details: None, lo: 17, hi: 18 });
        fields.insert("RLEG_IP6_MC_TTL", Field { brief: Some("IPv6 multicast HL limit. Packets with HL below the configured limit are not routed. HL is checked against RLEG_IP6_MC_TTL before transmission on egress router leg. Note: Regardless of the value configured for this parameter, IPv6 MC packets with HC<2 are not routed."), details: Some("0: Router leg based MC HL check disabled 1-2: N/A - such packets are not routed anyway. 3: If packet's HC is < 3 then packet is not routed. 4: If packet's HC is < 4 then packet is not routed. ..."), lo: 8, hi: 16 });
        regs.insert("VMID_MC", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("IP multicast router leg configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RLEG_IP4_VRID", Field { brief: Some("Router leg's VRID for IPv4. The configured VRID is used as part of the VRRP router MAC address. Only applicable if VRRP is enabled for router leg. See RLEG_CTRL.RLEG_IP4_VRID_ENA for further details. If only one of the two VRIDs is used, then the unused VRID must be set to the same value as the VRID in use."), details: None, lo: 0, hi: 8 });
        fields.insert("RLEG_IP6_VRID", Field { brief: Some("Router leg's VRID for IPv6. The configured VRID is used as part of the VRRP router MAC address. Only applicable if VRRP is enabled for router leg. See RLEG_CTRL.RLEG_IP6_VRID_ENA for further details. If only one of the two VRIDs is used, then the unused VRID must be set to the same value as the VRID in use."), details: None, lo: 8, hi: 16 });
        regs.insert("VRRP_CFG", Register { addr: Address { base: 1, count: 2, width: 1 }, brief: Some("Virtual router leg configuration"), details: Some("Configuration of Virtual Router Interface MAC address"), fields });
        groups.insert("VMID", RegisterGroup { addr: Address { base: 53248, count: 128, width: 8 }, desc: "Router Leg Table", regs });
        out.insert("ANA_L3", Target { desc: "ANA_L3 provides the following functionality: - VLAN handling - MSTP handling - IP routing", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CPU_FC_ENA", Field { brief: Some("This field determines if the ASM must assert the flow control signal to the CPU device when the ASM FIFO fill level exceeds the watermark given in\t   CPU_FC_WM."), details: Some("'0': Flow control is disabled. '1': Flow control is enabled."), lo: 0, hi: 1 });
        fields.insert("CPU_FC_WM", Field { brief: Some("This field determines the ASM FIFO fill level required for the ASM to activate FC. The fill level is given by the number of complete cells in the FIFO that are ready to be passed to the ANA block."), details: Some("0: Flow control is activated if the ASM FIFO of the DEVCPU holds 1 or more complete cells. 1: Flow control is activated if the ASM FIFO of the DEVCPU holds 2 or more complete cells. --- X: Flow control is activated if the ASM FIFO of the DEVCPU holds X+1 or more complete cells."), lo: 1, hi: 4 });
        regs.insert("CPU_FC_CFG", Register { addr: Address { base: 166, count: 1, width: 1 }, brief: Some("Holds DEVCPU specific Flow Control configuration signals"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MAC_ADDR_HIGH", Field { brief: Some("Upper 24 bits of MAC address. The MAC address is used when filtering incoming Pause Control Frames - i.e. when the ASM detemines whether or not a pause value must be passed to the DSM."), details: Some("The resulting MAC address of a device is determined as: MAC_ADDR_HIGH  & MAC_ADDR_LOW."), lo: 0, hi: 24 });
        regs.insert("MAC_ADDR_HIGH_CFG", Register { addr: Address { base: 1, count: 55, width: 1 }, brief: Some("MAC Address Configuration Register (MSB)"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MAC_ADDR_LOW", Field { brief: Some("Lower 24 bits of MAC address. The MAC address is used when filtering incoming Pause Control Frames - i.e. when the ASM detemines whether or not a pause value must be passed to the DSM."), details: Some("The resulting MAC address of a device is determined as: MAC_ADDR_HIGH  & MAC_ADDR_LOW."), lo: 0, hi: 24 });
        regs.insert("MAC_ADDR_LOW_CFG", Register { addr: Address { base: 56, count: 55, width: 1 }, brief: Some("MAC Address Configuration Register (LSB)"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ABORT_CTRL_ENA", Field { brief: Some("This field indicates whether or not the ASM must discard Control frames with type 0x8808 not being Pause frames, to the IQS by asserting the abort signal. One configuration bit is defined for each port."), details: Some("'0': The ASM must not discard Control frames. '1': The ASM must discard Control frames to the IQS by asserting the abort signal."), lo: 1, hi: 2 });
        fields.insert("ABORT_PAUSE_ENA", Field { brief: Some("This field indicates whether or not the ASM must discard a valid Pause frame to the IQS by asserting the abort signal. One configuration bit is defined for each port."), details: Some("'0': The ASM must not discard valid Pause frames. '1': The ASM must discard valid Pause frames to the IQS by asserting the abort signal, but the Pause value must still be used to stall the egress data flow."), lo: 0, hi: 1 });
        regs.insert("PAUSE_CFG", Register { addr: Address { base: 167, count: 55, width: 1 }, brief: Some("Holds configuration related to Pause frame detection."), details: Some("This register control whether pause and control frames should be forwarded or terminated at ingress."), fields });
        let mut fields = HashMap::new();
        fields.insert("CSC_STAT_DIS", Field { brief: Some("Disables the CSC statistics counters in the ASM for the port. Set this when the port utilizes a DEV10G device as this handles the statistics locally in the device."), details: None, lo: 11, hi: 12 });
        fields.insert("FRM_AGING_DIS", Field { brief: Some("This field determines if the ASM must abort mark frames that become older than 16-24 ms before and EOF is received."), details: Some("'0': Aging enabled. '1': Aging disabled."), lo: 6, hi: 7 });
        fields.insert("HIH_AFTER_PREAMBLE_ENA", Field { brief: Some("If this field is set the ASM remove the first 4 bytes of the payload and insert it into the HIH field of the IFH."), details: None, lo: 10, hi: 11 });
        fields.insert("IGN_TAXI_ABORT_ENA", Field { brief: Some("If this field is set the ASM will ignore any abort indication received on the TAXI interface for the port."), details: None, lo: 9, hi: 10 });
        fields.insert("INJ_DISCARD_CFG", Field { brief: Some("Configure discard behaviour depending on matching result of the selected injection format. This setting is only valid for injection formats with short or long prefix."), details: Some("0: Discard none 1: Discard frames with wrong injection format 2: Discard frames with correct injection format"), lo: 3, hi: 5 });
        fields.insert("INJ_FORMAT_CFG", Field { brief: Some("Set the mode for the formatting of incoming frames. Four different modes can be selected: - Normal mode (No IFH) - IFH without prefix - IFH with short prefix - IFH with long prefix If one of the IFH modes are selected incoming frames are expected to contain the selected prefix followed by an IFH as the first part of the frame. Frames are forwarded based on the contents in the IFH instead of normal forwarding. Three different prefix modes are supported: - No prefix. - IFH short prefix:. any DMAC, any SMAC, EtherType=0x8880, payload=0x0007 - IFH long prefix: any DMAC, any SMAC, VLAN Tag, EtherType=0x8880, payload=0x0007. In the IFH modes, if the incoming frame's format does not comply with the prefix, then IFH_PREFIX_ERR_STICKY is set."), details: Some("0: Normal mode (No IFH) 1: IFH without prefix 2: IFH with short prefix 3: IFH with long prefix"), lo: 1, hi: 3 });
        fields.insert("NO_PREAMBLE_ENA", Field { brief: Some("If this field is set the ASM does not expect the incoming frame data to have a preamble prepended."), details: None, lo: 8, hi: 9 });
        fields.insert("PAD_ENA", Field { brief: Some("This field determines if the ASM mustzero-pad Ethernet frames that are less than 64 bytes."), details: Some("'0': Padding is disabled. Frames that are less than 64 bytes and have not been abort marked are passed to the ANA block 'as is'. Frames that are less than 64 bytes and have been abort marked are normally discarded silently by the ASM. '1': Padding is enabled. If the resulting frame size will be less than 64 bytes, the frame is zero-padded, so that the resulting frame size is 64 bytes."), lo: 5, hi: 6 });
        fields.insert("SKIP_PREAMBLE_ENA", Field { brief: Some("If this field is set the ASM will not store the first 8 bytes from the packet. This must be enabled when injecting with IFH without prefix from an extenal CPU (INJ_FORMAT_CFG=1)."), details: None, lo: 7, hi: 8 });
        fields.insert("VSTAX2_AWR_ENA", Field { brief: Some("This bit defines if the ASM must be Vstax2 aware or not. If Vstax2 awareness is enabled and a frame holds a Vstax2 header following the SMAC address, this Vstax2 header is removed from the frame and placed in the IFH and the vstax_avail and update_fcs fields in the IFH will be set, so that the frame FCS is recalculated in the egress direction. If Vstax2 awareness is disabled or a frame does not hold a Vstax2 header, no bytes will be removed from the frame and the vstax_hdr, vstax_avail and fcs_update fields in the IFH will be cleared. When Vstax2 awareness is enabled INJ_FORMAT_CFG must be set to 0"), details: Some("0: Vstax2 awareness is disabled. 1: Vstax2 awareness is enabled."), lo: 0, hi: 1 });
        regs.insert("PORT_CFG", Register { addr: Address { base: 111, count: 55, width: 1 }, brief: Some("Port configuration"), details: Some("This register holds port configuration bit groups"), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_SYNC_LOST_ERR_CNT", Field { brief: Some("Counter to track the PCS's Sync-lost error"), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_SYNC_LOST_ERR_CNT", Register { addr: Address { base: 54, count: 1, width: 1 }, brief: Some("Counter to track the PCS's Sync-lost error"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("STAT_CNT_CLR_SHOT", Field { brief: Some("Setting of this bit initiates the clearing of all statistics counter."), details: Some("'0': No action '1': Stat cnt clr (Bit is automatically cleared)"), lo: 0, hi: 1 });
        regs.insert("STAT_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Statistics counter configuration"), details: Some("Register that contains the bitgroups to configure/control the statistics counters."), fields });
        groups.insert("CFG", RegisterGroup { addr: Address { base: 3394, count: 1, width: 223 }, desc: "Assembler Configuration Registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CM_ADDR", Field { brief: Some("Address selection within selected core memory (CMID register). Address is automatically advanced at every data access."), details: None, lo: 0, hi: 22 });
        fields.insert("CM_ID", Field { brief: Some("Please refer to cmid.xls in the AS1000, misc_docs folder."), details: None, lo: 22, hi: 30 });
        regs.insert("CM_ADDR", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Address selection"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CM_DATA", Field { brief: Some("Data register for core memory access. Wider memories are big endian mapped into the 32 BIT inspection space."), details: None, lo: 0, hi: 32 });
        regs.insert("CM_DATA", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Data register for core memory access."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RAM_ENA", Field { brief: Some("Core memory controllers are enabled when this field is set."), details: None, lo: 0, hi: 1 });
        fields.insert("RAM_INIT", Field { brief: Some("Initialize core memories. Field is automatically cleared when operation is complete ( approx. 40 us)."), details: None, lo: 1, hi: 2 });
        regs.insert("RAM_INIT", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Core reset control"), details: Some("Controls reset and initialization of the switching core. Proper startup sequence is: - Enable memories - Initialize memories - Enable core"), fields });
        groups.insert("COREMEM", RegisterGroup { addr: Address { base: 3392, count: 1, width: 2 }, desc: "Access core memory", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ABORT_DIS", Field { brief: Some("This field can be used to configure the ASM not to silently discard frames that are aborted by a device within the first cell of a frame. Note that enabling this feature may cause overflow in the ASM when small fragments are received at the Taxi interface."), details: Some("'0': Frames are silently discarded by the ASM if it is aborted within the first cell of the frame. '1': No frames are silently discarded by the ASM"), lo: 0, hi: 1 });
        fields.insert("CELL_BUS_DIS", Field { brief: Some("This field can be used to disable the cell bus output of the ASM - i.e. to configure the ASM to replace any data cells with IDLE cells. Data is flushed from the ASM FIFO when the output is disabled."), details: Some("'0': Any data cells read from the ASM FIFO are passed to the ANA block. '1': No data cells are passed to the ANA block. Only IDLE and REFRESH cells will be transmitted. Data is still read from the ASM FIFO, even though the cell bus interface has been disabled."), lo: 1, hi: 2 });
        fields.insert("FIFO_RST", Field { brief: Some("This field indicates if a given ASM FIFO must be reset or not. Resetting a FIFO does not affect the device status interface to the DSM."), details: Some("'0': The FIFO is NOT reset. '1': The FIFO is reset and it will remain reset until FIFO_RST is de-asserted."), lo: 3, hi: 12 });
        fields.insert("IDLE_TO_VD", Field { brief: Some("If this fields is set to 1, cell cycles allocated for front ports, but with no data available, will be given to the virtual device. Otherwise the VD is only given the cycles set by the cell bus calendar."), details: None, lo: 2, hi: 3 });
        regs.insert("DBG_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Miscellaneous debug configuration"), details: Some("This register holds miscellaneous configuration bit groups used for debug"), fields });
        let mut fields = HashMap::new();
        fields.insert("CALENDAR_STICKY", Field { brief: Some("Cell words must only be granted a given Taxi bus every 3rd cell cycle or more. I.e. for Taxi A there must always be two or more cell slots given to another Taxi other than A or idle, before Taxi A is allowed to get the next grant. If the cell bus calendar causes 2 cell slots to be allocated the same Taxi bus within 3 cell cycles, the last cell slot is ignored and a sticky bit is asserted."), details: Some("'0': No cell slot calendar error detected. '1': One or more cell slots have been ignored by ASM. Bit is cleared by writing a '1' to this position."), lo: 7, hi: 8 });
        fields.insert("CC_INTRN_ERR_STICKY", Field { brief: Some("The ASM must assert a sticky bit if an internal error occurs in the 'complete cell' FIFO."), details: Some("'0': No internal error has been detected in the 'complete cell' FIFO. '1': An internal error has been detected in the 'complete cell' FIFO. Bit is cleared by writing a '1' to this position."), lo: 10, hi: 11 });
        fields.insert("CC_OFLW_STICKY", Field { brief: Some("The ASM must assert a sticky bit if an overflow occurs in the 'complete cell' FIFO."), details: Some("'0': No overflow has been detected in the 'complete cell' FIFO. '1': An overflow has been detected in the 'complete cell' FIFO. Bit is cleared by writing a '1' to this position."), lo: 8, hi: 9 });
        fields.insert("CC_UFLW_STICKY", Field { brief: Some("The ASM must assert a sticky bit if an underflow occurs in the 'complete cell' FIFO."), details: Some("'0': No underflow has been detected in the 'complete cell' FIFO. '1': An underflow has been detected in the 'complete cell' FIFO. Bit is cleared by writing a '1' to this position."), lo: 9, hi: 10 });
        fields.insert("FC_OFLW_STICKY", Field { brief: Some("The ASM must assert a sticky bit if an overflow occurs in the 'free cell' FIFO."), details: Some("'0': No overflow has been detected in the 'free cell' FIFO. '1': An overflow has been detected in the 'free cell' FIFO. Bit is cleared by writing a '1' to this position."), lo: 11, hi: 12 });
        fields.insert("FC_UFLW_STICKY", Field { brief: Some("The ASM must assert a sticky bit if an underflow occurs in the 'free cell' FIFO."), details: Some("'0': No underflow has been detected in the 'free cell' FIFO. '1': An underflow has been detected in the 'free cell' FIFO. Bit is cleared by writing a '1' to this position."), lo: 12, hi: 13 });
        fields.insert("FRAGMENT_STICKY", Field { brief: Some("This sticky bit is set if the ASM passes a frame to the cell bus, which is less than 64 bytes (before any padding is done, if enabled) - and has not been aborted or abortion has been disabled. The padding configuration does not affect this sticky bit."), details: Some("'0': No error detected. '1': One or more frames have been passed to the cell bus, where the frame size was less than 64 bytes. Bit is cleared by writing a '1' to this position."), lo: 5, hi: 6 });
        fields.insert("INVLD_ABORT_STICKY", Field { brief: Some("This sticky bit is set if the ASM receives a Taxi word where ABORT is asserted but EOF is not asserted."), details: Some("'0': No misaligned ABORT/EOF indications detected. '1': Misaligned ABORT/EOF indications detected. Bit is cleared by writing a '1' to this position."), lo: 3, hi: 4 });
        fields.insert("MAIN_SM_INTRN_ERR_STICKY", Field { brief: Some("The ASM must assert a sticky bit if an overflow occurs in the main statemachine."), details: Some("'0': No overflow has been detected in the main statemachine. '1': An overflow has been detected in the main statemachine. Bit is cleared by writing a '1' to this position."), lo: 1, hi: 2 });
        fields.insert("MAIN_SM_OFLW_STICKY", Field { brief: Some("The ASM must assert a sticky bit if an overflow occurs in the main statemachine."), details: Some("'0': No overflow has been detected in the main statemachine. '1': An overflow has been detected in the main statemachine. Bit is cleared by writing a '1' to this position."), lo: 0, hi: 1 });
        fields.insert("MISSING_EOF_STICKY", Field { brief: Some("This sticky bit is set if the ASM receives a Taxi word where SOF is asserted and the previous valid Taxi word from that port did not hold an EOF."), details: Some("'0': No missing EOF detected '1': Missing EOF detected Bit is cleared by writing a '1' to this position."), lo: 4, hi: 5 });
        fields.insert("MISSING_SOF_STICKY", Field { brief: Some("This sticky bit is set if the ASM receives a Taxi word with SOF=0 and the previous valid Taxi word from that port hold an EOF."), details: Some("'0': No missing EOF detected '1': Missing EOF detected Bit is cleared by writing a '1' to this position."), lo: 2, hi: 3 });
        fields.insert("UNUSED_BYTES_STICKY", Field { brief: Some("This sticky bit is set if a partial Taxi word (unused_bytes <> 0) is received while EOF = 0."), details: Some("'0': No error detected in UNUSED_BYTES field ofTaxi word. '1': One or more Taxi words have been received where the UNUSED_BYTES field was different from 0 and EOP = 0. Bit is cleared by writing a '1' to this position."), lo: 6, hi: 7 });
        regs.insert("ERR_STICKY", Register { addr: Address { base: 1, count: 9, width: 1 }, brief: Some("Holds a number of sticky bits that are set if internal errors are detected."), details: Some("Writing a '1' to a bit group clears that bit."), fields });
        let mut fields = HashMap::new();
        fields.insert("INJ_TPID_CFG", Field { brief: Some("The TPID used for VLAN tag matching when injection with long IFH prefix is selected in INJ_FORMAT_CFG."), details: None, lo: 0, hi: 16 });
        fields.insert("INJ_VID_CFG", Field { brief: Some("The VID used for VLAN tag matching when injection with long IFH prefix is selected in INJ_FORMAT_CFG."), details: None, lo: 16, hi: 28 });
        regs.insert("INJ_VLAN_CFG", Register { addr: Address { base: 222, count: 1, width: 1 }, brief: Some("Configure custom VLAN tag for injection"), details: None, fields });
        groups.insert("DBG", RegisterGroup { addr: Address { base: 3617, count: 1, width: 11 }, desc: "Assembler Debug Registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("RX_ALIGNMENT_LOST_CNT", Field { brief: Some("The number of frames received with Alignment (dribble-nibble) error."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_ALIGNMENT_LOST_CNT", Register { addr: Address { base: 37, count: 1, width: 1 }, brief: Some("Counter to track the dribble-nibble (extra nibble) errors in frames."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_BAD_BYTES_CNT", Field { brief: Some("The number of received bytes in bad frames."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_BAD_BYTES_CNT", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Rx Bad Byte Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_BAD_BYTES_MSB_CNT", Field { brief: Some("Upper 4 bits of RX_BAD_BYTES_CNT."), details: Some("Counter can be written by SW."), lo: 0, hi: 4 });
        regs.insert("RX_BAD_BYTES_MSB_CNT", Register { addr: Address { base: 51, count: 1, width: 1 }, brief: Some("MSB of RX bad byte Counter"), details: Some("Register allowing to access the upper 4 bits of RX_IN_BYTE counter. Please note: When writing to RX_BAD_BYTES counter RX_BAD_BYTES_MSB_CNT has to be written before RX_BAD_BYTES_CNT is written. When reading RX_BAD_BYTES counter RX_BAD_BYTES_CNT has to be read before RX_BAD_BYTES_MSB_CNT is read. Accessing both counters must not be interfered by other register accesses."), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_BC_CNT", Field { brief: Some("The number of good broadcast frames received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_BC_CNT", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("Rx Broadcast Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_CRC_ERR_CNT", Field { brief: Some("The number of frames received with CRC error only."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_CRC_ERR_CNT", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("Rx CRC Error Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_FRAGMENTS_CNT", Field { brief: Some("The number of undersize frames with CRC error received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_FRAGMENTS_CNT", Register { addr: Address { base: 11, count: 1, width: 1 }, brief: Some("Rx Undersize Counter (CRC error)"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_IN_BYTES_CNT", Field { brief: Some("The number of bytes received (good, bad, and framing)."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_IN_BYTES_CNT", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Rx Byte Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_IN_BYTES_MSB_CNT", Field { brief: Some("Upper 4 bits of RX_IN_BYTES_CNT."), details: Some("Counter can be written by SW."), lo: 0, hi: 4 });
        regs.insert("RX_IN_BYTES_MSB_CNT", Register { addr: Address { base: 49, count: 1, width: 1 }, brief: Some("MSB of RX in byte Counter"), details: Some("Register allowing to access the upper 4 bits of RX_IN_BYTE counter. Please note: When writing to RX_IN_BYTES counter RX_IN_BYTES_MSB_CNT has to be written before RX_IN_BYTES_CNT is written. When reading RX_IN_BYTES counter RX_IN_BYTES_CNT has to be read before RX_IN_BYTES_MSB_CNT is read. Accessing both counters must not be interfered by other register accesses."), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_IN_RANGE_LEN_ERR_CNT", Field { brief: Some("The number of frames with legal length field that doesn't match length of MAC client data."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_IN_RANGE_LEN_ERR_CNT", Register { addr: Address { base: 12, count: 1, width: 1 }, brief: Some("Rx In-range Length Error Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_IPG_SHRINK_CNT", Field { brief: Some("Number of inter packet gap shrinks detected (IPG < 12 bytes)."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_IPG_SHRINK_CNT", Register { addr: Address { base: 23, count: 1, width: 1 }, brief: Some("Rx Inter Packet Gap Shrink Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_JABBERS_CNT", Field { brief: Some("The number of oversize frames with CRC error received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_JABBERS_CNT", Register { addr: Address { base: 15, count: 1, width: 1 }, brief: Some("Rx Jabbers Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_MC_CNT", Field { brief: Some("The number of good multicast frames received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_MC_CNT", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Rx Multicast Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_OK_BYTES_CNT", Field { brief: Some("The number of received bytes in good frames."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_OK_BYTES_CNT", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Rx OK Byte Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_OK_BYTES_MSB_CNT", Field { brief: Some("Upper 4 bits of RX_OK_BYTES_CNT."), details: Some("Counter can be written by SW."), lo: 0, hi: 4 });
        regs.insert("RX_OK_BYTES_MSB_CNT", Register { addr: Address { base: 50, count: 1, width: 1 }, brief: Some("MSB of RX ok byte Counter"), details: Some("Register allowing to access the upper 4 bits of RX_IN_BYTE counter. Please note: When writing to RX_OK_BYTES counter RX_OK_BYTES_MSB_CNT has to be written before RX_OK_BYTES_CNT is written. When reading RX_OK_BYTES counter RX_OK_BYTES_CNT has to be read before RX_OK_BYTES_MSB_CNT is read. Accessing both counters must not be interfered by other register accesses."), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_OUT_OF_RANGE_LEN_ERR_CNT", Field { brief: Some("The number of frames with illegal length field (frames using type field are not counted here)."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_OUT_OF_RANGE_LEN_ERR_CNT", Register { addr: Address { base: 13, count: 1, width: 1 }, brief: Some("Rx Out-Of-Range Length Error Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_OVERSIZE_CNT", Field { brief: Some("The number of oversize well-formed frames received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_OVERSIZE_CNT", Register { addr: Address { base: 14, count: 1, width: 1 }, brief: Some("Rx Oversize Counter (valid frame format)"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_PAUSE_CNT", Field { brief: Some("Number of pause control frames received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_PAUSE_CNT", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Rx Pause Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_SIZE1024TO1518_CNT", Field { brief: Some("The number of 1024 to 1518 bytes frames received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_SIZE1024TO1518_CNT", Register { addr: Address { base: 21, count: 1, width: 1 }, brief: Some("Rx 1024-1518 Byte Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_SIZE128TO255_CNT", Field { brief: Some("The number of 128 to 255 bytes frames received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_SIZE128TO255_CNT", Register { addr: Address { base: 18, count: 1, width: 1 }, brief: Some("Rx 128-255 Byte Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_SIZE1519TOMAX_CNT", Field { brief: Some("The number of frames received longer than 1518 bytes and not longer than Maximum Length Register (Maximum Length Register + 4 if the frame is VLAN tagged)."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_SIZE1519TOMAX_CNT", Register { addr: Address { base: 22, count: 1, width: 1 }, brief: Some("Rx 1519 To Max. Length Byte Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_SIZE256TO511_CNT", Field { brief: Some("The number of 256 to 511 bytes frames received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_SIZE256TO511_CNT", Register { addr: Address { base: 19, count: 1, width: 1 }, brief: Some("Rx 256-511 Byte Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_SIZE512TO1023_CNT", Field { brief: Some("The number of 512 to 1023 bytes frames received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_SIZE512TO1023_CNT", Register { addr: Address { base: 20, count: 1, width: 1 }, brief: Some("Rx 512-1023 Byte Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_SIZE64_CNT", Field { brief: Some("The number of 64 bytes frames received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_SIZE64_CNT", Register { addr: Address { base: 16, count: 1, width: 1 }, brief: Some("Rx 64 Byte Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_SIZE65TO127_CNT", Field { brief: Some("The number of 65 to 127 bytes frames received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_SIZE65TO127_CNT", Register { addr: Address { base: 17, count: 1, width: 1 }, brief: Some("Rx 65-127 Byte Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_SYMBOL_ERR_CNT", Field { brief: Some("The number of frames received with one or more symbol errors."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_SYMBOL_ERR_CNT", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Rx Symbol Carrier Error Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_TAGGED_FRMS_CNT", Field { brief: Some("The number of frames received with C-Tag or S-Tag information"), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_TAGGED_FRMS_CNT", Register { addr: Address { base: 38, count: 1, width: 1 }, brief: Some("Counts frames that are tagged (C-Tagged or S-Tagged)."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_UC_CNT", Field { brief: Some("The number of good unicast frames received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_UC_CNT", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Rx Unicast Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_UNDERSIZE_CNT", Field { brief: Some("The number of undersize well-formed frames received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_UNDERSIZE_CNT", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("Rx Undersize Counter (valid frame format)"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_UNSUP_OPCODE_CNT", Field { brief: Some("Number of control frames with unsupported opcode received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_UNSUP_OPCODE_CNT", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Rx Control Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_UNTAGGED_FRMS_CNT", Field { brief: Some("The number of frames received without C-Tag and S-Tag information."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_UNTAGGED_FRMS_CNT", Register { addr: Address { base: 39, count: 1, width: 1 }, brief: Some("Counts frames that are Not tagged  (neither C-Tagged nor S-Tagged)."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_BACKOFF1_CNT", Field { brief: Some("Number of frames sent successfully after 1 backoff/collision."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_BACKOFF1_CNT", Register { addr: Address { base: 47, count: 1, width: 1 }, brief: Some("Tx 1 Backoff Counter"), details: Some("Counter collecting the number of frames sent successfully after 1 backoff/collision."), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_BC_CNT", Field { brief: Some("The number of broadcast frames transmitted."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_BC_CNT", Register { addr: Address { base: 29, count: 1, width: 1 }, brief: Some("Tx Broadcast Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_CSENSE_CNT", Field { brief: Some("The number of times CarrierSenseError is true at the end of a frame transmission."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_CSENSE_CNT", Register { addr: Address { base: 48, count: 1, width: 1 }, brief: Some("Tx Carrier Sense Error Counter"), details: Some("Counter collecting the number of times CarrierSenseError is true at the end of a frame transmission."), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_DEFER_CNT", Field { brief: Some("The number of frames being deferred on first transmission attempt. Note: This counter always counts when a defer event is present, even when it is an excessive defer (TX_XDEFER_CNT)."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_DEFER_CNT", Register { addr: Address { base: 45, count: 1, width: 1 }, brief: Some("Tx First Defer Counter"), details: Some("Counter collecting the number of frames being deferred on first transmission attempt."), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_LATE_COLL_CNT", Field { brief: Some("The number of late collisions detected."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_LATE_COLL_CNT", Register { addr: Address { base: 43, count: 1, width: 1 }, brief: Some("Tx Late Collision Counter"), details: Some("Counter collecting the number of late collisions."), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_MC_CNT", Field { brief: Some("The number of multicast frames transmitted."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_MC_CNT", Register { addr: Address { base: 28, count: 1, width: 1 }, brief: Some("Tx Multicast Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_MULTI_COLL_CNT", Field { brief: Some("The number of frames transmitted without errors after multiple collisions."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_MULTI_COLL_CNT", Register { addr: Address { base: 42, count: 1, width: 1 }, brief: Some("Tx Multi Collision Counter"), details: Some("Counter collecting the number of frames transmitted without errors after multiple collisions."), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_OK_BYTES_CNT", Field { brief: Some("The number of bytes transmitted successfully."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_OK_BYTES_CNT", Register { addr: Address { base: 26, count: 1, width: 1 }, brief: Some("Tx OK Byte Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_OK_BYTES_MSB_CNT", Field { brief: Some("Upper 4 bits of TX_OK_BYTES_CNT."), details: Some("Counter can be written by SW."), lo: 0, hi: 4 });
        regs.insert("TX_OK_BYTES_MSB_CNT", Register { addr: Address { base: 53, count: 1, width: 1 }, brief: Some("MSB of TX ok byte Counter"), details: Some("Register allowing to access the upper 4 bits of RX_IN_BYTE counter. Please note: When writing to TX_OK_BYTES counter TX_OK_BYTES_MSB_CNT has to be written before TX_OK_BYTES_CNT is written. When reading TX_OK_BYTES counter TX_OK_BYTES_CNT has to be read before TX_OK_BYTES_MSB_CNT is read. Accessing both counters must not be interfered by other register accesses."), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_OUT_BYTES_CNT", Field { brief: Some("The number of bytes transmitted (good, bad and framing)."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_OUT_BYTES_CNT", Register { addr: Address { base: 24, count: 1, width: 1 }, brief: Some("Tx Byte Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_OUT_BYTES_MSB_CNT", Field { brief: Some("Upper 4 bits of TX_OUT_BYTES_CNT."), details: Some("Counter can be written by SW."), lo: 0, hi: 4 });
        regs.insert("TX_OUT_BYTES_MSB_CNT", Register { addr: Address { base: 52, count: 1, width: 1 }, brief: Some("MSB of TX out byte Counter"), details: Some("Register allowing to access the upper 4 bits of RX_IN_BYTE counter. Please note: When writing to TX_OUT_BYTES counter TX_OUT_BYTES_MSB_CNT has to be written before TX_OUT_BYTES_CNT is written. When reading TX_OUT_BYTES counter TX_OUT_BYTES_CNT has to be read before TX_OUT_BYTES_MSB_CNT is read. Accessing both counters must not be interfered by other register accesses."), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_PAUSE_CNT", Field { brief: Some("The number of pause control frames transmitted."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_PAUSE_CNT", Register { addr: Address { base: 25, count: 1, width: 1 }, brief: Some("Tx Pause Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_SIZE1024TO1518_CNT", Field { brief: Some("The number of 1024 to 1518 bytes frames transmitted."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_SIZE1024TO1518_CNT", Register { addr: Address { base: 35, count: 1, width: 1 }, brief: Some("Tx 1024-1518 Byte Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_SIZE128TO255_CNT", Field { brief: Some("The number of 128 to 255 bytes frames transmitted."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_SIZE128TO255_CNT", Register { addr: Address { base: 32, count: 1, width: 1 }, brief: Some("Tx 128-255 Byte Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_SIZE1519TOMAX_CNT", Field { brief: Some("The number of frames transmitted longer than 1518 bytes and not longer than Maximum Length Register (Maximum Length Register + 4 if the frame is VLAN tagged)."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_SIZE1519TOMAX_CNT", Register { addr: Address { base: 36, count: 1, width: 1 }, brief: Some("Tx 1519 To Max. Length Byte Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_SIZE256TO511_CNT", Field { brief: Some("The number of 256 to 511 bytes frames transmitted."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_SIZE256TO511_CNT", Register { addr: Address { base: 33, count: 1, width: 1 }, brief: Some("Tx 256-511 Byte Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_SIZE512TO1023_CNT", Field { brief: Some("The number of 512 to 1023 bytes frames transmitted."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_SIZE512TO1023_CNT", Register { addr: Address { base: 34, count: 1, width: 1 }, brief: Some("Tx 512-1023 Byte Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_SIZE64_CNT", Field { brief: Some("The number of 64 bytes frames transmitted."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_SIZE64_CNT", Register { addr: Address { base: 30, count: 1, width: 1 }, brief: Some("Tx 64 Byte Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_SIZE65TO127_CNT", Field { brief: Some("The number of 65 to 127 bytes frames transmitted."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_SIZE65TO127_CNT", Register { addr: Address { base: 31, count: 1, width: 1 }, brief: Some("Tx 65-127 Byte Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_TAGGED_FRMS_CNT", Field { brief: Some("The number of frames transmitted with C-Tag or S-Tag information"), details: None, lo: 0, hi: 32 });
        regs.insert("TX_TAGGED_FRMS_CNT", Register { addr: Address { base: 40, count: 1, width: 1 }, brief: Some("Counts frames that are tagged (C-Tagged or S-Tagged)."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_UC_CNT", Field { brief: Some("The number of unicast frames transmitted."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_UC_CNT", Register { addr: Address { base: 27, count: 1, width: 1 }, brief: Some("Tx Unicast Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_UNTAGGED_FRMS_CNT", Field { brief: Some("The number of frames transmitted without C-Tag and S-Tag information."), details: None, lo: 0, hi: 32 });
        regs.insert("TX_UNTAGGED_FRMS_CNT", Register { addr: Address { base: 41, count: 1, width: 1 }, brief: Some("Counts frames that are Not tagged  (neither C-Tagged nor S-Tagged)."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_XCOLL_CNT", Field { brief: Some("The number of frames lost due to excessive collisions."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_XCOLL_CNT", Register { addr: Address { base: 44, count: 1, width: 1 }, brief: Some("Tx Excessive Collision Counter"), details: Some("Counter collecting the number of frames due to excessive collisions."), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_XDEFER_CNT", Field { brief: Some("The number of frames sent with excessive deferral."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_XDEFER_CNT", Register { addr: Address { base: 46, count: 1, width: 1 }, brief: Some("Tx Excessive Defer Counter"), details: Some("Counter collecting the number of frames sent with excessive deferral."), fields });
        groups.insert("DEV_STATISTICS", RegisterGroup { addr: Address { base: 0, count: 53, width: 64 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("LBK_AGING_DIS", Field { brief: Some("Disable aging in loopback path."), details: Some("bitmask per port."), lo: 0, hi: 32 });
        regs.insert("LBK_AGING_DIS", Register { addr: Address { base: 0, count: 2, width: 1 }, brief: Some("Disable aging"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("VD_FC_WM", Field { brief: Some("Flowcontrol to QS is set when the FIFO fill level reaches this watermark."), details: None, lo: 0, hi: 5 });
        regs.insert("VD_FC_WM", Register { addr: Address { base: 0, count: 2, width: 1 }, brief: Some("Loopback watermark configration for flowcontrol on virtual devices"), details: None, fields });
        groups.insert("LBK_MISC_CFG", RegisterGroup { addr: Address { base: 3685, count: 1, width: 5 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("FIFO_FLUSH", Field { brief: Some("Flush all data in the FIFO"), details: None, lo: 0, hi: 1 });
        regs.insert("LBK_FIFO_CFG", Register { addr: Address { base: 2, count: 3, width: 1 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LBK_OVFLW_STICKY", Field { brief: Some("Frames are dropped due to FIFO overflow."), details: Some("bitmask per port."), lo: 0, hi: 32 });
        regs.insert("LBK_OVFLW_STICKY", Register { addr: Address { base: 0, count: 2, width: 1 }, brief: Some("Stickybits"), details: None, fields });
        groups.insert("LBK_STAT", RegisterGroup { addr: Address { base: 3690, count: 1, width: 4 }, desc: "Loopback Block Status registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("PFC_TIMER_VAL", Field { brief: Some("The current timer value per priority. Value >0 indicates that the priority is paused."), details: Some("Unit is 1024 bit times."), lo: 0, hi: 16 });
        regs.insert("PFC_TIMER", Register { addr: Address { base: 1, count: 8, width: 1 }, brief: Some("Current timer per priority"), details: None, fields });
        groups.insert("LBK_WM_CFG", RegisterGroup { addr: Address { base: 3683, count: 1, width: 2 }, desc: "Loopback Watermark Configuration", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("FC_LINK_SPEED", Field { brief: Some("Configures the link speed. This is used to evaluate the time specifications in incoming pause frames."), details: Some("0: 12000 Mbps 1: 10000 Mbps 2: 2500 Mbps 3: 1000 Mbps 4: 100 Mbps 5: 10 Mbps"), lo: 0, hi: 3 });
        fields.insert("RX_PFC_ENA", Field { brief: Some("Enable PFC per priority. Bit n enables PFC on priority n."), details: None, lo: 3, hi: 11 });
        regs.insert("PFC_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Priority-based flow control configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FRM_AGING_STICKY", Field { brief: Some("This field indicates if one or more Ethernet frames have been discarded due to aging."), details: Some("'0': No Ethernet frames have been discarded due to aging. '1': One or more Ethernet frames have been discarded due to aging. Bit is cleared by writing a '1' to this position."), lo: 0, hi: 1 });
        fields.insert("IFH_PREFIX_ERR_STICKY", Field { brief: Some("This field is set if the PORT_CFG.INJ_FORMAT_CFG field is set to one of the IFH modes and the incoming frame's format does not comply with the configured prefix."), details: None, lo: 1, hi: 2 });
        regs.insert("PORT_STICKY", Register { addr: Address { base: 0, count: 55, width: 1 }, brief: Some("ASM port sticky bits"), details: Some("This register holds all the sticky bits that exists for each port."), fields });
        groups.insert("PFC", RegisterGroup { addr: Address { base: 4096, count: 55, width: 16 }, desc: "Priority-based flow control configuration", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("PAUSE_FRM_PRE_CNT_OFLW_STICKY", Field { brief: Some("Will be set if one of the statistics pause frame pre counters has an overflow."), details: Some("'0': An overflow in\tpre-counter has not occured '1': An overflow in\tpre-counter has occured Bit is cleared by writing a '1' to this position."), lo: 0, hi: 1 });
        fields.insert("UNSUP_OPCODE_PRE_CNT_OFLW_STICKY", Field { brief: Some("Will be set if one of the statistics pre counters for unsupported control frames has an overflow."), details: Some("'0': An overflow in\tpre-counter has not occured '1': An overflow in\tpre-counter has occured Bit is cleared by writing a '1' to this position."), lo: 1, hi: 2 });
        regs.insert("PRE_CNT_OFLW_STICKY", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("Register containing sticky bits for pre counter overflow"), details: Some("Register containing sticky bits for pre counter overflow"), fields });
        groups.insert("PORT_STATUS", RegisterGroup { addr: Address { base: 3628, count: 1, width: 55 }, desc: "Status for ASM ingress ports", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("LBK_AGING_STICKY", Field { brief: Some("Frames are dropped due to aging in loopback FIFO."), details: Some("bitmask per port."), lo: 0, hi: 32 });
        regs.insert("LBK_AGING_STICKY", Register { addr: Address { base: 2, count: 2, width: 1 }, brief: None, details: None, fields });
        groups.insert("RAM_CTRL", RegisterGroup { addr: Address { base: 3694, count: 1, width: 1 }, desc: "Access core memory", regs });
        out.insert("ASM", Target { desc: "Assembler", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("TAXI_HOST_LB_ENA", Field { brief: Some("An internal loopback from the egress Taxi bus to the ingress Taxi bus can be enabled."), details: Some("'0': Loopback from Taxi egress to Taxi ingress is disabled '1': Loopback from Taxi egress to Taxi ingress is enabled"), lo: 0, hi: 1 });
        fields.insert("TAXI_PHY_LB_ENA", Field { brief: Some("An internal loopback from the igress Taxi bus to the egress Taxi bus can be enabled."), details: Some("'0': Loopback from Taxi ingress bus to Taxi egress bus disabled '1': Loopback from Taxi ingress bus to Taxi egress bus enabled"), lo: 4, hi: 5 });
        regs.insert("DEV_LB_CFG", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Loopback Configuration Register"), details: Some("A number of internal loopback can be enabled in each device by the configuration bits in this register."), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_RESYNC_MAX_FILL_LVL_CLR", Field { brief: Some("Clears RX_RESYNC_MAX_FILL_LVL that holds the max. fill level of RX RESYNC FIFO. This is a on shot bit automatically cleared by HW."), details: Some("'0': No action '1': clears RX_RESYNC_MAX_FILL_LVL (Bit is automatically cleared)"), lo: 13, hi: 14 });
        fields.insert("TX_FCS_UPDATE_SEL", Field { brief: Some("The device can be configured to disregard the fcs_update indication from the DSM and not update the FCS of any transmitted frames."), details: Some("0: The FCS of transmitted frames is updated according to the fcs_update indication from the DSM. 1: The FCS of transmitted frames is never updated. 2: The FCS of transmitted frames is always updated."), lo: 16, hi: 18 });
        regs.insert("DEV_MISC_CFG", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Debug Configuration Register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_PROTECT_ENA", Field { brief: Some("Enables snooping of egress data from another port. The port from which egress data is copied and transmitted at the Ethernet port is determined by the PORT_PROTECT_ID configuration."), details: Some("'0': Port protection is disabled. '1': Port protection is enabled."), lo: 0, hi: 1 });
        fields.insert("PORT_PROTECT_ID", Field { brief: Some("Indicates from which port egress data must be copied and transmitted at this Ethernet port. The port from which egress data is copied must always be a port that is closer to the ASM. I.e. DEV(X) may be configured to snoop egress data destined for DEV(X+n), where DEV(X+n) is closer to the ASM - but NOT vice versa."), details: Some("0: Reserved 1: Egress data destined for DEV(1) is also transmitted by this device. 2: Egress data destined for DEV(2) is also transmitted by this device. .."), lo: 4, hi: 6 });
        regs.insert("DEV_PORT_PROTECT", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Port Proetection Configuration Register"), details: Some("When port protedction is enabled the device will snoop and transmit data destined for another device 10G identified by port_protect_id."), fields });
        let mut fields = HashMap::new();
        fields.insert("MAC_RX_RST", Field { brief: Some("Reset MAC Rx clock domains of the device."), details: Some("'0': The MAC Rx clock domain is NOT reset '1': The MAC Rx clock domain is reset Note: MAC_RX_RST is NOT a one-shot operation. The MAC Rx clock domain remains reset until a '0' is written to MAC_RX_RST."), lo: 0, hi: 1 });
        fields.insert("MAC_TX_RST", Field { brief: Some("Reset MAC Tx clock domain of device."), details: Some("'0': The MAC Tx clock domain is not reset. '1': The MAC Tx clock domain is reset. Note: The MAC Tx clock domain remains reset until 0 is written to this register field."), lo: 4, hi: 5 });
        fields.insert("PARDET_MODE_ENA", Field { brief: Some("Backplane Ethernet: Enable parallel detection mode for autonegotiation"), details: Some("'0':  Parallel detection mode disabled '1': Parallel detection mode enabled"), lo: 23, hi: 24 });
        fields.insert("PCS_RX_RST", Field { brief: Some("Reset PCS Rx clock domains of the device."), details: Some("'0': The PCS Rx clock domain is NOT reset '1': The PCS Rx clock domain is reset Note: PCS_RX_RST is NOT a one-shot operation. The PCS Rx clock domain remains reset until a '0' is written to PCS_RX_RST."), lo: 8, hi: 9 });
        fields.insert("PCS_TX_RST", Field { brief: Some("Reset PCS Tx clock domains of the device."), details: Some("'0': The PCS Tx clock domain is NOT reset '1': The PCS Tx clock domain is reset Note: PCS_TX_RST is NOT a one-shot operation. The PCS Tx clock domain remains reset until a '0' is written to PCS_TX_RST."), lo: 12, hi: 13 });
        fields.insert("SPEED_SEL", Field { brief: Some("This field is used to configure the MAC and PCS Rx/Tx clock frequencies."), details: Some("'100':  XAUI/RXAUI 10 Gbps or 12Gbps OXAUI '110':  Both MAC and PCS Rx/Tx clocks are disabled '111':  XFI 10 Gbps Unused values are reserved."), lo: 20, hi: 23 });
        regs.insert("DEV_RST_CTRL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Clock/Reset Control Register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_RESYNC_MAX_FILL_LVL", Field { brief: Some("Maximum fill level of Rx resync FIFO. Fill level can be cleared by writing to RX_RESYNC_MAX_FILL_LVL_CLR bit."), details: None, lo: 0, hi: 4 });
        regs.insert("DEV_RX_STATUS", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("Ingress (receive) Path Status Register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_EOF_STICKY", Field { brief: Some("Indicates that a missing EOF has been detected. Writing a '1' clears the sticky bit."), details: Some("'0': No EOF error detected '1': Missing EOF indication detected in Rx path of DEV10G."), lo: 8, hi: 9 });
        fields.insert("RX_RESYNC_FIFO_OFLW_STICKY", Field { brief: Some("Indicates if an overflow has occured in the ingress resynchronization FIFO. Writing a '1' clears the sticky bit."), details: Some("'0': No overflow has occurred in the ingress resynchronization FIFO. '1': An overflow has occurred in the ingress resynchronization FIFO."), lo: 12, hi: 13 });
        fields.insert("RX_SOF_STICKY", Field { brief: Some("Indicates that a missing SOF has been detected in the Rx path of the DEV10G. Writing a '1' clears the sticky bit."), details: Some("'0': No missing SOF detected '1': Missing SOF indication detected in Rx path of DEV10G."), lo: 10, hi: 11 });
        fields.insert("TX_EOF_STICKY", Field { brief: Some("Indicates that a missing EOF has been detected. Writing a '1' clears the sticky bit."), details: Some("'0': No EOF error detected '1': Missing EOF indication detected in Tx path of DEV10G."), lo: 3, hi: 4 });
        fields.insert("TX_SOF_STICKY", Field { brief: Some("Indicates that a missing SOF has been detected in the Tx path of the DEV10G. Writing a '1' clears the sticky bit."), details: Some("'0': No missing SOF detected '1': Missing SOF indication detected in Tx path of DEV10G."), lo: 2, hi: 3 });
        regs.insert("DEV_STICKY", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Miscellaneous Sticky Bit Register"), details: Some("Clear the sticky bits by writing a '1' in the relevant bitgroups."), fields });
        let mut fields = HashMap::new();
        fields.insert("EEE_ENA", Field { brief: Some("Enable EEE operation on the port. A port enters the low power mode when no egress queues have data ready. The port is activated when one of the following conditions is true: - A queue has been non-empty for EEE_TIMER_AGE. - A queue has more than EEE_HIGH_FRAMES frames pending. - A queue has more than EEE_HIGH_BYTES bytes pending. - A queue is marked as a fast queue, and has data pending."), details: None, lo: 22, hi: 23 });
        fields.insert("EEE_TIMER_AGE", Field { brief: Some("Maximum time frames in any queue must wait before the port is activated. The default value corresponds to 48 us."), details: Some("Time = 4**(EEE_TIMER_AGE/16) * (EEE_TIMER_AGE mod 16) microseconds"), lo: 15, hi: 22 });
        fields.insert("EEE_TIMER_HOLDOFF", Field { brief: Some("When all queues are empty, the port is kept active until this time has passed. Default value corresponds to 5 us."), details: Some("Time = 4**(EEE_TIMER_HOLDOFF/16) * (EEE_TIMER_HOLDOFF mod 16) microseconds"), lo: 1, hi: 8 });
        fields.insert("EEE_TIMER_WAKEUP", Field { brief: Some("Time from the egress port is activated until frame transmission is restarted. Default value corresponds to 16 us."), details: Some("Time = 4**(EEE_TIMER_WAKEUP/16) * (EEE_TIMER_WAKEUP mod 16) microseconds"), lo: 8, hi: 15 });
        fields.insert("PORT_LPI", Field { brief: Some("Status bit indicating whether port is in low-power-idle due to the LPI algorithm (EEE_CFG). If set, transmissions are held back."), details: None, lo: 0, hi: 1 });
        regs.insert("EEE_CFG", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("Control Energy Efficient Ethernet operation."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LINK_DWN_INTR", Field { brief: Some("Link status is down (source: PCS1G, PCS10G or PCS2x6G depending on current DEV10G mode)"), details: Some("0 = no indication 1 = active indication"), lo: 0, hi: 1 });
        fields.insert("LINK_UP_INTR", Field { brief: Some("Link status is up (source: PCS1G, PCS10G or PCS2x6G depending on current DEV10G mode)"), details: Some("0 = no indication 1 = active indication"), lo: 1, hi: 2 });
        fields.insert("PCS_BR_INTR", Field { brief: Some("Aggregate of BaseR PCS indications, see PCS_10GBASE_R::PCS_INTR_STAT and PSC_10GBASE_R::PCS_INTR_MASK for more information. This field is set when any BaseR PCS interrupt indication is active and enabled."), details: None, lo: 4, hi: 5 });
        fields.insert("RX_LPI_INTR", Field { brief: Some("PCS10G, PCS1G: RX Low Power Idle mode has changed"), details: Some("0 = no indication 1 = active indication"), lo: 2, hi: 3 });
        fields.insert("TX_LPI_INTR", Field { brief: Some("PCS10G, PCS1G: TX Low Power Idle mode has changed"), details: Some("0 = no indication 1 = active indication"), lo: 3, hi: 4 });
        regs.insert("INTR", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Interrupt Source Register"), details: Some("Interrupt Source Register"), fields });
        let mut fields = HashMap::new();
        fields.insert("LINK_DWN_INTR_ENA", Field { brief: Some("Set to enable propagation of LINK_DWN interrupt."), details: None, lo: 0, hi: 1 });
        fields.insert("LINK_UP_INTR_ENA", Field { brief: Some("Set to enable propagation of LINK_UP interrupt."), details: None, lo: 1, hi: 2 });
        fields.insert("PCS_BR_INTR_ENA", Field { brief: Some("Set to enable propagation of PCS_BR interrupt."), details: None, lo: 4, hi: 5 });
        fields.insert("RX_LPI_INTR_ENA", Field { brief: Some("Set to enable propagation of RX_LPI interrupt."), details: None, lo: 2, hi: 3 });
        fields.insert("TX_LPI_INTR_ENA", Field { brief: Some("Set to enable propagation of TX_LPI interrupt."), details: None, lo: 3, hi: 4 });
        regs.insert("INTR_ENA", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Interrupt Enable Register"), details: Some("Interrupt Enable Register"), fields });
        let mut fields = HashMap::new();
        fields.insert("LINK_DWN_INTR_IDENT", Field { brief: Some("Set if LINK_DWN interrupt is currently active (indicating interrupt towards higher level interrupt controller.)"), details: None, lo: 0, hi: 1 });
        fields.insert("LINK_UP_INTR_IDENT", Field { brief: Some("Set if LINK_UP interrupt is currently active (indicating interrupt towards higher level interrupt controller.)"), details: None, lo: 1, hi: 2 });
        fields.insert("PCS_BR_INTR_IDENT", Field { brief: Some("Set if PCS_BR interrupt is currently active (indicating interrupt towards higher level interrupt controller.)"), details: None, lo: 4, hi: 5 });
        fields.insert("RX_LPI_INTR_IDENT", Field { brief: Some("Set if RX_LPI interrupt is currently active (indicating interrupt towards higher level interrupt controller.)"), details: None, lo: 2, hi: 3 });
        fields.insert("TX_LPI_INTR_IDENT", Field { brief: Some("Set if TX_LPI interrupt is currently active (indicating interrupt towards higher level interrupt controller.)"), details: None, lo: 3, hi: 4 });
        regs.insert("INTR_IDENT", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Interrupt Status Register"), details: Some("Interrupt Status Register"), fields });
        let mut fields = HashMap::new();
        fields.insert("FLIP_HMBUS", Field { brief: Some("Flip HM-Bus, i.e. map lane 0 on 1 and lane 1 on 0"), details: Some("0: Normal operation 1: Flipped lane assignment"), lo: 0, hi: 1 });
        fields.insert("INVERT_HMBUS", Field { brief: Some("Invert HM-Bus, invert all data signals from/to SERDES"), details: Some("0: Normal operation 1: Inverted HM-bus"), lo: 1, hi: 2 });
        regs.insert("PCS2X6G_EXT_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("PCS2x6G Extended Configuration"), details: Some("Special configuration bit groups for PCS2x6G."), fields });
        let mut fields = HashMap::new();
        fields.insert("PFC_PAUSE_MODE_SELECT", Field { brief: Some("'0' : counters will be having number of pause frame received/transmitted '1' : counters will be having number of PFC frame received/transmitted"), details: None, lo: 0, hi: 1 });
        regs.insert("PFC_PAUSE_MODE_CTRL", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("selects mode for which status counter will count the coresponding frames on RX and TX"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PTP_DOM", Field { brief: Some("Configures the time domain this port is assigned to. This domain assignment must be made before the central counters in DEVCPU block is enabled."), details: None, lo: 18, hi: 20 });
        fields.insert("PTP_ENA", Field { brief: Some("Enable PTP on the port"), details: None, lo: 20, hi: 21 });
        fields.insert("PTP_RX_IO_DLY", Field { brief: Some("Time in ns to subtract from timestamper in the ingress direction to compensate for static delay through the physical encoding layers."), details: None, lo: 9, hi: 18 });
        fields.insert("PTP_TX_IO_DLY", Field { brief: Some("Time in ns to add to timestamper in the egress direction to compensate for static delay through the physical encoding layers."), details: None, lo: 0, hi: 9 });
        regs.insert("PTP_CFG", Register { addr: Address { base: 11, count: 1, width: 1 }, brief: Some("PTP Configuration per port"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PTP_RX_BT_DLY", Field { brief: Some("Time in 100ps to subtract from timestamper in the ingress direction to compensate for static delay through the physical encoding layers."), details: None, lo: 16, hi: 20 });
        fields.insert("PTP_RX_GEARBOX_OFS", Field { brief: Some("Gearbox starting value when 6466b fifo is suspened in the ingress direction."), details: None, lo: 6, hi: 12 });
        fields.insert("PTP_TX_BT_DLY", Field { brief: Some("Time in 100ps to subtract from timestamper in the egress direction to compensate for static delay through the physical encoding layers."), details: None, lo: 12, hi: 16 });
        fields.insert("PTP_TX_GEARBOX_OFS", Field { brief: Some("Gearbox starting value when 6466b fifo is suspended in the egress direction."), details: None, lo: 0, hi: 6 });
        regs.insert("PTP_CFG_BTDLY", Register { addr: Address { base: 12, count: 1, width: 1 }, brief: Some("PTP Bit time accuracy configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CF_TOO_BIG_STICKY", Field { brief: Some("The correction field update went out of range. Valid range is -2^47 to 2^48-1. The frame CF will be changed to the maximum value. This range check is bypassed if ADDS48 mode is in use on the ingress or egress port."), details: None, lo: 0, hi: 1 });
        regs.insert("PTP_EVENTS", Register { addr: Address { base: 13, count: 1, width: 1 }, brief: Some("PTP Events per port"), details: None, fields });
        groups.insert("DEV_CFG_STATUS", RegisterGroup { addr: Address { base: 88, count: 1, width: 14 }, desc: "Device 10G Configuration and Status Registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("RX_IPG_SHRINK_STICKY", Field { brief: Some("Indicates that an inter packet gap shrink was detected (IPG < 12 bytes)."), details: Some("'0': no ipg shrink was detected '1': one or more ipg shrink were detected Bit is cleared by writing a '1' to this position."), lo: 9, hi: 10 });
        fields.insert("RX_MPLS_MC_STICKY", Field { brief: Some("Indicates that a frame with MPLS multicast was received."), details: Some("'0': No frames with MPLS multicast EtherType has been detected; '1': One or more frames with MPLS multicast EtherType have been detected; Bit is cleared by writing a '1' to this position."), lo: 4, hi: 5 });
        fields.insert("RX_MPLS_UC_STICKY", Field { brief: Some("Indicates that a frame with MPLS unicast was received."), details: Some("'0': No frames with MPLS Unicast EtherType has been detected; '1': One or more frames with MPLS Unicast EtherType have been detected; Bit is cleared by writing a '1' to this position."), lo: 3, hi: 4 });
        fields.insert("RX_NON_STD_PREAM_STICKY", Field { brief: Some("Indicates that a frame was received with a non-standard preamble."), details: Some("'0': No non-standard preamble detected; '1': One or more frames with non-standard preamble detected; Bit is cleared by writing a '1' to this position."), lo: 5, hi: 6 });
        fields.insert("RX_PREAM_ERR_STICKY", Field { brief: Some("If a SOP is received and a following control character is received within the preamble, this bit is set. (No data is passed to the host interface of the MAC)."), details: Some("'0': No Preamble error detected; '1': One or more preamble errors detected; Bit is cleared by writing a '1' to this position."), lo: 6, hi: 7 });
        fields.insert("RX_PREAM_MISMATCH_STICKY", Field { brief: Some("If Preamble Check is enabled and a SOP is received, this bit is set if the following bytes do not match a \"5555555555..55D5\" pattern. A 12 bytes preamble of \"55555555.55555555.555555D5\" will not cause this sticky bit to be set. This sticky bit can only be set when the port is setup in 10 Gbps mode."), details: Some("'0': No Preamble check has failed; '1': One or more preamble checks have failed; Bit is cleared by writing a '1' to this position."), lo: 7, hi: 8 });
        fields.insert("RX_PREAM_SHRINK_STICKY", Field { brief: Some("Indicates that a preamble shrink was detected (preamble < 8 bytes). This sticky bit can only be set when the port is setup in 10 Gbps mode, where frames with e.g. a 4 bytes preamble will be discarded, and it requires that PRM_SHK_CHK_DIS = 0 and SFD_CHK_ENA = 1. In SGMII mode, all preamble sizes down to 3 bytes (including SFD) are accepted and will not cause this sticky bit to be set."), details: Some("'0': no preamble shrink detected; '1': one or more preamble shrinks detected; Bit is cleared by writing a '1' to this position."), lo: 8, hi: 9 });
        fields.insert("RX_TAG_STICKY", Field { brief: Some("Indicates that a frame was received with a VLAN tag."), details: Some("'0': No Tagged frames have been detected; '1': One or more Tagged frames have been detected; Bit is cleared by writing a '1' to this position."), lo: 2, hi: 3 });
        fields.insert("TX_ABORT_STICKY", Field { brief: Some("Indicates that the transmit host initiated abort was executed."), details: Some("'0': no tx frame was aborted '1': one or more tx frames were aborted Bit is cleared by writing a '1' to this position."), lo: 0, hi: 1 });
        fields.insert("TX_UFLW_STICKY", Field { brief: Some("Sticky bit indicating that the MAC Transmit FIFO has dropped one or more frames because of underrun."), details: Some("'0': No MAC Tx FIFO underrun has occured '1': One or more MAC Tx FIFO underruns have occured Bit is cleared by writing a '1' to this position."), lo: 1, hi: 2 });
        regs.insert("MAC_STICKY", Register { addr: Address { base: 13, count: 1, width: 1 }, brief: Some("Sticky Bit Register"), details: Some("Clear the sticky bits by writing a '0' in the relevant bitgroups (writing a '1' sets the bit)!."), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_ALIGNMENT_LOST_CNT", Field { brief: Some("The number of frames received with Alignment (dribble-nibble) error."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_ALIGNMENT_LOST_CNT", Register { addr: Address { base: 32, count: 1, width: 1 }, brief: Some("Counter to track the dribble-nibble (extra nibble) errors in frames."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_BC_CNT", Field { brief: Some("The number of good broadcast frames received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_BC_CNT", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Rx Broadcast Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_CRC_ERR_CNT", Field { brief: Some("The number of frames received with CRC error only."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_CRC_ERR_CNT", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Rx CRC Error Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_FRAGMENTS_CNT", Field { brief: Some("The number of undersize frames with CRC error received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_FRAGMENTS_CNT", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("Rx Undersize Counter (CRC error)"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_HIH_CKSM_ERR_CNT", Field { brief: Some("Number of frames discarded due to errors in HIH checksum."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_HIH_CKSM_ERR_CNT", Register { addr: Address { base: 37, count: 1, width: 1 }, brief: Some("Rx HiH Checksum Error Counter"), details: Some("If HIH CRC checking is enabled, this counter will count the number of frames discarded due to HIH CRC errors."), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_IN_RANGE_LEN_ERR_CNT", Field { brief: Some("The number of frames with legal length field that doesn't match length of MAC client data."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_IN_RANGE_LEN_ERR_CNT", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("Rx In-range Length Error Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_IPG_SHRINK_CNT", Field { brief: Some("Number of inter packet gap shrinks detected (IPG < 12 bytes)."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_IPG_SHRINK_CNT", Register { addr: Address { base: 20, count: 1, width: 1 }, brief: Some("Rx Inter Packet Gap Shrink Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_JABBERS_CNT", Field { brief: Some("The number of oversize frames with CRC error received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_JABBERS_CNT", Register { addr: Address { base: 12, count: 1, width: 1 }, brief: Some("Rx Jabbers Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_MC_CNT", Field { brief: Some("The number of good multicast frames received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_MC_CNT", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Rx Multicast Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_OUT_OF_RANGE_LEN_ERR_CNT", Field { brief: Some("The number of frames with illegal length field (frames using type field are not counted here)."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_OUT_OF_RANGE_LEN_ERR_CNT", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("Rx Out-Of-Range Length Error Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_OVERSIZE_CNT", Field { brief: Some("The number of oversize well-formed frames received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_OVERSIZE_CNT", Register { addr: Address { base: 11, count: 1, width: 1 }, brief: Some("Rx Oversize Counter (valid frame format)"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_PAUSE_CNT", Field { brief: Some("Number of pause control frames received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_PAUSE_CNT", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Rx Pause Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_SIZE1024TO1518_CNT", Field { brief: Some("The number of 1024 to 1518 bytes frames received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_SIZE1024TO1518_CNT", Register { addr: Address { base: 18, count: 1, width: 1 }, brief: Some("Rx 1024-1518 Byte Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_SIZE128TO255_CNT", Field { brief: Some("The number of 128 to 255 bytes frames received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_SIZE128TO255_CNT", Register { addr: Address { base: 15, count: 1, width: 1 }, brief: Some("Rx 128-255 Byte Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_SIZE1519TOMAX_CNT", Field { brief: Some("The number of frames received longer than 1518 bytes and not longer than Maximum Length Register (Maximum Length Register + 4 if the frame is VLAN tagged)."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_SIZE1519TOMAX_CNT", Register { addr: Address { base: 19, count: 1, width: 1 }, brief: Some("Rx 1519 To Max. Length Byte Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_SIZE256TO511_CNT", Field { brief: Some("The number of 256 to 511 bytes frames received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_SIZE256TO511_CNT", Register { addr: Address { base: 16, count: 1, width: 1 }, brief: Some("Rx 256-511 Byte Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_SIZE512TO1023_CNT", Field { brief: Some("The number of 512 to 1023 bytes frames received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_SIZE512TO1023_CNT", Register { addr: Address { base: 17, count: 1, width: 1 }, brief: Some("Rx 512-1023 Byte Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_SIZE64_CNT", Field { brief: Some("The number of 64 bytes frames received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_SIZE64_CNT", Register { addr: Address { base: 13, count: 1, width: 1 }, brief: Some("Rx 64 Byte Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_SIZE65TO127_CNT", Field { brief: Some("The number of 65 to 127 bytes frames received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_SIZE65TO127_CNT", Register { addr: Address { base: 14, count: 1, width: 1 }, brief: Some("Rx 65-127 Byte Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_SYMBOL_ERR_CNT", Field { brief: Some("The number of frames received with one or more symbol errors."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_SYMBOL_ERR_CNT", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Rx Symbol Carrier Error Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_TAGGED_FRMS_CNT", Field { brief: Some("The number of frames received with C-Tag or S-Tag information"), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_TAGGED_FRMS_CNT", Register { addr: Address { base: 33, count: 1, width: 1 }, brief: Some("Counts frames that are tagged (C-Tagged or S-Tagged)."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_UC_CNT", Field { brief: Some("The number of good unicast frames received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_UC_CNT", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Rx Unicast Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_UNDERSIZE_CNT", Field { brief: Some("The number of undersize well-formed frames received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_UNDERSIZE_CNT", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Rx Undersize Counter (valid frame format)"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_UNSUP_OPCODE_CNT", Field { brief: Some("Number of control frames with unsupported opcode received."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_UNSUP_OPCODE_CNT", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Rx Control Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_UNTAGGED_FRMS_CNT", Field { brief: Some("The number of frames received without C-Tag and S-Tag information."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_UNTAGGED_FRMS_CNT", Register { addr: Address { base: 34, count: 1, width: 1 }, brief: Some("Counts frames that are Not tagged  (neither C-Tagged nor S-Tagged)."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_BC_CNT", Field { brief: Some("The number of broadcast frames transmitted."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_BC_CNT", Register { addr: Address { base: 24, count: 1, width: 1 }, brief: Some("Tx Broadcast Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_MC_CNT", Field { brief: Some("The number of multicast frames transmitted."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_MC_CNT", Register { addr: Address { base: 23, count: 1, width: 1 }, brief: Some("Tx Multicast Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_PAUSE_CNT", Field { brief: Some("The number of pause control frames transmitted."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_PAUSE_CNT", Register { addr: Address { base: 21, count: 1, width: 1 }, brief: Some("Tx Pause Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_SIZE1024TO1518_CNT", Field { brief: Some("The number of 1024 to 1518 bytes frames transmitted."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_SIZE1024TO1518_CNT", Register { addr: Address { base: 30, count: 1, width: 1 }, brief: Some("Tx 1024-1518 Byte Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_SIZE128TO255_CNT", Field { brief: Some("The number of 128 to 255 bytes frames transmitted."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_SIZE128TO255_CNT", Register { addr: Address { base: 27, count: 1, width: 1 }, brief: Some("Tx 128-255 Byte Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_SIZE1519TOMAX_CNT", Field { brief: Some("The number of frames transmitted longer than 1518 bytes and not longer than Maximum Length Register (Maximum Length Register + 4 if the frame is VLAN tagged)."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_SIZE1519TOMAX_CNT", Register { addr: Address { base: 31, count: 1, width: 1 }, brief: Some("Tx 1519 To Max. Length Byte Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_SIZE256TO511_CNT", Field { brief: Some("The number of 256 to 511 bytes frames transmitted."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_SIZE256TO511_CNT", Register { addr: Address { base: 28, count: 1, width: 1 }, brief: Some("Tx 256-511 Byte Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_SIZE512TO1023_CNT", Field { brief: Some("The number of 512 to 1023 bytes frames transmitted."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_SIZE512TO1023_CNT", Register { addr: Address { base: 29, count: 1, width: 1 }, brief: Some("Tx 512-1023 Byte Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_SIZE64_CNT", Field { brief: Some("The number of 64 bytes frames transmitted."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_SIZE64_CNT", Register { addr: Address { base: 25, count: 1, width: 1 }, brief: Some("Tx 64 Byte Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_SIZE65TO127_CNT", Field { brief: Some("The number of 65 to 127 bytes frames transmitted."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_SIZE65TO127_CNT", Register { addr: Address { base: 26, count: 1, width: 1 }, brief: Some("Tx 65-127 Byte Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_TAGGED_FRMS_CNT", Field { brief: Some("The number of frames transmitted with C-Tag or S-Tag information"), details: None, lo: 0, hi: 32 });
        regs.insert("TX_TAGGED_FRMS_CNT", Register { addr: Address { base: 35, count: 1, width: 1 }, brief: Some("Counts frames that are tagged (C-Tagged or S-Tagged)."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_UC_CNT", Field { brief: Some("The number of unicast frames transmitted."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_UC_CNT", Register { addr: Address { base: 22, count: 1, width: 1 }, brief: Some("Tx Unicast Frame Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_UNTAGGED_FRMS_CNT", Field { brief: Some("The number of frames transmitted without C-Tag and S-Tag information."), details: None, lo: 0, hi: 32 });
        regs.insert("TX_UNTAGGED_FRMS_CNT", Register { addr: Address { base: 36, count: 1, width: 1 }, brief: Some("Counts frames that are Not tagged  (neither C-Tagged nor S-Tagged)."), details: None, fields });
        groups.insert("DEV_STATISTICS_32BIT", RegisterGroup { addr: Address { base: 14, count: 1, width: 39 }, desc: "Device Statistics Registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("RX_BAD_BYTES_CNT", Field { brief: Some("The number of received bytes in bad frames."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_BAD_BYTES_CNT", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Rx Bad Byte Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_BAD_BYTES_MSB_CNT", Field { brief: Some("The number of received bytes in bad frames - MSBs only."), details: Some("Counter can be written by SW."), lo: 0, hi: 8 });
        regs.insert("RX_BAD_BYTES_MSB_CNT", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Rx Bad Bytes Counter - MSB part"), details: Some("The number of received bytes in bad frames -  MSBs only."), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_IN_BYTES_CNT", Field { brief: Some("The number of bytes received (good, bad, and framing)."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_IN_BYTES_CNT", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Rx Byte Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_IN_BYTES_MSB_CNT", Field { brief: Some("The number of bytes received (good, bad, and framing) - MSBs only"), details: Some("Counter can be written by SW."), lo: 0, hi: 8 });
        regs.insert("RX_IN_BYTES_MSB_CNT", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Rx In Bytes Counter - MSB part"), details: Some("The number of bytes received (good, bad. Framing). MSB s only)"), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_OK_BYTES_CNT", Field { brief: Some("The number of received bytes in good frames."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_OK_BYTES_CNT", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Rx OK Byte Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_OK_BYTES_MSB_CNT", Field { brief: Some("The numberof received bytes in good frames - MSBs only."), details: Some("Counter can be written by SW."), lo: 0, hi: 8 });
        regs.insert("RX_OK_BYTES_MSB_CNT", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Rx Ok Bytes Counter - MSB part"), details: Some("The number of received bytes in good frames - MSBs only"), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_XGMII_PROT_ERR_CNT", Field { brief: Some("Number of XGMII protocol errors detected."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("RX_XGMII_PROT_ERR_CNT", Register { addr: Address { base: 38, count: 1, width: 1 }, brief: Some("Rx XGMII Protocol Error Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_OK_BYTES_CNT", Field { brief: Some("The number of bytes transmitted successfully."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_OK_BYTES_CNT", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("Tx OK Byte Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_OUT_BYTES_CNT", Field { brief: Some("The number of bytes transmitted (good, bad and framing)."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("TX_OUT_BYTES_CNT", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Tx Byte Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_OUT_BYTES_MSB_CNT", Field { brief: Some("The number of bytes transmitted (good, bad, framing) - MSBs only."), details: Some("Counter can be written by SW."), lo: 0, hi: 8 });
        regs.insert("TX_OUT_BYTES_MSB_CNT", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Tx Out Bytes Counter - MSB part"), details: Some("The number of bytes transmitted (good, bad, and framing) - MSBs only"), fields });
        groups.insert("DEV_STATISTICS_40BIT", RegisterGroup { addr: Address { base: 53, count: 1, width: 10 }, desc: "Device Statistics Registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("EXT_EOP_CHK_ENA", Field { brief: Some("Extended End Of Packet Check: Specifies the requirement for the Rx column when holding an EOP character."), details: Some("'0': The values of the remaining Rx lanes of a column holding an EOP are ignored. E.g. if lane 1 holds an EOP, the value of lanes 2 and 3 are ignored '1': A received frame is error-marked if an Error character is received in any lane of the column holding the EOP character. E.g. if lane 1 holds an EOP, the frame is error-marked if lanes 0, 2, or 3 holds an Error character."), lo: 24, hi: 25 });
        fields.insert("EXT_SOP_CHK_ENA", Field { brief: Some("Extended Start Of Packet Check Enable: Specifies the requirement for the Rx column prior to SOP character."), details: Some("'0': Value of Rx column at the XGMII interface prior to a SOP character is ignored '1': An IDLE column at the XGMII interface must be received prior to a SOP character for the MAC to detect a start of frame."), lo: 20, hi: 21 });
        fields.insert("INR_ERR_ENA", Field { brief: Some("In-Range Error Check Enable: Determines whether or not a received frame should be discarded if the frame length does not match the frame PDU size:"), details: Some("'0': Frames which have a frame length field inconsistent with the actual frame length are not error-marked '1': Frames with inconsistent frame length fields are error marked and will be discarded by the Rx Queue System."), lo: 0, hi: 1 });
        fields.insert("OOR_ERR_ENA", Field { brief: Some("Out-Of-Range Error Check Enable: Determines whether or not a received frame should be discarded if the frame length field is out of range."), details: Some("'0': Out-of-range errors are ignored '1': A frame is discarded if the frame length field value is out of range"), lo: 4, hi: 5 });
        fields.insert("PRM_CHK_ENA", Field { brief: Some("Preamble Check Enable: Specifies the preamble requirement for a successful frame reception."), details: Some("'0': Skip preamble check. A SOP control character is sufficient for a successful frame reception. The minimum allowed preamble size is still 8 bytes (incl. SOP and SFD) but the preamble bytes between the SOP and SFD can have any data value. '1': Strict preamble check enabled, i.e. the last 6 bytes of a preamble - prior to the SFD - must all be equal to 0x55 for a successful frame reception. For preambles larger than 8 bytes, only the last 6 preamble bytes prior to the SFD are checked when this bit is set to 1."), lo: 8, hi: 9 });
        fields.insert("PRM_SHK_CHK_DIS", Field { brief: Some("Preamble Shrink Check Disable: The MAC can be setup to discard a frame, if a SFD is received in lane 3 of the column containing the SOP. If stacking tags must be supported, the MAC must accept any data byte at this position."), details: Some("'0': Frames with a SFD in lane 3 of the column containing the SOP are discarded. '1': Frames with a SFD in lane 3 of the column containing the SOP are NOT discarded."), lo: 12, hi: 13 });
        fields.insert("SFD_CHK_ENA", Field { brief: Some("Start-of-Frame-Delimiter Check Enable: Specifies the requirement for a successful frame reception. When disabled (='0'), MAC10G will assume that preamble is 8 bytes (incl. SOP & SFD) when SOP is received. No checking of SFD is carried out. When enabled (='1'), MAC10G will search for SFD in lane 3/7 after reception of SOP, before accepting frame data. MAC10G will search for SFD until SFD is found or a control character is encountered."), details: Some("'0': Skip SFD check '1': Strict SFD check enabled, i.e. the SFD must be \"D5\" for a successful frame reception."), lo: 16, hi: 17 });
        regs.insert("MAC_ADV_CHK_CFG", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Advanced Check Feature Configuration Register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_ENA", Field { brief: Some("Enable Receiver."), details: Some("'0': Disabled '1': Enabled."), lo: 4, hi: 5 });
        fields.insert("TX_ENA", Field { brief: Some("Enable Transmitter."), details: Some("'0': Disabled '1': Enabled."), lo: 0, hi: 1 });
        regs.insert("MAC_ENA_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Mode Configuration Register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("XGMII_HOST_LB_ENA", Field { brief: Some("Enables loopback from egress to ingress in the device. The MAC Rx clock is automatically set equal to the MAC Tx clock when the loop back is enabled."), details: Some("'0': Host loopback disabled at XGMII interface. '1': Host loopback enabled at XGMII interface."), lo: 4, hi: 5 });
        fields.insert("XGMII_PHY_LB_ENA", Field { brief: Some("Enables loopback from ingress to egres data path at XGMII interface."), details: Some("'0': PHY Loopback Disabled at XGMII interface. '1': PHY Loopback Enabled at XGMII interface."), lo: 0, hi: 1 });
        regs.insert("MAC_LB_CFG", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("Miscellaneous Configuration Register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LFS_MODE_ENA", Field { brief: Some("Link Fault Signaling Mode Enable: If enabled, the transmitter reacts on received Link Fault indications."), details: Some("'0': Ignore Link Faults detected by the MAC receiver module '1': React on detected Link Faults and transmit the appropriate Sequence Ordered Set."), lo: 0, hi: 1 });
        fields.insert("LFS_UNIDIR_ENA", Field { brief: Some("LFS Unidirectional mode enable. Implementation of 802.3 clause 66. When asserted, this enables MAC to transmit data during reception of Local Fault and Remote Fault ordered sets from the PHY. When in Unidirectional mode: When receiving LF, frames are transmitted separated by RF ordered sets. When receiving RF, frames are transmitted separated by IDLE symbols"), details: Some("'0' : LFS unidirectional mode is disabled '1' : LFS unidirectional mode is enabled"), lo: 3, hi: 4 });
        fields.insert("SPURIOUS_Q_DIS", Field { brief: Some("During normal 802.3 compliant operation, it is possible to send spurious ||Q|| after the lfs condition was deasserted. Asserting this bit will prevent these spurious ||Q|| by delaying TX until the PCS reports that no ||Q|| are pending. Applicable for XAUI speeds only."), details: Some("0 - Allow ||Q|| transmission (ieee 802.3 compliant) 1 - Suppress ||Q|| transmission"), lo: 1, hi: 2 });
        fields.insert("USE_LEADING_EDGE_DETECT", Field { brief: Some("GNATS #6146. Use the leading edge of the TX_ENA signal to control the state machine in tx_datapath. This bit is implemented to disable the fix incase it is causing problems."), details: Some("0 : Leading edge detect disabled 1 : Leading edge detect enabled"), lo: 2, hi: 3 });
        regs.insert("MAC_LFS_CFG", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("Link Fault Signaling Register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MAX_LEN", Field { brief: Some("The maximum frame length accepted by the Receive Module. If the length is exceeded, this is indicated in the Statistics Engine (LONG_FRAME). The maximum length is automatically adjusted to accommodate maximum sized frames containing a VLAN tag - given that the MAC is configured to be VLAN aware (default): MTU size = 10056 Bytes. This includes all encapsulations and TAGs. Not including IFH. Reason is: QS supports a max of 63 segments. A segment is 160 Bytes. The IFH must be stored in the QS also, so room must be allocated. Thereby: 63 x 160B - 24B (IFH) = 10056 Bytes"), details: Some("The maximum allowable size is 10056 Bytes."), lo: 0, hi: 16 });
        fields.insert("MAX_LEN_TAG_CHK", Field { brief: Some("Configures whether the Max Length Check takes the number of Q tags into consideration when assing if a frame is too long. If asserted, - 4 bytes will be added to MAX_LEN for single tagged frame. - 8 bytes will be added to MAX_LEN for double tagged frame. - 12 bytes will be added to MAX_LEN for tripple tagged frame."), details: Some("'0' : Only check max frame length against MAX_LEN '1' : Add 4/8/12 bytes to MAX_LEN when checking for max frame length"), lo: 16, hi: 17 });
        regs.insert("MAC_MAXLEN_CFG", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Max Length Configuration Register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("HIH_CRC_CHECK", Field { brief: Some("When asserted (=1) MAC10G must check HIH checksum and discard frames if HIH checksum is not valid. When deasserted (=0) MAC10G must disregard the HIH checksum."), details: Some("= 0 ; MAC10G should disregard the HIH CKSM. = 1 ; MAC10G should discard any frame with invalid CKSM"), lo: 0, hi: 1 });
        fields.insert("MAC_IPG_CFG", Field { brief: Some("Register configures the format of the IPG. 1) Normal IPG : Averaging IPG for average of 12 bytes 2) Shrinked IPG : Minimum IPG of 4 - 7 bytes (Incl. Terminate Character and IDLE BYTEs)"), details: Some("'0': Normal IPG. '1': Shrink IPG."), lo: 8, hi: 9 });
        fields.insert("MAC_PREAMBLE_CFG", Field { brief: Some("This register configures the format of the preamble. This supports: 1) Standard preamble = 0xFB555555555555D5 2) Minimum preamble = 0xFB 3) Host Interface Header (HIH) located before the SFD 4) Host Interface Header (HIH) located after the SFD - default CRC 5) Host Interface Header (HIH) located after the SFD - HIH included in CRC"), details: Some("0: Standard Preamble 1: Minimum Preamble = 0xFB 2: HIH before SFD -\tdefault CRC = 0xFB H0 H1 H2 H3 0x55 0x55 0xD5 3: HIH after SFD - default CRC = 0xFB 0x55 0x55 0xD5 H0 H1 H2 H3 4: HIH after SFD - HIH in CRC = 0xFB 0x55 0x55 0xD5 H0 H1 H2 H3 5 - 7: reserved HIH is 4 bytes: H0 H1 H2 H3"), lo: 12, hi: 15 });
        fields.insert("TUNNEL_PAUSE_FRAMES", Field { brief: Some("On a given link, Pause Frames can be either \"Link Pause frames\" or \"Tunnel Pause Frames\". \"Link Pause Frames\" will have standard preamble, while \"Tunnel Pause Frames\" will have HIH in the preamble. For \"Link Pause Frames\" MAC10G should not verify HIH CKSM, while for \"Tunnel Pause Frames\" MAC10G should verify HIH CKSM."), details: Some("0: Pause frames are expected to be Link Pause frames - No HIH CKSM verification in MAC10G 1: Pause frames are expected to be Tunnel Pause frames - HIH CKSM is verified in MAC10G"), lo: 16, hi: 17 });
        fields.insert("XGMII_GEN_MODE_ENA", Field { brief: Some("XGMII Generator Mode Enable: In this mode, the transmitter will not insert the preamble and the end-of-packet control characters. Data that matches one of the XGMII control characters will be translated from a data character to a control character. This mode enables the MAC 10G to transmit e.g. special XGMII messages and/or malformed frames (in terms of the XGMII protocol)."), details: Some("'0': XGMII Generator Mode Disabled '1': XGMII Generator Mode Enabled."), lo: 4, hi: 5 });
        regs.insert("MAC_MODE_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Mode Configuration Register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("NUM_TAGS", Field { brief: Some("Configuration for number of consecutive VLAN Tags supported by the MAC. Maximum value is 3."), details: Some("'0': No tags are detected by MAC. 'n': Maximum of n consecutive VLAN Tags are detected by the MAC and accordingly MAX LEN is modified for frame length calculations."), lo: 0, hi: 2 });
        regs.insert("MAC_NUM_TAGS_CFG", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Register to specify no.of tags supoorted"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LANE0_STICKY", Field { brief: Some("Sticky bits for debugging Lane 0."), details: Some("Bit 0: Sticky bit indicating that a Data character has been received on Lane 0. Writing a '1' clears the sticky bit. Bit 1: Sticky bit indicating that a Control character has been received on Lane 0. Writing a '1' clears the sticky bit. Bit 2: Sticky bit indicating that an Idle character has been received on Lane 0. Writing a '1' clears the sticky bit. Bit 3: Sticky bit indicating that a Sequence character (0x9C) has been received on Lane 0. Writing a '1' clears the sticky bit. Bit 4: Sticky bit indicating that a SOP character has been received on Lane 0. Writing a '1' clears the sticky bit. Bit 5: Sticky bit indicating that an EOP character has been received on Lane 0. Writing a '1' clears the sticky bit. Bit 6: Sticky bit indicating that an Error character has been received on Lane 0. Writing a '1' clears the sticky bit."), lo: 0, hi: 7 });
        fields.insert("LANE1_STICKY", Field { brief: Some("Sticky bits for debugging Lane 1."), details: Some("See format of LANE0 sticky bit register."), lo: 8, hi: 15 });
        fields.insert("LANE2_STICKY", Field { brief: Some("Sticky bits for debugging Lane 2."), details: Some("See format of LANE0 sticky bit register."), lo: 16, hi: 23 });
        fields.insert("LANE3_STICKY", Field { brief: Some("Sticky bits for debugging Lane 3."), details: Some("See format of LANE0 sticky bit register."), lo: 24, hi: 31 });
        regs.insert("MAC_RX_LANE_STICKY_0", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("XGMII Lane Debug Sticky bit Register 0"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LANE4_STICKY", Field { brief: Some("Sticky bits for debugging Lane 4."), details: Some("See format of LANE0 sticky bit register."), lo: 0, hi: 7 });
        fields.insert("LANE5_STICKY", Field { brief: Some("Sticky bits for debugging Lane 5."), details: Some("See format of LANE0 sticky bit register."), lo: 8, hi: 15 });
        fields.insert("LANE6_STICKY", Field { brief: Some("Sticky bits for debugging Lane 6."), details: Some("See format of LANE0 sticky bit register."), lo: 16, hi: 23 });
        fields.insert("LANE7_STICKY", Field { brief: Some("Sticky bits for debugging Lane 7."), details: Some("See format of LANE0 sticky bit register."), lo: 24, hi: 31 });
        regs.insert("MAC_RX_LANE_STICKY_1", Register { addr: Address { base: 11, count: 1, width: 1 }, brief: Some("XGMII Lane Debug Sticky bit Register 1"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TAG_ENA", Field { brief: Some("Enables TAG_ID apart from standard 0x8100 and 0x88A8 for Tag comparision."), details: Some("'0': The MAC doesn't take TAG_ID for tag identification. '1': The MAC looks for tag according to encoding of TAG_ID"), lo: 4, hi: 5 });
        fields.insert("TAG_ID", Field { brief: Some("This field defines which value is regarded as a VLAN/Service tag - besides 0x8100 and 0x88A8. The value is used for all ALL tag positions. I.e. a double tagged frame can have the following tag values: (INNER_TAG, OUTER_TAG): ( 0x8100, 0x8100 ) ( 0x8100, TAG_ID ) or ( TAG_ID, TAG_ID )"), details: Some("\"0x8100\" - Standard Ethernet Bridge ethertype (C-tag) \"0x88A8\" - Provider Bridge Ethertype  (S-tag)"), lo: 16, hi: 32 });
        regs.insert("MAC_TAGS_CFG", Register { addr: Address { base: 4, count: 3, width: 1 }, brief: Some("VLAN / Service tag configuration register"), details: Some("The MAC can be configured to accept 0, 1, 2 and 3 tags and the TAG value can be user-defined."), fields });
        let mut fields = HashMap::new();
        fields.insert("DIS_STATE_STICKY", Field { brief: Some("DISABLE state reached in Tx module of 10G MAC. Writing a '1' clears the sticky bit."), details: Some("'0': The DISABLE state has never been reached. '1': The DISABLE state has been reached. Bit is cleared by writing a '1' to this position."), lo: 0, hi: 1 });
        fields.insert("IDLE_STATE_STICKY", Field { brief: Some("IDLE state reached in Tx module of 10G MAC. Writing a '1' clears the sticky bit."), details: Some("'0': The IDLE state has never been reached. '1': The  IDLE state has been reached. Bit is cleared by writing a '1' to this position."), lo: 1, hi: 2 });
        fields.insert("LOCAL_ERR_STATE_STICKY", Field { brief: Some("LFS: LOCAL FAULT state reached in Tx module of 10G MAC. Writing a '1' clears the sticky bit."), details: Some("'0': The LOCAL_FAULT state has never been reached. '1': The LOCAL_FAULT state has been reached. Bit is cleared by writing a '1' to this position."), lo: 4, hi: 5 });
        fields.insert("REMOTE_ERR_STATE_STICKY", Field { brief: Some("LFS REMOTE FAULT state reached in Tx module of 10G MAC. Writing a '1' clears the sticky bit."), details: Some("'0': The REMOTE_FAULT state has never been reached. '1': The REMOTE_FAULT state has been reached. Bit is cleared by writing a '1' to this position."), lo: 3, hi: 4 });
        regs.insert("MAC_TX_MONITOR_STICKY", Register { addr: Address { base: 12, count: 1, width: 1 }, brief: Some("MAC10G Tx Monitor Sticky bit Register"), details: None, fields });
        groups.insert("MAC_CFG_STATUS", RegisterGroup { addr: Address { base: 0, count: 1, width: 14 }, desc: "MAC10G Configuration and Status Registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("JP_TX_CNT", Field { brief: Some("Jitter pattern transmit counter"), details: None, lo: 0, hi: 32 });
        regs.insert("PCS_XAUI_TSTPAT_TX_SEQ_CNT_STATUS", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Test Pattern Transmit Sequence Counter"), details: Some("Jitter Pattern Transmit Counter. The counter counts the number of transmitted frames (only frame based pattern, i.e. CRPAT and CJPAT)."), fields });
        groups.insert("PCS2X6G_CONFIGURATION", RegisterGroup { addr: Address { base: 83, count: 1, width: 1 }, desc: "PCS2X6G Configuration Registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ERR_64B66BDEC", Field { brief: Some("Number of errors detected in 64B/66B decoder."), details: None, lo: 0, hi: 24 });
        regs.insert("PCS2X6G_ERR_CNT_STAT", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("PCS2X6G Error Counter"), details: Some("PCS2X6G error counter"), fields });
        groups.insert("PCS2X6G_EXT_CONFIGURATION", RegisterGroup { addr: Address { base: 87, count: 1, width: 1 }, desc: "PCS2x6G Extended Configuration Registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("AN_LINK_CTRL_ENA", Field { brief: Some("Enable Link control via Backplane Ethernet ANEG"), details: Some("0: Disable link control 1: Enable link control"), lo: 1, hi: 2 });
        fields.insert("LF_GEN_DIS", Field { brief: Some("Disable RX Local Fault generation when no alignment has been reached"), details: Some("0: Output Local Fault symbol at XGMII when not aligned 1: Output IDLE symbols at XGMII when not aligned"), lo: 7, hi: 8 });
        fields.insert("PCS_ENA", Field { brief: Some("PCS2X6G enable"), details: Some("0: Disable PCS 1: Enable PCS"), lo: 0, hi: 1 });
        fields.insert("PLOOP_RA_ENA", Field { brief: Some("Enable rate adaption (use in parallel loop mode only)"), details: Some("0: Rate adaption disabled 1: Rate adaption enabled"), lo: 21, hi: 22 });
        fields.insert("RESYNC_ENA", Field { brief: Some("Force re-synchronization of receive logic"), details: Some("0: Normal operation 1: Reset Synchronization"), lo: 16, hi: 17 });
        fields.insert("SCRAM_DIS", Field { brief: Some("Disable Scrambler in 64B/66B codec (to be used only for test purposes)"), details: Some("0: Enable scrambler 1: Disable scrambler"), lo: 17, hi: 18 });
        fields.insert("SD_ENA", Field { brief: Some("Signal Detect Enable"), details: Some("0: The Signal Detect input pin is ignored. The PCS2X6G assumes an active Signal Detect at all times 1: The Signal Detect input pin is used to determine if a signal is detected"), lo: 24, hi: 25 });
        fields.insert("SD_POL", Field { brief: Some("Signal detect polarity: The signal level on signal_detect input pin must be equal to SD_POL to indicate signal detection (SD_ENA must be set)"), details: Some("0: Signal Detect input pin must be '0' to indicate a signal detection 1: Signal Detect input pin must be '1' to indicate a signal detection"), lo: 25, hi: 26 });
        fields.insert("SD_SEL", Field { brief: Some("Signal detect selection (select input for internal signal_detect line)"), details: Some("0: Select signal_detect line from hardmacro 1: Select external signal_detect line"), lo: 26, hi: 27 });
        fields.insert("SH_CNT_MAX", Field { brief: Some("Number of sync headers required for block lock plus one (used in 10Gb-R type SSM)"), details: None, lo: 10, hi: 16 });
        fields.insert("SLOOP_ENA", Field { brief: Some("Testloop, if active data are looped from TX path to RX path without using SERDES loops"), details: Some("0: Normal operation 1: Testloop enable"), lo: 20, hi: 21 });
        fields.insert("SYNC_TYPE_SEL", Field { brief: Some("Select type of Synchronization State Machine"), details: Some("0: Use 10Gb-R (Cl. 49) type 1: Use 10Gb-X (Cl. 48) type Others: Reserved"), lo: 8, hi: 10 });
        regs.insert("PCS2X6G_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("PCS2X6G Configuration"), details: Some("Configuration register"), fields });
        let mut fields = HashMap::new();
        fields.insert("ALIGNMENT_LOST_STICKY", Field { brief: Some("Alignment lost in deskew logic"), details: Some("0: No misalignment occured 1: A (temporary) misalignment has been detected Bit is cleared by writing a 1 to this position."), lo: 4, hi: 5 });
        fields.insert("C64B66B_ERR_STICKY", Field { brief: Some("Coding error detected in received 64B/66B encoded data"), details: Some("0: No error found 1: Coding error detected Bit is cleared by writing a 1 to this position."), lo: 5, hi: 6 });
        fields.insert("SYNC_LOST_STICKY", Field { brief: Some("Synchronization lost in lane i (i = 0...3, one bit per lane)"), details: Some("0: No sync lost occured 1: Synchronization lost in lane i (temporarily) Bit is cleared by writing a 1 to this position."), lo: 0, hi: 4 });
        fields.insert("XGMII_ERR_STICKY", Field { brief: Some("Coding error detected in xgmii data to be transmitted"), details: Some("0: No error found 1: Coding error detected Bit is cleared by writing a 1 to this position."), lo: 6, hi: 7 });
        regs.insert("PCS2X6G_ERR_STATUS", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("PCS2X6G Error Status"), details: Some("Error indication of 64B/66B PCS2X6G logic"), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_ALIGNMENT_STATUS", Field { brief: Some("Status of deskew logic"), details: Some("0: Lanes not aligned 1: All lanes are aligned"), lo: 4, hi: 5 });
        fields.insert("RX_SYNC_STATUS", Field { brief: Some("Status of synchronization in lane i (i = 0...3, one bit per lane)"), details: Some("0: Lane i out of sync 1: Lane i is in sync"), lo: 0, hi: 4 });
        fields.insert("SIGNAL_DETECT", Field { brief: Some("Current status of selected signal_detect input lines"), details: None, lo: 12, hi: 16 });
        regs.insert("PCS2X6G_STATUS", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("PCS2X6G Status"), details: Some("Status of PCS2X6G logic"), fields });
        groups.insert("PCS2X6G_STATUS", RegisterGroup { addr: Address { base: 84, count: 1, width: 3 }, desc: "PCS2X6G Status Registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("AN_LINK_CTRL_ENA", Field { brief: Some("Enable Link control via Backplane Ethernet ANEG"), details: Some("0: Disable link control 1: Enable link control"), lo: 1, hi: 2 });
        fields.insert("FIFO_RPT_RES", Field { brief: Some("RX FIFO read pointer reset"), details: Some("1: Reset RX fifo read pointer"), lo: 11, hi: 12 });
        fields.insert("IDLE_SEQ_MODE", Field { brief: Some("Idle sequencing mode (IPG shrink mode support). When active, the first ||I|| after ||T|| will be alternatingly ||K||, ||A|| or ||R|| instead of ||K|| or ||A|| only in normal mode"), details: Some("1: Modified idle sequencing for IPG shrink mode support 0: Normal idle sequencing"), lo: 12, hi: 13 });
        fields.insert("LF_GEN_DIS", Field { brief: Some("Disable RX Local Fault generation when no alignment has been reached"), details: Some("0: Output Local Fault symbol at XGMII when not aligned 1: Output IDLE symbols at XGMII when not aligned"), lo: 7, hi: 8 });
        fields.insert("PCS_ENA", Field { brief: Some("PCS enable"), details: Some("0: Disable PCS 1: Enable PCS"), lo: 0, hi: 1 });
        fields.insert("PT_DIS", Field { brief: Some("Disable RX Pad/Truncate Mode"), details: Some("0: Normal operation 1: Disable pad/truncate"), lo: 2, hi: 3 });
        fields.insert("PT_IPG_SIZE", Field { brief: Some("RX Minimum Inter Packet Gap (Minimum Idle columns, i.e. 4 /I/ on all four lanes, to occure before Truncate may happen)"), details: Some("0: No complete idle column is preserved 1: At least one idle column is preserved ..."), lo: 3, hi: 6 });
        fields.insert("XAUI_LOOP_ENA", Field { brief: Some("Testloop, if enabled (XAUI encoded) data are looped from TX path to RX path just before the SERDES"), details: Some("1: Enable loop 0: Disable loop"), lo: 20, hi: 21 });
        regs.insert("PCS_XAUI_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("PCS XAUI Configuration"), details: Some("PCS XAUI Configuration Register"), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_FLIP_HMBUS", Field { brief: Some("Flip HM-Bus in receive direction, i.e. map lane 0 on 3, lane 1 on 2, lane 2 on 1 and lane 3 on 0"), details: Some("0: Normal lane order 1: Flipped lane order"), lo: 2, hi: 3 });
        fields.insert("RX_INV_HMBUS", Field { brief: Some("Invert HM-Bus in receive direction, invert all data signals from SERDES"), details: Some("0: Normal operation 1: Invert HM-bus"), lo: 3, hi: 4 });
        fields.insert("TX_FLIP_HMBUS", Field { brief: Some("Flip HM-Bus in transmit direction, i.e. map lane 0 on 3, lane 1 on 2, lane 2 on 1 and lane 3 on 0"), details: Some("0: Normal lane order 1: Flipped lane order"), lo: 0, hi: 1 });
        fields.insert("TX_INV_HMBUS", Field { brief: Some("Invert HM-Bus in transmit direction, invert all data signals to SERDES"), details: Some("0: Normal operation 1: Invert HM-bus"), lo: 1, hi: 2 });
        regs.insert("PCS_XAUI_EXT_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("PCS XAUI Extended Configuration"), details: Some("Special configuration bit groups for PCS XAUI"), fields });
        let mut fields = HashMap::new();
        fields.insert("COMMA_REPL", Field { brief: Some("Comma replacement. In interleave mode (using /K/ byte orderung) one 20-bit word must have only one comma for proper alignment. Misleading commas are replaced by comma_repl in transmit direction and replaced by K28.5-commas again in receive direction. Comma_repl has to be an unused valid special code-group which does not contain a comma, i.e. K28.2, K28.6 or K23.7 are possible replacements."), details: None, lo: 8, hi: 16 });
        fields.insert("COM_ALIGN_POS", Field { brief: Some("Code-group alignment in 20-bit mode"), details: Some("0: align comma to lower 10 bits 1: align comma to upper 10 bits"), lo: 18, hi: 19 });
        fields.insert("DC_A_ALIGN_ENA", Field { brief: Some("Dual column ||A|| alignment (||A|| are inserted on even columns only)"), details: Some("0: Normal insertion 1: Even column insertion only"), lo: 17, hi: 18 });
        fields.insert("ILV_MODE", Field { brief: Some("Interleave mode selection. In interleave mode XAUI data are sent via two 5Gbps lanes"), details: Some("0: Interleave mode with /K/ comma based byte re-ordering (using comma replacement) 1: Interleave mode with /A/ alignment symbol based byte re-ordering"), lo: 1, hi: 2 });
        fields.insert("ILV_MODE_ENA", Field { brief: Some("Interleave mode enable. In interleave mode XAUI data are sent via two 5Gbps lanes"), details: Some("0: Normal XAUI mode 1: Interleave mode"), lo: 0, hi: 1 });
        fields.insert("K28_5_SYNC_ENA", Field { brief: Some("Comma synchronization mode"), details: Some("0: Synchronize on any 7-bit comma (XAUI compliant) 1: Synchronize on K28.5 only (non XAUI compliant)"), lo: 16, hi: 17 });
        fields.insert("RXCHAN_REORD1_ENA", Field { brief: Some("Channel reordering in receive direction (swap lane 0, 1 and lane 2, 3) before 8B/10B decoder"), details: Some("1: Enable 0: Disable"), lo: 5, hi: 6 });
        fields.insert("RXCHAN_REORD2_ENA", Field { brief: Some("Channel reordering in receive direction (swap lane 0, 1 and lane 2, 3) after 8B/10B decoder"), details: Some("1: Enable 0: Disable"), lo: 4, hi: 5 });
        fields.insert("RX_8B10B_ILV_DIS", Field { brief: Some("Disable 8b10b decoding of interleaved data stream"), details: Some("0: Interleaved data stream is 8b10b decoded 1: Each lane is individually 8b10b decoded"), lo: 3, hi: 4 });
        fields.insert("TXCHAN_REORD1_ENA", Field { brief: Some("Channel reordering in transmit direction (swap lane 0, 1 and lane 2, 3) before comma remapping"), details: Some("1: Enable 0: Disable"), lo: 7, hi: 8 });
        fields.insert("TXCHAN_REORD2_ENA", Field { brief: Some("Channel reordering in transmit direction (swap lane 0, 1 and lane 2, 3) after comma remapping"), details: Some("1: Enable 0: Disable"), lo: 6, hi: 7 });
        fields.insert("TX_8B10B_ILV_DIS", Field { brief: Some("Disable 8b10b encoding of interleaved data stream"), details: Some("0: Interleaved data stream is 8b10b encoded 1: Each lane is individually 8b10b encoded"), lo: 2, hi: 3 });
        regs.insert("PCS_XAUI_INTERLEAVE_MODE_CFG", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("PCS Interleave Mode Configuration"), details: Some("Configuration register set for Interleave Mode (XAUI via two lanes) - also known as DDR-XAUI"), fields });
        let mut fields = HashMap::new();
        fields.insert("CERR_MASK", Field { brief: Some("Codegroup error counting mask"), details: Some("0000: Count errors of all lanes 1110: Count error of lane 0 only ..."), lo: 8, hi: 12 });
        fields.insert("DERR_MASK", Field { brief: Some("Disparity error counting mask"), details: Some("0000: Count errors of all lanes 1110: Count error of lane 0 only ..."), lo: 12, hi: 16 });
        fields.insert("OFERR_MASK", Field { brief: Some("Fifo overflow error counting mask"), details: Some("0000: Count errors of all lanes 1110: Count error of lane 0 only ..."), lo: 0, hi: 4 });
        fields.insert("UFERR_MASK", Field { brief: Some("Fifo underflow error counting mask"), details: Some("0000: Count errors of all lanes 1110: Count error of lane 0 only ..."), lo: 4, hi: 8 });
        regs.insert("PCS_XAUI_RX_ERR_CNT_CFG", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("PCS XAUI Receiver Error Counter Configuration"), details: Some("Error Counter Configuration Register (if a bit in the mask field is set, the errors of that lane are not counted)."), fields });
        let mut fields = HashMap::new();
        fields.insert("SD_ENA", Field { brief: Some("Signal Detect Enable"), details: Some("0: The Signal Detect input pin is ignored. The PCS assumes an active Signal Detect at all times 1: The Signal Detect input pin is used to determine if a signal is detected"), lo: 0, hi: 1 });
        fields.insert("SD_POL", Field { brief: Some("Signal detect polarity: The signal level on signal_detect input pin must be equal to SD_POL to indicate signal detection (SD_ENA must be set)"), details: Some("0: Signal Detect input pin must be '0' to indicate a signal detection 1: Signal Detect input pin must be '1' to indicate a signal detection"), lo: 4, hi: 5 });
        fields.insert("SD_SEL", Field { brief: Some("Signal detect selection (select input for internal signal_detect line)"), details: Some("0: Select signal_detect line from hardmacro 1: Select external signal_detect line"), lo: 8, hi: 9 });
        regs.insert("PCS_XAUI_SD_CFG", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("PCS XAUI SignalDetect Configuration"), details: Some("PCS_XAUI signal_detect configuration"), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_Q", Field { brief: Some("Transmit ||Q|| code (Sequence information, i.e. lower 24 bit of a Sequence)"), details: None, lo: 8, hi: 32 });
        fields.insert("TX_Q_DIS", Field { brief: Some("Disable Transmit ||Q|| code replacement"), details: Some("1: Disable 0: Enable"), lo: 7, hi: 8 });
        regs.insert("PCS_XAUI_TX_SEQ_CFG", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("PCS Transmitter Sequence Configuration Register"), details: Some("Sequence Transmit Configuration Register"), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_OK_BYTES_MSB_CNT", Field { brief: Some("The numbe rof transmitted bytes transmitted successfully - MSBs only."), details: Some("Counter can be written by SW."), lo: 0, hi: 8 });
        regs.insert("TX_OK_BYTES_MSB_CNT", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("Tx OK Bytes Counter - MSB partTx OK Bytes Counter - MSB"), details: Some("The number of bytes transmitted - MSBs only."), fields });
        groups.insert("PCS_XAUI_CONFIGURATION", RegisterGroup { addr: Address { base: 63, count: 1, width: 7 }, desc: "PCS XAUI Configuration Registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("LANE_CGALIGN_DELAY", Field { brief: Some("Delay through the lane barrelshifter. Lane N delay is stored in bits 5N+4 to 5N. Unit is line bit times"), details: None, lo: 0, hi: 20 });
        regs.insert("PCS_XAUI_CGALIGN_STATUS", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("PCS Receiver comma alignment Register"), details: Some("Receive comma alignment status Register"), fields });
        let mut fields = HashMap::new();
        fields.insert("LANE_DESKEW_DELAY", Field { brief: Some("Delay through deskew fifo for each lane. Lane N delay is stored in bits 4N+3 to 4N. Unit is PCS clock cycles"), details: None, lo: 0, hi: 16 });
        regs.insert("PCS_XAUI_DESKEW_STATUS", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("PCS Receiver Deskew Register"), details: Some("Receive deskew status Register"), fields });
        let mut fields = HashMap::new();
        fields.insert("LPI_RX_WTIM", Field { brief: Some("Max wake-up time before link_fail"), details: Some("00: 8 us 01: 11 us 10: 15 us 11: 18 us"), lo: 4, hi: 6 });
        fields.insert("LPI_TESTMODE", Field { brief: Some("LPI-Timer test mode."), details: Some("0: Normal timing constants are used 1: Shortened timing constants are used"), lo: 16, hi: 17 });
        fields.insert("RX_LPI_OUT_DIS", Field { brief: Some("Disable output of Low-Power Idle in receive direction (to core)"), details: Some("0: Enable 1: Disable"), lo: 17, hi: 18 });
        fields.insert("TX_ASSERT_LPIDLE", Field { brief: Some("Assert Low-Power Idle (LPI) in transmit mode"), details: Some("0: Disable LPI transmission 1: Enable LPI transmission"), lo: 0, hi: 1 });
        regs.insert("PCS_XAUI_LPI_CFG", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("PCS Low Power Idle Configuration"), details: Some("Configuration register for Low Power Idle (Energy Efficient Ethernet)"), fields });
        let mut fields = HashMap::new();
        fields.insert("ALIGNMENT_LOST_STICKY", Field { brief: Some("Alignment lost in deskew logic"), details: Some("0: No misalignment occured 1: A (temporary) misalignment has been detected Bit is cleared by writing a 1 to this position."), lo: 4, hi: 5 });
        fields.insert("C8B10B_ERR_STICKY", Field { brief: Some("Coding error detected in received 8B/10B encoded data"), details: Some("0: No error found 1: Coding error detected Bit is cleared by writing a 1 to this position."), lo: 5, hi: 6 });
        fields.insert("SYNC_LOST_STICKY", Field { brief: Some("Synchronization lost in lane i (i = 0...3, one bit per lane)"), details: Some("0: No sync lost occured 1: Synchronization lost in lane i (temporarily) Bit is cleared by writing a 1 to this position."), lo: 0, hi: 4 });
        regs.insert("PCS_XAUI_RX_ERROR_STATUS", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("PCS Receiver Lane Error Status"), details: Some("Receiver Lane Error Status register"), fields });
        let mut fields = HashMap::new();
        fields.insert("ERR_CNT_10B8B_CG_L3", Field { brief: Some("Number of detected codegroup errors/Number of errors in lane 3"), details: None, lo: 0, hi: 32 });
        regs.insert("PCS_XAUI_RX_FIFO_CG_ERR_L3_CNT_STATUS", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("PCS RX 10b8b Codegroup Error and Lane 3 Error Counter"), details: Some("10b8b Decoder Codegroup error counter. In test pattern check mode, this counter counts the errors of lane 3. In the latter case the counter is incremented by one whenever at least one out of eighty received bits (eight symbols) is corrupted."), fields });
        let mut fields = HashMap::new();
        fields.insert("ERR_CNT_10B8B_D_L2", Field { brief: Some("Number of detected disparity errors/Number of errors in lane 2"), details: None, lo: 0, hi: 32 });
        regs.insert("PCS_XAUI_RX_FIFO_D_ERR_L2_CNT_STATUS", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("PCS RX 10b8b Disparity Error and Lane 2 Error Counter"), details: Some("10b8b Decoder Disparity error counter. In test pattern check mode, this counter counts the errors of lane 2. In the latter case the counter is incremented by one whenever at least one out of eighty received bits (eight symbols) is corrupted."), fields });
        let mut fields = HashMap::new();
        fields.insert("ERR_CNT_FIFO_OF_L0", Field { brief: Some("Number of detected fifo overflow errors/Number of errors in lane 0"), details: None, lo: 0, hi: 32 });
        regs.insert("PCS_XAUI_RX_FIFO_OF_ERR_L0_CNT_STATUS", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("PCS RX Fifo Overflow Error and Lane 0 Error Counter"), details: Some("Receive Fifo Overflow error counter. In test pattern check mode, this counter counts the errors of lane 0. In the latter case the counter is incremented by one whenever at least one out of eighty received bits (eight symbols) is corrupted."), fields });
        let mut fields = HashMap::new();
        fields.insert("ERR_CNT_FIFO_UF_L1", Field { brief: Some("Number of detected fifo underflow errors/Number of errors in lane 1"), details: None, lo: 0, hi: 32 });
        regs.insert("PCS_XAUI_RX_FIFO_UF_ERR_L1_CNT_STATUS", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("PCS RX Fifo Underflow Error and Lane 1 Error Counter"), details: Some("Receive Fifo Underflow error counter. In test pattern check mode, this counter counts the errors of lane 1. In the latter case the counter is incremented by one whenever at least one out of eighty received bits (eight symbols) is corrupted."), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_Q", Field { brief: Some("Received ||Q|| code (Sequence information, i.e. lower 24 bit of a Sequence)"), details: None, lo: 8, hi: 32 });
        fields.insert("RX_Q_CHANGED_STICKY", Field { brief: Some("Received ||Q|| code changed"), details: Some("1: New ||Q|| has been received 0: No new ||Q|| since last read Bit is cleared by writing a 1 to this position."), lo: 0, hi: 1 });
        regs.insert("PCS_XAUI_RX_SEQ_REC_STATUS", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("PCS Receiver Sequence Result Register"), details: Some("Sequence Receive Status Register"), fields });
        let mut fields = HashMap::new();
        fields.insert("ALIGNMENT_STATUS", Field { brief: Some("Status of lane alignment"), details: Some("1: All lanes are aligned 0: No alignment reached"), lo: 4, hi: 5 });
        fields.insert("LOCAL_FAULT_STICKY", Field { brief: Some("Local Fault status (one or more of sync/align/fifo_of/fifo_uf/8b10b error)"), details: Some("1: A fault occured 0: No fault detected Bit is cleared by writing a 1 to this position."), lo: 8, hi: 12 });
        fields.insert("SIGNAL_DETECT", Field { brief: Some("Current status of selected signal_detect input lines"), details: None, lo: 12, hi: 16 });
        fields.insert("SYNC_STATUS", Field { brief: Some("Status of code group alignment (lane independent)"), details: Some("1111: All lanes in sync 0001: Lane 0 is in sync ..."), lo: 0, hi: 4 });
        regs.insert("PCS_XAUI_RX_STATUS", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("PCS Receiver Status Register"), details: Some("Receive Lane Status Register"), fields });
        groups.insert("PCS_XAUI_STATUS", RegisterGroup { addr: Address { base: 70, count: 1, width: 10 }, desc: "PCS XAUI Status Registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("RX_LPI_EVENT_STICKY", Field { brief: Some("Receiver Low-Pwer idle occurrence"), details: Some("0: No LPI symbols received 1: Receiver has received LPI symbols Bit is cleared by writing a 1 to this position."), lo: 12, hi: 13 });
        fields.insert("RX_LPI_MODE", Field { brief: Some("Receiver Low-Power Idle mode"), details: Some("0: Receiver not in low power idle mode 1: Receiver is in low power idle mode"), lo: 8, hi: 9 });
        fields.insert("RX_QUIET", Field { brief: Some("Receiver Low-Power Quiet mode"), details: Some("0: Receiver not in quiet mode 1: Receiver is in quiet mode"), lo: 9, hi: 10 });
        fields.insert("TX_LPI_EVENT_STICKY", Field { brief: Some("Transmitter Low-Pwer idle occurrence"), details: Some("0: No LPI symbols transmitted 1: Transmitter has transmitted LPI symbols Bit is cleared by writing a 1 to this position."), lo: 4, hi: 5 });
        fields.insert("TX_LPI_MODE", Field { brief: Some("Transmitter Low-Power Idle mode"), details: Some("0: Transmitter not in low power idle mode 1: Transmitter is in low power idle mode"), lo: 0, hi: 1 });
        fields.insert("TX_QUIET", Field { brief: Some("Transmitter Low-Power Quiet mode"), details: Some("0: Transmitter not in quiet mode 1: Transmitter is in quiet mode"), lo: 1, hi: 2 });
        fields.insert("WAKE_ERR_CNT", Field { brief: Some("Receiver has failed to recover from Low-Power Idle mode"), details: Some("0: No failure 1: Failed to recover from LPI mode"), lo: 16, hi: 32 });
        regs.insert("PCS_XAUI_LPI_STATUS", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("PCS Low Power Idle Status"), details: Some("Status register for Low Power Idle (Energy Efficient Ethernet)"), fields });
        groups.insert("PCS_XAUI_TSTPAT_CONFIGURATION", RegisterGroup { addr: Address { base: 80, count: 1, width: 1 }, desc: "PCS XAUI Testpattern Configuration Registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("FREEZE_ERR_CNT_ENA", Field { brief: Some("Capture current error counter values"), details: Some("1: Capture"), lo: 8, hi: 9 });
        fields.insert("VT_CHK_ENA", Field { brief: Some("Enable Test pattern checker"), details: Some("1: Check 0: No checking"), lo: 7, hi: 8 });
        fields.insert("VT_CHK_SEL", Field { brief: Some("Check test pattern"), details: Some("000: Idle 011: MFPAT 100: CRPAT 101: CJPAT all others: Idle Note: LFPAT and HFPAT can not be checked since sync is impossible"), lo: 4, hi: 7 });
        fields.insert("VT_GEN_ENA", Field { brief: Some("Enable Test pattern generator"), details: Some("1: Generate test vectors 0: Normal operation"), lo: 3, hi: 4 });
        fields.insert("VT_GEN_SEL", Field { brief: Some("Generate test pattern"), details: Some("000: Idle 001: HFPAT 010: LFPAT 011: MFPAT 100: CRPAT 101: CJPAT All others: Idle"), lo: 0, hi: 3 });
        regs.insert("PCS_XAUI_TSTPAT_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("PCS XAUI Test Pattern Configuration"), details: Some("Test Pattern Generator/Checker Control Register"), fields });
        let mut fields = HashMap::new();
        fields.insert("RND_SEQ_TIMER", Field { brief: Some("Random sequence master counter"), details: None, lo: 0, hi: 32 });
        regs.insert("PCS_XAUI_TSTPAT_RX_SEQ_CNT_STATUS", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Test Pattern Receive Sequence Counter"), details: Some("Random Sequence Master Counter. The counter is used only if frame based pattern are to be checked (CRPAT, CJPAT) and it is incremented by one every 8th received symbol. The counter is started when a start of frame is detected and the counter stops when the last symbol of the (internally stored) reference frame was compared. The idle phase between two frames is not checked."), fields });
        groups.insert("PCS_XAUI_TSTPAT_STATUS", RegisterGroup { addr: Address { base: 81, count: 1, width: 2 }, desc: "PCS XAUI Testpattern Status Registers", regs });
        out.insert("DEV10G", Target { desc: "\\see vtss_target_DEV10G_e VAUI @ 12Gbps 2 lanes, XAUI @ 10 Gbps, XAUI @ 12 Gbps, VAUI @ 10Gbps 2 lanes and SGMII @ 10/100/1000/2500 Mbps", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("AN_LINK_DOWN_INTR_STICKY", Field { brief: Some("ANEG Link down interrupt (only PCS1g)"), details: Some("0: No interrupt 1: Interrupt occured Bit is cleared by writing a 1 to this position."), lo: 2, hi: 3 });
        fields.insert("AN_LINK_UP_INTR_STICKY", Field { brief: Some("ANEG Link up interrupt (only PCS1g)"), details: Some("0: No interrupt 1: Interrupt occured Bit is cleared by writing a 1 to this position."), lo: 3, hi: 4 });
        fields.insert("AN_PAGE_RX_INTR_STICKY", Field { brief: Some("ANEG next page receive interrupt (only PCS1g)"), details: Some("0: No interrupt 1: Interrupt occured Bit is cleared by writing a 1 to this position."), lo: 4, hi: 5 });
        fields.insert("FEF_FOUND_INTR_STICKY", Field { brief: Some("Far-end-fault indication found interrupt (only PCS_fx100)"), details: Some("0: No interrupt 1: Interrupt occured Bit is cleared by writing a 1 to this position."), lo: 8, hi: 9 });
        fields.insert("LINK_DOWN_INTR_STICKY", Field { brief: Some("Link down interrupt"), details: Some("0: No interrupt 1: Interrupt occured Bit is cleared by writing a 1 to this position."), lo: 0, hi: 1 });
        fields.insert("LINK_UP_INTR_STICKY", Field { brief: Some("Link up interrupt"), details: Some("0: No interrupt 1: Interrupt occured Bit is cleared by writing a 1 to this position."), lo: 1, hi: 2 });
        fields.insert("RX_LPI_INTR_STICKY", Field { brief: Some("Low Power Idle Receive interrupt (only PCS1g)"), details: Some("0: No interrupt 1: Interrupt occured Bit is cleared by writing a 1 to this position."), lo: 5, hi: 6 });
        fields.insert("TX_LPI_INTR_STICKY", Field { brief: Some("Low Power Idle Transmit interrupt (only PCS1g)"), details: Some("0: No interrupt 1: Interrupt occured Bit is cleared by writing a 1 to this position."), lo: 6, hi: 7 });
        regs.insert("DEV1G_INTR", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Dev1g Interrupt Reg"), details: Some("Interrupt register"), fields });
        let mut fields = HashMap::new();
        fields.insert("AN_LINK_DOWN_INTR_ENA", Field { brief: Some("ANEG Link down interrupt enable (only PCS1g)"), details: Some("0: Interrupt disabled 1: Interrupt enabled"), lo: 2, hi: 3 });
        fields.insert("AN_LINK_UP_INTR_ENA", Field { brief: Some("ANEG Link up interrupt enable (only PCS1g)"), details: Some("0: Interrupt disabled 1: Interrupt enabled"), lo: 3, hi: 4 });
        fields.insert("AN_PAGE_RX_INTR_ENA", Field { brief: Some("ANEG next page receive interrupt enable (only PCS1g)"), details: Some("0: Interrupt disabled 1: Interrupt enabled"), lo: 4, hi: 5 });
        fields.insert("FEF_FOUND_INTR_ENA", Field { brief: Some("Far-end-fault indication found interrupt enable (only PCS_fx100)"), details: Some("0: Interrupt disabled 1: Interrupt enabled"), lo: 8, hi: 9 });
        fields.insert("LINK_DOWN_INTR_ENA", Field { brief: Some("Link down interrupt enable"), details: Some("0: Interrupt disabled 1: Interrupt enabled"), lo: 0, hi: 1 });
        fields.insert("LINK_UP_INTR_ENA", Field { brief: Some("Link up interrupt enable"), details: Some("0: Interrupt disabled 1: Interrupt enabled"), lo: 1, hi: 2 });
        fields.insert("RX_LPI_INTR_ENA", Field { brief: Some("Low Power Idle Receive interrupt enable (only PCS1g)"), details: Some("0: Interrupt disabled 1: Interrupt enabled"), lo: 5, hi: 6 });
        fields.insert("TX_LPI_INTR_ENA", Field { brief: Some("Low Power Idle Transmit interrupt enable (only PCS1g)"), details: Some("0: Interrupt disabled 1: Interrupt enabled"), lo: 6, hi: 7 });
        regs.insert("DEV1G_INTR_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Dev1g Intr Configuration"), details: Some("Interrupt Mask (Enable) register"), fields });
        let mut fields = HashMap::new();
        fields.insert("AN_LINK_DOWN_INTR_IDENT", Field { brief: Some("ANEG Link down interrupt (only PCS1g)"), details: Some("0: No interrupt 1: Interrupt pending"), lo: 2, hi: 3 });
        fields.insert("AN_LINK_UP_INTR_IDENT", Field { brief: Some("ANEG Link up interrupt (only PCS1g)"), details: Some("0: No interrupt 1: Interrupt pending"), lo: 3, hi: 4 });
        fields.insert("AN_PAGE_RX_INTR_IDENT", Field { brief: Some("ANEG next page receive interrupt (only PCS1g)"), details: Some("0: No interrupt 1: Interrupt pending"), lo: 4, hi: 5 });
        fields.insert("FEF_FOUND_INTR_IDENT", Field { brief: Some("Far-end-fault indication found interrupt (only PCS_fx100)"), details: Some("0: No interrupt 1: Interrupt pending"), lo: 8, hi: 9 });
        fields.insert("LINK_DOWN_INTR_IDENT", Field { brief: Some("Link down interrupt"), details: Some("0: No interrupt 1: Interrupt pending"), lo: 0, hi: 1 });
        fields.insert("LINK_UP_INTR_IDENT", Field { brief: Some("Link up interrupt"), details: Some("0: No interrupt 1: Interrupt pending"), lo: 1, hi: 2 });
        fields.insert("RX_LPI_INTR_IDENT", Field { brief: Some("Low Power Idle Receive interrupt (only PCS1g)"), details: Some("0: No interrupt 1: Interrupt pending"), lo: 5, hi: 6 });
        fields.insert("TX_LPI_INTR_IDENT", Field { brief: Some("Low Power Idle Transmit interrupt (only PCS1g)"), details: Some("0: No interrupt 1: Interrupt pending"), lo: 6, hi: 7 });
        regs.insert("DEV1G_INTR_IDENT", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Dev1g Interrupt Ident"), details: Some("Pending Interrupts (only enabled interrupts are visible)"), fields });
        let mut fields = HashMap::new();
        fields.insert("EDGE_POS_PTP", Field { brief: Some("Data change position in the 10bit words received. Must be used for adjusting PTP ingress delays."), details: None, lo: 8, hi: 12 });
        fields.insert("FEF_FOUND_STICKY", Field { brief: Some("Far-end Fault state has occurred"), details: Some("1: A Far-End Fault has been detected 0: No Far-End Fault occurred Bit is cleared by writing a 1 to this position."), lo: 6, hi: 7 });
        fields.insert("FEF_STATUS", Field { brief: Some("Current status of Far-end Fault detection state"), details: Some("1: Link currently in fault state 0: Link is in normal state"), lo: 2, hi: 3 });
        fields.insert("PCS_ERROR_STICKY", Field { brief: Some("PCS error has occurred"), details: Some("1: RX_ER was high while RX_DV active 0: No RX_ER indication found while RX_DV active Bit is cleared by writing a 1 to this position."), lo: 7, hi: 8 });
        fields.insert("SIGNAL_DETECT", Field { brief: Some("Current status of selected signal_detect input line"), details: Some("1: Proper signal detected 0: No proper signal found"), lo: 1, hi: 2 });
        fields.insert("SSD_ERROR_STICKY", Field { brief: Some("Stream Start Delimiter error occurred"), details: Some("1: A Start-of-Stream Delimiter error has been detected 0: No SSD error occurred Bit is cleared by writing a 1 to this position."), lo: 5, hi: 6 });
        fields.insert("SYNC_LOST_STICKY", Field { brief: Some("Synchronization lost"), details: Some("1: Synchronization lost 0: No sync lost occurred Bit is cleared by writing a 1 to this position."), lo: 4, hi: 5 });
        fields.insert("SYNC_STATUS", Field { brief: Some("Status of synchronization"), details: Some("1: Link established 0: No link found"), lo: 0, hi: 1 });
        regs.insert("PCS_FX100_STATUS", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("PCS 100Base FX Status"), details: Some("Status bit groups for 100Base-FX PCS. Note: If sigdet_cfg != \"00\" is selected status signal \"signal_detect\" shows the internal signal_detect value is gated with the status of rx toggle-rate control circuitry."), fields });
        groups.insert("DEV1G_INTR_CFG_STATUS", RegisterGroup { addr: Address { base: 37, count: 1, width: 3 }, desc: "Device 1G Interrupt Configuration and Status Registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("BACKOFF_CNT_ENA", Field { brief: Some("The TX_Size and the TX_Backoff events share the same counters. Per default the counters count TX_SIZE events. BACKOFF_CNT_ENA switches the counter to count backup events instead."), details: Some("0: Count TX_SIZE events 1: Count TX_BACKOFF events"), lo: 0, hi: 1 });
        fields.insert("FCS_UPDATE_CFG", Field { brief: Some("Controls the FCS update function of the device."), details: Some("0: Use information from DSM to control FCS updating 1: Always update FCS 2: Never update FCS 3: Reserved"), lo: 2, hi: 4 });
        fields.insert("IFG_LEN_DIS", Field { brief: Some("Disable of advanced rate control feature."), details: Some("0: Advanced rate control active 1: Advanced rate control disabled"), lo: 1, hi: 2 });
        fields.insert("PRE_CNT_OFLW_ID", Field { brief: Some("Holds the ID of the last pre counter that had an overflow. The user has to check the PRE_CNT_OFLW_STICKY up front. See the IS0076 for a mapping of the counter ID to the counter type."), details: Some("0: Pre counter 0 had an overflow (if sticky bit is set) 1: Pre counter 1 had an overflow ..."), lo: 24, hi: 30 });
        fields.insert("TX_BUF_HIGH_WM", Field { brief: Some("Determines the required fill level that must be EXCEEDED before the buffer full signal to the DSM is asserted."), details: Some("0: The 'buffer full' signal is asserted as soon as the Tx FIFO holds any data 1: The 'buffer full' signal is asserted if the Tx FIFO holds more than 1 data word 2: The 'buffer full' signal is asserted if the Tx FIFO holds more than 2 data word ... 31: The 'buffer full' signal is disabled"), lo: 8, hi: 13 });
        fields.insert("TX_MAX_FILL_LVL", Field { brief: Some("Stores the maximum reach TX FiFo fill level."), details: Some("0: Max fill level was zero 1: Max fill level was one ..."), lo: 16, hi: 21 });
        fields.insert("TX_MAX_FILL_LVL_CLR_ONE_SHOT", Field { brief: Some("Clears TX_MAX_FILL_LVL that holds the maximal reached TX FiFo fill level. This bit is a one shot bit that is clear automatically by hardware."), details: Some("0: No action 1: Clear TX_MAX_FILL_LVL (Bit is automatically cleared)"), lo: 23, hi: 24 });
        regs.insert("DEV_DBG_CFG", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Device Debug Config"), details: Some("Device1G Debug Configuration Register"), fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_PROTECT_ENA", Field { brief: Some("Enables snooping of egress data from another port. The port from which egress data is copied and transmitted at the Ethernet port is determined by the PORT_PROTECT_ID configuration."), details: Some("0: Port protection is disabled 1: Port protection is enabled"), lo: 0, hi: 1 });
        fields.insert("PORT_PROTECT_ID", Field { brief: Some("Indicates from which port egress data must be copied and transmitted at this Ethernet port. The port from which egress data is copied must always be a port that is closer to the ASM. I.e. DEV_X may be configured to snoop egress data destined for DEV_X+n, where DEV_X+n is closer to the ASM - but NOT vice versa."), details: Some("0: Reserved 1: Egress data destined for DEV_1 is also transmitted by this device 2: Egress data destined for DEV_2 is also transmitted by this device ..."), lo: 4, hi: 7 });
        regs.insert("DEV_PORT_PROTECT", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Configuration for the port protectio feature"), details: Some("This register is used to configure the port protection feature of the device."), fields });
        let mut fields = HashMap::new();
        fields.insert("MAC_RX_RST", Field { brief: Some("Reset the MAC rx clock domain in the DEV1G. The setup registers in the DEV1G is not affected by this reset."), details: Some("0: No reset 1: Reset. Note: MAC_RX_RST is NOT a one-shot operation. The clock domain remains reset until a '0' is written to MAC_RX_RST."), lo: 0, hi: 1 });
        fields.insert("MAC_TX_RST", Field { brief: Some("Reset the MAC tx clock domain in the DEV1G. The setup registers in the DEV1G is not affected by this reset."), details: Some("0: No reset 1: Reset. Note: MAC_TX_RST is NOT a one-shot operation. The clock domain remains reset until a '0' is written to MAC_TX_RST."), lo: 4, hi: 5 });
        fields.insert("PCS_RX_RST", Field { brief: Some("Reset the PCS rx clock domain in the DEV1G. The setup registers in the DEV1G is not affected by this reset."), details: Some("0: No reset 1: Reset. Note: PCS_RX_RST is NOT a one-shot operation. The clock domain remains reset until a '0' is written to PCS_RX_RST."), lo: 8, hi: 9 });
        fields.insert("PCS_TX_RST", Field { brief: Some("Reset the PCS tx clock domain in the DEV1G. The setup registers in the DEV1G is not affected by this reset."), details: Some("0: No reset 1: Reset. Note: PCS_TX_RST is NOT a one-shot operation. The clock domain remains reset until a '0' is written to PCS_TX_RST."), lo: 12, hi: 13 });
        fields.insert("SPEED_SEL", Field { brief: Some("This register selects the port data rate. The no clock options is intended to save power for unused ports."), details: Some("0: 10 Mbps 1: 100 Mbps 2: 1000 Mbps 3: No clock."), lo: 20, hi: 22 });
        regs.insert("DEV_RST_CTRL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("DEV_RST_CTRL register"), details: Some("Clock/Reset Control Register"), fields });
        let mut fields = HashMap::new();
        fields.insert("PRE_CNT_OFLW_STICKY", Field { brief: Some("Will be set if one of the statistics pre counter have an overflow."), details: Some("0: No pre counter had an overflow 1: (At least) one of the pre counters had an overflow Bit is cleared by writing a 1 to this position."), lo: 11, hi: 12 });
        fields.insert("RX_OFLW_STICKY", Field { brief: Some("Indicates that an overflow has occured in the Rx Taxi FIFO."), details: Some("0: No overflow has occured in the Rx Taxi FIFO 1: An overflow has occured in the Rx Taxi FIFO Bit is cleared by writing a 1 to this position."), lo: 10, hi: 11 });
        fields.insert("SD_STICKY", Field { brief: Some("Signal detect failure sticky bit."), details: Some("0: No signal detect failure occurred 1: Signal detect failures occurred Bit is cleared by writing a 1 to this position."), lo: 14, hi: 15 });
        fields.insert("TX_EOF_STICKY", Field { brief: Some("Indicates that a missing EOF has been detected in the Tx path of the DEV1G."), details: Some("0: Missing EOF has not been detected 1: Missing EOF has been detected Bit is cleared by writing a 1 to this position."), lo: 3, hi: 4 });
        fields.insert("TX_OFLW_STICKY", Field { brief: Some("Indicates that an overflow has occured in the Tx FIFO."), details: Some("0: No buffer overflow has occured 1: A buffer overflow has occured Bit is cleared by writing a 1 to this position."), lo: 1, hi: 2 });
        fields.insert("TX_SOF_STICKY", Field { brief: Some("Indicates that a missing SOF has been detected in the Tx path of the DEV1G."), details: Some("0: Missing SOF has not been detected 1: Missing SOF has been detected Bit is cleared by writing a 1 to this position."), lo: 2, hi: 3 });
        fields.insert("TX_TAXI_PROT_ERR_STICKY", Field { brief: Some("Sticky bit that indicates a protocol error on the taxi input interface."), details: Some("0: No tx taxi protocol error has occured 1: One or more tx taxi protocol errors have occured Bit is cleared by writing a 1 to this position."), lo: 12, hi: 13 });
        fields.insert("TX_UFLW_STICKY", Field { brief: Some("Indicates that the Tx Resync FIFO has not been able to supply enough data to the MAC during frame transmission. The device automatically aborts the frame transmission."), details: Some("0: No buffer underflow detected 1: Buffer underflow detected Bit is cleared by writing a 1 to this position."), lo: 0, hi: 1 });
        regs.insert("DEV_STICKY", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Sticky bit Register"), details: Some("Clear the sticky bits by writing a '1' in the relevant bitgroups."), fields });
        let mut fields = HashMap::new();
        fields.insert("EEE_ENA", Field { brief: Some("Enable EEE operation on the port. A port enters the low power mode when no egress queues have data ready. The port is activated when one of the following conditions is true: - A queue has been non-empty for EEE_TIMER_AGE. - A queue has more than EEE_HIGH_FRAMES frames pending. - A queue has more than EEE_HIGH_BYTES bytes pending. - A queue is marked as a fast queue, and has data pending."), details: None, lo: 22, hi: 23 });
        fields.insert("EEE_TIMER_AGE", Field { brief: Some("Maximum time frames in any queue must wait before the port is activated. The default value corresponds to 48 us."), details: Some("Time = 4**(EEE_TIMER_AGE/16) * (EEE_TIMER_AGE mod 16) microseconds"), lo: 15, hi: 22 });
        fields.insert("EEE_TIMER_HOLDOFF", Field { brief: Some("When all queues are empty, the port is kept active until this time has passed. Default value corresponds to 5 us."), details: Some("Time = 4**(EEE_TIMER_HOLDOFF/16) * (EEE_TIMER_HOLDOFF mod 16) microseconds"), lo: 1, hi: 8 });
        fields.insert("EEE_TIMER_WAKEUP", Field { brief: Some("Time from the egress port is activated until frame transmission is restarted. Default value corresponds to 16 us."), details: Some("Time = 4**(EEE_TIMER_WAKEUP/16) * (EEE_TIMER_WAKEUP mod 16) microseconds"), lo: 8, hi: 15 });
        fields.insert("PORT_LPI", Field { brief: Some("Status bit indicating whether port is in low-power-idle due to the LPI algorithm (EEE_CFG). If set, transmissions are held back."), details: None, lo: 0, hi: 1 });
        regs.insert("EEE_CFG", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Control Energy Efficient Ethernet operation."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PTP_DOM", Field { brief: Some("Configures the time domain this port is assigned to. This domain assignment must be made before the central counters in DEVCPU block is enabled."), details: None, lo: 20, hi: 22 });
        fields.insert("PTP_ENA", Field { brief: Some("Disable PTP on the port"), details: None, lo: 22, hi: 23 });
        fields.insert("PTP_IF_MODE", Field { brief: Some("Bit rate for the physical interface. 0: 5Gbps(QSGMII), 1: 1.25Gbps SGMII), 2: 3.125 Gbps, 3: reserved"), details: Some("0: 5Gbps (QSGMII) 1: 1.125 Gbps (SGMII) 2: 3.125 Gbps (SGMII-2.5) 3: Reserved"), lo: 18, hi: 20 });
        fields.insert("PTP_RX_IO_DLY", Field { brief: Some("Time in ns to subtract from timestamper in the ingress direction to compensate for static delay through the physical encoding layers."), details: None, lo: 9, hi: 18 });
        fields.insert("PTP_TX_IO_DLY", Field { brief: Some("Time in ns to add to timestamper in the egress direction to compensate for static delay through the physical encoding layers."), details: None, lo: 0, hi: 9 });
        regs.insert("PTP_CFG", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("PTP Configuration per port"), details: None, fields });
        groups.insert("DEV_CFG_STATUS", RegisterGroup { addr: Address { base: 0, count: 1, width: 7 }, desc: "Dev1g Configuration and Status Registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("LEN_DROP_ENA", Field { brief: Some("Length Drop Enable:\\nConfigures the Receive Module to drop frames in reference to in-range and out-of-range errors:"), details: Some("'0': Length Drop Disabled '1': Length Drop Enabled."), lo: 0, hi: 1 });
        regs.insert("MAC_ADV_CHK_CFG", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Advanced Check Feature Configuration Register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_ENA", Field { brief: Some("Receiver Module Enable."), details: Some("'0': Receiver Module Disabled '1': Receiver Module Enabled"), lo: 4, hi: 5 });
        fields.insert("TX_ENA", Field { brief: Some("Transmitter Module Enable."), details: Some("'0': Transmitter Module Disabled '1': Transmitter Module Enabled"), lo: 0, hi: 1 });
        regs.insert("MAC_ENA_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Mode Configuration Register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BYPASS_COL_SYNC", Field { brief: Some("Bypass 2-step synchronization of collision signal gmii_col in defer and backoff logic to allow for optimized collision handling in half duplex modes"), details: Some("'0': Do not bypass gmii_col sync stage '1': Bypass gmii_col sync stage"), lo: 26, hi: 27 });
        fields.insert("LATE_COL_POS", Field { brief: Some("Adjustment of early/late collision boundary:\\nThis bitgroup is used to adjust the MAC so that a collision on a shared transmission medium before bit 512 is handled as an early collision, whereas a collision after bit 512 is handled as a late collision, i.e. no retransmission is performed."), details: None, lo: 0, hi: 7 });
        fields.insert("RETRY_AFTER_EXC_COL_ENA", Field { brief: Some("This bit is used to setup the MAC to retransmit a frame after an early collision even though 16 (or more) early collisions have occurred. This feature violates the IEEE 802.3 standard and should only be used when running in HDX flow control, which is not defined in the IEEE standard anyway."), details: Some("'0': A frame will be discarded and counted as an excessive collision if 16 collisions occur for this frame. '1': The MAC will retransmit a frame after an early collision, regardless of the number of previous early collisions. The backoff sequence will be reset after every 16 collisions."), lo: 8, hi: 9 });
        fields.insert("SEED", Field { brief: Some("Seed value loaded into the PRBS of the MAC."), details: Some("Used to prevent excessive collision events."), lo: 16, hi: 24 });
        fields.insert("SEED_LOAD", Field { brief: Some("Load SEED value into PRNG register. A SEED value is loaded into the PRNG register of the MAC, when SEED_LOAD is asserted. After a load, the SEED_LOAD must be deasserted."), details: Some("'0': Do not load SEED value '1': Load SEED value."), lo: 12, hi: 13 });
        regs.insert("MAC_HDX_CFG", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Half Duplex Configuration Register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RESTORE_OLD_IPG_CHECK", Field { brief: Some("This configuration bit allows to relax the minimum IPG check to 11 symbols instead of 12. If the IPG is below 12 (or 11 if relaxed mode is enabled) the IPG_SHRINK statistics counter is incremented."), details: Some("'0' Normal mode (check for minimum IPG of 12 symbols) '1' Relaxed mode (check for minimum IPG of 11 symbols)"), lo: 17, hi: 18 });
        fields.insert("RX_IFG1", Field { brief: Some("Used to adjust the duration of the first part of the inter-frame gap in the Rx direction and must be set according to the speed settings."), details: Some("TBA: Add correct values found by validation. 10/100 Mbps: 0xXX 1000 Mbps: 0xXX."), lo: 0, hi: 4 });
        fields.insert("RX_IFG2", Field { brief: Some("Used to adjust the duration of the second part of the inter-frame gap in the Rx direction and must be set according to the speed and duplex settings."), details: Some("TBA: Add correct values found by validation. 10/100 Mbps, HDX, FDX: 0xXX, 0xXX 1000 Mbps: 0xXX."), lo: 4, hi: 8 });
        fields.insert("TX_IFG", Field { brief: Some("Used to adjust the duration of the inter-frame gap in the Tx direction and must be set according to the speed and duplex settings."), details: Some("TBA: Add correct values found by validation. 10/100 Mbps, HDX, FDX 0xXX, 0xXX 1000 Mbps: 0xXX."), lo: 8, hi: 13 });
        regs.insert("MAC_IFG_CFG", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Inter Frame Gap Configuration Register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MAX_LEN", Field { brief: Some("The maximum frame length accepted by the Receive Module of the MAC. If the length is exceeded, this is indicated in the Statistics Engine (RX_OVERSIZE). The maximum length is automatically adjusted to accommodate maximum sized frames containing single/double VLAN tag(s) - given that the MAC is configured to be single/double VLAN aware."), details: None, lo: 0, hi: 16 });
        regs.insert("MAC_MAXLEN_CFG", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Max Length Configuration Register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FC_WORD_SYNC_ENA", Field { brief: Some("This bit enables synchronization of Flow Control Jamming to currently used word boundaries (10/100 Mbps mode)."), details: Some("'0' Normal mode, Flow Control Jamming is output as soon as possible '1' Word sync mode, Flow Control Jamming is synchronized 10/100 Mbps word boundaries"), lo: 8, hi: 9 });
        fields.insert("FDX_ENA", Field { brief: Some("Enables Full Duplex:"), details: Some("'0': Half Duplex '1': Full duplex. \\nNote: Full duplex MUST be selected if GIGA_MODE is enabled."), lo: 0, hi: 1 });
        fields.insert("GIGA_MODE_ENA", Field { brief: Some("Enables 1 Gbps mode."), details: Some("'0': 10/100 Mbps mode '1': 1 Gbps mode. Note: FDX MUST be asserted."), lo: 4, hi: 5 });
        regs.insert("MAC_MODE_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Mode Configuration Register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PB_ENA", Field { brief: Some("Provider Bridge Enable (multiple VLAN awareness)"), details: Some("0: The MAC operates in a single VLAN aware mode. 1: The MAC operates in a double VLAN aware mode. 2: The MAC operates in a triple VLAN aware mode. 3: Reserved. For VLAN awareness to take effect VLAN_AWR_ENA must be set to '1'."), lo: 1, hi: 3 });
        fields.insert("TAG_ID", Field { brief: Some("This field defines a 1st programmable VLAN/Service tag (custom TPID 1).\\nThis field together with the TAG_ID2 and TAG_ID3 - as well as the default tags 0x8100 and 0x88A8 - are used for ALL possible tag positions (up to 3). Any order of known VLAN/Service tags (0x8100, 0x88A8, TAG_ID, TAG_ID2, TAG_ID3) is found. VLAN/Service tag awareness depends on VLAN_AWR_ENA and PB_ENA."), details: None, lo: 16, hi: 32 });
        fields.insert("VLAN_AWR_ENA", Field { brief: Some("VLAN Awareness: Enables the MAC to work in a VLAN aware environment."), details: Some("'0': VLAN awareness disabled. '1': VLAN awareness enabled."), lo: 0, hi: 1 });
        fields.insert("VLAN_LEN_AWR_ENA", Field { brief: Some("When set, single, double and triple tagged frames are allowed to be 4/8/12 bytes longer than the MAXLEN configuration."), details: None, lo: 3, hi: 4 });
        regs.insert("MAC_TAGS_CFG", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("VLAN / Service tag configuration register"), details: Some("The MAC can be configured to accept 0, 1 and 2 tags and the TAG value can be user-defined."), fields });
        let mut fields = HashMap::new();
        fields.insert("TAG_ID2", Field { brief: Some("This field defines a 2nd programmable VLAN/Service tag (custom TPID 2)."), details: Some("tbd"), lo: 0, hi: 16 });
        fields.insert("TAG_ID3", Field { brief: Some("This field defines a 3rd programmable VLAN/Service tag (custom TPID 3)."), details: Some("tbd"), lo: 16, hi: 32 });
        regs.insert("MAC_TAGS_CFG2", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("VLAN / Service tag configuration register2"), details: Some("This register contains two additional freely programmable custom VLAN tags."), fields });
        let mut fields = HashMap::new();
        fields.insert("CF_TOO_BIG_STICKY", Field { brief: Some("The correction field update went out of range. Valid range is -2^47 to 2^48-1. The frame CF will be changed to the maximum value. This range check is bypassed if ADDS48 mode is in use on the ingress or egress port."), details: None, lo: 0, hi: 1 });
        regs.insert("PTP_EVENTS", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("PTP events per port"), details: None, fields });
        groups.insert("MAC_CFG_STATUS", RegisterGroup { addr: Address { base: 7, count: 1, width: 9 }, desc: "MAC1G Configuration and Status Registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("RX_IPG_SHRINK_STICKY", Field { brief: Some("Sticky bit indicating that an inter packet gap shrink was detected (IPG < 12 bytes)."), details: None, lo: 9, hi: 10 });
        fields.insert("RX_JUNK_STICKY", Field { brief: Some("Sticky bit indicating that junk was received (bytes not recognized as a frame)."), details: Some("'0': no junk was received '1': junk was received one or more times Bit is cleared by writing a '1' to this position."), lo: 5, hi: 6 });
        fields.insert("RX_PREAM_SHRINK_STICKY", Field { brief: Some("Sticky bit indicating that a preamble shrink was detected (preamble < 8 bytes)."), details: Some("'0': no preamble shrink was detected '1': a preamble shrink was detected one or more times Bit is cleared by writing a '1' to this position."), lo: 8, hi: 9 });
        fields.insert("TX_ABORT_STICKY", Field { brief: Some("Sticky bit indicating that the transmit host initiated abort was executed."), details: None, lo: 0, hi: 1 });
        fields.insert("TX_FIFO_OFLW_STICKY", Field { brief: Some("Sticky bit indicating that the MAC transmit FIFO has overrun."), details: None, lo: 2, hi: 3 });
        fields.insert("TX_JAM_STICKY", Field { brief: Some("Sticky bit indicating that the transmit host issued a jamming signal."), details: Some("'0': the transmit host issued no jamming signal '1': the transmit host issued one or morejamming signals Bit is cleared by writing a '1' to this position."), lo: 3, hi: 4 });
        fields.insert("TX_RETRANSMIT_STICKY", Field { brief: Some("Sticky bit indicating that the transmit MAC asked the host for a frame retransmission."), details: Some("'0': no tx retransmission was initiated '1': one or more tx retransmissions were initiated Bit is cleared by writing a '1' to this position."), lo: 4, hi: 5 });
        regs.insert("MAC_STICKY", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("Sticky Bit Register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ADV_ABILITY", Field { brief: Some("Advertised Ability Register: Holds the capabilities of the device as described IEEE 802.3, Clause 37."), details: None, lo: 16, hi: 32 });
        fields.insert("ANEG_ENA", Field { brief: Some("Auto Negotiation Enable"), details: Some("0: Auto Negotiation Disabled 1: Auto Negotiation Enabled"), lo: 0, hi: 1 });
        fields.insert("ANEG_RESTART_ONE_SHOT", Field { brief: Some("Auto Negotiation Restart"), details: Some("0: No action 1: Restart Auto Negotiation"), lo: 1, hi: 2 });
        fields.insert("SW_RESOLVE_ENA", Field { brief: Some("Software Resolve Abilities"), details: Some("0: If Auto Negotiation fails (no matching HD or FD capabilities) the link is disabled 1: The result of an Auto Negotiation is ignored - the link can be setup via software. This bit must be set in SGMII mode."), lo: 8, hi: 9 });
        regs.insert("PCS1G_ANEG_CFG", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("PCS1G Aneg Configuration"), details: Some("PCS1G Auto-negotiation configuration register"), fields });
        let mut fields = HashMap::new();
        fields.insert("NP_LOADED_ONE_SHOT", Field { brief: Some("Next page loaded"), details: Some("0: next page is free and can be loaded 1: next page register has been filled (to be set after np_tx has been filled)"), lo: 0, hi: 1 });
        fields.insert("NP_TX", Field { brief: Some("Next page register: Holds the next-page information as described in IEEE 802.3, Clause 37"), details: None, lo: 16, hi: 32 });
        regs.insert("PCS1G_ANEG_NP_CFG", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("PCS1G Aneg Next Page Configuration"), details: Some("PCS1G Auto-negotiation configuration register for next-page function"), fields });
        let mut fields = HashMap::new();
        fields.insert("LP_NP_RX", Field { brief: Some("Next page ability register from link partner as described in IEEE 802.3, Clause 37"), details: None, lo: 16, hi: 32 });
        regs.insert("PCS1G_ANEG_NP_STATUS", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("PCS1G Aneg Next Page Status Register"), details: Some("PCS1G Auto-negotiation next page status register"), fields });
        let mut fields = HashMap::new();
        fields.insert("ANEG_COMPLETE", Field { brief: Some("Auto Negotiation Complete"), details: Some("0: No Auto Negotiation has been completed 1: Indicates that an Auto Negotiation has completed successfully"), lo: 0, hi: 1 });
        fields.insert("LP_ADV_ABILITY", Field { brief: Some("Advertised abilities from link partner as described in IEEE 802.3, Clause 37"), details: None, lo: 16, hi: 32 });
        fields.insert("PAGE_RX_STICKY", Field { brief: Some("Status indicating whether a new page has been received."), details: Some("0: No new page received 1: New page received Bit is cleared by writing a 1 to this position."), lo: 3, hi: 4 });
        fields.insert("PR", Field { brief: Some("Resolve priority"), details: Some("0: ANEG is in progress 1: ANEG nearly finished - priority can be resolved (via software)"), lo: 4, hi: 5 });
        regs.insert("PCS1G_ANEG_STATUS", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("PCS1G ANEG Status Register"), details: Some("PCS1G Auto-negotiation status register"), fields });
        let mut fields = HashMap::new();
        fields.insert("CDET_ENA", Field { brief: Some("Enable comma detection and code-group alignment"), details: Some("0: Comma detection disabled 1: Comma detection enabled"), lo: 0, hi: 1 });
        regs.insert("PCS1G_CDET_CFG", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("PCS1G comma detection Configuration"), details: Some("PCS1G comma detection configuration"), fields });
        let mut fields = HashMap::new();
        fields.insert("AN_LINK_CTRL_ENA", Field { brief: Some("Enable Link control via Backplane Ethernet ANEG"), details: Some("0: Disable link control 1: Enable link control"), lo: 1, hi: 2 });
        fields.insert("LINK_STATUS_TYPE", Field { brief: Some("Set type of link_status indication at CPU-System"), details: Some("0: Sync_status (from PCS synchronization state machine) 1: Bit 15 of PCS1G_ANEG_STATUS.lp_adv_ability (Link up/down)"), lo: 4, hi: 5 });
        fields.insert("PCS_ENA", Field { brief: Some("PCS enable"), details: Some("0: Disable PCS 1: Enable PCS"), lo: 0, hi: 1 });
        regs.insert("PCS1G_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("PCS1G Configuration"), details: Some("PCS1G main configuration register"), fields });
        let mut fields = HashMap::new();
        fields.insert("UDLT", Field { brief: Some("Use Debug Link Timer"), details: Some("0: Normal 10 ms (1.6 ms in sgmii mode) timer is selected 1: Reduced 9.77 us (1.56 us in sgmii mode) timer is selected"), lo: 0, hi: 1 });
        regs.insert("PCS1G_DBG_CFG", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("PCS1G Debug Configuration"), details: Some("PCS1G Debug configuration register"), fields });
        let mut fields = HashMap::new();
        fields.insert("XMIT_MODE", Field { brief: Some("Indicates the mode of the TBI"), details: Some("00: Idle mode 01: Configuration mode 10: Reserved 11: Data mode"), lo: 12, hi: 14 });
        regs.insert("PCS1G_DEBUG_STATUS", Register { addr: Address { base: 13, count: 1, width: 1 }, brief: Some("PCS1G debug status"), details: Some("PCS1G debug status register"), fields });
        let mut fields = HashMap::new();
        fields.insert("GMII_PHY_LB_ENA", Field { brief: Some("Loops data in PCS (GMII side) from ingress direction to egress direction. Rate adaption is automatically performed in a FIFO within the PCS"), details: Some("0: GMII Loopback Disabled 1:GMII Loopback Enabled"), lo: 1, hi: 2 });
        fields.insert("RA_ENA", Field { brief: Some("Enable rate adaption capability in PCS receive direction explicitely (required when PHY data looped back within MAC)"), details: Some("0: Disable 1: Enable"), lo: 4, hi: 5 });
        fields.insert("TBI_HOST_LB_ENA", Field { brief: Some("Loops data in PCS (TBI side) from egress direction to ingress direction. The Rx clock is automatically set equal to the Tx clock"), details: Some("0: TBI Loopback Disabled 1:TBI Loopback Enabled"), lo: 0, hi: 1 });
        regs.insert("PCS1G_LB_CFG", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("PCS1G Loopback Configuration"), details: Some("PCS1G Loop-Back configuration register"), fields });
        let mut fields = HashMap::new();
        fields.insert("LINK_DOWN_CNT", Field { brief: Some("Link Down Counter. A counter that counts the number of times a link has been down. The counter does not saturate at 255 and is only cleared when writing 0 to the register"), details: None, lo: 0, hi: 8 });
        regs.insert("PCS1G_LINK_DOWN_CNT", Register { addr: Address { base: 11, count: 1, width: 1 }, brief: Some("PCS1G link down counter"), details: Some("PCS1G link down counter register"), fields });
        let mut fields = HashMap::new();
        fields.insert("DELAY_VAR", Field { brief: Some("Additional delay in rx-path; multiply the value of this field by the line-rate bit-period (800ps for 10/100/1000, 320ps for 2G5 mode.) This field is valid when the link is up, it remains constant for as long as the link is up, value may cange on link-down event. This field shows the number of data bits that is stored in the rx comma-alignment block, values of 0-9 is possible."), details: None, lo: 12, hi: 16 });
        fields.insert("LINK_STATUS", Field { brief: Some("Indicates whether the link is up or down. A link is up when ANEG state machine is in state LINK_OK or AN_DISABLE_LINK_OK"), details: Some("0: Link down 1: Link up"), lo: 4, hi: 5 });
        fields.insert("SIGNAL_DETECT", Field { brief: Some("Indicates whether or not the selected Signal Detect input line is asserted"), details: Some("0: No signal detected 1: Signal detected"), lo: 8, hi: 9 });
        fields.insert("SYNC_STATUS", Field { brief: Some("Indicates if PCS has successfully synchronized"), details: Some("0: PCS is out of sync 1: PCS has synchronized"), lo: 0, hi: 1 });
        regs.insert("PCS1G_LINK_STATUS", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("PCS1G link status"), details: Some("PCS1G link status register"), fields });
        let mut fields = HashMap::new();
        fields.insert("LPI_TESTMODE", Field { brief: Some("LPI-Timer test mode."), details: Some("0: Normal timing constants are used 1: Shortened timing constants are used"), lo: 16, hi: 17 });
        fields.insert("QSGMII_MS_SEL", Field { brief: Some("QSGMII master/slave selection (only one master allowed per QSGMII). The master drives LPI timing on serdes"), details: Some("0: Slave 1: Master"), lo: 20, hi: 21 });
        fields.insert("RX_LPI_OUT_DIS", Field { brief: Some("Disable output of Low-Power Idle in receive direction (to core)"), details: Some("0: Enable 1: Disable"), lo: 17, hi: 18 });
        fields.insert("TX_ASSERT_LPIDLE", Field { brief: Some("Assert Low-Power Idle (LPI) in transmit mode"), details: Some("0: Disable LPI transmission 1: Enable LPI transmission"), lo: 0, hi: 1 });
        regs.insert("PCS1G_LPI_CFG", Register { addr: Address { base: 14, count: 1, width: 1 }, brief: Some("PCS1G Low Power Idle Configuration"), details: Some("Configuration register for Low Power Idle (Energy Efficient Ethernet)"), fields });
        let mut fields = HashMap::new();
        fields.insert("WAKE_ERROR_CNT", Field { brief: Some("Wake Error Counter. A counter that is incremented when the link partner does not send wake-up burst in due time. The counter saturates at 65535 and is cleared when writing 0 to the register"), details: None, lo: 0, hi: 16 });
        regs.insert("PCS1G_LPI_WAKE_ERROR_CNT", Register { addr: Address { base: 15, count: 1, width: 1 }, brief: Some("PCS1G wake error counter"), details: Some("PCS1G Low Power Idle wake error counter (Energy Efficient Ethernet)"), fields });
        let mut fields = HashMap::new();
        fields.insert("SGMII_MODE_ENA", Field { brief: Some("Selection of PCS operation"), details: Some("0: PCS is used in SERDES mode 1: PCS is used in SGMII mode"), lo: 0, hi: 1 });
        fields.insert("UNIDIR_MODE_ENA", Field { brief: Some("Unidirectional mode enable. Implementation of 802.3, Clause 66. When asserted, this enables MAC to transmit data independent of the state of the receive link."), details: Some("0: Unidirectional mode disabled 1: Unidirectional mode enabled"), lo: 4, hi: 5 });
        regs.insert("PCS1G_MODE_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("PCS1G Mode Configuration"), details: Some("PCS1G mode configuration"), fields });
        let mut fields = HashMap::new();
        fields.insert("SD_ENA", Field { brief: Some("Signal Detect Enable"), details: Some("0: The Signal Detect input pin is ignored. The PCS assumes an active Signal Detect at all times 1: The Signal Detect input pin is used to determine if a signal is detected"), lo: 0, hi: 1 });
        fields.insert("SD_POL", Field { brief: Some("Signal detect polarity: The signal level on signal_detect input pin must be equal to SD_POL to indicate signal detection (SD_ENA must be set)"), details: Some("0: Signal Detect input pin must be '0' to indicate a signal detection 1: Signal Detect input pin must be '1' to indicate a signal detection"), lo: 4, hi: 5 });
        fields.insert("SD_SEL", Field { brief: Some("Signal detect selection (select input for internal signal_detect line)"), details: Some("0: Select signal_detect line from hardmacro 1: Select external signal_detect line"), lo: 8, hi: 9 });
        regs.insert("PCS1G_SD_CFG", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("PCS1G Signal Detect Configuration"), details: Some("PCS1G signal_detect configuration"), fields });
        let mut fields = HashMap::new();
        fields.insert("LINK_DOWN_STICKY", Field { brief: Some("The sticky bit is set when the link has been down - i.e. if the ANEG state machine has not been in the AN_DISABLE_LINK_OK or LINK_OK state for one or more clock cycles. This occurs if e.g. ANEG is restarted or for example if signal-detect or synchronization has been lost for more than 10 ms (1.6 ms in SGMII mode). By setting the UDLT bit, the required down time can be reduced to 9,77 us (1.56 us)"), details: Some("0: Link is up 1: Link has been down Bit is cleared by writing a 1 to this position."), lo: 4, hi: 5 });
        fields.insert("OUT_OF_SYNC_STICKY", Field { brief: Some("Sticky bit indicating if PCS synchronization has been lost"), details: Some("0: Synchronization has not been lost at any time 1: Synchronization has been lost for one or more clock cycles Bit is cleared by writing a 1 to this position."), lo: 0, hi: 1 });
        regs.insert("PCS1G_STICKY", Register { addr: Address { base: 12, count: 1, width: 1 }, brief: Some("PCS1G sticky register"), details: Some("PCS1G status register for sticky bits"), fields });
        groups.insert("PCS1G_CFG_STATUS", RegisterGroup { addr: Address { base: 16, count: 1, width: 17 }, desc: "PCS 1G Configuration Status Registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("RX_LPI_EVENT_STICKY", Field { brief: Some("Receiver Low-Power idle occurrence"), details: Some("0: No LPI symbols received 1: Receiver has received LPI symbols Bit is cleared by writing a 1 to this position."), lo: 12, hi: 13 });
        fields.insert("RX_LPI_MODE", Field { brief: Some("Receiver Low-Power Idle mode"), details: Some("0: Receiver not in low power idle mode 1: Receiver is in low power idle mode"), lo: 8, hi: 9 });
        fields.insert("RX_QUIET", Field { brief: Some("Receiver Low-Power Quiet mode"), details: Some("0: Receiver not in quiet mode 1: Receiver is in quiet mode"), lo: 9, hi: 10 });
        fields.insert("TX_LPI_EVENT_STICKY", Field { brief: Some("Transmitter Low-Power idle occurrence"), details: Some("0: No LPI symbols transmitted 1: Transmitter has transmitted LPI symbols Bit is cleared by writing a 1 to this position."), lo: 4, hi: 5 });
        fields.insert("TX_LPI_MODE", Field { brief: Some("Transmitter Low-Power Idle mode"), details: Some("0: Transmitter not in low power idle mode 1: Transmitter is in low power idle mode"), lo: 0, hi: 1 });
        fields.insert("TX_QUIET", Field { brief: Some("Transmitter Low-Power Quiet mode"), details: Some("0: Transmitter not in quiet mode 1: Transmitter is in quiet mode"), lo: 1, hi: 2 });
        regs.insert("PCS1G_LPI_STATUS", Register { addr: Address { base: 16, count: 1, width: 1 }, brief: Some("PCS1G Low Power Idle Status"), details: Some("Status register for Low Power Idle (Energy Efficient Ethernet)"), fields });
        let mut fields = HashMap::new();
        fields.insert("JTP_SEL", Field { brief: Some("Jitter Test Pattern Select: Enables and selects the jitter test pattern to be transmitted. The jitter test patterns are according to the IEEE 802.3, Annex 36A"), details: Some("0: Disable transmission of test patterns 1: High frequency test pattern - repeated transmission of D21.5 code group 2: Low frequency test pattern - repeated transmission of K28.7 code group 3: Mixed frequency test pattern - repeated transmission of K28.5 code group 4: Long continuous random test pattern (packet length is 1524 bytes) 5: Short continuous random test pattern (packet length is 360 bytes)"), lo: 0, hi: 3 });
        regs.insert("PCS1G_TSTPAT_MODE_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("PCS1G TSTPAT MODE CFG"), details: Some("PCS1G testpattern mode configuration register (Frame based pattern 4 and 5 might be not available depending on chip type)"), fields });
        groups.insert("PCS1G_TSTPAT_CFG_STATUS", RegisterGroup { addr: Address { base: 33, count: 1, width: 2 }, desc: "PCS1G Testpattern Configuration and Status Registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("JTP_ERR", Field { brief: Some("Jitter Test Pattern Error"), details: Some("0: Jitter pattern checker has found no error 1: Jitter pattern checker has found an error"), lo: 4, hi: 5 });
        fields.insert("JTP_ERR_CNT", Field { brief: Some("Jitter Test Pattern Error Counter. Due to re-sync measures it might happen that single errors are not counted (applies for 2.5gpbs mode). The counter saturates at 255 and is only cleared when writing 0 to the register"), details: None, lo: 8, hi: 16 });
        fields.insert("JTP_LOCK", Field { brief: Some("Jitter Test Pattern Lock"), details: Some("0: Jitter pattern checker has not locked 1: Jitter pattern checker has locked"), lo: 0, hi: 1 });
        regs.insert("PCS1G_TSTPAT_STATUS", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("PCS1G TSTPAT STATUS"), details: Some("PCS1G testpattern status register"), fields });
        groups.insert("PCS_FX100_CONFIGURATION", RegisterGroup { addr: Address { base: 35, count: 1, width: 1 }, desc: "PCS FX100 Configuration Registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("FEFCHK_ENA", Field { brief: Some("Far-End Fault (FEF) detection enable"), details: Some("0: Disable FEF detection 1 Enable FEF detection"), lo: 2, hi: 3 });
        fields.insert("FEFGEN_ENA", Field { brief: Some("Far-End Fault (FEF) generation enable"), details: Some("0: Disable FEF generation 1 Enable FEF generation"), lo: 1, hi: 2 });
        fields.insert("LINKHYSTTIMER", Field { brief: Some("Link hysteresis timer configuration. The hysteresis time lasts [linkhysttimer] * 65536 ns + 2320 ns. If linkhysttime is set to 5, the hysteresis lasts the minimum time of 330 us as specified in IEEE802.3 - 24.3.3.4."), details: None, lo: 4, hi: 8 });
        fields.insert("LINKHYST_TM_ENA", Field { brief: Some("Link hysteresis timer test mode. When enabled, [linkhysttimer] steps are reduced from 65536 ns to 2048 ns."), details: Some("1: Enable test mode 0: Disable test mode"), lo: 8, hi: 9 });
        fields.insert("LOOPBACK_ENA", Field { brief: Some("Testloop, if enabled 4B5B encoded data are looped from TX path to RX path just before the SERDES"), details: Some("1: Enable loop 0: Disable loop"), lo: 20, hi: 21 });
        fields.insert("PCS_ENA", Field { brief: Some("PCS enable"), details: Some("0: Disable PCS 1: Enable PCS"), lo: 0, hi: 1 });
        fields.insert("RXBITSEL", Field { brief: Some("Select single bit from incomming 10-bit Deserializer value. Change is only required in case CP/MD handling incorrect in Clock and Data Recovery logic"), details: None, lo: 12, hi: 16 });
        fields.insert("SD_ENA", Field { brief: Some("Signal Detect Enable"), details: Some("0: The Signal Detect input pin is ignored. The PCS assumes an active Signal Detect at all times 1: The Signal Detect input pin is used to determine if a signal is detected"), lo: 24, hi: 25 });
        fields.insert("SD_POL", Field { brief: Some("Signal detect polarity: The signal level on signal_detect input pin must be equal to SD_POL to indicate signal detection (SD_ENA must be set). Use '1' when SD_SEL is set to hardmacro."), details: Some("0: Signal Detect input pin must be '0' to indicate a signal detection 1: Signal Detect input pin must be '1' to indicate a signal detection"), lo: 25, hi: 26 });
        fields.insert("SD_SEL", Field { brief: Some("Signal detect selection (select input for internal signal_detect line)"), details: Some("0: Select signal_detect line from hardmacro 1: Select external signal_detect line"), lo: 26, hi: 27 });
        fields.insert("SIGDET_CFG", Field { brief: Some("Influence of rx toggle-rate on signal_detect. Signal detect is forced to 0 after a programable number of missing edges on rx bit-stream"), details: Some("0: No influence 1: Force to 0 after 50 cycles without edge 2: Force to 0 after 10 cycles without edge 3: Force to 0 after 5 cycles without edge"), lo: 9, hi: 11 });
        fields.insert("SWAP_MII_ENA", Field { brief: Some("Swap transmission/receive order of MII nibbles"), details: Some("0: Lower nibble of GMII byte is transferred/received first 1: Upper nibble of GMII byte is transferred/received first"), lo: 16, hi: 17 });
        fields.insert("UNIDIR_MODE_ENA", Field { brief: Some("Unidirectional mode enable. Implementation 0f 802.3 clause 66. When asserted, this enables MAC to transmit data independent of the state of the receive link."), details: Some("0: Unidirectional mode disabled 1: Unidirectional mode enabled"), lo: 3, hi: 4 });
        regs.insert("PCS_FX100_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("PCS 100Base FX Configuration"), details: Some("Configuration bit groups for 100Base-FX PCS"), fields });
        groups.insert("PCS_FX100_STATUS", RegisterGroup { addr: Address { base: 36, count: 1, width: 1 }, desc: "PCS FX100 Status Registers", regs });
        out.insert("DEV1G", Target { desc: "\\see vtss_target_DEV1G_e The device operates as an interface between the TAXI bus and SGMII macro supporting data rates of 10M, 100M, and 1000Mbps. The device includes PCS, MAC and rate adaption logic.", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("MFG_ID", Field { brief: Some("Manufacturer ID."), details: None, lo: 1, hi: 12 });
        fields.insert("ONE", Field { brief: Some("Always 1."), details: None, lo: 0, hi: 1 });
        fields.insert("PART_ID", Field { brief: Some("Part ID: Part ID for identification of Vitesse Chips."), details: None, lo: 12, hi: 28 });
        fields.insert("REV_ID", Field { brief: Some("Revision ID : Chip revision starting from 0."), details: None, lo: 28, hi: 32 });
        regs.insert("CHIP_ID", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Chip ID register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FEA_STAT", Field { brief: Some("Efuse values. Some of these bits controls the hardware of the chip, others are free for SW to use."), details: None, lo: 0, hi: 32 });
        regs.insert("FEA_STAT", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Encoded features"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("GPR", Field { brief: Some("General purpose register for software development."), details: None, lo: 0, hi: 32 });
        regs.insert("GPR", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("General purpose register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DFT_CLK_MON_ENA", Field { brief: Some("Set to enable the DFT clock monitor feature on the GPIOs."), details: None, lo: 0, hi: 1 });
        fields.insert("DFT_STAT_ENA", Field { brief: Some("Set to enable the DFT STAToutput on the GPIOs."), details: None, lo: 1, hi: 2 });
        regs.insert("HW_CFG", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Various configrations"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SD_HIGH_ENA", Field { brief: Some("Set bits in this field to use 2G5 and 10G signal detects from 3'rd SIO controller instead of default positions inside 1'st and 2'nd controllers. Bit 0 in this field corresponds to dev2g5_0, bit 1 corresponds ot dev2g5_1 and so on. Bit 24 corrsponds to NPI port. Bit 25 corresponds to dev10g_0, bit 26 corresponds to dev10g_1 and so on. For the dev10g devices; signal detect is provided to both the 10g device and the corresponding dev2g5 (see HSIO::HW_CFG.DEV10G_0_MODE for more information.)"), details: None, lo: 0, hi: 29 });
        regs.insert("HW_SGPIO_SD_CFG", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Additional configuration of SGPIO signal detect"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MEM_FAIL", Field { brief: Some("This field is set if a hardware fail has been detected in any of the memories during startup-initialization of the chip. This field is valid after release of reset."), details: None, lo: 0, hi: 1 });
        regs.insert("HW_STAT", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Various status indications"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SOFT_CHIP_RST", Field { brief: Some("Set this field to reset the whole chip. This field is automatically cleared by the reset. Note: It is possible for the VCore to protect itself from this soft-reset, for more info see ICPU_CFG::RESET.CORE_RST_PROTECT."), details: None, lo: 0, hi: 1 });
        fields.insert("SOFT_NON_CFG_RST", Field { brief: Some("Set this field to reset everything except the chip configuration. The reset remains asserted until this field is cleared."), details: None, lo: 2, hi: 3 });
        fields.insert("SOFT_SWC_RST", Field { brief: Some("Set this field to reset the switch core (everything except the SERDES IO and PLL blocks.) This field is automatically cleared by the reset. Note: It is possible for the VCore to protect itself from this soft-reset, for more info see ICPU_CFG::RESET.CORE_RST_PROTECT."), details: None, lo: 1, hi: 2 });
        regs.insert("SOFT_RST", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Reset control register"), details: None, fields });
        groups.insert("CHIP_REGS", RegisterGroup { addr: Address { base: 0, count: 1, width: 8 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CLK_PERIOD", Field { brief: Some("The system clock period given in the clock period in PS divided by 100."), details: Some("Values below 40 are reserved."), lo: 7, hi: 15 });
        fields.insert("DUTY_CYCLE", Field { brief: Some("Define the duty cycle"), details: Some("0x00: Always \"off\" 0xFF: Always \"on\""), lo: 16, hi: 24 });
        fields.insert("FAN_STAT_CFG", Field { brief: Some("Configure behavior of TACH input tick counter, see DEVCPU_GCB::FAN_CNT for more infromation."), details: None, lo: 0, hi: 1 });
        fields.insert("GATE_ENA", Field { brief: Some("Enable gating of the TACH input by the PWM output so that only TACH pulses received when PWM is \"on\" are counted."), details: Some("0: Disabled 1: Enabled"), lo: 2, hi: 3 });
        fields.insert("INV_POL", Field { brief: Some("Define the polarity of the PWM output."), details: Some("0: PWM is logic 1 when \"on\" 1: PWM is logic 0 when \"on\""), lo: 3, hi: 4 });
        fields.insert("PWM_FREQ", Field { brief: Some("Set the frequency of the PWM output"), details: Some("0: 25 kHz 1: 120 Hz 2: 100 Hz 3: 80 Hz 4: 60 Hz 5: 40 Hz 6: 20 Hz 7: 10 Hz"), lo: 4, hi: 7 });
        fields.insert("PWM_OPEN_COL_ENA", Field { brief: Some("Configure the PWM output to be open collector"), details: None, lo: 1, hi: 2 });
        regs.insert("FAN_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Fan controller configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SIO_INTR_IDENT", Field { brief: Some("Shows the currently active interrupts. This register is the result of the SIO_INTR interrupts with the disabled interrupts (from SIO_INTR_ENA and SIO_GPIO_INTR_ENA) removed."), details: Some("0: No active interrupt for given gpio 1: Active interrupt for given gpio"), lo: 0, hi: 32 });
        regs.insert("SIO_INTR_IDENT", Register { addr: Address { base: 63, count: 4, width: 1 }, brief: Some("Currently active interrupts"), details: None, fields });
        groups.insert("FAN_CTRL", RegisterGroup { addr: Address { base: 285, count: 1, width: 2 }, desc: "Fan controller configuration and status", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("G_ALT", Field { brief: Some("Configures alternate functions for individual GPIOs. See datasheet for information on possible alternate functions. The LSB of the GPIO encoding is placed in replication 0, MSB is placed in replication 1. For example; to encode Alternate mode 2 for GPIO[n] write DEVCPU_GCB::GPIO_ALT[0][n] = 0, and DEVCPU_GCB::GPIO_ALT[1][n] = 1. Note: This register is only reset by the device's reset input, i.e. it is not affected by soft reset!"), details: Some("00: GPIO mode 01: Alternate mode 1 10: Alternate mode 2 11: Alternate mode 3"), lo: 0, hi: 32 });
        regs.insert("GPIO_ALT", Register { addr: Address { base: 16, count: 2, width: 1 }, brief: Some("GPIO alternate functions"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("G_ALT1", Field { brief: Some("Bit 32-63 of field G_ALT."), details: Some("00: GPIO mode 01: Alternate mode 1 10: Alternate mode 2 11: Alternate mode 3"), lo: 0, hi: 32 });
        regs.insert("GPIO_ALT1", Register { addr: Address { base: 18, count: 2, width: 1 }, brief: Some("GPIO alternate functions"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("G_IN", Field { brief: Some("GPIO input register. Reflects the current state of the corresponding GPIO pins."), details: None, lo: 0, hi: 32 });
        regs.insert("GPIO_IN", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("GPIO input"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("G_IN1", Field { brief: Some("Bit 32-63 of field G_IN."), details: None, lo: 0, hi: 32 });
        regs.insert("GPIO_IN1", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("GPIO input"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("G_INTR", Field { brief: Some("Indicates whether a GPIO input has changed since last clear."), details: Some("'0': No change '1': GPIO has changed"), lo: 0, hi: 32 });
        regs.insert("GPIO_INTR", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("GPIO interrupt"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("G_INTR1", Field { brief: Some("Bit 32-63 of field G_INTR."), details: Some("'0': No change '1': GPIO has changed"), lo: 0, hi: 32 });
        regs.insert("GPIO_INTR1", Register { addr: Address { base: 11, count: 1, width: 1 }, brief: Some("GPIO interrupt"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("G_INTR_ENA", Field { brief: Some("Enables individual GPIO pins for interrupt."), details: None, lo: 0, hi: 32 });
        regs.insert("GPIO_INTR_ENA", Register { addr: Address { base: 12, count: 1, width: 1 }, brief: Some("GPIO interrupt enable"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("G_INTR_ENA1", Field { brief: Some("Bit 32-63 of field G_INTR_ENA."), details: None, lo: 0, hi: 32 });
        regs.insert("GPIO_INTR_ENA1", Register { addr: Address { base: 13, count: 1, width: 1 }, brief: Some("GPIO interrupt enable"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("G_INTR_IDENT", Field { brief: Some("Shows which GPIO sources that are currently interrupting. This field is the result of an AND-operation between the GPIO_INTR and the GPIO_INTR_ENA registers."), details: None, lo: 0, hi: 32 });
        regs.insert("GPIO_INTR_IDENT", Register { addr: Address { base: 14, count: 1, width: 1 }, brief: Some("GPIO interrupt identity"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("G_INTR_IDENT1", Field { brief: Some("Bit 32-63 of field G_INTR_IDENT."), details: None, lo: 0, hi: 32 });
        regs.insert("GPIO_INTR_IDENT1", Register { addr: Address { base: 15, count: 1, width: 1 }, brief: Some("GPIO interrupt identity"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("G_OE", Field { brief: Some("Configures the direction of the GPIO pins."), details: Some("'0': Input '1': Output"), lo: 0, hi: 32 });
        regs.insert("GPIO_OE", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("GPIO pin direction"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("G_OE1", Field { brief: Some("Bit 32-63 of field G_OE."), details: Some("'0': Input '1': Output"), lo: 0, hi: 32 });
        regs.insert("GPIO_OE1", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("GPIO pin direction"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("G_OUT", Field { brief: Some("Controls the value on the GPIO pins enabled for output (via the GPIO_OE register). This field can be modified directly or by using the GPIO_O_SET and GPIO_O_CLR registers."), details: None, lo: 0, hi: 32 });
        regs.insert("GPIO_OUT", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("GPIO output"), details: Some("In a multi-threaded software environment using the registers GPIO_OUT_SET and GPIO_OUT_CLR for modifying GPIO values removes the need for software-locked access."), fields });
        let mut fields = HashMap::new();
        fields.insert("G_OUT1", Field { brief: Some("Bit 32-63 of field G_OUT."), details: None, lo: 0, hi: 32 });
        regs.insert("GPIO_OUT1", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("GPIO output"), details: Some("In a multi-threaded software environment using the registers GPIO_OUT_SET and GPIO_OUT_CLR for modifying GPIO values removes the need for software-locked access."), fields });
        let mut fields = HashMap::new();
        fields.insert("G_OUT_CLR", Field { brief: Some("Setting a bit in this field will immediately clear the corresponding bit in GPIO_OUT.G_OUT. Reading this register always return 0."), details: Some("'0': No change '1': Corresponding bit in GPIO_OUT.G_OUT is cleared."), lo: 0, hi: 32 });
        regs.insert("GPIO_OUT_CLR", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("GPIO output clear"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("G_OUT_CLR1", Field { brief: Some("Bit 32-63 of field G_OUT_CLR."), details: Some("'0': No change '1': Corresponding bit in GPIO_OUT.G_OUT is cleared."), lo: 0, hi: 32 });
        regs.insert("GPIO_OUT_CLR1", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("GPIO output clear"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("G_OUT_SET", Field { brief: Some("Setting a bit in this field will immediately set the corresponding bit in GPIO_OUT.G_OUT. Reading this register always return 0."), details: Some("'0': No change '1': Corresponding bit in GPIO_OUT.G_OUT is set."), lo: 0, hi: 32 });
        regs.insert("GPIO_OUT_SET", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("GPIO output set"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("G_OUT_SET1", Field { brief: Some("Bit 32-63 of field G_OUT_SET."), details: Some("'0': No change '1': Corresponding bit in GPIO_OUT.G_OUT is set."), lo: 0, hi: 32 });
        regs.insert("GPIO_OUT_SET1", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("GPIO output set"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("VA_DATA_INERT", Field { brief: Some("This field behaves in the same way as VA_DATA.VA_DATA. Except accesses (read or write) does not initiate VCore accesses. Writing to this register just overwrites the value currently held by all of the data registers (VA_DATA, VA_DATA_INCR, and VA_DATA_INERT)."), details: None, lo: 0, hi: 32 });
        regs.insert("VA_DATA_INERT", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Data register for VCore accesses (will not initiate access)"), details: None, fields });
        groups.insert("GPIO", RegisterGroup { addr: Address { base: 14, count: 1, width: 36 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("FAN_CNT", Field { brief: Some("Counts the number of TACH input ticks. If DEVCPU_GCB::FAN_CFG.FAN_STAT_CFG is set then this is a wrapping counter that shows the total number of registered TACH ticks. If DEVCPU_GCB::FAN_CFG.FAN_STAT_CFG is cleared then this counter is updated once every second with the number of TACH ticks registered during the last second."), details: None, lo: 0, hi: 16 });
        regs.insert("FAN_CNT", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("TACH counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ACTIVATE", Field { brief: Some("Setting this field transitions the integrity monitor between operating modes. Transitioning between modes takes time, this field remains set until the new mode is reached. During this time the monitor also reports busy DEVCPU_GCB::MEMITGR_STAT.MODE_BUSY is set). From IDLE (DEVCPU_GCB::MEMITGR_STAT.MODE_IDLE is set) the monitor can transition into either DETECT or LISTEN mode, the DETECT mode is entered if a memory reports an indication - the LISTEN mode is entered if no indications are reported. The first time after reset the monitor will not detect indications, that is; it will transition directly from IDLE to LISTEN mode. From DETECT (DEVCPU_GCB::MEMITGR_STAT.MODE_DETECT is set) the monitor can transition into either DETECT or LISTEN mode, the DETECT mode is entered if more indications are reported - the LISTEN mode is entered if no more indications are reported. From LISTEN (DEVCPU_GCB::MEMITGR_STAT.MODE_LISTEN is set) the monitor can transition into IDLE mode. Software shall not set this field when the monitor is BUSY (when DEVCPU_GCB::MEMITGR_STAT.MODE_BUSY is set.)"), details: None, lo: 0, hi: 1 });
        regs.insert("MEMITGR_CTRL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Monitor control"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MEM_DIV", Field { brief: Some("Configure divider for generating the sync-pulse to memories (controls the speed at which the monitor talks to the memories). The lower this is set the faster indications can be read out of the memories."), details: Some("See datasheet for appropriate value."), lo: 0, hi: 16 });
        regs.insert("MEMITGR_DIV", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Monitor speed"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MEM_IDX", Field { brief: Some("This field contains a unique index for the memory for which info is currently provided in DEVCPU_GCB::MEMITGR_INFO. Indexes are counted from 1 (not 0)."), details: None, lo: 0, hi: 16 });
        regs.insert("MEMITGR_IDX", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Memory index"), details: Some("This field is only valid when the monitor is in the DETECT (DEVCPU_GCB::MEMITGR_STAT.MODE_DETECT is set) mode."), fields });
        let mut fields = HashMap::new();
        fields.insert("MEM_ADDR", Field { brief: Some("This field is valid only when DEVCPU_GCB::MEMITGR_INFO.MEM_ERR or DEVCPU_GCB::MEMITGR_INFO.MEM_COR is set."), details: None, lo: 0, hi: 28 });
        fields.insert("MEM_COR", Field { brief: Some("This field is set if the monitor has detected a correction."), details: None, lo: 30, hi: 31 });
        fields.insert("MEM_COR_OVF", Field { brief: Some("This field is set if the monitor has correction indication for which the address has not been recorded. If DEVCPU_GCB::MEMITGR_INFO.MEM_ERR is set then there has also been a parity indication (or an unrecoverable correction) which takes priority over correction indications. If DEVCPU_GCB::MEMITGR_INFO.MEM_ERR is cleared and DEVCPU_GCB::MEMITGR_INFO.MEM_COR is set then there has been more than one correction indication, then only the address of the newest correction indication has been kept. If DEVCPU_GCB::MEMITGR_INFO.MEM_ERR and DEVCPU_GCB::MEMITGR_INFO.MEM_COR is both cleared then a correction indication has occurred for which the address could not be stored, this is a very rare situation that can only happen if an indication is detected just as the memory is talking to the monitor."), details: None, lo: 28, hi: 29 });
        fields.insert("MEM_ERR", Field { brief: Some("This field is set if the monitor has detected a parity indication (or an unrecoverable correction)."), details: None, lo: 31, hi: 32 });
        fields.insert("MEM_ERR_OVF", Field { brief: Some("This field is set if the monitor has detected a parity indication (or an unrecoverable correction) for which the address has not been recorded. If DEVCPU_GCB::MEMITGR_INFO.MEM_ERR is set then there has been more than one indication, then only the address of the newest indication has been kept. If DEVCPU_GCB::MEMITGR_INFO.MEM_ERR is cleared then an indication has occurred for which the address could not be stored, this is a very rare situation that can only happen if an indication is detected just as the memory is talking to the monitor."), details: None, lo: 29, hi: 30 });
        regs.insert("MEMITGR_INFO", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Memory indication"), details: Some("This field is only valid when the monitor is in the DETECT (DEVCPU_GCB::MEMITGR_STAT.MODE_DETECT is set) mode."), fields });
        let mut fields = HashMap::new();
        fields.insert("INDICATION", Field { brief: Some("If this field is set then there is an indication from one of the memories that needs to be analyzed. An indication is either a parity detection or an error correction. This field is only set when the monitor is in LISTEN mode (DEVCPU_GCB::MEMITGR_STAT.MODE_LISTEN is set), in all other states (including BUSY) this field returns 0."), details: None, lo: 4, hi: 5 });
        fields.insert("INDICATION_OVF", Field { brief: Some("This field is set if there is an overflow when recording indications from the memories. If this happens (setting of this field) the value of the DEVCPU_GCB::MEMITGR_DIV.MEM_DIV field is set too low!"), details: None, lo: 5, hi: 6 });
        fields.insert("MODE_BUSY", Field { brief: Some("The busy signal is a copy of the DEVCPU_GCB::MEMITGR_CTRL.ACTIVATE field, see description of that field for more information about the different states/modes of the monitor."), details: None, lo: 0, hi: 1 });
        fields.insert("MODE_DETECT", Field { brief: Some("This field is set when the monitor is in DETECT mode, during detect mode the DEVCPU_GCB::MEMITGR_INFO and DEVCPU_GCB::MEMITGR_IDX registers contains valid information about one indication."), details: None, lo: 2, hi: 3 });
        fields.insert("MODE_IDLE", Field { brief: Some("This field is set when the monitor is in IDLE mode."), details: None, lo: 1, hi: 2 });
        fields.insert("MODE_LISTEN", Field { brief: Some("This field is set when the monitor is in LISTEN mode, during listen mode the monitor continually check for parity/correction indications from the memories."), details: None, lo: 3, hi: 4 });
        regs.insert("MEMITGR_STAT", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Monitor status"), details: None, fields });
        groups.insert("MEMITGR", RegisterGroup { addr: Address { base: 287, count: 1, width: 6 }, desc: "Memory integrity monitor", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("G_SD_MAP", Field { brief: Some("Set to map a specific GPIO mapped signal detect input to specific front-port index. There is one replication for each GPIO mapped signal detect input. If multiple signal detects are enabled and map to same front-port index, then the higher replication index will take priority. For example to map 3'rd signal detect input asif it was provided by 2'nd SERDES; set DEVCPU_GCB::GPIO_SD_MAP[2].G_SD_MAP = 1 and enable SD2 via DEVCPU_GCB::GPIO_ALT registers."), details: None, lo: 0, hi: 6 });
        regs.insert("GPIO_SD_MAP", Register { addr: Address { base: 20, count: 16, width: 1 }, brief: Some("GPIO Signal Detect Mapping"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DEADLOCK_FIX_DIS", Field { brief: Some("Option to disable deadlock fix if it causes any troubles."), details: None, lo: 11, hi: 12 });
        fields.insert("MIIM_CFG_DBG", Field { brief: Some("Selects the interpretation of the BUSY_OR_IN_PROGRESS field in MII_STATUS."), details: None, lo: 8, hi: 9 });
        fields.insert("MIIM_CFG_PRESCALE", Field { brief: Some("Configures the MIIM clock frequency. This is computed as system_clk/(2*(1+X)), where X is the value written to this register. Note : Setting X to 0 is invalid and will result in the same frequency as setting X to 1."), details: None, lo: 0, hi: 8 });
        fields.insert("MIIM_ST_CFG_FIELD", Field { brief: Some("The ST (start-of-frame) field of the MIIM frame format adopts the value of this field. This must be configured for either clause 22 or 45 MIIM operation."), details: Some("\"01\": Clause 22 \"00\": Clause 45 Other values are reserved."), lo: 9, hi: 11 });
        regs.insert("MII_CFG", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("MIIM Configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MIIM_7226_CFG_FIELD", Field { brief: Some("Use of XAUI/XGMII translator device."), details: Some("0 : Disable 1 : Enable."), lo: 9, hi: 10 });
        regs.insert("MII_CFG_7226", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("MIIM Configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MIIM_CMD_OPR_FIELD", Field { brief: Some("Indicates type of operation."), details: Some("Clause 22: 01 : Write 10 : Read Clause 45: 00 : Address 01 : Write 10 : Read inc. 11 : Read."), lo: 1, hi: 3 });
        fields.insert("MIIM_CMD_PHYAD", Field { brief: Some("Indicates the addressed PHY number."), details: None, lo: 25, hi: 30 });
        fields.insert("MIIM_CMD_REGAD", Field { brief: Some("Indicates the addressed of the register within the PHY that shall be accessed."), details: None, lo: 20, hi: 25 });
        fields.insert("MIIM_CMD_SCAN", Field { brief: Some("Indicates whether automatic scanning of PHY registers is enabled. When enabled, the PHY-number for each automatic read is continuously round-robined from PHY_ADDR_LOW through PHY_ADDR_HIGH. This function is started upon a read operation (ACCESS_TYPE). Scan MUST be disabled when doing any configuration of the MIIM controller."), details: Some("0 : Disabled 1 : Enabled."), lo: 0, hi: 1 });
        fields.insert("MIIM_CMD_SINGLE_SCAN", Field { brief: Some("Select if scanning of the PHY shall be done once, or scanning should be done continuously."), details: Some("0 : Do continuously PHY scanning 1 : Stop once all PHY have been scanned."), lo: 3, hi: 4 });
        fields.insert("MIIM_CMD_VLD", Field { brief: Some("Must be set for starting a new PHY access. This bit is automatically cleared."), details: Some("0 : Write to this register is ignored. 1 : Write to this register is processed."), lo: 31, hi: 32 });
        fields.insert("MIIM_CMD_WRDATA", Field { brief: Some("Data to be written in the PHY register."), details: None, lo: 4, hi: 20 });
        regs.insert("MII_CMD", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("MIIM Command"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MIIM_DATA_RDDATA", Field { brief: Some("Data read from PHY register."), details: None, lo: 0, hi: 16 });
        fields.insert("MIIM_DATA_SUCCESS", Field { brief: Some("Indicates whether a read operation failed or succeeded."), details: Some("00 : OK 11 : Error"), lo: 16, hi: 18 });
        regs.insert("MII_DATA", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("MIIM Reply Data"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MIIM_SCAN_PHYADHI", Field { brief: Some("Indicates the high PHY number to scan during automatic scanning."), details: None, lo: 5, hi: 10 });
        fields.insert("MIIM_SCAN_PHYADLO", Field { brief: Some("Indicates the low PHY number to scan during automatic scanning."), details: None, lo: 0, hi: 5 });
        regs.insert("MII_SCAN_0", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("MIIM Scan 0"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MIIM_SCAN_EXPECT", Field { brief: Some("Indicates the expected value for comparing the PHY registers during automatic scan."), details: None, lo: 0, hi: 16 });
        fields.insert("MIIM_SCAN_MASK", Field { brief: Some("Indicates the mask for comparing the PHY registers during automatic scan."), details: None, lo: 16, hi: 32 });
        regs.insert("MII_SCAN_1", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("MIIM Scan 1"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MIIM_LAST_RSLT", Field { brief: Some("Indicates for each PHY if a PHY register has matched the expected value (with mask). This register reflects the value of the last reading of the phy register."), details: Some("0 : Mismatch. 1 : Match."), lo: 0, hi: 32 });
        regs.insert("MII_SCAN_LAST_RSLTS", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("MIIM Results"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MIIM_SCAN_COMPLETE", Field { brief: Some("Signals if all PHYs have been scanned ( with auto scan ) at least once."), details: Some("0 : Auto scan has not scanned all PHYs. 1 : Auto scan has scanned all PHY at least once."), lo: 4, hi: 5 });
        fields.insert("MIIM_STAT_BUSY", Field { brief: Some("Indicates the current state of the MIIM controller. When read operations are done (no longer busy), then read data is available via the DEVCPU_GCB::MII_DATA register."), details: Some("0: MIIM controller is in idle state 1: MIIM controller is busy performing MIIM cmd (Either read or read cmd)."), lo: 3, hi: 4 });
        fields.insert("MIIM_STAT_OPR_PEND", Field { brief: Some("The MIIM controller has a CMD fifo of depth one. When this field is 0, then it is safe to write another MIIM command to the MIIM controller."), details: Some("0 : Read or write not pending 1 : Read or write pending."), lo: 2, hi: 3 });
        fields.insert("MIIM_STAT_PENDING_RD", Field { brief: Some("Indicates whether a read operation via the MIIM interface is in progress or not."), details: Some("0 : Read not in progress 1 : Read in progress."), lo: 1, hi: 2 });
        fields.insert("MIIM_STAT_PENDING_WR", Field { brief: Some("Indicates whether a write operation via the MIIM interface is in progress or not."), details: Some("0 : Write not in progress 1 : Write in progress."), lo: 0, hi: 1 });
        regs.insert("MII_STATUS", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("MIIM Status"), details: None, fields });
        groups.insert("MIIM", RegisterGroup { addr: Address { base: 50, count: 3, width: 9 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("MIIM_LAST_RSLT_VLD", Field { brief: Some("Indicates for each PHY if a PHY register matched are valid or not."), details: Some("0 : Scan result not valid. 1 : Scan result valid."), lo: 0, hi: 32 });
        regs.insert("MII_SCAN_LAST_RSLTS_VLD", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("MIIM Results"), details: None, fields });
        groups.insert("MIIM_READ_SCAN", RegisterGroup { addr: Address { base: 77, count: 1, width: 3 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("TEMP", Field { brief: Some("Temperature data readout, this field is valid when DEVCPU_GCB::TEMP_SENSOR_STAT.TEMP_VALID is set. This field is continually updated (approximately every 500us) while the termperature sensor is enabled, see DEVCPU_GCB::TEMP_SENSOR_CTRL.SAMPLE_ENA for more information."), details: Some("Temperature(C)=177.4 - 0.8777*DATA"), lo: 0, hi: 8 });
        fields.insert("TEMP_VALID", Field { brief: Some("This fied is set when valid temperature data is available in DEVCPU_GCB::TEMP_SENSOR_STAT.TEMP."), details: None, lo: 8, hi: 9 });
        regs.insert("TEMP_SENSOR_STAT", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Temperature Sensor Status"), details: None, fields });
        groups.insert("MIIM_SLAVE", RegisterGroup { addr: Address { base: 83, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("SPIKE_FILTER_CFG", Field { brief: Some("Configuration of the spike filter width on the MDC and MDIO inputs. Filters spikes with a width of (SPIKE_FILTER_CFG+1)*SYSTEM_CLK or less."), details: None, lo: 1, hi: 6 });
        fields.insert("SPIKE_FILTER_ENA", Field { brief: Some("Set this field to enable the spike filter on the MDC and MDIO inputs. When enabled the MIIM_SLAVE_CFG.SPIKE_FILTER_CFG field determines the width of the spike filter."), details: None, lo: 0, hi: 1 });
        regs.insert("MIIM_SLAVE_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("MIIM Slave Spike Filter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SIO_AUTO_REPEAT", Field { brief: Some("Use this to output repeated bursts interleaved with burst gaps. Must be manually reset again to stop output of bursts."), details: None, lo: 10, hi: 11 });
        fields.insert("SIO_BLINK_RESET", Field { brief: Some("Reset the blink counters. Used to synchronize the blink modes between different chips."), details: Some("0: Blink counter is running 1: Blink counter is reset until sio_blink_reset is unset again"), lo: 18, hi: 19 });
        fields.insert("SIO_BMODE_0", Field { brief: Some("Configuration of blink mode 0. Supports four different blink modes."), details: Some("0 : Blink freq appr. 5Hz. 1 : Blink freq appr. 2.5Hz. 2 : Blink freq appr. 1.25Hz. 3 : Blink freq appr. 0.625Hz."), lo: 19, hi: 21 });
        fields.insert("SIO_BMODE_1", Field { brief: Some("Configuration for blink mode 1. Supports three different blink modes and a \"burst toggle\" mode in which blink mode 1 will alternate for each burst."), details: Some("0: Blink freq appr. 20Hz 1: Blink freq appr. 10Hz 2: Blink freq appr. 5Hz 3: Burst toggle"), lo: 21, hi: 23 });
        fields.insert("SIO_BURST_GAP", Field { brief: Some("Configures the length of burst gap in steps of approx. 1 ms. Burst gap can be disabled by setting DEVCPU_GCB::SIO_CFG.SIO_BURST_GAP_DIS."), details: Some("0: 1.05 ms burst gap 1: 2.10 ms burst gap ... 31: 33.55 ms burst gap"), lo: 12, hi: 17 });
        fields.insert("SIO_BURST_GAP_DIS", Field { brief: Some("Set to disable burst gap."), details: None, lo: 17, hi: 18 });
        fields.insert("SIO_GPIO_INTR_ENA", Field { brief: Some("Bit interrupt enable. Enables interrupts for the four gpios in a port. Is applied to all ports."), details: Some("0: Interrupt is disabled for bit n for all ports 1: Interrupt is enabled for bit n for all ports"), lo: 1, hi: 5 });
        fields.insert("SIO_LD_POLARITY", Field { brief: Some("Polarity of the \"Ld\" signal"), details: Some("0: load signal is active low 1: load signal is active high"), lo: 9, hi: 10 });
        fields.insert("SIO_MASTER_INTR_ENA", Field { brief: Some("Master interrupt enable. Enables interrupts. Is applied to all gpios on all ports. This field only has effect on the interrupt output signal of the sio_ctrl block. It has no effect on the interrupt registers."), details: Some("0: Interrupt is disabled for all bits for all ports 1: Interrupt is enabled for all bits for all ports"), lo: 0, hi: 1 });
        fields.insert("SIO_PORT_WIDTH", Field { brief: Some("Number of SGPIOs pr. port."), details: Some("0: 1 gpio pr. port 1: 2 gpios pr. port 2: 3 gpios pr. port 3: 4 gpios pr. port"), lo: 7, hi: 9 });
        fields.insert("SIO_REVERSE_INPUT", Field { brief: Some("Reverse the input bitstream. The default order of the input bit stream is (displayed in received order): (port0 bit0, port0 bit1, ...., portN bit2, portN bit3) The reverse order of the input bit stream is (displayed in received order): (portN bit3, portN bit2, ...., port0 bit1, port0 bit0)"), details: Some("0: Do not reverse 1: Reverse"), lo: 5, hi: 6 });
        fields.insert("SIO_REVERSE_OUTPUT", Field { brief: Some("Reverse the output bitstream. The default order of the output bit stream is (displayed in transmitted order): (portN bit3, portN bit2, ...., port0 bit1, port0 bit0) The reverse order of the output bit stream is (displayed in transmitted order): (port0 bit0, port0 bit1, ...., portN bit2, portN bit3)"), details: Some("0: Do not reverse 1: Reverse"), lo: 6, hi: 7 });
        fields.insert("SIO_SINGLE_SHOT", Field { brief: Some("Use this to output a single burst. Will be cleared by hardware when the burst has finished."), details: None, lo: 11, hi: 12 });
        regs.insert("SIO_CFG", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("General configurations"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SIO_CLK_FREQ", Field { brief: Some("SIO controller clock frequency. Divides the 250 MHz system clk with the value of this field. E.g. field is set to 10, the output frequency will be 25 MHz."), details: Some("0: Disable clock 1: Reserved, do not use Others : Clock divider value."), lo: 8, hi: 20 });
        fields.insert("SYS_CLK_PERIOD", Field { brief: Some("The system clock period given in the clock period in PS divided by 100."), details: None, lo: 0, hi: 8 });
        regs.insert("SIO_CLOCK", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("SGPIO shift clock frequency"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SIO_INPUT_DATA", Field { brief: Some("Serial input data. Each replication, N, holds bit N from all ports - bit N from port M is mapped to replication N bit M. Values of disabled gpios are undefined."), details: None, lo: 0, hi: 32 });
        regs.insert("SIO_INPUT_DATA", Register { addr: Address { base: 0, count: 4, width: 1 }, brief: Some("Last value at SGPIO pins"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SIO_INTR", Field { brief: Some("Interrupt register. These sticky bits are set when an input is received that are triggered by the corresponding SIO_INTR_TRIGGER configuration."), details: Some("0: No interrupt for given gpio 1: Interrupt for given gpio"), lo: 0, hi: 32 });
        regs.insert("SIO_INTR", Register { addr: Address { base: 58, count: 4, width: 1 }, brief: Some("Currently interrupting SGPIOs"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SIO_INTR_ENA", Field { brief: Some("Interrupt enable vector with one enable bit for each port. Port order: (portN downto port0)"), details: Some("0: Interrupt is disabled for the port 1: Interrupt is enabled for the port"), lo: 0, hi: 32 });
        regs.insert("SIO_INTR_ENA", Register { addr: Address { base: 62, count: 1, width: 1 }, brief: Some("SGPIO interrupt enable per port"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SIO_INTR_POL", Field { brief: Some("Interrupt polarity. This register defines at which logic value an interrupt is generated. For bit0 this register is also used to define the polarity of the \"loss of signal\" output."), details: Some("0: interrupt and \"loss of signal\" is active high 1: interrupt and \"loss of signal\" is active low"), lo: 0, hi: 32 });
        regs.insert("SIO_INTR_POL", Register { addr: Address { base: 42, count: 4, width: 1 }, brief: Some("SGPIO interrupt polarity"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SIO_INTR_RAW", Field { brief: Some("Shows the current value of individual interrupts. All interrupts are active high (but has been corrected for polarity as configured in SIO_INTR_POL)."), details: None, lo: 0, hi: 32 });
        regs.insert("SIO_INTR_RAW", Register { addr: Address { base: 46, count: 4, width: 1 }, brief: Some("Interrupt raw status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SIO_INTR_TRIGGER0", Field { brief: Some("Configure trigger mode of individual interrupts. The trigger mode determines how the value of the SIO_INTR_RAW register is transfered to the SIO_INTR register. This register is the LSB of the encoding. Register SIO_INTR_TRIGGER1 is the MSB of the encoding. For level-triggered interrupts SIO_INTR is set when an input is received that results in a high corresponding bit in SIO_INTR_RAW. For edge-triggered interrupts SIO_INTR is set when an input is received that results in a change of the corresponding bit in SIO_INTR_RAW. For falling-edge-triggered interrupts SIO_INTR is set when an input is received that results in a change from '1' to '0' of the corresponding bit in SIO_INTR_RAW. For rising-edge-triggered interrupts SIO_INTR is set when an input is received that results in a change from '0' to '1' of the corresponding bit in SIO_INTR_RAW."), details: Some("00: Interrupt is level-activated 01: Interrupt is edge-triggered 10: Interrupt is falling-edge-triggered 11: Interrupt is rising-edge-triggered"), lo: 0, hi: 32 });
        regs.insert("SIO_INTR_TRIGGER0", Register { addr: Address { base: 50, count: 4, width: 1 }, brief: Some("Interrupt trigger mode 0"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SIO_INTR_TRIGGER1", Field { brief: Some("See description of SIO_INTR_TRIGGER0."), details: None, lo: 0, hi: 32 });
        regs.insert("SIO_INTR_TRIGGER1", Register { addr: Address { base: 54, count: 4, width: 1 }, brief: Some("Interrupt trigger mode 1"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BIT_POLARITY", Field { brief: Some("Output polarity select for the four outputs from each port.The polarity select is encoded using one bit for each output bit."), details: Some("0: Normal polarity 1: Inversed polarity"), lo: 0, hi: 4 });
        fields.insert("BIT_SOURCE", Field { brief: Some("Output source select for the four outputs from each port.The source select is encoded using three bits for each output bit: Output bit0 is defined by (2 downto 0), output bit1 is defined by (5 downto 3), output bit2 is defined by (8 downto 6), and output bit3 is defined by (11 downto 9)."), details: Some("0: Forced 0 1: Forced 1 2: Blink mode 0 3: Blink mode 1 4: Link activity blink mode 0 5: Link activity blink mode 1 6: Reserved 7: Reserved"), lo: 12, hi: 24 });
        fields.insert("PWM_SOURCE", Field { brief: Some("PWM source select for the four outputs from each port.The PWM source select is encoded using two bits for each output bit: Output bit0 is defined by (1 downto 0), output bit1 is defined by (3 downto 2), output bit2 is defined by (5 downto 4), and output bit3 is defined by (7 downto 6)."), details: Some("0: PWM disabled 1: PWM 0 used 2: PWM 1 used 3: PWM 2 used"), lo: 4, hi: 12 });
        regs.insert("SIO_PORT_CFG", Register { addr: Address { base: 6, count: 32, width: 1 }, brief: Some("Output configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SIO_PORT_ENA", Field { brief: Some("Port enable vector with one enable bit for each port. Port order: (portN downto port0)"), details: Some("0: Port is disabled 1: Port is enabled"), lo: 0, hi: 32 });
        regs.insert("SIO_PORT_ENA", Register { addr: Address { base: 38, count: 1, width: 1 }, brief: Some("Port enable"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PWM_DUTY_CYCLE", Field { brief: Some("Define the duty cycle for the PWMs."), details: Some("0x00: Always \"off\" 0xFF: Always \"on\""), lo: 0, hi: 8 });
        regs.insert("SIO_PWM_CFG", Register { addr: Address { base: 39, count: 3, width: 1 }, brief: Some("Pulse-width modulation configuration"), details: None, fields });
        groups.insert("SIO_CTRL", RegisterGroup { addr: Address { base: 84, count: 3, width: 67 }, desc: "Serial IO control configuration", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("FEA_DIS", Field { brief: Some("Efuse force values. These bits are or'ed together with the corresponding efuse fields - setting bits here corresponds to burning efuses and can be used for validation purposes."), details: None, lo: 0, hi: 32 });
        regs.insert("FEA_DIS", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Disable of features"), details: None, fields });
        groups.insert("SW_REGS", RegisterGroup { addr: Address { base: 8, count: 1, width: 1 }, desc: "Registers for software/software interaction", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("MIIM_SCAN_RSLTS_STICKY", Field { brief: Some("Indicates for each PHY if a PHY register has had a mismatch of the expected value (with mask) since last reading of MIIM_SCAN_RSLTS_STICKY. Result is sticky, and result will indicate if there has been a mismatch since the last reading of this register. Upon reading this register, all bits are reset to '1'."), details: Some("0 : Mismatch 1 : Match."), lo: 0, hi: 32 });
        regs.insert("MII_SCAN_RSLTS_STICKY", Register { addr: Address { base: 0, count: 3, width: 1 }, brief: Some("MIIM Results"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RUN_WID", Field { brief: Some("The time to keep RUN asserted during a sample period, time is in 1024 SwC clock cycles."), details: Some("0: Reserved n: n * 1024 * clock-period between samples"), lo: 8, hi: 16 });
        fields.insert("SAMPLE_PER", Field { brief: Some("The delay between temperature sensor samples in 1024 SwC clock cycles. The default value corresponds to 500us. The delay have to be big enough to allow the temperature sensor to complete its sample."), details: Some("0: Reserved n: n * 1024 * clock-period between samples"), lo: 0, hi: 8 });
        regs.insert("TEMP_SENSOR_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Temperature sensor sample period"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FORCE_CLK", Field { brief: Some("Set to force clock signal towards temperature sensor. This field only works when SAMPLE_ENA is cleared."), details: None, lo: 1, hi: 2 });
        fields.insert("FORCE_NO_RST", Field { brief: Some("Set to force RESETN signal towards temperature sensor (release of reset). This field only works when SAMPLE_ENA is cleared."), details: None, lo: 3, hi: 4 });
        fields.insert("FORCE_POWER_UP", Field { brief: Some("Set to force PDB signal towards temperature sensor. This field only works when SAMPLE_ENA is cleared."), details: None, lo: 2, hi: 3 });
        fields.insert("FORCE_RUN", Field { brief: Some("Set to force RUN signal towards temperature sensor. This field only works when SAMPLE_ENA is cleared."), details: None, lo: 4, hi: 5 });
        fields.insert("FORCE_TEMP_RD", Field { brief: Some("Set to force reading of temperature irregardless of when Temperature sensor says done."), details: None, lo: 5, hi: 6 });
        fields.insert("SAMPLE_ENA", Field { brief: Some("Set this field to enable sampling of temperature. Approximately 500us after setting this field DEVCPU_GCB::TEMP_SENSOR_STAT.TEMP_VALID will be set together with a valid temperature value. After this the temperature will be updated every 500us for as long as this field remains set. Clear ths field to disable temperature sensor."), details: None, lo: 0, hi: 1 });
        regs.insert("TEMP_SENSOR_CTRL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Temperature Sensor Control"), details: None, fields });
        groups.insert("TEMP_SENSOR", RegisterGroup { addr: Address { base: 80, count: 1, width: 3 }, desc: "Temperature sensor control", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("SW0_INTR", Field { brief: Some("Set this field to assert software interrupt 0. This field is automatically cleared after interrupt has been generated."), details: None, lo: 0, hi: 1 });
        fields.insert("SW1_INTR", Field { brief: Some("Set this field to inject software interrupt 1. This field is automatically cleared after interrupt has been generated."), details: None, lo: 1, hi: 2 });
        regs.insert("SW_INTR", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Manually assert software interrupt"), details: Some("This register provides a simple interface for interrupting on either sofware interrupt 0 or 1, without implementing semaphore support. Note: setting this field causes a short pulse on the corresponding interrupt connection, this kind of interrupt cannot be used in combination with the SW1_INTR_CONFIG.SW1_INTR_BYPASS feature."), fields });
        let mut fields = HashMap::new();
        fields.insert("VA_ADDR", Field { brief: Some("The address to access in the VCore domain, all addresses must be 32-bit alligned (i.e. the two least significant bit must always be 0). When accesses are initiated using the VA_DATA_INCR register, then this field is autoincremented by 4 at the end of the transfer. The memory region of the VCore that maps to switch-core registers may not be accessed by using these registers."), details: None, lo: 0, hi: 32 });
        regs.insert("VA_ADDR", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Address register for VCore accesses"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("VA_BUSY", Field { brief: Some("This field is set by hardware when an access into VCore domain is started, and cleared when the access is done."), details: None, lo: 0, hi: 1 });
        fields.insert("VA_BUSY_RD", Field { brief: Some("This field is set to the value of VA_CTRL.VA_BUSY whenever one of the data registers VA_DATA, VA_DATA_INCR, or VA_DATA_RO is read. By examining this field it is possible to determine if VA_BUSY was set at the time a read from one of these registers was performed."), details: None, lo: 1, hi: 2 });
        fields.insert("VA_ERR", Field { brief: Some("If the VCore access logic detects an error this field is set based on the nature of the error. This is a read-only field which is cleared by the VCore access logic when a new access is (sucessfully) accepted."), details: Some("0: No errors detected. 1: SBA not ready when accessed. 2: SBA reported error. 3: DATA or ADDR written during active access."), lo: 2, hi: 4 });
        fields.insert("VA_SIZE", Field { brief: Some("Controls the size of the access inside VCore domain. It is possible to do 32-bit, 16-bit and 8-bit accesses. For 8bit and 16bit write-accesses data must be aligned appropriately inside the 32bit write-data word (i.e. for a byte-write to address 0x20001003 data has to be placed in [31:24]). Likewise for 8bit and 16bit read operations, here data is alligned accordingly to address."), details: Some("0: 32bit 1: Reserved, do not use 2: 8bit 3: 16bit"), lo: 4, hi: 6 });
        regs.insert("VA_CTRL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Control register for VCore accesses"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("VA_DATA", Field { brief: Some("Reading or writing from/to this field initiates accesses into the VCore domain. While an access is ongoing (VA_CTRL.VA_BUSY is set) this field may not be written. It is possible to read this field while an access is ongoing, but the data returned will be 0x80000000. When writing to this field; a write into the VCore domain is initiated to the address specified in the VA_ADDR register, with the data that was written to this field. Only 32-bit writes are supported. This field may not be written to untill the VA_CTRL.VA_BUSY indicates that no accesses is ongoing. When reading from this field; a read from the VCore domain is initiated from the address specified in the VA_ADDR register. Important: The data that is returned from reading this field (and stating an access) is not the result of the newly initiated read, instead the data from the last access is returned. The result of the newly initiated read access will be ready once the VA_CTRL.VA_BUSY field shows that the access is done. Note: When the result of a read-access is read from this field (the second read), a new access will automatically be intiated. This is desirable when reading a series of addresses from VCore domain. If a new access is not desirable, then the result should be read from the VA_DATA_INERT register instead of this field!"), details: None, lo: 0, hi: 32 });
        regs.insert("VA_DATA", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Data register for VCore accesses"), details: Some("The VA_DATA, VA_DATA_INCR, and VA_DATA_INERT registers are used for indirect access into the VCore domain. The functionality of the VA_DATA_INCR and VA_DATA_INERT registers are similar to this register - but with minor exceptions. These exceptions are fleshed out in the description of the respective registers."), fields });
        let mut fields = HashMap::new();
        fields.insert("VA_DATA_INCR", Field { brief: Some("This field behaves in the same way as VA_DATA.VA_DATA. Except when an access is initiated by using this field (either read or write); the address register (VA_ADDR) is automatically incremented by 4 at the end of the access, i.e. when VA_CTRL.VA_BUSY is deasserted."), details: None, lo: 0, hi: 32 });
        regs.insert("VA_DATA_INCR", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Data register for VCore accesses (w. auto increment of address)"), details: None, fields });
        groups.insert("VCORE_ACCESS", RegisterGroup { addr: Address { base: 9, count: 1, width: 5 }, desc: "Registers for accessing the VCore", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("DATA_IN", Field { brief: Some("Always shows the (resynced) value of the data-field of the integrity-ring into the monitor."), details: None, lo: 5, hi: 6 });
        fields.insert("DETECT_ENA", Field { brief: Some("Set this field to enable detection of parity detections and ecc corrections. The monitor must be initialized before first use (after reset), this is done by making the first transtion from IDLE to LISTEN mode without enabeling detections (this field is cleared) and then setting this field once the monitor reaches the LISTEN mode."), details: None, lo: 0, hi: 1 });
        fields.insert("ENA_IN", Field { brief: Some("Always shows the (resynced) value of the ena-field of the integrity-ring into the monitor."), details: None, lo: 6, hi: 7 });
        fields.insert("ENA_OUT", Field { brief: Some("When DEVCPU_GCB::MEMITGR_DBG.FORCE_ENA is set, this value is driven to ena-field of the intgrity-ring out from the monitor."), details: None, lo: 2, hi: 3 });
        fields.insert("FORCE_ENA", Field { brief: Some("Set to overtake ena and sync outputs (bit banging on the integrity ring) and drive these by DEVCPU_GCB::MEMITGR_DBG.ENA_OUT and DEVCPU_GCB::MEMITGR_DBG.SYNC_OUT respectively."), details: None, lo: 1, hi: 2 });
        fields.insert("FORCE_INTR", Field { brief: Some("Set to force the intr-field of the intgrity-ring out from the monitor."), details: None, lo: 8, hi: 9 });
        fields.insert("INTR_IN", Field { brief: Some("Always shows the (resynced) value of the intr-field of the integrity-ring into the monitor."), details: None, lo: 4, hi: 5 });
        fields.insert("MEM_DIV_SENSE", Field { brief: Some("This field is used for test purposes."), details: None, lo: 9, hi: 10 });
        fields.insert("SYNC_IN", Field { brief: Some("Always shows the (resynced) value of the sync-field of the integrity-ring into the monitor."), details: None, lo: 7, hi: 8 });
        fields.insert("SYNC_OUT", Field { brief: Some("When DEVCPU_GCB::MEMITGR_DBG.FORCE_ENA is set, this value is driven to sync-field of the intgrity-ring out from the monitor."), details: None, lo: 3, hi: 4 });
        regs.insert("MEMITGR_DBG", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Debug registers"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CMD_INVALID_STICKY", Field { brief: Some("This field is set if an invalid command inside a valid VRAP frame has been received. The VRAP engine has ignored the command."), details: None, lo: 2, hi: 3 });
        fields.insert("FRM_INVALID_STICKY", Field { brief: Some("This field is set if an invalid VRAP frame has been received and discarded by the VRAP-engine. Frames with a VRAP header different from V1 are considered invalid."), details: None, lo: 1, hi: 2 });
        fields.insert("FRM_RECV_STICKY", Field { brief: Some("This field is set if a valid VRAP (Vitesse Register Access Protocol) frame has been received."), details: None, lo: 3, hi: 4 });
        fields.insert("REPLY_ABORT_STICKY", Field { brief: Some("This field is set if a VRAP reply frame has been aborted. This my happen if a protocol violation is detected during VRAP request frame processing."), details: None, lo: 0, hi: 1 });
        regs.insert("VRAP_ACCESS_STAT", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VRAP events"), details: None, fields });
        groups.insert("VRAP", RegisterGroup { addr: Address { base: 293, count: 1, width: 1 }, desc: "VRAP controller", regs });
        out.insert("DEVCPU_GCB", Target { desc: "General Configuration Block", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ERR_NO_ACTION", Field { brief: Some("The \"No Action\" indication is triggered when a target is accessed with a non-existing address. In other words, the target did not contain a register at the requested address."), details: None, lo: 4, hi: 8 });
        fields.insert("ERR_TGT_BUSY", Field { brief: Some("The \"Target Busy\" indication is triggered when an interface tries to access a target which is currently reset or if another interface is using the target."), details: None, lo: 16, hi: 20 });
        fields.insert("ERR_UTM", Field { brief: Some("The \"Unknown Target Module\" indication is triggered when a non-existing target is requested. In other words there was no target with the requested target-id."), details: None, lo: 0, hi: 4 });
        fields.insert("ERR_WD_DROP", Field { brief: Some("The \"Watch Dog Drop\" indication is triggered when a target is too long about processing a request. Usually requests are processed immediately but some accesses requires interaction with the core-logic, when this logic is in reset or during very heavy traffic load there is a chance of timing out in the target."), details: None, lo: 8, hi: 12 });
        fields.insert("ERR_WD_DROP_ORG", Field { brief: Some("The \"Watch Dog Drop Origin\" indication is triggered when the origin does not receive reply from the CSR ring within a given amount of time. This cannot happen during normal operation."), details: None, lo: 12, hi: 16 });
        regs.insert("ERR_CNTS", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Error counters"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("GPR", Field { brief: Some("General purpose 32-bit registers for debug and software development. The contents of this register can always (safely) be read. However write operations from different masters (to this register), which occur at (exactly) the same time, will fail."), details: None, lo: 0, hi: 32 });
        regs.insert("GPR", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("General purpose register"), details: Some("This register is shared between all interfaces on the Origin."), fields });
        let mut fields = HashMap::new();
        fields.insert("IF_CFG", Field { brief: Some("SI interface: This is the number of padding bytes to insert before read-data is shifted out of the device.This is needed when using high serial interface frequencies."), details: None, lo: 0, hi: 4 });
        fields.insert("IF_NUM", Field { brief: Some("Interface number; software can use this field to determine which interface that is currently used for accessing the device."), details: Some("0: VCore System 1: VRAP 2: SI 3: MIIM"), lo: 24, hi: 32 });
        fields.insert("IF_STAT", Field { brief: Some("SI interface: This field is set if the SI interface has read data from device before it was ready (this can happen if the SI frequency is too high or when too few padding bytes has been specified)."), details: None, lo: 16, hi: 17 });
        regs.insert("IF_CFGSTAT", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Physical interface configuration and status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("IF_CTRL", Field { brief: Some("This register configures critical interface parameters, it is constructed so that it can always be written correctly no matter the current state of the interface. When initializing a physical interface, then this is the first register that must be written, the state of the interface at that point may be unknown and therefore the following scheme is required to bring the interface to a known state: When writing a 4-bit value to this field construct a 32-bit data-word as follows: a) copy the 4-bit value into bits 3:0, 11:8, 19:16, and 27:24. b) reverse the 4-bit value and copy into bits 7:4, 15:12, 23:20, and 31:28. Example: To write the value 2 to this field; the 32-bit data-word to write is \"0x42424242\". Bit 0 configures endianness (when applicable), 0:Little-Endian, 1:Big-Endian. Bit 1 configures bit-order (when applicable), 0:MSB-first, 1:LSB-first. Bit 2,3 are reserved and should be kept 0. For the SI interface the default value of this field is 0x1. For all other interfaces the default value  is 0x0."), details: None, lo: 0, hi: 4 });
        regs.insert("IF_CTRL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Physical interface control"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MAILBOX", Field { brief: Some("Mailbox register which is shared between all interfaces on the Origin. Atomic (safe) modifications to the contents of this register can be performed by using the DEVCPU_ORG::MAILBOX_CLR and DEVCPU_ORG::MAILBOX_SET registers."), details: None, lo: 0, hi: 32 });
        regs.insert("MAILBOX", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("Mailbox"), details: Some("This register is shared between all interfaces on the Origin."), fields });
        let mut fields = HashMap::new();
        fields.insert("MAILBOX_CLR", Field { brief: Some("Set bits in this register to atomically clear corresponding bits in the DEVCPU_ORG::MAILBOX register. This register return 0 on read."), details: None, lo: 0, hi: 32 });
        regs.insert("MAILBOX_CLR", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Atomic clear of mailbox"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MAILBOX_SET", Field { brief: Some("Set bits in this register to atomically set corresponding bits in the DEVCPU_ORG::MAILBOX register. This register return 0 on read."), details: None, lo: 0, hi: 32 });
        regs.insert("MAILBOX_SET", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Atomic set of mailbox"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BLOCKING_ENA", Field { brief: Some("Set this field to hold back CSR scheduling when this interface want to access a target that is \"in use\"."), details: None, lo: 2, hi: 3 });
        fields.insert("DROP_MODE_ENA", Field { brief: Some("Set this field to schedule requests from this interface without looking at the state of other interfaces. The default operation is that an interface waits for a target to be free-up before scheduling (new) requests for a particular target."), details: None, lo: 1, hi: 2 });
        fields.insert("FAST_WR", Field { brief: Some("Clear this field to make write accesses return status. By default write operations return status OK because they are finished before status of the access is known. All non-OK responses will be logged in DEVCPU_ORG::ERR_CNTS no matter the value of this field."), details: None, lo: 0, hi: 1 });
        regs.insert("ORG_CFG", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Origin configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SEMA0", Field { brief: Some("General Semaphore.The first interface to read this field will be granted the semaphore (reading this field returns 0x1). Once the semaphore has been granted, all reads return '0' from this field (until the semaphore has been released). Any interface can release the semaphore by writing (any value) to this field."), details: Some("0: Semaphore ownership denied. 1: Semaphore has been granted."), lo: 0, hi: 1 });
        regs.insert("SEMA0", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("Semaphore 0"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SEMA0_OWNER", Field { brief: Some("Current owner of the semaphore. This field is a one-hot encoded vector, each bit in this vector correspond to an interface on the origin. If this field return 0, then the semaphore was free at the time of reading the register."), details: Some("0: Semaphore is free. 1: VCore System owns semaphore 2: VRAP owns semaphore 4: SI owns smaphore 8: MIIM owns semaphore"), lo: 0, hi: 32 });
        regs.insert("SEMA0_OWNER", Register { addr: Address { base: 11, count: 1, width: 1 }, brief: Some("Semaphore 0 owner"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SEMA1", Field { brief: Some("General Semaphore.The first interface to read this field will be granted the semaphore (reading this field returns 0x1). Once the semaphore has been granted, all reads return '0' from this field (until the semaphore has been released). Any interface can release the semaphore by writing (any value) to this field."), details: Some("0: Semaphore ownership denied. 1: Semaphore has been granted."), lo: 0, hi: 1 });
        regs.insert("SEMA1", Register { addr: Address { base: 12, count: 1, width: 1 }, brief: Some("Semaphore 1"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SEMA1_OWNER", Field { brief: Some("Current owner of the semaphore. This field is a one-hot encoded vector, each bit in this vector correspond to an interface on the origin. If this field return 0, then the semaphore was free at the time of reading the register."), details: Some("0: Semaphore is free. 1: VCore System owns semaphore 2: VRAP owns semaphore 4: SI owns smaphore 8: MIIM owns semaphore"), lo: 0, hi: 32 });
        regs.insert("SEMA1_OWNER", Register { addr: Address { base: 13, count: 1, width: 1 }, brief: Some("Semaphore 1 owner"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SEMA_INTR_POL", Field { brief: Some("By default semaphore-interrupt is generated when a semaphore is free. By setting this field interrupt is generated when semaphore is taken, bit 0 corresponds to semaphore 0, bit 1 to semaphore 1."), details: Some("0: Interrupt on taken semaphore 1: Interrupt on free semaphore"), lo: 0, hi: 2 });
        regs.insert("SEMA_CFG", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("Semaphore configuration"), details: Some("This register is shared between all interfaces on the Origin."), fields });
        let mut fields = HashMap::new();
        fields.insert("TIMEOUT_CFG", Field { brief: Some("The contents of this field controls the timeout delay for the CSR system. Setting this field to 0 disables timeout. Timeout is handled as follows: A counter that decrements continually, when reaching 0 it will wrap to the value specified by this field. When a target has been processing a request for three \"wraps\" the target time-out and generate a WD_DROP indication. In the origin an Interface that has been processing a request for four \"wraps\" will time out and generate a WD_DROP_ORG indication."), details: None, lo: 0, hi: 12 });
        regs.insert("TIMEOUT_CFG", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Timeout configuration"), details: Some("This register is shared between all interfaces on the Origin."), fields });
        groups.insert("DEVCPU_ORG", RegisterGroup { addr: Address { base: 0, count: 1, width: 14 }, desc: "Origin registers", regs });
        out.insert("DEVCPU_ORG", Target { desc: "CPU device origin", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CLK_ADJ_DIR", Field { brief: Some("Clock frequency adjustment direction."), details: Some("0: Positive adjustment. Every adjustment adds 1ns to the counter. => clock period is decreased, clock frequency is increased 1: Negative adjustment. Every adjustment subtracts 1ns from the counter. => clock period is increased, clock frequency is decreased"), lo: 1, hi: 2 });
        fields.insert("CLK_ADJ_ENA", Field { brief: Some("Clock frequency adjust enable."), details: Some("0: Adjustment Disabled 1: Adjustment Enabled"), lo: 0, hi: 1 });
        regs.insert("CLK_ADJ_CFG", Register { addr: Address { base: 1, count: 3, width: 1 }, brief: Some("Generated clock adjustment configuration"), details: Some("One replication exsists per time domain"), fields });
        let mut fields = HashMap::new();
        fields.insert("CLK_ADJ", Field { brief: Some("Clock frequency adjust./"), details: Some("N: Number of unadjusted CLK_ADJ_UNIT after which the counter for the clock must be adjusted."), lo: 0, hi: 30 });
        fields.insert("CLK_ADJ_UNIT", Field { brief: Some("Clock frequency adjust unit./"), details: Some("0: Adjustment made every CLK_ADJ picoseconds. 1: Adjustment made every CLK_ADJ nanoseconds."), lo: 30, hi: 31 });
        regs.insert("CLK_ADJ_FRQ", Register { addr: Address { base: 4, count: 3, width: 1 }, brief: Some("Generated clock frequency adjustment"), details: Some("Adjust master timer acording to detected PPB error. Ex: 1PBB: Adjust every 1ns. 50.006PBB: Adjust every 19.997.600ps"), fields });
        let mut fields = HashMap::new();
        fields.insert("INTR_PTP_IDENT", Field { brief: Some("Bit n will be high if an interrupt is currently pending for pin <n>."), details: None, lo: 0, hi: 5 });
        regs.insert("PTP_INTR_IDENT", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("Current interrupt status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PTP_ENA", Field { brief: Some("Enable master counter."), details: Some("0: Master counter disabled and reset 1: Master counter enabled"), lo: 6, hi: 9 });
        fields.insert("PTP_HOLD", Field { brief: Some("Hold master counter."), details: Some("0: Master counter counts if enabled 1: Master counter will stay at the reached value"), lo: 3, hi: 6 });
        fields.insert("PTP_TOD_FREEZE", Field { brief: Some("The PTP_CUR timers will be frozen when this field is set for a domain, in order to return concurrent values."), details: None, lo: 0, hi: 3 });
        regs.insert("PTP_MISC_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Misc PTP configurations"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INTR_PTP", Field { brief: Some("One bit per pin set when an active edge is seen."), details: None, lo: 0, hi: 5 });
        regs.insert("PTP_PIN_INTR", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Pending interrupt mask"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INTR_PTP_ENA", Field { brief: Some("Enable interrupt per ptp pin."), details: None, lo: 0, hi: 5 });
        regs.insert("PTP_PIN_INTR_ENA", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("Enable interrupts per pin"), details: None, fields });
        groups.insert("PTP_CFG", RegisterGroup { addr: Address { base: 40, count: 1, width: 11 }, desc: "PTP controller configuration and status", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("PIN_WFH", Field { brief: Some("Configure waveform. Unit is nanoseconds. EX. 25MHz 60/40 clock: PIN_ACTION=CLOCK, PIN_SYNC=0, PIN_WFH=24, PIN_WFL=16 EX. 1 us pulse after 150 ns PIN_ACTION=CLOCK, PIN_SYNC=1, PIN_WFH=1000, PIN_WFL=150"), details: None, lo: 0, hi: 30 });
        regs.insert("PIN_WF_HIGH_PERIOD", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Waveform programming"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PIN_WFL", Field { brief: Some("Configure waveform"), details: None, lo: 0, hi: 30 });
        regs.insert("PIN_WF_LOW_PERIOD", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Waveform programming"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PTP_CUR_SEC_MSB", Field { brief: Some("Current time of day, seconds part, latched when NSF was read"), details: None, lo: 0, hi: 16 });
        regs.insert("PTP_CUR_SEC_MSB", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Current time of day"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PTP_NSF", Field { brief: Some("Value of NSF counter when load/save action was executed. This value will not be loaded into the timers upon a LOAD operation."), details: None, lo: 0, hi: 32 });
        regs.insert("PTP_NSF", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Stamper clock"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PTP_PIN_ACTION", Field { brief: Some("Defined actions are: IDLE: No operation LOAD:   Load TimeOfDay with configured values STORE:  Store TimeOfDay and NSF of selected time domain CLOCK:  Generate a clock output DELTA:  Add PTP_TOD_NSEC field as a signed integer to TimeOfDay When the sync option is set, the action will be done when the pin sees an active edge. The action will automatically return to IDLE when complete."), details: Some("0: IDLE 1: LOAD 2: STORE 3: CLOCK 4: DELTA 5-7: reserved"), lo: 4, hi: 7 });
        fields.insert("PTP_PIN_DOM", Field { brief: Some("Configures the time domain the pin is connected to."), details: None, lo: 0, hi: 2 });
        fields.insert("PTP_PIN_INV_POL", Field { brief: Some("Polarity of the PTP pin."), details: Some("0: Active high 1: Active low"), lo: 2, hi: 3 });
        fields.insert("PTP_PIN_SYNC", Field { brief: Some("For LOAD/STORE/DELTA actions, setting this option will suspend the action until an active edge is seen on the pin. Otherwise it will be done immidiately. For the CLOCK action, the sync option makes the pin generate a single pulse, <WAFEFORM_LOW> nanoseconds after the timeof day has increased the seconds. The pulse will get a width of <WAVEFORM_HIGH> nanoseconds."), details: None, lo: 3, hi: 4 });
        regs.insert("PTP_PIN_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Configuration of use of the register group"), details: Some("Select use of the ptp i/o pin. Ptp pin 4 is not attached to any physical I/O."), fields });
        let mut fields = HashMap::new();
        fields.insert("PTP_TOD_NSEC", Field { brief: Some("Time Of Day nanoseconds loaded or stored into TimeOfDay. A synced store operation may return a value between -2 and 999.999.999 in this field. To normalize the complete TOD, in case field is read 0x3ffffffe/f, software must subtract one from the SEC part, and add 1.000.000.000 to the NSEC part."), details: None, lo: 0, hi: 30 });
        regs.insert("PTP_TOD_NSEC", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Time Of Day nanosecs part"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PTP_TOD_SEC_LSB", Field { brief: Some("Bits 31:0 of the time-of-day seconds"), details: None, lo: 0, hi: 32 });
        regs.insert("PTP_TOD_SEC_LSB", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Time Of Day LSB"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PTP_TOD_SEC_MSB", Field { brief: Some("Bits 47:32 of the time-of-day seconds"), details: None, lo: 0, hi: 16 });
        regs.insert("PTP_TOD_SEC_MSB", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Time Of Day MSB"), details: None, fields });
        groups.insert("PTP_PINS", RegisterGroup { addr: Address { base: 0, count: 5, width: 8 }, desc: "Timing synchronization", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("PTP_CUR_NSEC", Field { brief: Some("Time of day naoseconds, latched when NSF was read."), details: None, lo: 0, hi: 30 });
        regs.insert("PTP_CUR_NSEC", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Current time of day"), details: Some("Current time of day, nanoseconds part."), fields });
        let mut fields = HashMap::new();
        fields.insert("PTP_CUR_NSF", Field { brief: Some("Returns the current value of the timestamping clock. The time of day registers will be latched when this register is read."), details: None, lo: 0, hi: 32 });
        regs.insert("PTP_CUR_NSF", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Current timestamping value"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PTP_CUR_SEC_LSB", Field { brief: Some("Value of current tod secs, latched when NSF was read."), details: None, lo: 0, hi: 32 });
        regs.insert("PTP_CUR_SEC_LSB", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Current time of day"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PTP_SYS_CLK_PER_NS", Field { brief: Some("Must be configured to running system clock period, rounded down to closest interger nanoseconds value."), details: None, lo: 4, hi: 9 });
        fields.insert("PTP_SYS_CLK_PER_PS100", Field { brief: Some("Must be configured to number of 100ps to add on top of the PTP_SYS_CLK_PER_NS value to get to the correct clock period."), details: None, lo: 0, hi: 4 });
        regs.insert("PTP_SYS_CLK_CFG", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("System clock configuration"), details: None, fields });
        groups.insert("PTP_STATUS", RegisterGroup { addr: Address { base: 51, count: 3, width: 4 }, desc: "Status of PTP timers", regs });
        out.insert("DEVCPU_PTP", Target { desc: "DEVCPU Precision Timing Protocol Originator", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ABORT", Field { brief: Some("Set to abort the current frame."), details: None, lo: 20, hi: 21 });
        fields.insert("EOF", Field { brief: Some("Set to indicate that the next data written to DEVCPU_Qs::INJ_WR is end-of-frame. At the same time as setting this field, also set DEVCPU_QS::INJ_CTRL.VLD_BYTES to indicate the number of valid data bytes in the end-of-frame word."), details: None, lo: 19, hi: 20 });
        fields.insert("GAP_SIZE", Field { brief: Some("Controls the min-spacing from EOF to SOF on injected frames, the default value emulates the delay of standard preamble/IFG setting on a front-port. Set this field to zero when injecting with IFH."), details: None, lo: 21, hi: 25 });
        fields.insert("SOF", Field { brief: Some("Set to indicate that the next data written to DEVCPU_QS::INJ_WR is start-of-frame."), details: None, lo: 18, hi: 19 });
        fields.insert("VLD_BYTES", Field { brief: Some("Set to indicate how many bytes of the next data written to DEVCPU_QS::INJ_WR which are valid. This field is only used during end-of-frame words (see DEVCPU_QS::INJ_CTRL.EOF for more information). The position of the valid bytes follows the endianness encoding and swapping."), details: Some("0: All bytes are valid n: 'n' byte are valid"), lo: 16, hi: 18 });
        regs.insert("INJ_CTRL", Register { addr: Address { base: 4, count: 2, width: 1 }, brief: Some("Injection control"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ABORT_ERR_STICKY", Field { brief: Some("Set if a frame has been aborted because of double-SOF injection (missing EOF)."), details: None, lo: 1, hi: 2 });
        fields.insert("WR_ERR_STICKY", Field { brief: Some("Set in case of overflow as a result of not obeying FIFO-ready"), details: None, lo: 0, hi: 1 });
        regs.insert("INJ_ERR", Register { addr: Address { base: 7, count: 2, width: 1 }, brief: Some("Injection errors"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BYTE_SWAP", Field { brief: Some("This field allows swapping the endianess of the DEVCPU_QS::INJ_WR register. Most software will want to write injection data in network order (big-endian mode), i.e. the first byte of the destiantion MAC address to be placed on byte-address 0 of DEVCPU_QS::INJ_WR. In order to do this a little endian CPU must set this field, a big endian CPU must clear this field. This field only applies to manual extraction mode (see DEVCPU_QS::INJ_GRP_CFG.MODE)."), details: Some("0: Same endianess as CPU 1: Swap endianness"), lo: 0, hi: 1 });
        fields.insert("MODE", Field { brief: Some("Configures mode of the injection group. Each injection group can be assigned to one of three owners. Note: The VRAP block support only one context, if more than one injection group is assigned the lowest group-number will be used."), details: Some("0: VRAP block 1: Manual injection (via DEVCPU_QS registers) 2: FDMA injection and manual injection via SBA registers"), lo: 2, hi: 4 });
        regs.insert("INJ_GRP_CFG", Register { addr: Address { base: 0, count: 2, width: 1 }, brief: Some("Injection group configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FIFO_RDY", Field { brief: Some("When '1' the injector group's FIFO is ready for additional data written through the DEVCPU_QS::INJ_WR register."), details: Some("0: The injector group cannot accept additional data 1: The injector group is able to accept additional data"), lo: 2, hi: 4 });
        fields.insert("INJ_IN_PROGRESS", Field { brief: Some("When '1' the injector group is in the process of receiving a frame, and at least one write to INJ_WR remains before the frame is forwarded to the front ports. When '0' the injector group is waiting for an initiation of a frame injection."), details: Some("0: A frame injection is not in progress 1: A frame injection is in progress"), lo: 0, hi: 2 });
        fields.insert("WMARK_REACHED", Field { brief: Some("Before the CPU injects a frame, software may check if the input queue has reached high watermark. If wathermark in the IQS has been reached this bit will be set."), details: Some("0: Input queue has not reached high watermark 1: Input queue has reached high watermark, and frames injected may be dropped due to buffer overflow"), lo: 4, hi: 6 });
        regs.insert("INJ_STATUS", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Injection status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DATA", Field { brief: Some("Frame Write. Write to this register inject  the next 32 bits of the frame data currently injected into the chip. Reading from this register returns 0."), details: None, lo: 0, hi: 32 });
        regs.insert("INJ_WR", Register { addr: Address { base: 2, count: 2, width: 1 }, brief: Some("Manual injection data"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FRM_CNT", Field { brief: Some("For debugging purpose, frames injected are counted with a small wrapping counter."), details: Some("0: No frames has been injected 1: 1 frame has been injected ... 15: 15 frames have been injected"), lo: 0, hi: 4 });
        regs.insert("VTSS_DBG", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("Injection debug"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DP_WM", Field { brief: Some("Watermark, when filling of extraction FIFO exceeds this (or EOF is present in the xtraction buffer) the DEVCPU_QS::XTR_DATA_PRESENT register will indicate that data is available."), details: None, lo: 2, hi: 5 });
        fields.insert("OFLW_ERR_STICKY", Field { brief: Some("Overflow in extraction FIFO. If this happens, SCH_WM must be decreased."), details: Some("0: No buffer overruns detected 1: Buffer has overrruned at least once"), lo: 0, hi: 2 });
        regs.insert("XTR_CFG", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("General extraction configuration and status"), details: None, fields });
        groups.insert("INJ", RegisterGroup { addr: Address { base: 9, count: 1, width: 10 }, desc: "Frame injection", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("DATA_PRESENT", Field { brief: Some("Shows if data is available for a specific group. It remains set until all frame data have been extracted. This field is only set if the mode of the group is set to manual extraction via DEVCPU_QS registers."), details: Some("0: No frames available for this CPU queue group 1: At least one frame is available for this CPU queue group"), lo: 0, hi: 2 });
        regs.insert("XTR_DATA_PRESENT", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Extraction status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FLUSH", Field { brief: Some("Enable software flushing of a CPU queue. Note the queue will continue to be flushed until this field is cleared by SW. The flushing will automatically stop on frame boundary so OQS is allowed to transmit to the CPU queue during flushing."), details: Some("0: No action 1: Do CPU queue flushing"), lo: 0, hi: 2 });
        regs.insert("XTR_FLUSH", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Extraction group flush"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PRUNE_SIZE", Field { brief: Some("Extracted frames for the corresponding queue are pruned to (PRUNE_SIZE+1) 32-bit words. Note :  PRUNE_SIZE includes the IFH when this present in the frame."), details: Some("0 : No pruning 1:  Frames extracted are pruned to 8 bytes 2:  Frames extracted are pruned to 12 bytes ... 255:  Frames extracted are pruned to 1024 bytes"), lo: 0, hi: 8 });
        regs.insert("XTR_FRM_PRUNING", Register { addr: Address { base: 4, count: 2, width: 1 }, brief: Some("Extraction frame pruning"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BYTE_SWAP", Field { brief: Some("This field allows swapping the endianess of DEVCPU_QS::XTR_RD. Most software will want to read extraction data in network order (big-endian mode), i.e. the first byte of the destiantion MAC address to be placed on byte-address 0 of DEVCPU_QS::XTR_RD. In order to do this a little endian CPU must set this field, a big endian CPU must clear this field. This field only applies to manual extraction mode (see DEVCPU_QS::XTR_GRP_CFG.MODE)."), details: Some("0: Same endianess 1: Swap endianness"), lo: 0, hi: 1 });
        fields.insert("MODE", Field { brief: Some("Configures mode of the extraction group. Each extraction group can be assigned to one of three owners. Note: The VRAP block support only one context, if more than one extraction group is assigned the lowest group-number will be used."), details: Some("0: VRAP block 1: Manual extraction (via DEVCPU_QS registers) 2: FDMA extraction and manual extraction via SBA registers"), lo: 2, hi: 4 });
        fields.insert("STATUS_WORD_POS", Field { brief: Some("Select order of last data and status words. This field only applies to manual extraction mode (see DEVCPU_QS::XTR_GRP_CFG.MODE)."), details: Some("0: Status just before last data 1: Status just after last data"), lo: 1, hi: 2 });
        regs.insert("XTR_GRP_CFG", Register { addr: Address { base: 0, count: 2, width: 1 }, brief: Some("Extraction group configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DATA", Field { brief: Some("Frame Data. Read from this register to obtain the next 32 bits of the frame data currently stored in the CPU queue system. Each read must check for the special values \"0x8000000n\", 0<=n<=7, as described by the encoding. Note: The encoding is presented in little endian format, if swapping is used (see DEVCPU_QS::XTR_GRP_CFG.BYTE_SWAP), then the special values are swapped as well. I.e. a little endian CPU using BYTE_SWAP=1 has to look for \"0x0n000080\" instead of \"0x8000000n\". The position of the unused/valid bytes follows the endianness encoding and swapping."), details: Some("n=0-3: EOF. Unused bytes in end-of-frame word is 'n' n=4\t : EOF, but truncated n=5\t : EOF Aborted. Frame invalid n=6\t : Escape. Next read is packet data n=7\t : Data not ready for reading out"), lo: 0, hi: 32 });
        regs.insert("XTR_RD", Register { addr: Address { base: 2, count: 2, width: 1 }, brief: Some("Manual extraction data"), details: None, fields });
        groups.insert("XTR", RegisterGroup { addr: Address { base: 0, count: 1, width: 9 }, desc: "Frame extraction", regs });
        out.insert("DEVCPU_QS", Target { desc: "CPU Device Queue System", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("AGING_ENA", Field { brief: Some("Enable aging of frames stuck in the DSM buffer system for long periods. Aging is done by comparing the age era stamped into the frame with the current age era. This check is only performed at SOF. If the current age era is more than one higher than the era stamped into the frame, then the frame is discarded."), details: Some("'0': Aging disabled. '1': Aging enabled."), lo: 0, hi: 1 });
        fields.insert("CSC_STAT_DIS", Field { brief: Some("Disables the CSC statistics counters in the DSM for the port. Set this when the port utilizes a DEV10G device as this handles the statistics locally in the device."), details: None, lo: 1, hi: 2 });
        regs.insert("BUF_CFG", Register { addr: Address { base: 0, count: 55, width: 1 }, brief: Some("Configuration per device buffer."), details: Some("Miscellaneous configurations per device buffer."), fields });
        let mut fields = HashMap::new();
        fields.insert("CLR_BUF", Field { brief: Some("A write to this register clears the indicated buffer. No other buffers will be influenced by clearing this buffer. Encoding: 1: Clears buffer for port 0 2: Clears buffer for port 1 2^N: Clears buffer for port N If N > 31 Use respective next register."), details: Some("'0': No action '1': Buffer is cleared (Bit is automatically cleared)"), lo: 0, hi: 32 });
        regs.insert("CLR_BUF", Register { addr: Address { base: 165, count: 2, width: 1 }, brief: Some("Clear a single buffer in the DSM."), details: Some("This register controls clearing of buffers in the DSM."), fields });
        let mut fields = HashMap::new();
        fields.insert("CM_DATA", Field { brief: Some("Data register for core memory access. Wider memories are big endian mapped into the 32 BIT inspection space."), details: None, lo: 0, hi: 32 });
        regs.insert("CM_DATA", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Data register for core memory access."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DEV10G_SHADOW_ENA", Field { brief: Some("Set this to '1' when a 10G capable port runs at speeds below 10G."), details: None, lo: 6, hi: 7 });
        fields.insert("DEV_TX_STOP_WM", Field { brief: Some("When the token counter value for the device exceeds this value the DSM will stop transmission to the device. When set to 0 a hardware calculated default value is used. When a port is configured for HDX this WM must be set to 1."), details: None, lo: 0, hi: 6 });
        fields.insert("FAST_STARTUP_ENA", Field { brief: Some("Set this to 0 to disable the fast startup of frames in the token system."), details: None, lo: 7, hi: 8 });
        regs.insert("DEV_TX_STOP_WM_CFG", Register { addr: Address { base: 277, count: 55, width: 1 }, brief: Some("Token count tx stop watermark"), details: Some("Token count tx stop watermark"), fields });
        let mut fields = HashMap::new();
        fields.insert("FC_ANA_ENA", Field { brief: Some("Obey FC status received from ANA"), details: None, lo: 1, hi: 2 });
        fields.insert("FC_QS_ENA", Field { brief: Some("Obey FC status received from QSYS"), details: None, lo: 0, hi: 1 });
        regs.insert("ETH_FC_CFG", Register { addr: Address { base: 387, count: 55, width: 1 }, brief: Some("FC configuration for Ethernet ports."), details: Some("FC configuration for Ethernet ports."), fields });
        let mut fields = HashMap::new();
        fields.insert("PFC_ENA", Field { brief: Some("Enable PFC operation for the port."), details: None, lo: 0, hi: 1 });
        fields.insert("PFC_MIN_UPDATE_TIME", Field { brief: Some("Minimum time between two PFC PDUs when PFC state changes after transmission of PFC PDU."), details: None, lo: 2, hi: 17 });
        fields.insert("PFC_XOFF_MIN_UPDATE_ENA", Field { brief: Some("Upon sending  PFC PDU with flow control deasserted for all priorities, enforce a PFC_MIN_UPDATE_TIME delay before allowing transmission of next PFC PDU."), details: None, lo: 1, hi: 2 });
        regs.insert("ETH_PFC_CFG", Register { addr: Address { base: 442, count: 55, width: 1 }, brief: Some("PFC configuration for Ethernet ports."), details: Some("PFC configuration for Ethernet ports."), fields });
        let mut fields = HashMap::new();
        fields.insert("IPG_PREAM_SHRINK_ENA", Field { brief: Some("Enable for preamble shrink in IPG shrink mode of DEV10G, DEV24G. Preamble shrink is only allowed when IPG shrink mode is enabled."), details: None, lo: 1, hi: 2 });
        fields.insert("IPG_SHRINK_ENA", Field { brief: Some("Enable for IPG shrink mode of DEV10G, DEV24G. In shrink mode frame gap compensation is depending on frame size."), details: None, lo: 0, hi: 1 });
        regs.insert("IPG_SHRINK_CFG", Register { addr: Address { base: 110, count: 55, width: 1 }, brief: Some("Configuration register for IPG shrink mode"), details: Some("Configuration register for IPG shrink mode"), fields });
        let mut fields = HashMap::new();
        fields.insert("MAC_ADDR_HIGH", Field { brief: Some("Bits 47-24 of MAC base address. Used when generating Pause Control Frames with the specified MAC address."), details: None, lo: 0, hi: 24 });
        regs.insert("MAC_ADDR_BASE_HIGH_CFG", Register { addr: Address { base: 552, count: 53, width: 1 }, brief: Some("MAC Address Base Configuration Register - bits 47-24."), details: Some("MAC base address. Used when generating Pause Control Frames with the specified MAC address."), fields });
        let mut fields = HashMap::new();
        fields.insert("MAC_ADDR_LOW", Field { brief: Some("Bits 23-0 of MAC base address. Used when generating Pause Control Frames with the specified MAC address."), details: None, lo: 0, hi: 24 });
        regs.insert("MAC_ADDR_BASE_LOW_CFG", Register { addr: Address { base: 605, count: 53, width: 1 }, brief: Some("MAC Address Base Configuration Register - bits 23-0."), details: Some("MAC base address. Used when generating Pause Control Frames with the specified MAC address."), fields });
        let mut fields = HashMap::new();
        fields.insert("HDX_BACKPRESSURE", Field { brief: Some("Enables HDX backpressure instead of FDX FC when FC is generated. Note: 10G and 24G ports can not run HDX, so for those ports this field must always be set to '0'."), details: Some("'0': FDX FC is used. '1': HDX backpreassure is used."), lo: 2, hi: 3 });
        fields.insert("SEND_PAUSE_FRM_TWICE", Field { brief: Some("Defines whether or not each pause frame will be sent twice."), details: Some("'0': Send one pause frame two times per pause period. '1': Send two pause frames back to back two times per pause period."), lo: 1, hi: 2 });
        fields.insert("TX_PAUSE_VAL", Field { brief: Some("Tx Pause Value: The pause value inserted in each Pause Control Frame in the Tx direction. It is also used to schedule the transmission of Pause Control Frames when Flow Control is enabled and active. If flow control is enabled, the pause value must be set to a value different from 0, based on the link characteristics."), details: Some("0x0000: 0 quanta (512-bit times) 0x0001: 1 quanta ... 0xFFFF: 64K-1 quanta."), lo: 16, hi: 32 });
        fields.insert("TX_PAUSE_XON_XOFF", Field { brief: Some("TX pause zero on de-assert. Determines whether or not a pause control frame with pause value zero is transmitted when flow control is de-asserted."), details: Some("'0': No pause frame with value zero is transmitted. '1': Pause frame with value zero is transmitted when flow control becomes inactive."), lo: 0, hi: 1 });
        regs.insert("MAC_CFG", Register { addr: Address { base: 497, count: 55, width: 1 }, brief: Some("MAC Configuration Register."), details: Some("Contains configuration for flowcontrol and operation in FDX or HDX for Ethernet ports connected to the DSM."), fields });
        let mut fields = HashMap::new();
        fields.insert("FRM_GAP_COMP", Field { brief: Some("If Rate Limit mode Frame Rate Overhead is enabled this bitgroup is used for configuration of txAdditionalFrameOverhead."), details: None, lo: 24, hi: 32 });
        regs.insert("RATE_CTRL", Register { addr: Address { base: 55, count: 55, width: 1 }, brief: Some("txAdditionalFrameOverhead configuration"), details: Some("Configuration of the txAdditionalFrameOverhead in RateLimit"), fields });
        let mut fields = HashMap::new();
        fields.insert("FC_OBEY_LOCAL", Field { brief: Some("Configures for each Ethernet port whether flow control is obeyed locally in the DSM or if the flow_control information is sent to the SCH. If not all priorities should obey flow control for this port, then the DSM should not stop the data stream in a flow control case, but let the SCH stop the traffic to avoid head of line blocking. If all priorities should obey flow control for this port, then the DSM should stop the data stream locally to be able to pass 802.3 conformance testing. If the data stream is stopped by the SCH frames in the OQS can not be aged, thus the Allocation Bitmaps in the QS must not recover lost elements."), details: Some("'0': This Ethernet port obeys flow control locally in the DSM. '1': This Ethernet port sends flow control information to the SCH and does not stop traffic in the DSM."), lo: 0, hi: 1 });
        fields.insert("RX_PAUSE_EN", Field { brief: Some("Rx Pause Enable: Enables Flow Control in Rx direction:"), details: Some("'0': Flow Control Disabled '1': Flow Control Enabled."), lo: 1, hi: 2 });
        regs.insert("RX_PAUSE_CFG", Register { addr: Address { base: 332, count: 55, width: 1 }, brief: Some("Pause frame handling in RX direction"), details: Some("Pause frame handling in RX direction"), fields });
        let mut fields = HashMap::new();
        fields.insert("SCH_STOP_WM", Field { brief: Some("DSM buffer fill level at which SCH is stopped to send to this device."), details: Some("The SCH is stopped when the fill level is above the configured value. When set to 0 the hardware will use a default watermark set to the mid of the buffer."), lo: 0, hi: 9 });
        regs.insert("SCH_STOP_WM_CFG", Register { addr: Address { base: 167, count: 55, width: 1 }, brief: Some("SCH stop fill level"), details: Some("SCH stop fill level"), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_START_WM", Field { brief: Some("The number of 4-bytes words in DSM buffer required before the DSM will start to transmit on the taxi bus. The fill level must above a certain threshold to avoid underflow in the devices. Single cell frames will be transfered immediately."), details: Some("The DSM will not begin transmission until the fill level is above this watermark or one complete frame is present in the buffer."), lo: 0, hi: 9 });
        regs.insert("TX_START_WM_CFG", Register { addr: Address { base: 222, count: 55, width: 1 }, brief: Some("Transmit start fill level"), details: Some("Transmit start fill level"), fields });
        groups.insert("CFG", RegisterGroup { addr: Address { base: 3, count: 1, width: 659 }, desc: "Configuration registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CM_ADDR", Field { brief: Some("Address selection within selected core memory (CMID register). Address is automatically advanced at every data access."), details: None, lo: 0, hi: 22 });
        fields.insert("CM_ID", Field { brief: Some("Please refer to cmid.xls in the AS1000, misc_docs folder."), details: None, lo: 22, hi: 30 });
        regs.insert("CM_ADDR", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Address selection"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RAM_ENA", Field { brief: Some("Core memory controllers are enabled when this field is set."), details: None, lo: 0, hi: 1 });
        fields.insert("RAM_INIT", Field { brief: Some("Initialize core memories. Field is automatically cleared when operation is complete ( approx. 40 us)."), details: None, lo: 1, hi: 2 });
        regs.insert("RAM_INIT", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Core reset control"), details: Some("Controls reset and initialization of the switching core. Proper startup sequence is: - Enable memories - Initialize memories - Enable core"), fields });
        groups.insert("COREMEM", RegisterGroup { addr: Address { base: 0, count: 1, width: 2 }, desc: "Access core memory", regs });
        let regs = HashMap::new();
        groups.insert("RAM_CTRL", RegisterGroup { addr: Address { base: 2, count: 1, width: 1 }, desc: "Access core memory", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("PRE_CNT_OFLW_STICKY", Field { brief: Some("Will be set if one of the statistics pre counter have an overflow."), details: Some("'0': Pre counter overflow has not occurred '1': Pre counter overflow has occurred Bit is cleared by writing a '1' to this position."), lo: 8, hi: 9 });
        regs.insert("PRE_CNT_OFLW_STICKY", Register { addr: Address { base: 60, count: 1, width: 1 }, brief: Some("Pause Frame pre-counter overflow sticky register"), details: Some("Pause Frame pre-counter overflow sticky register"), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_FRAME_RATE_START", Field { brief: Some("Value loaded into the txFrameRateTimer at the start of each packet, when TX_RATE_LIMIT_FRAME_RATE mode is enabled. Timer is decremented with each byte transmitted. IPG is set to timer value at EOF. Note: If resulting IPG is smaller than the minimum IPG of 12 bytes, it will be set to 12 bytes."), details: Some("Timer start value in bytes. To take effect, value must be above 84. (64byte min frame size, 8 byte preamble, 12 byte minimum IFG)."), lo: 0, hi: 16 });
        regs.insert("TX_FRAME_RATE_START_CFG", Register { addr: Address { base: 110, count: 55, width: 1 }, brief: Some("Configuration register for txFrameRateStart"), details: Some("Configuration register for txFrameRateStart"), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_FINE_IPG_STRETCH_RATIO", Field { brief: Some("Determines the extent of the interPacketGap extension, when txRateLimitPayloadRate mode is enabled. It may be considered as the number of bits in a packet that would require 32 octets of interPacketGap extension. Note that each interPacketGap is increased by an integer number of octets, the average increase is ( (frame length in bits) * 32) / txFineIpgStretchRatio. Note: fractions left at frame border will be carried on to the next frame. Example: Packet length = 64 bytes + 8 bytes preamble value = 2048 IPG increase = 9 bytes Maximum IPG increase is 255 bytes."), details: Some("IPG increase = frame length in bits * 32 / value. values below 2048 and above 518143 are reserved for arithmetic processing  reasons."), lo: 0, hi: 19 });
        regs.insert("TX_IPG_STRETCH_RATIO_CFG", Register { addr: Address { base: 55, count: 55, width: 1 }, brief: Some("Configuration register for txFineIpgStretchRatio"), details: Some("Configuration register for txFineIpgStretchRatio"), fields });
        let mut fields = HashMap::new();
        fields.insert("IPG_SCALE_VAL", Field { brief: Some("Scale the IPG calculated by txRateLimitFrameOverhead and/or txRateLimitPayloadRate by a power of 2 to enable shaping down to lower BW. Note: For txRateLimitPayloadRate only the additional overhead excluding the standard 12 byte IPG is scaled whereas for txRateLimitFrameOverhead the complete value is scaled."), details: Some("0: Don't scale 1: Multiply by 2 2: Multiply by 4 (...) 10: Multiply by 1024 11-15: Reserved"), lo: 16, hi: 20 });
        fields.insert("PAYLOAD_CFG", Field { brief: Some("Defines if what is configured as header size in TX_RATE_LIMIT_HDR_SIZE::TX_RATE_LIMIT_HDR_CFG is subtracted form the payload in txRateLimitPayloadRate and txRateLimitFrameRate mode."), details: Some("0: Nothing is subtracted from payload 1: TX_RATE_LIMIT_HDR_SIZE::TX_RATE_LIMIT_HDR_CFG is subtracted from payload"), lo: 9, hi: 10 });
        fields.insert("PAYLOAD_PREAM_CFG", Field { brief: Some("This bitgroup defines whether the preamble is counted as payload in txRateLimitPayloadRate and txRateLimitFrameRate mode."), details: Some("'0': Preamble is not counted as payload '1': Preamble is counted as payload"), lo: 8, hi: 9 });
        fields.insert("TX_RATE_IPG_PPM_ADAPT_ENA", Field { brief: Some("Enable for IPG reduction to allow adaption to clock frequency offsets. When this mode is enabled, all other TX_RATE_LIMIT modes must be disabled."), details: Some("'0': tx IPG reduction test feature disabled '1': tx IPG reduction test feature enabled"), lo: 3, hi: 4 });
        fields.insert("TX_RATE_LIMIT_ACCUM_MODE_ENA", Field { brief: Some("Enable for accumulated rate limit mode. Instead of taking the maximum  IPG of txRateLimitFrameOverhead, txRateLimitPayloadRate and txRateLimitFrameRate. The resulting IPG is the sum of txRateLimitFrameOverhead and txRateLimitPayloadRate. txRateLimitFrameRate must be disabled."), details: Some("'0': Accumulated rate limit mode is disabled '1': Accumulated rate limit mode is enabled"), lo: 4, hi: 5 });
        fields.insert("TX_RATE_LIMIT_FRAME_OVERHEAD_ENA", Field { brief: Some("Enable txRateLimitFrameOverhead mode. IPG is increased by a fixed value specified in RATE_CTRL::FRM_GAP_COMP"), details: Some("'0': txRateLimitFrameOverhead disabled '1': txRateLimitFrameOverhead enabled"), lo: 0, hi: 1 });
        fields.insert("TX_RATE_LIMIT_FRAME_RATE_ENA", Field { brief: Some("Enable txRateLimitFrameRate mode. IPG is extended so that frame_size + IPG result in the value configured in RATE_CTRL::TX_FRAME_RATE_START"), details: Some("'0': txRateLimitFrameRate disabled '1': txRateLimitFrameRate enabled"), lo: 2, hi: 3 });
        fields.insert("TX_RATE_LIMIT_PAYLOAD_RATE_ENA", Field { brief: Some("Enable txRateLimitPayloadRate mode. IPG is increased relative to payload size."), details: Some("'0': txRateLimitPayloadRate disabled '1': txRateLimitPayloadRate enable"), lo: 1, hi: 2 });
        regs.insert("TX_RATE_LIMIT_MODE", Register { addr: Address { base: 0, count: 55, width: 1 }, brief: Some("Configuration register for rate limit modes"), details: Some("Configuration register for rate limit modes"), fields });
        groups.insert("RATE_LIMIT_CFG", RegisterGroup { addr: Address { base: 723, count: 1, width: 166 }, desc: "Configuration registers for rate limit modes", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("TX_RATE_LIMIT_HDR_SIZE", Field { brief: Some("Defines how much of the frame is seen as header and not counted as payload in txRateLimitPayloadRate and txRateLimitFrameRate mode when TX_RATE_LIMIT_MODE::PAYLOAD_CFG is set to 1."), details: Some("0: 32 bytes are counted as header 1-31: 1-31 bytes are counted as header"), lo: 0, hi: 5 });
        regs.insert("TX_RATE_LIMIT_HDR_CFG", Register { addr: Address { base: 165, count: 1, width: 1 }, brief: Some("Header size configuration register for txRateLimitPayloadRate mode"), details: Some("Header size configuration register for txRateLimitPayloadRate mode"), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_RATE_LIMIT_STICKY", Field { brief: Some("Sticky bit set when one of the three tx rate limitation modes has increased the IPG. I.e. when a tx rate limit mode was enabled an DSM has requested the device to use a IPG different from 12 byte."), details: Some("'0': Tx Rate Limitation has not occurred. '1': Tx Rate Limitation has occurred. Bit is cleared by writing a '1' to this position."), lo: 0, hi: 32 });
        regs.insert("TX_RATE_LIMIT_STICKY", Register { addr: Address { base: 0, count: 2, width: 1 }, brief: Some("Sticky bit register for rate limit modes"), details: Some("Sticky bit register for rate limit modes"), fields });
        groups.insert("RATE_LIMIT_STATUS", RegisterGroup { addr: Address { base: 889, count: 1, width: 2 }, desc: "Status registers for rate limit modes", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("AGED_FRMS_CNT", Field { brief: Some("Count number of aged frames for each port."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("AGED_FRMS", Register { addr: Address { base: 0, count: 55, width: 1 }, brief: Some("Counts number of aged frames."), details: Some("This counter holds the number of aged frames from this port."), fields });
        let mut fields = HashMap::new();
        fields.insert("BUF_OFLW_STICKY", Field { brief: Some("Sticky bits for detecting buffer overflow in any of the cell buffers in the DSM."), details: Some("'0': No buffer overflow detected. '1': Buffer overflow detected. Bit is cleared by writing a '1' to this position."), lo: 0, hi: 32 });
        regs.insert("BUF_OFLW_STICKY", Register { addr: Address { base: 56, count: 2, width: 1 }, brief: Some("Buffer Overflow"), details: Some("Buffer Overflow"), fields });
        let mut fields = HashMap::new();
        fields.insert("BUF_UFLW_STICKY", Field { brief: Some("Sticky bits for detecting buffer underflow in any of the cell buffers in the DSM."), details: Some("'0': No buffer underflow detected. '1': Buffer underflow detected. Bit is cleared by writing a '1' to this position."), lo: 0, hi: 32 });
        regs.insert("BUF_UFLW_STICKY", Register { addr: Address { base: 58, count: 2, width: 1 }, brief: Some("Buffer Underrun"), details: Some("Buffer Underrun"), fields });
        let mut fields = HashMap::new();
        fields.insert("CELL_BUS_MISSING_EOF_STICKY", Field { brief: Some("This bit is set if data marked as SOF is received without the current frame has been terminated with EOF. The current frame will be terminated by setting the abort bit and the next frame will be discarded."), details: Some("'0': Missing EOF has not been detected. '1': Missing EOF has been detected. Bit is cleared by writing a '1' to this position."), lo: 0, hi: 1 });
        fields.insert("CELL_BUS_MISSING_SOF_STICKY", Field { brief: Some("This bit is set if cells are received after an EOF and before the following SOF."), details: Some("'0': Missing SOF has not been detected. '1': Missing SOF has been detected. Bit is cleared by writing a '1' to this position."), lo: 1, hi: 2 });
        regs.insert("CELL_BUS_STICKY", Register { addr: Address { base: 55, count: 1, width: 1 }, brief: Some("Sticky bits for the DSM cell bus interface."), details: Some("This register holds sticky bit information for the cell bus interface of the DSM."), fields });
        let mut fields = HashMap::new();
        fields.insert("DBG_EVENT_CTRL", Field { brief: Some("Controls which event the AGE counter counts. This setting is common for all aging counters."), details: Some("0: Number of aged frames 1: Number of SOF transmitted on taxi bus 2: Number of EOF transmitted on taxi bus 3: Number of ABORT transmitted on taxi bus 4: Reserved 5: Number of retransmits requests received from port status 6: Reserved 7: Reserved"), lo: 0, hi: 3 });
        regs.insert("DBG_CTRL", Register { addr: Address { base: 658, count: 1, width: 1 }, brief: Some("Debug control"), details: Some("Configures which events are counterd in the ageing counter."), fields });
        groups.insert("STATUS", RegisterGroup { addr: Address { base: 662, count: 1, width: 61 }, desc: "Status registers", regs });
        out.insert("DSM", Target { desc: "Disassembler", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CIR_BURST", Field { brief: Some("Burst capacity of this shaper. Unit is 4096 bytes. The shaper is disabled when CIR_BURST=0."), details: None, lo: 0, hi: 6 });
        fields.insert("CIR_RATE", Field { brief: Some("Leak rate for this shaper. Unit is defined by the leak list period the shaper is attached to (see HSCH_LEAK_CFG.LEAK_TIME)."), details: None, lo: 6, hi: 23 });
        regs.insert("CIR_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Shaping configuration of the SE"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("EIR_BURST", Field { brief: Some("Burst capacity of this shaper. Unit is 4096 bytes. The dual leaky bucket shaper operates as a single leaky bucket shaper when EIR_BURST=0."), details: None, lo: 0, hi: 6 });
        fields.insert("EIR_RATE", Field { brief: Some("Leak rate for this shaper. Same unit as CIR_RATE unit."), details: None, lo: 6, hi: 23 });
        regs.insert("EIR_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Excess rate configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("WIN_SHIST", Field { brief: Some("Contains the layer 0 scheduling history descriptor for a frames passing through layer-1 element A, input B. Group replication index is A and register replication is B."), details: None, lo: 0, hi: 23 });
        regs.insert("HSCH_L1W", Register { addr: Address { base: 0, count: 64, width: 1 }, brief: Some("Winner table"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SE_AVB_ENA", Field { brief: Some("Enable AVB mode for this shaper, creating burst capacity only when data is available."), details: None, lo: 5, hi: 6 });
        fields.insert("SE_DWRR_CNT", Field { brief: Some("Number of inputs running with DWRR algorithm, otherwise strict. Strict inputs always have the highest input index."), details: Some("0: No inputs uses DWRR 1: 2 lowest inputs used DWRR n: (n+1) lowest inputs uses DWRR"), lo: 6, hi: 12 });
        fields.insert("SE_DWRR_FRM_MODE", Field { brief: Some("Accounting mode for the dwrr distribution."), details: Some("0: Line rate. Cost is frame length including HSCH_MISC_CFG.FRM_ADJ. 1: Data rate. Cost is frame length excluding IPG. 2. Frame rate. Cost is 1. 3: Reserved."), lo: 1, hi: 3 });
        fields.insert("SE_FRM_MODE", Field { brief: Some("Accounting mode for this shaper."), details: Some("0: Line rate. Shape bytes including HSCH_MISC_CFG.FRM_ADJ. 1: Data rate. Shape bytes excluding IPG. 2. Frame rate. Shape frames with rate unit = 100 fps and burst unit = 32.8 frames. 3: Frame rate. Shape framed with rate unit = 1 fps and burst unit = 0.3 frames."), lo: 3, hi: 5 });
        fields.insert("SE_STOP", Field { brief: Some("Block traffic through this element. This can be used for transfering element to other locations in the scheduling hierarchy"), details: Some("0: Traffic can flow through this element 1: This element will block its output"), lo: 0, hi: 1 });
        regs.insert("SE_CFG", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Configuration of shaper and scheduling algorithm"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SE_LEAK_LINK", Field { brief: Some("Forms the leak chains."), details: None, lo: 0, hi: 15 });
        regs.insert("SE_CONNECT", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Configuration of the connections between SEs"), details: None, fields });
        groups.insert("HSCH_CFG", RegisterGroup { addr: Address { base: 0, count: 3400, width: 8 }, desc: "Configuration of scheduling system and shapers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("INP_STATE", Field { brief: Some("Returns the 32 input states for se cfg_se_idx, from offset 32*replication"), details: None, lo: 0, hi: 32 });
        regs.insert("INP_STATE", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("INPUT state"), details: None, fields });
        groups.insert("HSCH_DWRR", RegisterGroup { addr: Address { base: 27456, count: 64, width: 1 }, desc: "Configure DWRR weights", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CIR_LVL", Field { brief: Some("Current fill level. Unit is 1 bit."), details: None, lo: 0, hi: 24 });
        regs.insert("QSHP_CIR_STATE", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("CIR status"), details: None, fields });
        groups.insert("HSCH_INP_STATE", RegisterGroup { addr: Address { base: 27520, count: 2, width: 1 }, desc: "Status of scheduling element inputs", regs });
        let regs = HashMap::new();
        groups.insert("HSCH_L0_CFG", RegisterGroup { addr: Address { base: 57344, count: 3400, width: 1 }, desc: "Hierarchy configuration", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("L2_IDX", Field { brief: Some("Index of layer 2 element connected to by this layer 1 element"), details: None, lo: 0, hi: 6 });
        regs.insert("HSCH_L1_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Hierarchy configuration"), details: None, fields });
        groups.insert("HSCH_L1W", RegisterGroup { addr: Address { base: 28672, count: 64, width: 64 }, desc: "Win data for layer 1", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("L1_IDX", Field { brief: Some("Index of layer 1 element connected to."), details: None, lo: 6, hi: 12 });
        fields.insert("L1_INP", Field { brief: Some("Input of layer 1 element connected to"), details: None, lo: 0, hi: 6 });
        regs.insert("HSCH_L0_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Hierarchy configuration"), details: None, fields });
        groups.insert("HSCH_L1_CFG", RegisterGroup { addr: Address { base: 27200, count: 64, width: 1 }, desc: "Hierarchy configuration", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("HFORCE_1SHOT", Field { brief: Some("Update the requested scheduling element"), details: None, lo: 0, hi: 1 });
        fields.insert("HFORCE_LAYER", Field { brief: Some("Set to layer in which an element must be updated."), details: Some("0: Update a layer 0 element 1: Update a layer 1 element 2: Update a layer 2 element 3: Reserved"), lo: 13, hi: 15 });
        fields.insert("HFORCE_SE_IDX", Field { brief: Some("Set to index of element to force"), details: None, lo: 1, hi: 13 });
        regs.insert("HSCH_FORCE_CTRL", Register { addr: Address { base: 138, count: 1, width: 1 }, brief: Some("Force update of an element in the hierarchy"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LEAK_ERR", Field { brief: Some("The leak group didnt succeed traversing all shapers. Rates will be wrong."), details: None, lo: 0, hi: 1 });
        fields.insert("LEAK_FIRST", Field { brief: Some("First shaper in the leak group"), details: None, lo: 1, hi: 16 });
        regs.insert("HSCH_LEAK_CFG", Register { addr: Address { base: 4, count: 4, width: 1 }, brief: Some("Leak configuration per leak group"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LEAK_TIME", Field { brief: Some("Number of nanoseconds between each traversal of the leak list. A value of 10000 correspond to 10us. Each traversal subtracts the configured rate from the shaper buckets, counting bits. With the value of 10000, a rate of 1 corresponds to 1 bit per 10us, or 100kbps. A leak group can be set up for 16kbps unit by seting the leak_time to 1 bit per 62500 nanoseconds."), details: Some("0: Leaking disabled 62500: 16kbps unit 10000: 100kbps unit 1000:  1Mbps unit (any other)"), lo: 0, hi: 18 });
        regs.insert("HSCH_TIMER_CFG", Register { addr: Address { base: 0, count: 4, width: 1 }, brief: Some("Leak configuration per leak group"), details: None, fields });
        groups.insert("HSCH_LEAK_LISTS", RegisterGroup { addr: Address { base: 27661, count: 4, width: 8 }, desc: "Configuration of leak lists", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("PORT_KICK", Field { brief: Some("Force port to be frame pending. To be used when a port for some unknown reason gets stuck. The port configured in FLUSH_PORT will be marked pending."), details: None, lo: 0, hi: 1 });
        regs.insert("DEBUG_CTRL", Register { addr: Address { base: 134, count: 1, width: 1 }, brief: Some("Internal control for debugging only"), details: Some("Core events."), fields });
        let mut fields = HashMap::new();
        fields.insert("DWRR_BALANCE", Field { brief: Some("Current balance of the input"), details: None, lo: 0, hi: 20 });
        fields.insert("DWRR_COST", Field { brief: Some("When a specific input to an element is used, the cost is used when updating the balance."), details: None, lo: 20, hi: 25 });
        regs.insert("DWRR_ENTRY", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Configuration and status of a dwrr entry"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FP_FREE_CNT", Field { brief: Some("Number of free frame references."), details: None, lo: 0, hi: 16 });
        regs.insert("EQ_STAT", Register { addr: Address { base: 133, count: 1, width: 1 }, brief: Some("Egress queue status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("EV_ENQ_ERR", Field { brief: Some("If an frame is added to an invalid queue in the scheduling hierarchy, this sticky bit will be set, and the violating request is see the EVENT_ENQ_ERR register."), details: None, lo: 0, hi: 1 });
        fields.insert("EV_FRD", Field { brief: Some("Look in the RTL!"), details: None, lo: 1, hi: 5 });
        fields.insert("EV_HSCH", Field { brief: Some("Look in the RTL!"), details: None, lo: 5, hi: 12 });
        regs.insert("EVENTS_CORE", Register { addr: Address { base: 132, count: 1, width: 1 }, brief: Some("Internal events for debugging only"), details: Some("Core events."), fields });
        let mut fields = HashMap::new();
        fields.insert("ENQ_ERR_PORT", Field { brief: Some("Contains last enqueuing error egress port number"), details: None, lo: 15, hi: 21 });
        fields.insert("ENQ_ERR_QNO", Field { brief: Some("Scheduling element being violated."), details: None, lo: 0, hi: 15 });
        regs.insert("EVENT_ENQ_ERR", Register { addr: Address { base: 136, count: 1, width: 1 }, brief: Some("Information about enqueueing error"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FLUSH_DST", Field { brief: Some("Frame transmitted on the configured port will be flushed if set."), details: None, lo: 23, hi: 24 });
        fields.insert("FLUSH_ENA", Field { brief: Some("Set to enable flushing of all frames matching the flush criterias in this register"), details: None, lo: 25, hi: 26 });
        fields.insert("FLUSH_HIER", Field { brief: Some("Flushing will only affect frames from this queue or SE."), details: None, lo: 0, hi: 15 });
        fields.insert("FLUSH_PORT", Field { brief: Some("Flushing will only affect frames on this port."), details: None, lo: 17, hi: 23 });
        fields.insert("FLUSH_QUEUE", Field { brief: Some("Frames transmitted from the configured queue specified in FLUSH_HIER will be flushed."), details: None, lo: 16, hi: 17 });
        fields.insert("FLUSH_SE", Field { brief: Some("Frames transmitted from the configured SE index specified in FLUSH_HIER will be flushed."), details: None, lo: 15, hi: 16 });
        fields.insert("FLUSH_SRC", Field { brief: Some("Frame received on the configured port will be flushed if set."), details: None, lo: 24, hi: 25 });
        regs.insert("FLUSH_CTRL", Register { addr: Address { base: 131, count: 1, width: 1 }, brief: Some("Enable flushing of selected framesy"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CFG_SE_IDX", Field { brief: Some("The DWRR balances and queue shapers will be accessed for the scheduling element indexed by this field."), details: None, lo: 14, hi: 26 });
        fields.insert("CSR_GRANT", Field { brief: Some("Skip a hierarchy update every time this number of updates has been done. If zero, the feature is disabled. Setting to 4095 will disable hierachy updates."), details: None, lo: 0, hi: 12 });
        fields.insert("HSCH_LAYER", Field { brief: Some("The HSCH layer set in this field will be accessed by the configuration interfaces."), details: None, lo: 12, hi: 14 });
        regs.insert("HSCH_CFG_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Configuration selection register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("HSCH_LARGE_ENA", Field { brief: Some("Bit n in replication k enables extended width on scheduling element (32k+n)*2. Scheduling element (32k+n)*2+1 must not be used if enabled. Fx. if scheduling element 180 should handle 16 inputs, HSCH_LARGE_ENA[2] bit 26 should be set to 1, and element 181 must not be used."), details: None, lo: 0, hi: 32 });
        regs.insert("HSCH_LARGE_ENA", Register { addr: Address { base: 112, count: 14, width: 1 }, brief: Some("Enable large scheduling elements"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FRM_ADJ", Field { brief: Some("Values to add each frame when frame length adjustment is in use."), details: None, lo: 0, hi: 5 });
        fields.insert("LEAK_DIS", Field { brief: Some("Set this to one to disabled all leaking from leaky bucket shapers"), details: None, lo: 5, hi: 6 });
        regs.insert("HSCH_MISC_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Common config for HSCH and policer module"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("HSCH_UPDATE_CNT", Field { brief: Some("Return the maximum period of constant update need. Clear by writing one to the lsb of the register."), details: None, lo: 0, hi: 13 });
        regs.insert("HSCH_UPDATE_STAT", Register { addr: Address { base: 135, count: 1, width: 1 }, brief: Some("Return information about scheduler busyness"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("OUTB_CPU_SHARE_ENA", Field { brief: Some("When enabled, unused bandwidth sharing will be granted to the an internal CPUport, only when the calendar designated port is another internal CPU port. The OUTB_SHARE_ENA must be configured for the CPU ports when this is enabled"), details: None, lo: 0, hi: 1 });
        regs.insert("OUTB_CPU_SHARE_ENA", Register { addr: Address { base: 126, count: 1, width: 1 }, brief: Some("Cellbus configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("OUTB_SHARE_ENA", Field { brief: Some("Sets the minimum distance between grants to an internal port. Extra grants are disabled when configured value is 0, otherwise the port seeks extra bandwidth, and the minimim distance in clock cycles is given by this value. The four replications are for internal CPU 0, internal CPU 1, VD0 and VD1. Setting a value of 14 grants extra bandwidth every 14 cycles, which for minimum sized frames corresponds to 84 bytes per 14 x 6,4 ns, or 7.5Gbps. Setting a value of 10 grants every 10 cycles, corresponding to 84 bytes per 64 ns, or 10.5Gbps. Minimum value for VD0 is 14, and 8 for the other internal ports."), details: None, lo: 0, hi: 8 });
        regs.insert("OUTB_SHARE_ENA", Register { addr: Address { base: 127, count: 4, width: 1 }, brief: Some("Cellbus configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PFC_LAYER", Field { brief: Some("Set the layer at which PFC status should be applied for this port. Only layers 1 and 2 supports PFC blocking of the hierarchy."), details: Some("0: Dont block any branches through PFC status 1: Use pfc status for the port on layer 1 2: Use pfc status for the port on layer 2 3: Reserved"), lo: 6, hi: 8 });
        fields.insert("PFC_SE", Field { brief: Some("Set to the scheduling element number which should be affected by pfc status for this port."), details: None, lo: 0, hi: 6 });
        regs.insert("PFC_CFG", Register { addr: Address { base: 59, count: 53, width: 1 }, brief: Some("Per port PFC configuration"), details: Some("These configurations exists per front port."), fields });
        let mut fields = HashMap::new();
        fields.insert("AGE_DIS", Field { brief: Some("Disable aging of all frames transmitted to the port. Frame aging related parameters: QSYS:SYSTEM:FRM_AGING.MAX_AGE HSCH:HSCH_MISC:PORT_MODE.AGE_DIS DSM:CFG:BUF_CFG.AGING_ENA"), details: None, lo: 3, hi: 4 });
        fields.insert("CPU_PRIO_MODE", Field { brief: Some("Select the priority mode for CPU copies transmitted on the port."), details: Some("0: IFH CPU mask shows all CPU queues the frame applies to. Priority of frame set to the CPU queue the frame copy is generated for 1: IFH CPU mask shows the CPU queue number the frame copy is generated for. Priority of frame set to the priority selected for the particular frame copy (see QFWD::FRAME_COPY_CFG)"), lo: 0, hi: 1 });
        fields.insert("DEQUEUE_DIS", Field { brief: Some("Disable dequeuing from the egress queues. Frames are not discarded, but may become aged when dequeuing is reenabled."), details: None, lo: 4, hi: 5 });
        fields.insert("EIR_REMARK_ENA", Field { brief: Some("Increase DP by one in case scheduled frame passed due to excess rate shaper."), details: None, lo: 1, hi: 2 });
        fields.insert("TRUNC_ENA", Field { brief: Some("Enable truncation of stack learnall frames."), details: None, lo: 2, hi: 3 });
        regs.insert("PORT_MODE", Register { addr: Address { base: 2, count: 57, width: 1 }, brief: Some("Per device port configuration"), details: Some("These configurations exists per front port and for each of the two CPU ports (11+12)."), fields });
        let mut fields = HashMap::new();
        fields.insert("SYS_CLK_PER_100PS", Field { brief: Some("Must be set to the system clock period with unit 100 picoseconds."), details: None, lo: 0, hi: 8 });
        regs.insert("SYS_CLK_PER", Register { addr: Address { base: 137, count: 1, width: 1 }, brief: Some("System clock period configuration"), details: None, fields });
        groups.insert("HSCH_MISC", RegisterGroup { addr: Address { base: 27522, count: 1, width: 139 }, desc: "Miscellaneous scheduler configuration", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CIR_LVL", Field { brief: Some("Current fill level. Unit is 1 bit."), details: None, lo: 0, hi: 24 });
        regs.insert("CIR_STATE", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("CIR status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("EIR_LVL", Field { brief: Some("Current fill level. Unit is 1 bit."), details: None, lo: 0, hi: 24 });
        regs.insert("EIR_STATE", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("EIR status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SE_DLB_DPORT", Field { brief: Some("Destination port used when SE_DLB_DPORT_ENA is set."), details: None, lo: 8, hi: 14 });
        fields.insert("SE_DLB_DPORT_ENA", Field { brief: Some("Enable destination port awareness by the DLB shaper. If set, the DLB shaper allows excess information rate when the egress buffer use for destination port SE_DLB_SPORT has reached threshold BUF_P_RSRV_E[SE_DLB_DPORT] minus 3000 bytes. If multiple awareness functions (SE_DLB_PRIO_ENA, SE_DLB_SPORT_ENA, SE_DLB_DPORT_ENA) are enabled, all relevant thresholds must be exceeded before excess information rate is allowed."), details: None, lo: 0, hi: 1 });
        fields.insert("SE_DLB_PRIO", Field { brief: Some("QoS class used when SE_DLB_PRIO_ENA is set."), details: None, lo: 14, hi: 17 });
        fields.insert("SE_DLB_PRIO_ENA", Field { brief: Some("Enable priority awareness by the DLB shaper. If set, the DLB shaper allows excess information rate when the egress buffer use for QoS class SE_DLB_PRIO has reached threshold BUF_PRIO_SHR_E[SE_DLB_PRIO] minus 3000 bytes. If both SE_DLB_PRIO_ENA and SE_DLB_SPORT_ENA are set, the excess information rate is alllowed when the ingress buffer use for QoS class per source port has reached threshold BUF_Q_RSRV_I[SE_DLB_PRIO, SE_DLB_SPORT] minus 3000 bytes. If both SE_DLB_PRIO_ENA and SE_DLB_DPORT_ENA are set, the excess information rate is alllowed when the egress buffer use for QoS class per destination port has reached threshold BUF_Q_RSRV_E[SE_DLB_PRIO, SE_DLB_DPORT] minus 3000 bytes. If multiple awareness functions (SE_DLB_PRIO_ENA, SE_DLB_SPORT_ENA, SE_DLB_DPORT_ENA) are enabled, all relevant thresholds must be exceeded before excess information rate is allowed."), details: None, lo: 1, hi: 2 });
        fields.insert("SE_DLB_SPORT_OBSOLETE", Field { brief: Some("Not connected."), details: None, lo: 2, hi: 8 });
        regs.insert("SE_DLB_SENSE", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Configuration of which fill levels in the queue system that the DLB shapers use to trigger excess information rate"), details: None, fields });
        groups.insert("HSCH_STATUS", RegisterGroup { addr: Address { base: 32768, count: 3400, width: 4 }, desc: "Status of scheduling system and shapers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("QSHP_BASE", Field { brief: Some("First input using queue shapers are using this queue shaper index."), details: None, lo: 0, hi: 13 });
        fields.insert("QSHP_MAX", Field { brief: Some("Last input using queue shapers. A value lower than the SHP_MIN input disables queue shaping."), details: None, lo: 13, hi: 19 });
        fields.insert("QSHP_MIN", Field { brief: Some("First input using queue shapers."), details: None, lo: 19, hi: 25 });
        regs.insert("QSHP_ALLOC_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Assign queue shapers to queues"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SE_FRM_MODE", Field { brief: Some("Accounting mode for this shaper."), details: Some("0: Line rate. Shape bytes including HSCH_MISC_CFG.FRM_ADJ. 1: Data rate. Shape bytes excluding IPG. 2. Frame rate. Shape frames with rate unit = 100 fps and burst unit = 32.8 frames. 3: Frame rate. Shape framed with rate unit = 1 fps and burst unit = 0.3 frames."), lo: 0, hi: 2 });
        regs.insert("QSHP_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Configuration of queue shaper"), details: None, fields });
        groups.insert("QSHP_ALLOC_CFG", RegisterGroup { addr: Address { base: 49152, count: 3400, width: 2 }, desc: "Assign queue shapers to queues", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CIR_BURST", Field { brief: Some("Burst capacity of this shaper. Unit is 4096 kilobytes. The shaper is disabled when CIR_BURST=0."), details: None, lo: 0, hi: 6 });
        fields.insert("CIR_RATE", Field { brief: Some("Leak rate for this shaper. Unit is defined by the leak list period the shaper is attached to (see HSCH_LEAK_CFG.LEAK_TIME)."), details: None, lo: 6, hi: 23 });
        regs.insert("QSHP_CIR_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Queue Shaping configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FORCE_UPD", Field { brief: Some("The queue selector must be updated about the state of this element"), details: None, lo: 0, hi: 1 });
        regs.insert("SE_STATE", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("State of the inputs to this SE"), details: None, fields });
        groups.insert("QSHP_CFG", RegisterGroup { addr: Address { base: 27264, count: 64, width: 2 }, desc: "Configuration of queue shapers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("SE_LEAK_LINK", Field { brief: Some("Forms the leak chains."), details: None, lo: 0, hi: 12 });
        regs.insert("QSHP_CONNECT", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Configuration of the connections between queue shapers"), details: None, fields });
        groups.insert("QSHP_STATUS", RegisterGroup { addr: Address { base: 27392, count: 64, width: 1 }, desc: "Status of queue shapers", regs });
        out.insert("HSCH", Target { desc: "Hierarchical Scheduler Configuration", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ANAOUT_ENA", Field { brief: Some("Set to enable drive of analog test-output pin."), details: None, lo: 20, hi: 21 });
        fields.insert("DEV10G_0_MODE", Field { brief: Some("Configure mode of DEV10G and hookup of SerDes10G blocks. The device has dedicated DEV10G for 10 Gbit/sec speed, and DEV2G5 for 2.5 Gbit/sec and lower speeds. The DEV10G and corresponding DEV2G5 cannot be active at the same time."), details: Some("0: DEV10G_0 XFI-mode via SerDes10G_0. 1: DEV10G_0 XAUI-mode via SerDes6G_16, SerDes6G_17, SerDes6G_18, and SerDes6G_19. 2: DEV10G_0 RXAUI-mode via SerDes6G_16 and SerDes6G_18. 3: DEV2G5_25 via SerDes10G_0."), lo: 12, hi: 14 });
        fields.insert("DEV10G_1_MODE", Field { brief: Some("See DEVCPU_GCB::DEV10G_0_MODE for description."), details: Some("0: DEV10G_1 XFI-mode via SerDes10G_1. 1: DEV10G_1 XAUI-mode via SerDes6G_20, SerDes6G_21, SerDes6G_22, and SerDes6G_23. 2: DEV10G_1 RXAUI-mode via SerDes6G_20 and SerDes6G_22. 3: DEV2G5_26 via SerDes10G_1."), lo: 14, hi: 16 });
        fields.insert("DEV10G_2_MODE", Field { brief: Some("See DEVCPU_GCB::DEV10G_0_MODE for description."), details: Some("0: DEV10G_2 XFI-mode via SerDes10G_2. 1: DEV10G_2 XAUI-mode via SerDes6G_8, SerDes6G_9, SerDes6G_10, and SerDes6G_11. 2: DEV10G_2 RXAUI-mode via SerDes6G_8 and SerDes6G_10. 3: DEV2G5_27 via SerDes10G_2."), lo: 16, hi: 18 });
        fields.insert("DEV10G_3_MODE", Field { brief: Some("See DEVCPU_GCB::DEV10G_0_MODE for description."), details: Some("0: DEV10G_3 XFI-mode via SerDes10G_3. 1: DEV10G_3 XAUI-mode via SerDes6G_12, SerDes6G_13, SerDes6G_14, and SerDes6G_15. 2: DEV10G_3 RXAUI-mode via SerDes6G_12 and SerDes6G_14. 3: DEV2G5_28 via SerDes10G_3."), lo: 18, hi: 20 });
        fields.insert("QSGMII_ENA", Field { brief: Some("Set bit 0 to enable QSGMII mode for devices DEV1G_0, DEV1G_1, DEV1G_2, and DEV1G_3 via SerDes6G_4. Set bit 1 to enable QSGMII mode for devices DEV1G_4, DEV1G_5, DEV1G_6, and DEV1G_7 via SerDes6G_5. Set bit 2 to enable QSGMII mode for devices DEV2G5_0, DEV2G5_1, DEV2G5_2, and DEV2G5_3 via SerDes6G_6. Set bit 3 to enable QSGMII mode for devices DEV2G5_4, DEV2G5_5, DEV2G5_6, and DEV2G5_7 via SerDes6G_7. Set bit 4 to enable QSGMII mode for devices DEV2G5_8, DEV2G5_9, DEV2G5_10, and DEV2G5_11 via SerDes6G_8. Set bit 5 to enable QSGMII mode for devices DEV2G5_12, DEV2G5_13, DEV2G5_14, and DEV2G5_15 via SerDes6G_9. Set bit 6 to enable QSGMII mode for devices DEV2G5_16, DEV2G5_17, DEV2G5_18, and DEV2G5_19 via SerDes6G_10. Set bit 7 to enable QSGMII mode for devices DEV2G5_20, DEV2G5_21, DEV2G5_22, and DEV2G5_23 via SerDes6G_11. Set bit 8 to enable QSGMII mode for devices DEV1G_8, DEV1G_9, DEV1G_10, and DEV1G_11 via SerDes6G_12. Set bit 9 to enable QSGMII mode for devices DEV1G_12, DEV1G_13, DEV1G_14, and DEV1G_15 via SerDes6G_13. Set bit 10 to enable QSGMII mode for devices DEV1G_16, DEV1G_17, DEV1G_18, and DEV1G_19 via SerDes6G_14. Set bit 11 to enable QSGMII mode for devices DEV1G_20, DEV1G_21, DEV1G_22, and DEV1G_23 via SerDes6G_15."), details: None, lo: 0, hi: 12 });
        regs.insert("HW_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Various configration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("E_DET_ENA", Field { brief: Some("Set to enable 8b10b receive error propagation; 8b10b error code-groups are replaced by K70.7 error symbols. This setting applies to all QSGMII channels."), details: None, lo: 13, hi: 14 });
        fields.insert("FLIP_LANES", Field { brief: Some("Set to flip QSGMII lanes: Lane 0 is interchanged with 3, and 1 is interchanged with 2 for both receie and transmit directions. Each bit in this field correspond to a QSGMII channel, bit 0 configures QSGMII#0, bit 1 configures QSGMII#1, etc."), details: None, lo: 0, hi: 12 });
        fields.insert("SHYST_DIS", Field { brief: Some("Set to disable hysteresis of receive synchronization state machine. This setting applies to all QSGMII channels."), details: None, lo: 14, hi: 15 });
        fields.insert("USE_I1_ENA", Field { brief: Some("Set to transmit I1 during idle sequencing only. This setting applies to all QSGMII channels."), details: None, lo: 12, hi: 13 });
        regs.insert("HW_QSGMII_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Additional configuration for QSGMII channels"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DELAY_VAR_X200PS", Field { brief: Some("Variable delay in QSGMII ingress path provided in steps of 200ps, values 0 though 39 is possible allowing a span from 0ns to 7.8ns. Each replication of this register correspond to a QSGMII channel, replication 0 is from QSGMII#0, replication 1 is from QSGMII#1, etc. The value for a QSGMII channel is valid when it has synchronized to an incomming QSGMII signal, and will remain constant while the channel stays in sync."), details: None, lo: 1, hi: 7 });
        fields.insert("SYNC", Field { brief: Some("Set when QSGMII channel has successfully synchronized on K28.1 code-group, this field is only valid when DEVCPU_GCB::HW_QSGMII_CFG.SHYST_DIS is 0."), details: None, lo: 0, hi: 1 });
        regs.insert("HW_QSGMII_STAT", Register { addr: Address { base: 2, count: 12, width: 1 }, brief: Some("Additional status from QSGMII channels"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SERDES6G_ADDR", Field { brief: Some("Activation vector for SERDES6G-Slaves, one-hot coded, each bit is related to one macro, e.g. bit 0 enables/disables access to macro no. 0."), details: Some("0: Disable macro access via MCB 1: Enable macro access via MCB"), lo: 0, hi: 25 });
        fields.insert("SERDES6G_RD_ONE_SHOT", Field { brief: Some("Initiate a read access to marked SERDES6G Slaves"), details: Some("0: No read operation pending (read op finished after bit has been set) 1: Initiate a read access (kept 1 until read operation has finished)"), lo: 30, hi: 31 });
        fields.insert("SERDES6G_WR_ONE_SHOT", Field { brief: Some("Initiate a write access to marked SERDES6G Slaves"), details: Some("0: No write operation pending 1: Initiate write to slaves (kept 1 until write operation has finished)"), lo: 31, hi: 32 });
        regs.insert("MCB_SERDES6G_ADDR_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("MCB SERDES6G Address Cfg"), details: Some("Configuration of SERDES6G MCB Slaves to be accessed"), fields });
        groups.insert("HW_CFGSTAT", RegisterGroup { addr: Address { base: 91, count: 1, width: 14 }, desc: "General high-speed IO configuration and status", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("DES_100FX_PHASE_SEL", Field { brief: Some("Phase selection of DES in 100fx mode"), details: Some("0: CDR locked at bit 9 1: CDR locked at bit 4"), lo: 0, hi: 1 });
        regs.insert("SERDES1G_MISC_STATUS", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("SERDES1G Misc Status"), details: Some("Status register for miscellaneous functions"), fields });
        groups.insert("MCB_SERDES1G_CFG", RegisterGroup { addr: Address { base: 58, count: 1, width: 1 }, desc: "MCB SERDES1G Configuration Register", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("DES_REV", Field { brief: Some("DES revision"), details: None, lo: 10, hi: 16 });
        fields.insert("IB_REV", Field { brief: Some("IB revision"), details: None, lo: 0, hi: 5 });
        fields.insert("OB_REV", Field { brief: Some("OB revision"), details: None, lo: 5, hi: 10 });
        fields.insert("RCPLL_REV", Field { brief: Some("RCPLL revision"), details: None, lo: 21, hi: 26 });
        fields.insert("SERDES_REV", Field { brief: Some("Serdes revision"), details: None, lo: 26, hi: 32 });
        fields.insert("SER_REV", Field { brief: Some("SER revision"), details: None, lo: 16, hi: 21 });
        regs.insert("SERDES6G_REVID", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("SERDES6G REVID"), details: Some("Revision ID register"), fields });
        groups.insert("MCB_SERDES6G_CFG", RegisterGroup { addr: Address { base: 90, count: 1, width: 1 }, desc: "MCB SERDES6G Configuration Register", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("PLLB_DIV_FACTOR_PRE", Field { brief: Some("BIST compare pre divider M"), details: None, lo: 0, hi: 16 });
        regs.insert("PLL5G_BIST_CFG0A", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("PLL5G BIST Configuration register 0A"), details: Some("Configuration register 0A for PLL5G BIST."), fields });
        let mut fields = HashMap::new();
        fields.insert("PLLB_LOCK_REPEAT", Field { brief: Some("BIST compare divider repeat count"), details: None, lo: 4, hi: 8 });
        fields.insert("PLLB_LOCK_UNCERT", Field { brief: Some("BIST compare divider phase uncertainty"), details: None, lo: 0, hi: 4 });
        fields.insert("PLLB_MEAS_MODE", Field { brief: Some("BIST measure mode, 0: frequency, 1: phase"), details: None, lo: 14, hi: 15 });
        fields.insert("PLLB_START_BIST", Field { brief: Some("BIST start, 0: reset BIST, 1: start/enable BIST"), details: None, lo: 15, hi: 16 });
        regs.insert("PLL5G_BIST_CFG0B", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("PLL5G BIST Configuration register 0B"), details: Some("Configuration register 0B for PLL5G BIST."), fields });
        let mut fields = HashMap::new();
        fields.insert("PLLB_DIV_FACTOR_M", Field { brief: Some("BIST compare divider M"), details: None, lo: 0, hi: 16 });
        regs.insert("PLL5G_BIST_CFG1", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("PLL5G BIST Configuration register 1"), details: Some("Configuration register 1 for PLL5G BIST."), fields });
        let mut fields = HashMap::new();
        fields.insert("FBCNT_DIF", Field { brief: Some("VCO frequency difference to refclk"), details: None, lo: 4, hi: 14 });
        fields.insert("FSM_LOCK", Field { brief: Some("startup FSM lock status"), details: None, lo: 0, hi: 1 });
        fields.insert("FSM_STAT", Field { brief: Some("startup FSM internal status"), details: None, lo: 1, hi: 4 });
        fields.insert("GAIN_STAT", Field { brief: Some("VCO frequency step stop"), details: None, lo: 14, hi: 19 });
        fields.insert("SIG_DEL", Field { brief: Some("sigma delta ADC output"), details: None, lo: 19, hi: 27 });
        regs.insert("PLL5G_STATUS1", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("PLL5G Status 1"), details: Some("Status register 1 for the PLL5G"), fields });
        groups.insert("PLL5G_BIST_CFG", RegisterGroup { addr: Address { base: 18, count: 2, width: 4 }, desc: "PLL5G BIST Configuration Register set", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("PLLB_DIV_FACTOR_N", Field { brief: Some("BIST compare divider N"), details: None, lo: 0, hi: 16 });
        regs.insert("PLL5G_BIST_CFG2", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("PLL5G BIST Configuration register 2"), details: Some("Configuration register 2 for PLL5G BIST."), fields });
        let mut fields = HashMap::new();
        fields.insert("PLLB_BUSY", Field { brief: Some("BIST busy, 0: not busy, 1: busy"), details: None, lo: 2, hi: 3 });
        fields.insert("PLLB_DONE_N", Field { brief: Some("BIST done, 0: done, 1: not done"), details: None, lo: 1, hi: 2 });
        fields.insert("PLLB_FAIL", Field { brief: Some("BIST pass/fail, 0: passed, 1: failed"), details: None, lo: 0, hi: 1 });
        fields.insert("PLLB_FSM_STAT", Field { brief: Some("BIST pll_cnt upper limit at max. frequency"), details: None, lo: 4, hi: 8 });
        regs.insert("PLL5G_BIST_STAT0", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("PLL5G BIST Status register 0"), details: Some("Status register 0 for PLL5G BIST."), fields });
        let mut fields = HashMap::new();
        fields.insert("PLLB_CNT_REF_DIFF", Field { brief: Some("BIST compare divider phase difference"), details: None, lo: 0, hi: 16 });
        regs.insert("PLL5G_BIST_STAT1A", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("PLL5G BIST Status register 1A"), details: Some("Status register 1A for PLL5G BIST."), fields });
        groups.insert("PLL5G_BIST_STATUS", RegisterGroup { addr: Address { base: 26, count: 2, width: 3 }, desc: "PLL5G BIST Status Register set", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CORE_CLK_DIV", Field { brief: Some("setting for core clock divider 0:625MHz, 1:312.5MHz, 2:500MHz, 3:277.77MHz, 4:500MHz, 5:250MHz, 6:416.66MHz, 7:227.27MHz, 8:416.66MHz, 9:208.33MHz, 10:357.14MHz, 11:192.3MHz, 12:357.14MHz, 13:178.57MHz, 14:312.5MHz, 15:166.66,MHz, 17:156.25MHz, 33:625MHz"), details: None, lo: 0, hi: 6 });
        fields.insert("CPU_CLK_DIV", Field { brief: Some("Setting for CPU clock divider"), details: Some("2: 500 MHz 5: 250 MHz 6: 416.66 MHz 14: 312.5 MHz 15: 166.66 MHz Others: Reserved"), lo: 6, hi: 12 });
        fields.insert("DIV4", Field { brief: Some("RCPLL feedback divider setting"), details: None, lo: 28, hi: 29 });
        fields.insert("ENA_BIAS", Field { brief: Some("enable BIAS circuitry incl. Bandgap, voltage regulators, etc."), details: None, lo: 12, hi: 13 });
        fields.insert("ENA_CLKTREE", Field { brief: Some("RCPLL enable BIAS for clocktree buffer (active low) 0: enable BIAS, 1: disable BIAS"), details: None, lo: 29, hi: 30 });
        fields.insert("ENA_CP1", Field { brief: Some("enable current mode chargepump, normal mode"), details: None, lo: 14, hi: 15 });
        fields.insert("ENA_LANE", Field { brief: Some("RCPLL Global enable for serdes lane."), details: None, lo: 30, hi: 31 });
        fields.insert("ENA_LOCK_FINE", Field { brief: Some("enable fine locking, last stage in startup locking sequence"), details: None, lo: 27, hi: 28 });
        fields.insert("ENA_ROT", Field { brief: Some("RCPLL feedback divider setting"), details: None, lo: 31, hi: 32 });
        fields.insert("ENA_VCO_BUF", Field { brief: Some("enable BIAS for LCPLL VCO output buffer"), details: None, lo: 13, hi: 14 });
        fields.insert("ENA_VCO_CONTRH", Field { brief: Some("enable fine VCO operating point regulator"), details: None, lo: 15, hi: 16 });
        fields.insert("LOOP_BW_RES", Field { brief: Some("setting for filter resistor value 0: biggest resistance, 31: lowest resistance"), details: None, lo: 18, hi: 23 });
        fields.insert("SELBGV820", Field { brief: Some("fine tune of bandgap voltage distribution 0: lowest voltage, 15: highest voltage"), details: None, lo: 23, hi: 27 });
        fields.insert("SELCPI", Field { brief: Some("setting for chargepump current 0: lowest current, 3: highest current"), details: None, lo: 16, hi: 18 });
        regs.insert("PLL5G_CFG0", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("PLL5G Configuration 0"), details: Some("Configuration register 0 for PLL5G"), fields });
        let mut fields = HashMap::new();
        fields.insert("ENA_DIRECT", Field { brief: Some("enable for direct data mode (ATPG/JTAG) reference clock input buffer and test output buffer"), details: None, lo: 18, hi: 19 });
        fields.insert("FORCE_SET_ENA", Field { brief: Some("RCPLL When set to '1' the value at sx_pll_fsm_ctrl_data_I is not taken as reference value for the FSM, but is directly apllied to the PLL as frequency range setting."), details: None, lo: 0, hi: 1 });
        fields.insert("HALF_RATE", Field { brief: Some("RCPLL Enable for half rate mode"), details: None, lo: 1, hi: 2 });
        fields.insert("OUT_OF_RANGE_RECAL_ENA", Field { brief: Some("RCPLL Enable recalibration of PLL when out of range is detected"), details: None, lo: 2, hi: 3 });
        fields.insert("PWD_RX", Field { brief: Some("RCPLL Power down for the RX-path"), details: None, lo: 3, hi: 4 });
        fields.insert("PWD_TX", Field { brief: Some("RCPLL Power down for the TX-path"), details: None, lo: 4, hi: 5 });
        fields.insert("QUARTER_RATE", Field { brief: Some("RCPLL Enable for quarter rate mode"), details: None, lo: 5, hi: 6 });
        fields.insert("RC_CTRL_DATA", Field { brief: Some("RCPLL Control input for startup FSM"), details: None, lo: 6, hi: 14 });
        fields.insert("RC_ENABLE", Field { brief: Some("RCPLL Enable for startup FSM"), details: None, lo: 14, hi: 15 });
        fields.insert("READBACK_DATA_SEL", Field { brief: Some("RCPLL Selects whether (when set to '1') the frequency range setting from the FSM can be read back at sx_pll_rb_data_o or (when cleared to '0') the measured period."), details: None, lo: 15, hi: 16 });
        fields.insert("ROT_DIR", Field { brief: Some("RCPLL feedback divider setting"), details: None, lo: 16, hi: 17 });
        fields.insert("ROT_SPEED", Field { brief: Some("RCPLL feedback divider setting"), details: None, lo: 17, hi: 18 });
        regs.insert("PLL5G_CFG1", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("PLL5G Configuration 1"), details: Some("Configuration register 1 for PLL5G"), fields });
        let mut fields = HashMap::new();
        fields.insert("AMPC_SEL", Field { brief: Some("static VCO amplitude control, active w/ ena_amp_ctrl_force 0: lowest current, 255: highest current"), details: None, lo: 12, hi: 20 });
        fields.insert("DISABLE_FSM", Field { brief: Some("disable automatic FSM startup frequency stepping"), details: None, lo: 1, hi: 2 });
        fields.insert("DISABLE_FSM_POR", Field { brief: Some("disables the startup FSM to start ramp up the frequency from POR 0: normal,1: disable"), details: None, lo: 10, hi: 11 });
        fields.insert("ENA_AMPCTRL", Field { brief: Some("enable automatic VCO amplitude control"), details: None, lo: 21, hi: 22 });
        fields.insert("ENA_AMP_CTRL_FORCE", Field { brief: Some("enable static VCO amplitude control"), details: None, lo: 20, hi: 21 });
        fields.insert("ENA_CLK_BYPASS", Field { brief: Some("enable clock bypass for all output clocks to come from ref clock pad"), details: None, lo: 23, hi: 24 });
        fields.insert("ENA_CLK_BYPASS1", Field { brief: Some("enable clock bypass for all output clocks to come from extra dividers (125MHz, 250MHz, 312.5MHz)"), details: None, lo: 24, hi: 25 });
        fields.insert("ENA_CP2", Field { brief: Some("enable resistor mode chargepump, test mode"), details: None, lo: 25, hi: 26 });
        fields.insert("ENA_FBTESTOUT", Field { brief: Some("enable feedback divider output to test output buffer"), details: None, lo: 27, hi: 28 });
        fields.insert("ENA_GAIN_TEST", Field { brief: Some("enable static VCO frequency stepping"), details: None, lo: 0, hi: 1 });
        fields.insert("ENA_PFD_IN_FLIP", Field { brief: Some("enable flip of refclk and fbclk at PFD, used for 2nd chargepump"), details: None, lo: 29, hi: 30 });
        fields.insert("ENA_RCPLL", Field { brief: Some("enable RCPLL clock buffer in LCPLL VCO (sx_ena_vco_buf_i must be set to 0)"), details: None, lo: 26, hi: 27 });
        fields.insert("ENA_TEST_MODE", Field { brief: Some("enables test modes, e.g. fbdivsel"), details: None, lo: 30, hi: 31 });
        fields.insert("ENA_VCO_NREF_TESTOUT", Field { brief: Some("enable VCO frequency control output"), details: None, lo: 28, hi: 29 });
        fields.insert("EN_RESET_FRQ_DET", Field { brief: Some("enable FSM frequency deviation detection"), details: None, lo: 2, hi: 3 });
        fields.insert("EN_RESET_LIM_DET", Field { brief: Some("enable FSM limiter detection"), details: None, lo: 3, hi: 4 });
        fields.insert("EN_RESET_OVERRUN", Field { brief: Some("enable FSM frequency deviation overrun"), details: None, lo: 4, hi: 5 });
        fields.insert("FRC_FSM_POR", Field { brief: Some("forces the startup FSM to start ramp up the frequency by POR 0: no force,1: force"), details: None, lo: 11, hi: 12 });
        fields.insert("GAIN_TEST", Field { brief: Some("setting for static VCO frequency stepping 0: lowest frequency,31: highest frequency"), details: None, lo: 5, hi: 10 });
        fields.insert("PWD_AMPCTRL_N", Field { brief: Some("force VCO amplitude control output to low (no VCO current) 0:force, 1: no force"), details: None, lo: 22, hi: 23 });
        regs.insert("PLL5G_CFG2", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("PLL5G Configuration 2"), details: Some("Configuration register 2 for PLL5G"), fields });
        let mut fields = HashMap::new();
        fields.insert("CLKOUT2_SEL", Field { brief: Some("Set to 3 to enable CLKOUT2 synchronous Ethernet reference clock output. Applies only to PLL2."), details: None, lo: 19, hi: 22 });
        fields.insert("ENA_ANA_TEST_OUT", Field { brief: Some("enable analog test output"), details: None, lo: 18, hi: 19 });
        fields.insert("ENA_TEST_OUT", Field { brief: Some("enable differential test output"), details: None, lo: 17, hi: 18 });
        fields.insert("FBDIVSEL", Field { brief: Some("setting for feedback divider, divide by 12..255 12..255"), details: None, lo: 0, hi: 8 });
        fields.insert("FBDIVSEL_TST_ENA", Field { brief: Some("enable feedback divider testmode"), details: None, lo: 8, hi: 9 });
        fields.insert("FORCE_CP", Field { brief: Some("force chargepump output to nominal VCO operating point"), details: None, lo: 9, hi: 10 });
        fields.insert("FORCE_ENA", Field { brief: Some("enable force VCO frequency high/low (force_hi/lo)"), details: None, lo: 10, hi: 11 });
        fields.insert("FORCE_HI", Field { brief: Some("force chargepump output to high, gives highest VCO frequency"), details: None, lo: 11, hi: 12 });
        fields.insert("FORCE_LO", Field { brief: Some("force chargepump output to low, gives lowest VCO frequency"), details: None, lo: 12, hi: 13 });
        fields.insert("FORCE_VCO_CONTRH", Field { brief: Some("force vco contrh input to mid level (mid CML level)"), details: None, lo: 13, hi: 14 });
        fields.insert("RST_FB_N", Field { brief: Some("reset for feedback divider, active low 0: reset,1:no reset"), details: None, lo: 14, hi: 15 });
        fields.insert("SEL_CML_CMOS_PFD", Field { brief: Some("select CML or CMOS phase/frequency detector 0: CML, 1: CMOS"), details: None, lo: 15, hi: 16 });
        fields.insert("SEL_FBDCLK", Field { brief: Some("enable symmetric feedback divider clock output 0: fbclk/2, 1: fbclk"), details: None, lo: 16, hi: 17 });
        fields.insert("TEST_ANA_OUT_SEL", Field { brief: Some("select analog test output input signal"), details: None, lo: 22, hi: 24 });
        regs.insert("PLL5G_CFG3", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("PLL5G Configuration 3"), details: Some("Configuration register 3 for PLL5G"), fields });
        let mut fields = HashMap::new();
        fields.insert("IB_BIAS_CTRL", Field { brief: Some("settings for reference clock input buffer BIAS"), details: None, lo: 16, hi: 24 });
        fields.insert("IB_CTRL", Field { brief: Some("settings for reference clock input buffer"), details: None, lo: 0, hi: 16 });
        regs.insert("PLL5G_CFG4", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("PLL5G Configuration 4"), details: Some("Configuration register 4 for PLL5G"), fields });
        let mut fields = HashMap::new();
        fields.insert("OB_BIAS_CTRL", Field { brief: Some("settings for test output buffer BIAS"), details: None, lo: 16, hi: 24 });
        fields.insert("OB_CTRL", Field { brief: Some("settings for test output buffer"), details: None, lo: 0, hi: 16 });
        regs.insert("PLL5G_CFG5", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("PLL5G Configuration 5"), details: Some("Configuration register 5 for PLL5G"), fields });
        groups.insert("PLL5G_CFG", RegisterGroup { addr: Address { base: 0, count: 2, width: 7 }, desc: "PLL5G Configuration Registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("DDR_CLK_DIV", Field { brief: Some("Setting for DDR clock divider"), details: Some("2: 500 MHz 5: 250 MHz 6: 416.66 MHz 14: 312.5 MHz 15: 166.66 MHz Others: Reserved"), lo: 0, hi: 6 });
        fields.insert("ENA_FBCLKC2", Field { brief: Some("enable feedback divider CMOS 1/2 clock (for FSM)"), details: None, lo: 6, hi: 7 });
        fields.insert("ENA_REFCLKC2", Field { brief: Some("Enable reference CMOS 1/2 clock"), details: None, lo: 7, hi: 8 });
        regs.insert("PLL5G_CFG6", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("PLL5G Configuration 6"), details: Some("Configuration register 6 for PLL5G"), fields });
        let mut fields = HashMap::new();
        fields.insert("CALIBRATION_DONE", Field { brief: Some("RCPLL Flag that indicates that the calibration procedure has finished."), details: None, lo: 9, hi: 10 });
        fields.insert("CALIBRATION_ERR", Field { brief: Some("RCPLL Flag that indicates errors that may occur during the calibration procedure."), details: None, lo: 10, hi: 11 });
        fields.insert("LOCK_STATUS", Field { brief: Some("PLL lock status 0: not locked, 1: locked"), details: None, lo: 0, hi: 1 });
        fields.insert("OUT_OF_RANGE_ERR", Field { brief: Some("RCPLL Flag that indicates a out of range condition while NOT in calibration mode."), details: None, lo: 11, hi: 12 });
        fields.insert("RANGE_LIM", Field { brief: Some("RCPLL Flag range limiter signaling"), details: None, lo: 12, hi: 13 });
        fields.insert("READBACK_DATA", Field { brief: Some("RCPLL Interface to read back internal data of the FSM."), details: None, lo: 1, hi: 9 });
        regs.insert("PLL5G_STATUS0", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("PLL5G Status 0"), details: Some("Status register 0 for the PLL5G"), fields });
        groups.insert("PLL5G_STATUS", RegisterGroup { addr: Address { base: 14, count: 2, width: 2 }, desc: "PLL5G Status Registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("PLLB_CNT_OUT", Field { brief: Some("BIST compare divider phase difference"), details: None, lo: 0, hi: 16 });
        regs.insert("PLL5G_BIST_STAT1B", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("PLL5G BIST Status register 1B"), details: Some("Status register 1B for PLL5G BIST."), fields });
        groups.insert("RCOMP_CFG", RegisterGroup { addr: Address { base: 32, count: 1, width: 1 }, desc: "RCOMP Configuration Registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("FORCE_ENA", Field { brief: Some("Overwrite measured resistor value with value programmed in rcomp_val"), details: Some("0: normal mode 1: overwrite mode"), lo: 4, hi: 5 });
        fields.insert("MODE_SEL", Field { brief: Some("RCOMP operation mode"), details: Some("0: inactive 1: perform calibration permanently 2: perform calibration once 3: perform calibration once and generate alarm if necessary"), lo: 8, hi: 10 });
        fields.insert("PWD_ENA", Field { brief: Some("Enable power-down after calibration was done"), details: Some("0: disable power-down 1: enable power-down"), lo: 13, hi: 14 });
        fields.insert("RCOMP_VAL", Field { brief: Some("Resistor comparator value"), details: Some("0: maximum resistance value 15: minimum resistance value"), lo: 0, hi: 4 });
        fields.insert("RUN_CAL", Field { brief: Some("Start calibration"), details: Some("0: idle/inactive 1: start (activate)"), lo: 12, hi: 13 });
        fields.insert("SPEED_SEL", Field { brief: Some("Speed selection. Setting time for analog circuit after changing resistor settings."), details: Some("0: max period 1: max period/2 2: max period/4 3: max period/8"), lo: 10, hi: 12 });
        regs.insert("RCOMP_CFG0", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("RCOMP Configuration 0"), details: Some("Configuration register 0 for RCOMP"), fields });
        groups.insert("RCOMP_STATUS", RegisterGroup { addr: Address { base: 33, count: 1, width: 1 }, desc: "RCOMP Status Registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ENA_DIRECT", Field { brief: Some("Enable direct line"), details: Some("0: Disable 1: Enable"), lo: 12, hi: 13 });
        fields.insert("ENA_ELOOP", Field { brief: Some("Enable equipment loop"), details: Some("0: Disable 1: Enable"), lo: 11, hi: 12 });
        fields.insert("ENA_FLOOP", Field { brief: Some("Enable facility loop"), details: Some("0: Disable 1: Enable"), lo: 10, hi: 11 });
        fields.insert("ENA_ILOOP", Field { brief: Some("Enable input loop"), details: Some("0: Disable 1: Enable"), lo: 9, hi: 10 });
        fields.insert("ENA_LANE", Field { brief: Some("Enable lane"), details: Some("0: Disable lane 1: Enable line"), lo: 18, hi: 19 });
        fields.insert("ENA_PLOOP", Field { brief: Some("Enable pad loop"), details: Some("0: Disable 1: Enable"), lo: 8, hi: 9 });
        fields.insert("HRATE", Field { brief: Some("Enable half rate"), details: Some("0: Disable 1: Enable"), lo: 7, hi: 8 });
        fields.insert("IF_MODE", Field { brief: Some("Interface mode"), details: Some("0: 8-bit mode 1: 10-bit mode"), lo: 0, hi: 1 });
        fields.insert("LANE_CTRL", Field { brief: Some("Hidden spare bits (not connected internally yet)"), details: None, lo: 13, hi: 16 });
        fields.insert("PWD_RX", Field { brief: Some("Power-down RX-path"), details: Some("0: Normal mode 1: Power down mode"), lo: 17, hi: 18 });
        fields.insert("PWD_TX", Field { brief: Some("Power-down TX-path"), details: Some("0: Normal mode 1: Power down mode"), lo: 16, hi: 17 });
        fields.insert("SE_AUTO_SQUELCH_ENA", Field { brief: Some("Enable auto-squelching for sync. ethernet clock output: when set the clock output will stop toggling (keep its last value constantly) when PCS looses link synchrony."), details: Some("0: Disable 1: Enable"), lo: 21, hi: 22 });
        fields.insert("SYS_RST", Field { brief: Some("System reset (low active)"), details: Some("0: Apply reset (not self-clearing) 1: Reset released"), lo: 31, hi: 32 });
        regs.insert("SERDES1G_COMMON_CFG", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("SERDES1G Common Cfg"), details: Some("Configuration register for common SERDES1G functions Note: When enabling the facility loop (ena_floop) also the phase alignment in the serializer has to be enabled and configured adequate."), fields });
        let mut fields = HashMap::new();
        fields.insert("DES_BW_ANA", Field { brief: Some("Bandwidth selection for proportional path of CDR loop."), details: Some("0: No division 1: Divide by 2 2: Divide by 4 3: Divide by 8 4: Divide by 16 5: Divide by 32 6: Divide by 64 7: Divide by 128"), lo: 5, hi: 8 });
        fields.insert("DES_BW_HYST", Field { brief: Some("Selection of time constant for integrative path of CDR loop."), details: Some("0: Divide by 2 1: Divide by 4 2: Divide by 8 3: Divide by 16 4: Divide by 32 5: Divide by 64 6: Divide by 128 7: Divide by 256"), lo: 1, hi: 4 });
        fields.insert("DES_CPMD_SEL", Field { brief: Some("Deserializer phase control, main CP/MD select"), details: Some("0: Directly from DES 1: Through hysteresis stage from DES 2: From core 3: Disabled"), lo: 11, hi: 13 });
        fields.insert("DES_MBTR_CTRL", Field { brief: Some("Des phase control for 180 degrees deadlock block mode of operation"), details: Some("0: Depending on density of input pattern 1: Active until PCS has synchronized 2: Depending on density of input pattern until PCS has synchronized 3: Never 4: Always 5-7: Reserved"), lo: 8, hi: 11 });
        fields.insert("DES_PHS_CTRL", Field { brief: Some("Control of phase regulator logic. Bit 3 must be set to 0."), details: Some("0: Disabled 1: Enabled with 99 ppm limit 2: Enabled with 202 ppm limit 3: Enabled with 485 ppm limit 4: Enabled if corresponding PCS is in sync with 50 ppm limit 5: Enabled if corresponding PCS is in sync with 99 ppm limit 6: Enabled if corresponding PCS is in sync with 202 ppm limit 7: Enabled if corresponding PCS is in sync with 485 ppm limit"), lo: 13, hi: 17 });
        fields.insert("DES_SWAP_ANA", Field { brief: Some("Swap non-hysteresis CP/MD signals."), details: Some("0: No swapping 1: Swapping"), lo: 4, hi: 5 });
        fields.insert("DES_SWAP_HYST", Field { brief: Some("Swap hysteresis CP/MD signals."), details: Some("0: No swapping 1: Swapping"), lo: 0, hi: 1 });
        regs.insert("SERDES1G_DES_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("SERDES1G Deserializer Cfg"), details: Some("Configuration register for SERDES1G deserializer"), fields });
        let mut fields = HashMap::new();
        fields.insert("ACJTAG_HYST", Field { brief: Some("Hysteresis level for AC-JTAG Input"), details: Some("0: low 7: high"), lo: 24, hi: 27 });
        fields.insert("IB_DET_LEV", Field { brief: Some("Detect thresholds:"), details: Some("0: 159-189mVppd 1: 138-164mVppd 2: 109-124mVppd 3: 74-89mVppd"), lo: 19, hi: 22 });
        fields.insert("IB_ENA_CMV_TERM", Field { brief: Some("Enable common mode voltage termination"), details: Some("0: Low termination (VDD_A x 0.7) 1: High termination (VDD_A)"), lo: 13, hi: 14 });
        fields.insert("IB_ENA_DC_COUPLING", Field { brief: Some("Enable dc-coupling of input signal"), details: Some("0: Disable 1: Enable"), lo: 12, hi: 13 });
        fields.insert("IB_ENA_DETLEV", Field { brief: Some("Enable detect level circuit"), details: Some("0: Disable 1: Enable"), lo: 11, hi: 12 });
        fields.insert("IB_ENA_HYST", Field { brief: Some("Enable hysteresis for input signal. Hystesis can only be enabled if DC offset compensation is disabled."), details: Some("0: Disable 1: Enable"), lo: 10, hi: 11 });
        fields.insert("IB_ENA_OFFSET_COMP", Field { brief: Some("Enable offset compensation of input stage. This bit must be disabled to enable hysteresis (IB_ENA_HYST)."), details: Some("0: Disable 1: Enable"), lo: 9, hi: 10 });
        fields.insert("IB_EQ_GAIN", Field { brief: Some("Selects weighting between AC and DC input path:"), details: Some("0: Reserved 1: Reserved 2: 0dB (recommended value) 3: 1.5dB 4: 3dB 5: 6dB 6: 9dB 12.5dB"), lo: 6, hi: 9 });
        fields.insert("IB_FX100_ENA", Field { brief: Some("Switches signal detect circuit into low frequency mode, must be used in FX100 mode"), details: None, lo: 27, hi: 28 });
        fields.insert("IB_HYST_LEV", Field { brief: Some("Input buffer hysteresis levels:"), details: Some("0: 59-79mV 1: 81-124mV"), lo: 14, hi: 15 });
        fields.insert("IB_RESISTOR_CTRL", Field { brief: Some("Resistor control. Value must be taken from RCOMP_STATUS.RCOMP. (default: -3)"), details: None, lo: 0, hi: 4 });
        fields.insert("IB_SEL_CORNER_FREQ", Field { brief: Some("Corner frequencies of AC path:"), details: Some("0: 1.3GHz 1: 1.5GHz 2: 1.6GHz 3: 1.8GHz"), lo: 4, hi: 6 });
        regs.insert("SERDES1G_IB_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("SERDES1G Input Buffer Cfg"), details: Some("Configuration register for SERDES1G input buffer"), fields });
        let mut fields = HashMap::new();
        fields.insert("OB_AMP_CTRL", Field { brief: Some("Amplitude control in steps of 50mVppd."), details: Some("0: 0.4Vppd 15: 1.1Vppd"), lo: 13, hi: 17 });
        fields.insert("OB_CMM_BIAS_CTRL", Field { brief: Some("CMM bias control"), details: None, lo: 10, hi: 13 });
        fields.insert("OB_DIS_VCM_CTRL", Field { brief: Some("Disable VCM control"), details: None, lo: 9, hi: 10 });
        fields.insert("OB_EN_MEAS_VREG", Field { brief: Some("Enable measure vreg"), details: None, lo: 8, hi: 9 });
        fields.insert("OB_RESISTOR_CTRL", Field { brief: Some("Resistor control. Value must be taken from RCOMP_STATUS.RCOMP. (default: +1)"), details: None, lo: 0, hi: 4 });
        fields.insert("OB_SLP", Field { brief: Some("Slope / slew rate control:"), details: Some("0: 45ps 1: 85ps 2: 105ps 3: 115ps"), lo: 17, hi: 19 });
        fields.insert("OB_VCM_CTRL", Field { brief: Some("Common mode voltage control:"), details: Some("0: Reserved 1: 440mV 2: 480mV 3: 460mV 4: 530mV 5: 500mV 6: 570mV 7: 550mV"), lo: 4, hi: 8 });
        regs.insert("SERDES1G_OB_CFG", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("SERDES1G Output Buffer Cfg"), details: Some("Configuration register for SERDES1G output buffer"), fields });
        let mut fields = HashMap::new();
        fields.insert("SER_ALISEL", Field { brief: Some("Select reference clock source for phase alignment"), details: Some("0: RXCLKP 1: RefClk15MHz 2: RXCLKN 3: ext. ALICLK"), lo: 4, hi: 6 });
        fields.insert("SER_BIG_WIN", Field { brief: Some("Use wider window for phase alignment"), details: Some("0: Use small window for low jitter (100 to 200ps) 1: Use wide window for higher jitter (150 to 300 ps)"), lo: 2, hi: 3 });
        fields.insert("SER_CPMD_SEL", Field { brief: Some("Select source of CP/MD signals"), details: Some("0: Phase alignment block 1: Core"), lo: 7, hi: 8 });
        fields.insert("SER_DEEMPH", Field { brief: Some("Invert and delays (one clk cycle) output D1 for de-emphasis of OB"), details: Some("0: Non-inverting and non-delaying 1: Inverting and delaying"), lo: 8, hi: 9 });
        fields.insert("SER_ENALI", Field { brief: Some("Enable phase alignment"), details: Some("0: Disable phase alignment 1: Enable phase alignment"), lo: 0, hi: 1 });
        fields.insert("SER_ENHYS", Field { brief: Some("Enable hysteresis for phase alignment"), details: Some("0: Disable hysteresis 1: Enable hysteresis"), lo: 3, hi: 4 });
        fields.insert("SER_EN_WIN", Field { brief: Some("Enable window for phase alignment"), details: Some("0: Disable window 1: Enable window"), lo: 1, hi: 2 });
        fields.insert("SER_IDLE", Field { brief: Some("Invert output D0b for idle-mode of OB"), details: Some("0: Non-inverting 1. Inverting"), lo: 9, hi: 10 });
        fields.insert("SER_SWAP_CPMD", Field { brief: Some("Swap CP/MD signals of phase alignment circuit"), details: Some("0: Disable swapping 1: Enable swapping"), lo: 6, hi: 7 });
        regs.insert("SERDES1G_SER_CFG", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("SERDES1G Serializer Cfg"), details: Some("Configuration register for SERDES1G serializer"), fields });
        let mut fields = HashMap::new();
        fields.insert("SD10G_AUTO_SQUELCH_ENA", Field { brief: Some("Set to enable auto-squelching for sync. ethernet clock output: when set the clock output will stop toggling (keep its last value constantly) when PCS looses link synchrony."), details: None, lo: 0, hi: 1 });
        fields.insert("SD10G_RECO_CLK_DIV", Field { brief: Some("Divider setting for the SD10G recovered clock output. These settings are applied prior to sending recovered clock to the optional PAD-divder (see HSIO::SYNC_ETH_CFG.SEL_RECO_CLK_DIV.)"), details: Some("0: No clock dividing 1: Divide clock by 2 2: Divide clock by (66/32) 3: reserved"), lo: 1, hi: 3 });
        regs.insert("SYNC_ETH_SD10G_CFG", Register { addr: Address { base: 5, count: 4, width: 1 }, brief: None, details: None, fields });
        groups.insert("SERDES1G_ANA_CFG", RegisterGroup { addr: Address { base: 43, count: 1, width: 6 }, desc: "SERDES1G Analog Configuration Registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("PLL_ENA_FB_DIV2", Field { brief: Some("Enable feedback divider (divide by two)"), details: Some("0: Disable 1: Enable"), lo: 22, hi: 23 });
        fields.insert("PLL_ENA_RC_DIV2", Field { brief: Some("Enable reference clock divider (divide by two)"), details: Some("0: Disable 1: Enable"), lo: 21, hi: 22 });
        fields.insert("PLL_FSM_CTRL_DATA", Field { brief: Some("Control data for FSM"), details: None, lo: 8, hi: 16 });
        fields.insert("PLL_FSM_ENA", Field { brief: Some("Enable FSM"), details: None, lo: 7, hi: 8 });
        fields.insert("PLL_FSM_FORCE_SET_ENA", Field { brief: Some("Enable FSM forcing"), details: None, lo: 6, hi: 7 });
        fields.insert("PLL_FSM_OOR_RECAL_ENA", Field { brief: Some("Enable FSM recalibration"), details: None, lo: 5, hi: 6 });
        fields.insert("PLL_RB_DATA_SEL", Field { brief: Some("Select RB data"), details: None, lo: 3, hi: 4 });
        regs.insert("SERDES1G_PLL_CFG", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("SERDES1G Pll Cfg"), details: Some("Configuration register for SERDES1G RCPLL"), fields });
        groups.insert("SERDES1G_ANA_STATUS", RegisterGroup { addr: Address { base: 49, count: 1, width: 1 }, desc: "SERDES1G Analog Status Register", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("INV_DIS", Field { brief: Some("Disable output inverter of BIST PRBS generator"), details: None, lo: 23, hi: 24 });
        fields.insert("LAZYBIT", Field { brief: Some("Lazy designers spare bit"), details: None, lo: 31, hi: 32 });
        fields.insert("PRBS_SEL", Field { brief: Some("Select PRBS pattern for BIST"), details: Some("0: G(x) = x^7 + x^6 + 1 1: G(x) = x^15 + x^14 + 1 2: G(x) = x^23 + x^18 + 1 3: G(x) = x^31 + x^28 + 1"), lo: 20, hi: 22 });
        fields.insert("RX_DFT_ENA", Field { brief: Some("General enable for Jitter-Injection/Frequency-Offset-Generation Block (RX-Path)"), details: Some("0: Off 1: On"), lo: 2, hi: 3 });
        fields.insert("RX_PDSENS_ENA", Field { brief: Some("Enable sensitivity for phasedetector CP/MD (RX-Path)"), details: Some("0: Off 1: On"), lo: 3, hi: 4 });
        fields.insert("RX_PHS_CORR_DIS", Field { brief: Some("Disable influence of external phase correction on step controller"), details: Some("0: Enable 1: Disable"), lo: 4, hi: 5 });
        fields.insert("TEST_MODE", Field { brief: Some("Selection of test mode"), details: Some("0: Normal operation 1: BIST 2: Fixed pattern 3: Random pattern 4-7: Reserved"), lo: 16, hi: 19 });
        fields.insert("TX_DFT_ENA", Field { brief: Some("General enable for Jitter-Injection/Frequency-Offset-Generation Block (TX-Path)"), details: Some("0: Off 1: On"), lo: 0, hi: 1 });
        regs.insert("SERDES1G_DFT_CFG0", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("SERDES1G DFT Configuration register 0"), details: Some("Configuration register 0 for SERDES1G DFT functions"), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_FREQOFF_DIR", Field { brief: Some("Direction of Frequency-Offset (TX-Path)"), details: Some("0: Down 1: Up"), lo: 1, hi: 2 });
        fields.insert("TX_FREQOFF_ENA", Field { brief: Some("Enable Frequency-Offset-Generation (TX-Path)"), details: Some("0: Off 1: On"), lo: 0, hi: 1 });
        fields.insert("TX_JITTER_AMPL", Field { brief: Some("Amplitude of jitter for Jitter-Injection (TX-Path)"), details: None, lo: 8, hi: 18 });
        fields.insert("TX_JI_ENA", Field { brief: Some("Enable TX jitter intertion"), details: Some("0: Off 1:On"), lo: 3, hi: 4 });
        fields.insert("TX_STEP_FREQ", Field { brief: Some("Stepping frequency for Jitter-Injection/Frequency-Offset-Generation (1/2^n) (TX-Path)"), details: None, lo: 4, hi: 8 });
        fields.insert("TX_WAVEFORM_SEL", Field { brief: Some("Select waveform for Jitter-Injection (TX-Path)"), details: Some("0: Triangular 1: Flattened (sinusoidal)"), lo: 2, hi: 3 });
        regs.insert("SERDES1G_DFT_CFG1", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("SERDES1G DFT Configuration register 1"), details: Some("Configuration register 1 for SERDES1G DFT functions (TX direction)"), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_FREQOFF_DIR", Field { brief: Some("Direction of Frequency-Offset (RX-Path)"), details: Some("0: Down 1: Up"), lo: 1, hi: 2 });
        fields.insert("RX_FREQOFF_ENA", Field { brief: Some("Enable Frequency-Offset-Generation (RX-Path)"), details: Some("0: Off 1: On"), lo: 0, hi: 1 });
        fields.insert("RX_JITTER_AMPL", Field { brief: Some("Amplitude of jitter for Link-Quality-Evaluation/Jitter-Injection (RX-Path)"), details: None, lo: 8, hi: 18 });
        fields.insert("RX_JI_ENA", Field { brief: Some("Enable RX jitter intertion"), details: Some("0: Off 1:On"), lo: 3, hi: 4 });
        fields.insert("RX_STEP_FREQ", Field { brief: Some("Stepping frequency for Jitter-Injection/Frequency-Offset-Generation (1/2^n) (RX-Path)"), details: None, lo: 4, hi: 8 });
        fields.insert("RX_WAVEFORM_SEL", Field { brief: Some("Select waveform for Jitter-Injection (RX-Path)"), details: Some("0: Triangular 1: Flattened"), lo: 2, hi: 3 });
        regs.insert("SERDES1G_DFT_CFG2", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("SERDES1G DFT Configuration register 2"), details: Some("Configuration register 2 for SERDES1G DFT functions (RX direction)"), fields });
        let mut fields = HashMap::new();
        fields.insert("PLL_CAL_ERR", Field { brief: Some("Calibration error"), details: Some("0: No error during calibration 1: Errors occured during calibration"), lo: 11, hi: 12 });
        fields.insert("PLL_CAL_NOT_DONE", Field { brief: Some("Calibration status"), details: Some("0: Calibration not started or ongoing 1: Calibration finished"), lo: 12, hi: 13 });
        fields.insert("PLL_OUT_OF_RANGE_ERR", Field { brief: Some("Out of range error"), details: Some("0: No out of range condition detected 1: Out of range condition since last calibration detected"), lo: 10, hi: 11 });
        fields.insert("PLL_RB_DATA", Field { brief: Some("PLL read-back data, depending on \"pll_rb_data_sel\" either the calibrated setting or the measured period"), details: None, lo: 0, hi: 8 });
        regs.insert("SERDES1G_PLL_STATUS", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("SERDES1G Pll Status"), details: Some("Status register of SERDES1G RCPLL"), fields });
        let mut fields = HashMap::new();
        fields.insert("PLL_BIST_ENA", Field { brief: Some("Enables the BIST for the RC-PLL"), details: None, lo: 20, hi: 21 });
        fields.insert("PLL_BIST_FBS_HIGH", Field { brief: Some("Feedback divider setting for closed loop test at high frequency. B1: Rc_div2, B0: Fb_div2."), details: None, lo: 16, hi: 18 });
        fields.insert("PLL_BIST_HIGH", Field { brief: Some("Higher frequnecy for the RC-PLL BIST"), details: None, lo: 8, hi: 16 });
        fields.insert("PLL_BIST_LOW", Field { brief: Some("Lower frequnecy for the RC-PLL BIST"), details: None, lo: 0, hi: 8 });
        regs.insert("SERDES1G_RC_PLL_BIST_CFG", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("SERDES1G RCPLL BIST Configuration"), details: Some("Configuration register for the 1G RC-PLL BIST"), fields });
        let mut fields = HashMap::new();
        fields.insert("STATIC_PATTERN", Field { brief: Some("Static pattern tranferred in fixed pattern test mode, LSB is transferred first"), details: None, lo: 0, hi: 20 });
        regs.insert("SERDES1G_TP_CFG", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("SERDES1G Test Pattern Configuration"), details: Some("Test bits (pattern) for SERDES1G lane. These bits are used when Lane_Test_cfg.Test_mode is set to 2 (fixed pattern)"), fields });
        groups.insert("SERDES1G_DIG_CFG", RegisterGroup { addr: Address { base: 50, count: 1, width: 6 }, desc: "SERDES1G Digital Configuration Register", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("BIST_ACTIVE", Field { brief: Some("BIST activity"), details: Some("0: BIST inactive 1: BIST active"), lo: 3, hi: 4 });
        fields.insert("BIST_COMPLETE_N", Field { brief: Some("BIST completion state (low-active)"), details: Some("0: BIST completed 1: not completed"), lo: 1, hi: 2 });
        fields.insert("BIST_ERROR", Field { brief: Some("BIST result"), details: Some("0: No error found 1: Errors during BIST found"), lo: 0, hi: 1 });
        fields.insert("BIST_NOSYNC", Field { brief: Some("BIST sync result"), details: Some("0: Synchronization successful 1: Synchronization on BIST data failed"), lo: 2, hi: 3 });
        fields.insert("PLL_BIST_FAILED", Field { brief: Some("RC-PLL BIST result"), details: Some("0: No error found 1: Errors during BIST found"), lo: 6, hi: 7 });
        fields.insert("PLL_BIST_NOT_DONE", Field { brief: Some("RC-PLL BIST not done flag"), details: Some("0: BIST done 1: BIST not started or active"), lo: 7, hi: 8 });
        fields.insert("PLL_BIST_TIMEOUT_ERR", Field { brief: Some("RC-PLL BIST timeout error flag"), details: Some("0: No timeout occured 1: Timeout occured"), lo: 5, hi: 6 });
        regs.insert("SERDES1G_DFT_STATUS", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("SERDES1G DFT Status"), details: Some("Status register of SERDES1G DFT functions"), fields });
        let mut fields = HashMap::new();
        fields.insert("DES_100FX_CPMD_ENA", Field { brief: Some("Enable deserializer cp/md handling for 100fx mode"), details: Some("0: Disable 1: Enable"), lo: 8, hi: 9 });
        fields.insert("DES_100FX_CPMD_MODE", Field { brief: Some("Select simple 100fx mode"), details: Some("0: Normal mode 1: Simple mode"), lo: 9, hi: 10 });
        fields.insert("DES_100FX_CPMD_SWAP", Field { brief: Some("Swap cp/md signals in 100fx mode"), details: Some("0: No swapping of cp and md 1: Swap cp and md"), lo: 10, hi: 11 });
        fields.insert("DES_100FX_KICK_MODE", Field { brief: Some("Select mode of kick-out-of-180-degree functionality"), details: None, lo: 11, hi: 13 });
        fields.insert("LANE_RST", Field { brief: Some("Lane Reset"), details: Some("0: No reset 1: Reset (not self-clearing)"), lo: 0, hi: 1 });
        fields.insert("RX_DATA_INV_ENA", Field { brief: Some("Enable data inversion received from Deserializer"), details: Some("0: Disable 1: Enable"), lo: 3, hi: 4 });
        fields.insert("RX_LPI_MODE_ENA", Field { brief: Some("Enable RX-Low-Power feature (Power control by LPI-FSM in connected PCS)"), details: Some("0: Disable 1: Enable"), lo: 5, hi: 6 });
        fields.insert("TX_DATA_INV_ENA", Field { brief: Some("Enable data inversion sent to Serializer"), details: Some("0: Disable 1: Enable"), lo: 2, hi: 3 });
        fields.insert("TX_LPI_MODE_ENA", Field { brief: Some("Enable TX-Low-Power feature (Power control by LPI-FSM in connected PCS)"), details: Some("0: Disable 1: Enable"), lo: 4, hi: 5 });
        regs.insert("SERDES1G_MISC_CFG", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("SERDES1G Misc Configuration"), details: Some("Configuration register for miscellaneous functions"), fields });
        groups.insert("SERDES1G_DIG_STATUS", RegisterGroup { addr: Address { base: 56, count: 1, width: 2 }, desc: "SERDES1G Digital Status Register", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ACJTAG_ENA", Field { brief: Some("ACJTAG enable (ac_mode)"), details: None, lo: 1, hi: 2 });
        fields.insert("ACJTAG_INIT_CLK", Field { brief: Some("ACJTAG clock line"), details: None, lo: 3, hi: 4 });
        fields.insert("ACJTAG_INIT_DATA_N", Field { brief: Some("ACJTAG init data for n leg"), details: None, lo: 5, hi: 6 });
        fields.insert("ACJTAG_INIT_DATA_P", Field { brief: Some("ACJTAG init data for p leg"), details: None, lo: 4, hi: 5 });
        fields.insert("JTAG_CTRL_ENA", Field { brief: Some("Enable JTAG control via CSR"), details: Some("0: External controlled 1: CSR controlled"), lo: 0, hi: 1 });
        fields.insert("OB_DIRECT", Field { brief: Some("JTAG direct output (directly driven)"), details: None, lo: 2, hi: 3 });
        regs.insert("SERDES6G_ACJTAG_CFG", Register { addr: Address { base: 12, count: 1, width: 1 }, brief: Some("SERDES6G ACJTAG Cfg"), details: Some("Configuration register for (AC)JTAG debug capability"), fields });
        let mut fields = HashMap::new();
        fields.insert("ENA_DIRECT", Field { brief: Some("Enable direct line"), details: Some("0: Disable 1: Enable"), lo: 8, hi: 9 });
        fields.insert("ENA_ELOOP", Field { brief: Some("Enable equipment loop"), details: Some("0: Disable 1: Enable"), lo: 7, hi: 8 });
        fields.insert("ENA_FLOOP", Field { brief: Some("Enable facility loop SERDES6G_SER_CFG.SER_ENALI must be set to 1 SERDES6G_SER_CFG.SER_ALISEL must be set to 0"), details: Some("0: Disable 1: Enable"), lo: 6, hi: 7 });
        fields.insert("ENA_ILOOP", Field { brief: Some("Enable input loop"), details: Some("0: Disable 1: Enable"), lo: 5, hi: 6 });
        fields.insert("ENA_LANE", Field { brief: Some("Enable lane"), details: Some("0: Disable lane 1: Enable line"), lo: 14, hi: 15 });
        fields.insert("ENA_PLOOP", Field { brief: Some("Enable pad loop"), details: Some("0: Disable 1: Enable"), lo: 4, hi: 5 });
        fields.insert("HRATE", Field { brief: Some("Enable half rate Baudrate configuration is controlled by: SERDES6G_COMMON_CFG.PLL_DIV4 SERDES6G_COMMON_CFG.PLL_ROT_FRQ SERDES6G_COMMON_CFG.PLL_ROT_DIR SERDES6G_COMMON_CFG.PLL_ENA_ROT SERDES6G_COMMON_CFG.IF_MODE SERDES6G_COMMON_CFG.HRATE SERDES6G_COMMON_CFG.QRATE"), details: Some("0: Disable 1: Enable"), lo: 3, hi: 4 });
        fields.insert("IF_MODE", Field { brief: Some("Interface mode Baudrate configuration is controlled by: SERDES6G_COMMON_CFG.PLL_DIV4 SERDES6G_COMMON_CFG.PLL_ROT_FRQ SERDES6G_COMMON_CFG.PLL_ROT_DIR SERDES6G_COMMON_CFG.PLL_ENA_ROT SERDES6G_COMMON_CFG.IF_MODE SERDES6G_COMMON_CFG.HRATE SERDES6G_COMMON_CFG.QRATE"), details: Some("0: 8-bit mode 1: 10-bit mode 2: 16-bit mode 3: 20-bit mode"), lo: 0, hi: 2 });
        fields.insert("LANE_CTRL", Field { brief: Some("Hidden spare bits (not connected internally yet)"), details: None, lo: 9, hi: 12 });
        fields.insert("PWD_RX", Field { brief: Some("Power-down RX-path"), details: Some("0: Normal mode 1: Power down mode"), lo: 13, hi: 14 });
        fields.insert("PWD_TX", Field { brief: Some("Power-down TX-path"), details: Some("0: Normal mode 1: Power down mode"), lo: 12, hi: 13 });
        fields.insert("QRATE", Field { brief: Some("Enable quarter rate Baudrate configuration is controlled by: SERDES6G_COMMON_CFG.PLL_DIV4 SERDES6G_COMMON_CFG.PLL_ROT_FRQ SERDES6G_COMMON_CFG.PLL_ROT_DIR SERDES6G_COMMON_CFG.PLL_ENA_ROT SERDES6G_COMMON_CFG.IF_MODE SERDES6G_COMMON_CFG.HRATE SERDES6G_COMMON_CFG.QRATE"), details: Some("0: Disable 1: Enable"), lo: 2, hi: 3 });
        fields.insert("SE_AUTO_SQUELCH_ENA", Field { brief: Some("Enable auto-squelching for sync. ethernet clock output: when set the clock output will stop toggling (keep its last value constantly) when PCS looses link synchrony."), details: Some("0: Disable 1: Enable"), lo: 15, hi: 16 });
        fields.insert("SYS_RST", Field { brief: Some("System reset (low active) Should be set after SERDES6G_COMMON_CFG.ENA_LANE was set to 1."), details: Some("0: Apply reset (not self-clearing) 1: Reset released (mission mode)"), lo: 16, hi: 17 });
        regs.insert("SERDES6G_COMMON_CFG", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("SERDES6G Common Cfg"), details: Some("Configuration register for common SERDES6G functions"), fields });
        let mut fields = HashMap::new();
        fields.insert("DES_BW_ANA", Field { brief: Some("Bandwidth selection. Selects dividing factor for non-hysteresis CP/MD outputs."), details: Some("0: No division 1: Divide by 2 2: Divide by 4 3: Divide by 8 4: Divide by 16 5: Divide by 32 6: Divide by 64 7: Divide by 128"), lo: 1, hi: 4 });
        fields.insert("DES_BW_HYST", Field { brief: Some("Bandwidth selection. Selects dividing factor for hysteresis CP/MD outputs."), details: Some("0: Divide by 2 1: Divide by 4 2: Divide by 8 3: Divide by 16 4: Divide by 32 5: Divide by 64 6: Divide by 128 7: Divide by 256"), lo: 5, hi: 8 });
        fields.insert("DES_CPMD_SEL", Field { brief: Some("DES phase control, main cp/md select"), details: Some("00: Directly from DES 01: Through hysteresis stage from DES 10: From core 11: Disabled"), lo: 8, hi: 10 });
        fields.insert("DES_MBTR_CTRL", Field { brief: Some("Des phase control for 180 degrees deadlock block mode of operation"), details: Some("000: Depending on density of input pattern 001: Active until PCS has synchronized 010: Depending on density of input pattern until PCS has synchronized 011: Never 100: Always 111: Debug feature: Add cp/md of DES and cp/md from core"), lo: 10, hi: 13 });
        fields.insert("DES_PHS_CTRL", Field { brief: Some("Control of phase regulator logic (bit 3 selects input to integrator block - 0: cp/md from DES, 1: cp/md from core)"), details: Some("0: Disabled 1: Enabled with 99 ppm limit 2: Enabled with 202 ppm limit 3: Enabled with 485 ppm limit 4: Enabled if corresponding PCS is in sync with 50 ppm limit 5: Enabled if corresponding PCS is in sync with 99 ppm limit 6: Enabled if corresponding PCS is in sync with 202 ppm limit 7: Enabled if corresponding PCS is in sync with 485 ppm limit"), lo: 13, hi: 17 });
        fields.insert("DES_SWAP_ANA", Field { brief: Some("Swap non-hysteresis cp/md signals."), details: Some("0: No swapping 1: Swapping"), lo: 0, hi: 1 });
        fields.insert("DES_SWAP_HYST", Field { brief: Some("Swap hysteresis cp/md signals."), details: Some("0: No swapping 1: Swapping"), lo: 4, hi: 5 });
        regs.insert("SERDES6G_DES_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("SERDES6G Deserializer Cfg"), details: Some("Configuration register for SERDES6G deserializer"), fields });
        let mut fields = HashMap::new();
        fields.insert("IB_ANA_TEST_ENA", Field { brief: Some("Enable analog test output."), details: Some("0: Disable 1: Enable"), lo: 6, hi: 7 });
        fields.insert("IB_CAL_ENA", Field { brief: Some("Enable calibration IB calibration should be started after SERDES6G_COMMON_CFG.ENA_LANE was set to '1'. Calibration procedure takes up to 1sec depending on configuration of SERDES6G_IB_CFG0.IB_SIG_DET_CLK_SEL. Max.- calibration time is for SERDES6G_IB_CFG0.IB_SIG_DET_CLK_SEL set to 7."), details: Some("0: Disable 1: Enable (mission mode)"), lo: 3, hi: 4 });
        fields.insert("IB_CONCUR", Field { brief: Some("Selection between constant current and constant resistor mode for CML cells"), details: Some("0: Constant resistor mode 1: Constant current mode"), lo: 4, hi: 5 });
        fields.insert("IB_EQZ_ENA", Field { brief: Some("Enable EQualiZation-Stage"), details: Some("0: Disable 1: Enable (mission mode)"), lo: 1, hi: 2 });
        fields.insert("IB_ICML_ADJ", Field { brief: Some("Current adjustment for CML cells"), details: Some("0: low current 1: high current"), lo: 20, hi: 24 });
        fields.insert("IB_REG_ENA", Field { brief: Some("Enable equalizer REGulation stage"), details: Some("0: Disable 1: Enable (mission mode)"), lo: 0, hi: 1 });
        fields.insert("IB_REG_PAT_SEL_HP", Field { brief: Some("Selects pattern detection for regulation of high-pass-gain"), details: Some("0: Only regulation assessment if basic pattern is detected 1: Regulation assessment if basic and simplified pattern are detected 2: Regulation assessment if basic and critical pattern are detected 3: Regulation assessment if simplified basic and critical pattern are detected."), lo: 13, hi: 15 });
        fields.insert("IB_REG_PAT_SEL_LP", Field { brief: Some("Selects pattern detection for regulation of low-pass-gain"), details: Some("0: Only regulation assessment if basic pattern is detected 1: Regulation assessment if basic and simplified pattern are detected 2: Regulation assessment if basic and critical pattern are detected 3: Regulation assessment if simplified basic and critical pattern are detected."), lo: 9, hi: 11 });
        fields.insert("IB_REG_PAT_SEL_MID", Field { brief: Some("Selects pattern detection for regulation of mid-pass-gain"), details: Some("0: Only regulation assessment if basic pattern is detected 1: Regulation assessment if basic and simplified pattern are detected 2: Regulation assessment if basic and critical pattern are detected 3: Regulation assessment if simplified basic and critical pattern are detected."), lo: 11, hi: 13 });
        fields.insert("IB_REG_PAT_SEL_OFFSET", Field { brief: Some("Selects pattern detection for regulation of offset"), details: Some("0: Only regulation assessment if basic pattern is detected 1: Regulation assessment if basic and simplified pattern are detected 2: Regulation assessment if basic and critical pattern are detected 3: Regulation assessment if simplified basic and critical pattern are detected."), lo: 7, hi: 9 });
        fields.insert("IB_RTRM_ADJ", Field { brief: Some("Resistance adjustment for termination and CML cell regulation. This configuration defines an offset (2-complement) to the RCOMP value. The effective value is limited between 0 to 15."), details: Some("7: RCOMP+7 1: RCOMP+1 0: RCOMP 15: RCOMP-1 8: RCOMP -8"), lo: 24, hi: 28 });
        fields.insert("IB_SAM_ENA", Field { brief: Some("Enable SAMpling stage"), details: Some("0: Disable 1: Enable (mission mode)"), lo: 2, hi: 3 });
        fields.insert("IB_SIG_DET_CLK_SEL", Field { brief: Some("Select signal detect clock: Frequency = 125 MHz / 2**n Set to 0 for ATE testing (reduces test-time) Set to 7 for optimized performance in mission mode"), details: None, lo: 15, hi: 18 });
        fields.insert("IB_SIG_DET_ENA", Field { brief: Some("Enable signal detection."), details: Some("0: Disable 1: Enable"), lo: 5, hi: 6 });
        fields.insert("IB_SOFSI", Field { brief: Some("Select location of offset correction inside equalizer"), details: Some("0: No offset correction 1: First stage (preferred) 2: Last stage 3: First and last stage"), lo: 29, hi: 31 });
        fields.insert("IB_TERM_MODE_SEL", Field { brief: Some("Select common mode termination voltage."), details: Some("0: Open - recommended mission mode for DC-coupling 1: VCM ref - recommended mission mode for AC-coupling 2: VDD - used to increase amplitude in certain DC-coupled modes 3: capacitance only - Reserved for debug test purpose"), lo: 18, hi: 20 });
        fields.insert("IB_VBULK_SEL", Field { brief: Some("Controls Bulk Voltage of High Speed Cells"), details: Some("0: Reserved 1: Low (mission mode)"), lo: 28, hi: 29 });
        regs.insert("SERDES6G_IB_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("SERDES6G IB Configuration register 0"), details: Some("Configuration settings 0"), fields });
        let mut fields = HashMap::new();
        fields.insert("IB_FILT_HP", Field { brief: Some("Selects doubled filtering of high-pass-gain regulation or set it to hold if ib_frc_hp = 1"), details: None, lo: 7, hi: 8 });
        fields.insert("IB_FILT_LP", Field { brief: Some("Selects doubled filtering of low-pass-gain regulation or set it to hold if ib_frc_lp = 1"), details: None, lo: 5, hi: 6 });
        fields.insert("IB_FILT_MID", Field { brief: Some("Selects doubled filtering of mid-pass-gain regulation or set it to hold if ib_frc_mid = 1"), details: None, lo: 6, hi: 7 });
        fields.insert("IB_FILT_OFFSET", Field { brief: Some("Selects doubled filtering of offset regulation or set it to hold if ib_frc_offset = 1"), details: None, lo: 4, hi: 5 });
        fields.insert("IB_FRC_HP", Field { brief: Some("Selects manual control for high-pass-gain regulation if enabled"), details: None, lo: 3, hi: 4 });
        fields.insert("IB_FRC_LP", Field { brief: Some("Selects manual control for low-pass-gain regulation if enabled"), details: None, lo: 1, hi: 2 });
        fields.insert("IB_FRC_MID", Field { brief: Some("Selects manual control for mid-pass-gain regulaltion if enabled"), details: None, lo: 2, hi: 3 });
        fields.insert("IB_FRC_OFFSET", Field { brief: Some("Selects manual control for offset regulation if enabled"), details: None, lo: 0, hi: 1 });
        fields.insert("IB_SCALY", Field { brief: Some("Selects number of calibration cycles for equalizer, sampling stage, signal-detect and AC-JTAG comparator, BIAS. 0: no calibration --> neutral values are used."), details: None, lo: 8, hi: 12 });
        fields.insert("IB_TJTAG", Field { brief: Some("Selects threshold voltage for ac-jtag. Voltage = (n + 1) * 20 mV."), details: None, lo: 17, hi: 22 });
        fields.insert("IB_TSDET", Field { brief: Some("Selects threshold voltage for signal detect. Voltage = (n + 1) * 20 mV."), details: None, lo: 12, hi: 17 });
        regs.insert("SERDES6G_IB_CFG1", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("SERDES6G IB Configuration register 1"), details: Some("Configuration settings 1"), fields });
        let mut fields = HashMap::new();
        fields.insert("IB_OCALS", Field { brief: Some("Selects offset voltage for main sampler calibration."), details: Some("0: -70mV ... 31: -0mV 32: +0mV ... 63: 70mV"), lo: 10, hi: 16 });
        fields.insert("IB_OINFI", Field { brief: Some("Selects maximum offset influence for offset regulation."), details: Some("0: 10mV 1: 20mV ..."), lo: 22, hi: 27 });
        fields.insert("IB_OINFS", Field { brief: Some("Selects maximum offset influence for offset calibration of main samplers."), details: Some("0: 40mV 1: 80mV ..."), lo: 16, hi: 19 });
        fields.insert("IB_TAUX", Field { brief: Some("Reserved"), details: None, lo: 19, hi: 22 });
        fields.insert("IB_TCALV", Field { brief: Some("Selects threshold voltage for VScope sampler calibration."), details: Some("0: 10mV 1: 20mV ..."), lo: 5, hi: 10 });
        fields.insert("IB_TINFV", Field { brief: Some("Selects maximum threshold influence for threshold calibration of vscope samplers."), details: Some("0: 40mV 1: 80mV ..."), lo: 27, hi: 30 });
        fields.insert("IB_UMAX", Field { brief: Some("Tunes common mode voltage to adapt to max. voltage of input signal."), details: Some("0: 320mVppd 1: 480mVppd 2: 640mVppd (recommended for mission mode) 3: 800mVppd"), lo: 3, hi: 5 });
        fields.insert("IB_UREG", Field { brief: Some("0dB regulation voltage for high-speed-cells."), details: Some("0: 160mV 1: 180mV 2: 200mV 3: 220mV 4: 240mV (recommended for mission mode) 5: 260mV 6: 280mV 7: 300mV"), lo: 0, hi: 3 });
        regs.insert("SERDES6G_IB_CFG2", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("SERDES6G IB Configuration register 2"), details: Some("Configuration settings 2"), fields });
        let mut fields = HashMap::new();
        fields.insert("IB_INI_HP", Field { brief: Some("Init force value for high-pass gain regulation"), details: None, lo: 18, hi: 24 });
        fields.insert("IB_INI_LP", Field { brief: Some("Init force value for low-pass gain regulation"), details: None, lo: 6, hi: 12 });
        fields.insert("IB_INI_MID", Field { brief: Some("Init force value for mid-pass gain regulation"), details: None, lo: 12, hi: 18 });
        fields.insert("IB_INI_OFFSET", Field { brief: Some("Init force value for offset gain regulation"), details: None, lo: 0, hi: 6 });
        regs.insert("SERDES6G_IB_CFG3", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("SERDES6G IB Configuration register 3"), details: Some("Configuration settings 3"), fields });
        let mut fields = HashMap::new();
        fields.insert("IB_MAX_HP", Field { brief: Some("Max value for high-pass gain regulation"), details: None, lo: 18, hi: 24 });
        fields.insert("IB_MAX_LP", Field { brief: Some("Max value for low-pass gain regulation"), details: None, lo: 6, hi: 12 });
        fields.insert("IB_MAX_MID", Field { brief: Some("Max value for mid-pass gain regulation"), details: None, lo: 12, hi: 18 });
        fields.insert("IB_MAX_OFFSET", Field { brief: Some("Max value for offset gain regulation"), details: None, lo: 0, hi: 6 });
        regs.insert("SERDES6G_IB_CFG4", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("SERDES6G IB Configuration register 4"), details: Some("Configuration settings 4"), fields });
        let mut fields = HashMap::new();
        fields.insert("IB_MIN_HP", Field { brief: Some("Min value for high-pass gain regulation"), details: None, lo: 18, hi: 24 });
        fields.insert("IB_MIN_LP", Field { brief: Some("Min value for low-pass gain regulation"), details: None, lo: 6, hi: 12 });
        fields.insert("IB_MIN_MID", Field { brief: Some("Min value for mid-pass gain regulation"), details: None, lo: 12, hi: 18 });
        fields.insert("IB_MIN_OFFSET", Field { brief: Some("Min value for offset gain regulation"), details: None, lo: 0, hi: 6 });
        regs.insert("SERDES6G_IB_CFG5", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("SERDES6G IB Configuration register 5"), details: Some("Configuration settings 5"), fields });
        let mut fields = HashMap::new();
        fields.insert("DES_100FX_PHASE_SEL", Field { brief: Some("Phase selection of DES in 100fx mode"), details: Some("0: CDR locked at bit 9 1: CDR locked at bit 4"), lo: 0, hi: 1 });
        regs.insert("SERDES6G_MISC_STATUS", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("SERDES6G Misc Status"), details: Some("Status register for miscellaneous functions"), fields });
        let mut fields = HashMap::new();
        fields.insert("OB_ENA1V_MODE", Field { brief: Some("Output buffer supply voltage"), details: Some("1: Set to nominal 1V 0: Set to higher voltage"), lo: 30, hi: 31 });
        fields.insert("OB_IDLE", Field { brief: Some("PCIe support"), details: Some("1: idle - force to 0V differential 0: Normal mode"), lo: 31, hi: 32 });
        fields.insert("OB_POL", Field { brief: Some("Polarity of output signal"), details: Some("0: Normal 1: Inverted"), lo: 29, hi: 30 });
        fields.insert("OB_POST0", Field { brief: Some("Coefficients for 1st Post Cursor (MSB is sign)"), details: None, lo: 23, hi: 29 });
        fields.insert("OB_POST1", Field { brief: Some("Coefficients for 2nd Post Cursor (MSB is sign)"), details: None, lo: 11, hi: 16 });
        fields.insert("OB_PREC", Field { brief: Some("Coefficients for Pre Cursor (MSB is sign)"), details: None, lo: 18, hi: 23 });
        fields.insert("OB_RESISTOR_CTRL", Field { brief: Some("Resistance adjustment for termination and CML cell regulation. This configuration defines an offset (2-complement) to the RCOMP value. The effective value is limited between 0 to 15."), details: Some("7: RCOMP+7 1: RCOMP+1 0: RCOMP 15: RCOMP-1 8: RCOMP -8"), lo: 0, hi: 4 });
        fields.insert("OB_R_ADJ_MUX", Field { brief: Some("Resistor adjust mux, driving strength selection of mux"), details: Some("1: Reduced 0: Normal"), lo: 17, hi: 18 });
        fields.insert("OB_R_ADJ_PDR", Field { brief: Some("Resistor adjust predriver, driving strength selection of predriver"), details: Some("1: Reduced 0: Normal"), lo: 16, hi: 17 });
        fields.insert("OB_R_COR", Field { brief: Some("Reduce the impedance by 3%"), details: Some("0: Disable 1: Enable"), lo: 10, hi: 11 });
        fields.insert("OB_SEL_RCTRL", Field { brief: Some("Select resistor control"), details: Some("0: Automatic mode 1: Manual mode - use ob_r_adj_mux and ob_r_adj_pdr for driving strength control"), lo: 9, hi: 10 });
        fields.insert("OB_SR", Field { brief: Some("Driver speed, fine adjustment of slew rate 30-60ps (if OB_SR_H = 0), 60-140ps (if OB_SR_H = 1). LSB is not used."), details: Some("000x: ~30ps/60ps ... 111x: ~60ps/140ps"), lo: 4, hi: 8 });
        fields.insert("OB_SR_H", Field { brief: Some("Half the predriver speed, use for slew rate control"), details: Some("0: Disable - slew rate < 60 ps 1: Enable - slew rate > 60 ps"), lo: 8, hi: 9 });
        regs.insert("SERDES6G_OB_CFG", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("SERDES6G Output Buffer Cfg 0"), details: Some("Configuration register 0 for SERDES6G output buffer"), fields });
        let mut fields = HashMap::new();
        fields.insert("OB_ENA_CAS", Field { brief: Some("Output skew, used for skew adjustment in SGMII mode - 1bit-hot-coded"), details: Some("000: Non-SGMII/1Gbps modes 001: Lowest skew 010: SGMII/1Gbps mode 100: Highest skew All other settings: Reserved"), lo: 6, hi: 9 });
        fields.insert("OB_LEV", Field { brief: Some("Level of output amplitude for 1V mode: max: ~48 for 1.2V mode: max: 63"), details: Some("0: lowest level 63: highest level"), lo: 0, hi: 6 });
        regs.insert("SERDES6G_OB_CFG1", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("SERDES6G Output Buffer Cfg1"), details: Some("Configuration register 1 for SERDES6G output buffer"), fields });
        let mut fields = HashMap::new();
        fields.insert("PLL_DIV4", Field { brief: Some("Enable div4 mode Baudrate configuration is controlled by: SERDES6G_COMMON_CFG.PLL_DIV4 SERDES6G_COMMON_CFG.PLL_ROT_FRQ SERDES6G_COMMON_CFG.PLL_ROT_DIR SERDES6G_COMMON_CFG.PLL_ENA_ROT SERDES6G_COMMON_CFG.IF_MODE SERDES6G_COMMON_CFG.HRATE SERDES6G_COMMON_CFG.QRATE"), details: None, lo: 15, hi: 16 });
        fields.insert("PLL_ENA_OFFS", Field { brief: Some("Enable offset compensation B1: Feedback path; B0: VCO."), details: None, lo: 16, hi: 18 });
        fields.insert("PLL_ENA_ROT", Field { brief: Some("Enable rotation Baudrate configuration is controlled by: SERDES6G_COMMON_CFG.PLL_DIV4 SERDES6G_COMMON_CFG.PLL_ROT_FRQ SERDES6G_COMMON_CFG.PLL_ROT_DIR SERDES6G_COMMON_CFG.PLL_ENA_ROT SERDES6G_COMMON_CFG.IF_MODE SERDES6G_COMMON_CFG.HRATE SERDES6G_COMMON_CFG.QRATE"), details: None, lo: 14, hi: 15 });
        fields.insert("PLL_FSM_CTRL_DATA", Field { brief: Some("Control data for PLL-FSM Encoding below are only examples for some modes. Baudrate configuration is controlled by: SERDES6G_COMMON_CFG.PLL_DIV4 SERDES6G_COMMON_CFG.PLL_ROT_FRQ SERDES6G_COMMON_CFG.PLL_ROT_DIR SERDES6G_COMMON_CFG.PLL_ENA_ROT SERDES6G_COMMON_CFG.IF_MODE SERDES6G_COMMON_CFG.HRATE SERDES6G_COMMON_CFG.QRATE"), details: Some("60: SGMII/1G-Modes 48: XAUI/2.5Gbps 96: RXAUI 120: QSGMII"), lo: 6, hi: 14 });
        fields.insert("PLL_FSM_ENA", Field { brief: Some("Enable FSM"), details: None, lo: 5, hi: 6 });
        fields.insert("PLL_FSM_FORCE_SET_ENA", Field { brief: Some("Enable FSM forcing"), details: None, lo: 4, hi: 5 });
        fields.insert("PLL_FSM_OOR_RECAL_ENA", Field { brief: Some("Enable FSM recalibration"), details: None, lo: 3, hi: 4 });
        fields.insert("PLL_RB_DATA_SEL", Field { brief: Some("Select RB data"), details: None, lo: 2, hi: 3 });
        fields.insert("PLL_ROT_DIR", Field { brief: Some("Select rotation direction Baudrate configuration is controlled by: SERDES6G_COMMON_CFG.PLL_DIV4 SERDES6G_COMMON_CFG.PLL_ROT_FRQ SERDES6G_COMMON_CFG.PLL_ROT_DIR SERDES6G_COMMON_CFG.PLL_ENA_ROT SERDES6G_COMMON_CFG.IF_MODE SERDES6G_COMMON_CFG.HRATE SERDES6G_COMMON_CFG.QRATE"), details: None, lo: 1, hi: 2 });
        fields.insert("PLL_ROT_FRQ", Field { brief: Some("Select rotation frequency Baudrate configuration is controlled by: SERDES6G_COMMON_CFG.PLL_DIV4 SERDES6G_COMMON_CFG.PLL_ROT_FRQ SERDES6G_COMMON_CFG.PLL_ROT_DIR SERDES6G_COMMON_CFG.PLL_ENA_ROT SERDES6G_COMMON_CFG.IF_MODE SERDES6G_COMMON_CFG.HRATE SERDES6G_COMMON_CFG.QRATE"), details: None, lo: 0, hi: 1 });
        regs.insert("SERDES6G_PLL_CFG", Register { addr: Address { base: 11, count: 1, width: 1 }, brief: Some("SERDES6G Pll Cfg"), details: Some("Configuration register for SERDES6G RCPLL"), fields });
        let mut fields = HashMap::new();
        fields.insert("SER_4TAP_ENA", Field { brief: Some("Enable the fourth cml output Q3 for POST1 input of OB8G"), details: Some("0: Disable 4th output 1: Enable 4th output"), lo: 8, hi: 9 });
        fields.insert("SER_ALISEL", Field { brief: Some("Select reference clock source for phase alignment"), details: Some("00: RXCLKP (for facility loop mode) 01: RefClk15MHz (for XAUI/RXAUI) 10: RXCLKN (debug) 11: ext. ALICLK (debug)"), lo: 4, hi: 6 });
        fields.insert("SER_BIG_WIN", Field { brief: Some("Use wider window for phase alignment"), details: Some("0: Use small-window 1: Use wide window"), lo: 2, hi: 3 });
        fields.insert("SER_CPMD_SEL", Field { brief: Some("Select source of cp/md signals"), details: Some("0: Phase alignment block 1: Core"), lo: 7, hi: 8 });
        fields.insert("SER_ENALI", Field { brief: Some("Enable phase alignment"), details: Some("0: Disable phase alignment 1: Enable phase alignment (required for MLD-modes - XAUI/RXAUI - and facility loop mode)"), lo: 0, hi: 1 });
        fields.insert("SER_ENHYS", Field { brief: Some("Enable hysteresis for phase alignment"), details: Some("0: Disable hysteresis 1: Enable hysteresis"), lo: 3, hi: 4 });
        fields.insert("SER_EN_WIN", Field { brief: Some("Enable window for phase alignment"), details: Some("0: Disable window 1: Enable window"), lo: 1, hi: 2 });
        fields.insert("SER_SWAP_CPMD", Field { brief: Some("Swap cp/md signals"), details: Some("0: Disable swapping 1: Enable swapping"), lo: 6, hi: 7 });
        regs.insert("SERDES6G_SER_CFG", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("SERDES6G Serializer Cfg"), details: Some("Configuration register for SERDES6G serializer"), fields });
        groups.insert("SERDES6G_ANA_CFG", RegisterGroup { addr: Address { base: 71, count: 1, width: 14 }, desc: "SERDES6G Analog ConfigStatus Registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ACJTAG_CAPT_DATA_N", Field { brief: Some("ACJTAG captured data for n leg"), details: None, lo: 2, hi: 3 });
        fields.insert("ACJTAG_CAPT_DATA_P", Field { brief: Some("ACJTAG captured data for p leg"), details: None, lo: 1, hi: 2 });
        fields.insert("IB_DIRECT", Field { brief: Some("JTAG direct input (directly driven)"), details: None, lo: 0, hi: 1 });
        regs.insert("SERDES6G_ACJTAG_STATUS", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("SERDES6G ACJTAG Status"), details: Some("Status register of (AC)JTAG debug capability"), fields });
        let mut fields = HashMap::new();
        fields.insert("GP_LSB", Field { brief: Some("Bit 9: SNFBC Select negative feedback center - enable for hysteresis suppression in main sampler FFs Bit 8: SNFBV Select negative feedback Vscope - enable for hysteresis suppression in vscope sampler FFs Bit 1: ERLS (used for debug only, allows for manual stepping through calibration procedure) Bit 0: CRLS (used for debug only, allows for manual stepping through calibration procedure)"), details: None, lo: 0, hi: 16 });
        fields.insert("GP_MSB", Field { brief: Some("To be defined"), details: None, lo: 16, hi: 32 });
        regs.insert("SERDES6G_GP_CFG", Register { addr: Address { base: 13, count: 1, width: 1 }, brief: Some("SERDES6G GP CFG"), details: Some("General purpose register A"), fields });
        let mut fields = HashMap::new();
        fields.insert("IB_CAL_DONE", Field { brief: Some("Signals mission mode after calibration was done."), details: None, lo: 8, hi: 9 });
        fields.insert("IB_HP_GAIN_ACT", Field { brief: Some("Flag high-pass-gain regulation activity. Caution: currently this signal is generated with a clock of datarate/16 and NOT captured (sticky)."), details: None, lo: 7, hi: 8 });
        fields.insert("IB_LP_GAIN_ACT", Field { brief: Some("Flag low-pass-gain regulation activity. Caution: currently this signal is generated with a clock of datarate/16 and NOT captured (sticky)."), details: None, lo: 5, hi: 6 });
        fields.insert("IB_MID_GAIN_ACT", Field { brief: Some("Flag mid-pass-gain regulation activity. Caution: currently this signal is generated with a clock of datarate/16 and NOT captured (sticky)."), details: None, lo: 6, hi: 7 });
        fields.insert("IB_OFFSDIR", Field { brief: Some("Detection of offset direction in selected (ib_offsx) sampling channels"), details: None, lo: 1, hi: 2 });
        fields.insert("IB_OFFSET_ACT", Field { brief: Some("Flag offset regulation activity. Caution: currently this signal is generated with a clock of datarate/16 and NOT captured (sticky)."), details: None, lo: 4, hi: 5 });
        fields.insert("IB_OFFSET_ERR", Field { brief: Some("Overflow error during calibration process. Value at ib_offset_stat not valid."), details: None, lo: 2, hi: 3 });
        fields.insert("IB_OFFSET_VLD", Field { brief: Some("Valid average data of calibration process at ib_offset_stat available."), details: None, lo: 3, hi: 4 });
        fields.insert("IB_SIG_DET", Field { brief: Some("Detection of toggling signal at PADP and PADN"), details: None, lo: 0, hi: 1 });
        regs.insert("SERDES6G_IB_STATUS0", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("SERDES6G IB Status register 0"), details: Some("Status register for Signal Detect"), fields });
        let mut fields = HashMap::new();
        fields.insert("IB_HP_GAIN_STAT", Field { brief: Some("Current high-pass-gain regulation value"), details: None, lo: 18, hi: 24 });
        fields.insert("IB_LP_GAIN_STAT", Field { brief: Some("Current low-pass-gain regulation value"), details: None, lo: 6, hi: 12 });
        fields.insert("IB_MID_GAIN_STAT", Field { brief: Some("Current mid-pass-gain regulation value"), details: None, lo: 12, hi: 18 });
        fields.insert("IB_OFFSET_STAT", Field { brief: Some("Current offset regulation value"), details: None, lo: 0, hi: 6 });
        regs.insert("SERDES6G_IB_STATUS1", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("SERDES6G IB Status register 1"), details: Some("Regulation stage status register"), fields });
        let mut fields = HashMap::new();
        fields.insert("PLL_CAL_ERR", Field { brief: Some("Calibration error"), details: Some("0: No error during calibration 1: Errors occured during calibration"), lo: 9, hi: 10 });
        fields.insert("PLL_CAL_NOT_DONE", Field { brief: Some("Calibration status"), details: Some("0: Calibration not started or ongoing 1: Calibration finished"), lo: 10, hi: 11 });
        fields.insert("PLL_OUT_OF_RANGE_ERR", Field { brief: Some("Out of range error"), details: Some("0: No out of range condition detected 1: Out of range condition since last calibration detected"), lo: 8, hi: 9 });
        fields.insert("PLL_RB_DATA", Field { brief: Some("PLL read-back data, depending on \"pll_rb_data_sel\" either the calibrated setting or the measured period"), details: None, lo: 0, hi: 8 });
        regs.insert("SERDES6G_PLL_STATUS", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("SERDES6G Pll Status"), details: Some("Status register of SERDES6G RCPLL"), fields });
        groups.insert("SERDES6G_ANA_STATUS", RegisterGroup { addr: Address { base: 85, count: 1, width: 5 }, desc: "SERDES6G Analog Status Registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("SERDES1G_ADDR", Field { brief: Some("Activation vector for SERDES1G-Slaves, one-hot coded, each bit is related to one macro, e.g. bit 0 enables/disables access to macro no. 0."), details: Some("0: Disable macro access via MCB 1: Enable macro access via MCB"), lo: 0, hi: 9 });
        fields.insert("SERDES1G_RD_ONE_SHOT", Field { brief: Some("Initiate a read access to marked SERDES1G slaves"), details: Some("0: No read operation pending (read op finished after bit has been set) 1: Initiate a read access (kept 1 until read operation has finished)"), lo: 30, hi: 31 });
        fields.insert("SERDES1G_WR_ONE_SHOT", Field { brief: Some("Initiate a write access to marked SERDES1G slaves"), details: Some("0: No write operation pending 1: Initiate write to slaves (kept 1 until write operation has finished)"), lo: 31, hi: 32 });
        regs.insert("MCB_SERDES1G_ADDR_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("MCB SERDES1G Address Cfg"), details: Some("Configuration of SERDES1G MCB slaves to be accessed"), fields });
        let mut fields = HashMap::new();
        fields.insert("INV_DIS", Field { brief: Some("Disable output inverter of BIST PRBS generator"), details: None, lo: 23, hi: 24 });
        fields.insert("LAZYBIT", Field { brief: Some("Lazy designers spare bit"), details: None, lo: 31, hi: 32 });
        fields.insert("PRBS_SEL", Field { brief: Some("Select PRBS pattern for BIST"), details: Some("0: G(x) = x^7 + x^6 + 1 1: G(x) = x^15 + x^14 + 1 2: G(x) = x^23 + x^18 + 1 3: G(x) = x^31 + x^28 + 1"), lo: 20, hi: 22 });
        fields.insert("RX_DFT_ENA", Field { brief: Some("General enable for Jitter-Injection/Frequency-Offset-Generation Block (RX-Path)"), details: Some("0: Off 1: On"), lo: 2, hi: 3 });
        fields.insert("RX_PDSENS_ENA", Field { brief: Some("Enable sensitivity for phasedetector CP/MD (RX-Path)"), details: Some("0: Off 1: On"), lo: 3, hi: 4 });
        fields.insert("RX_PHS_CORR_DIS", Field { brief: Some("Disable influence of external phase correction on step controller"), details: Some("0: Enable 1: Disable"), lo: 4, hi: 5 });
        fields.insert("TEST_MODE", Field { brief: Some("Selection of test mode"), details: Some("0: Normal operation 1: BIST 2: Fixed pattern 3: Random pattern 4: Jitter injection 5-7: Reserved"), lo: 16, hi: 19 });
        fields.insert("TX_DFT_ENA", Field { brief: Some("General enable for Jitter-Injection/Frequency-Offset-Generation Block (TX-Path)"), details: Some("0: Off 1: On"), lo: 0, hi: 1 });
        regs.insert("SERDES6G_DFT_CFG0", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("SERDES6G DFT Configuration register 0"), details: Some("Configuration register 0 for SERDES6G DFT functions"), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_FREQOFF_DIR", Field { brief: Some("Direction of Frequency-Offset (TX-Path)"), details: Some("0: Down 1: Up"), lo: 1, hi: 2 });
        fields.insert("TX_FREQOFF_ENA", Field { brief: Some("Enable Frequency-Offset-Generation (TX-Path)"), details: Some("0: Off 1: On"), lo: 0, hi: 1 });
        fields.insert("TX_JITTER_AMPL", Field { brief: Some("Amplitude of jitter for Jitter-Injection (TX-Path)"), details: None, lo: 8, hi: 18 });
        fields.insert("TX_JI_ENA", Field { brief: Some("Enable TX jitter intertion"), details: Some("0: Off 1:On"), lo: 3, hi: 4 });
        fields.insert("TX_STEP_FREQ", Field { brief: Some("Stepping frequency for Jitter-Injection/Frequency-Offset-Generation (1/2^n) (RX-Path)"), details: None, lo: 4, hi: 8 });
        fields.insert("TX_WAVEFORM_SEL", Field { brief: Some("Select waveform for Jitter-Injection (TX-Path)"), details: Some("0: Triangular 1: Flattened (sinusoidal)"), lo: 2, hi: 3 });
        regs.insert("SERDES6G_DFT_CFG1", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("SERDES6G DFT Configuration register 1"), details: Some("Configuration register 1 for SERDES6G DFT functions (TX direction)"), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_FREQOFF_DIR", Field { brief: Some("Direction of Frequency-Offset (RX-Path)"), details: Some("0: Down 1: Up"), lo: 1, hi: 2 });
        fields.insert("RX_FREQOFF_ENA", Field { brief: Some("Enable Frequency-Offset-Generation (RX-Path)"), details: Some("0: Off 1: On"), lo: 0, hi: 1 });
        fields.insert("RX_JITTER_AMPL", Field { brief: Some("Amplitude of jitter for Link-Quality-Evaluation/Jitter-Injection (RX-Path)"), details: None, lo: 8, hi: 18 });
        fields.insert("RX_JI_ENA", Field { brief: Some("Enable RX jitter intertion"), details: Some("0: Off 1:On"), lo: 3, hi: 4 });
        fields.insert("RX_STEP_FREQ", Field { brief: Some("Stepping frequency for Jitter-Injection/Frequency-Offset-Generation (1/2^n) (TX-Path)"), details: None, lo: 4, hi: 8 });
        fields.insert("RX_WAVEFORM_SEL", Field { brief: Some("Select waveform for Jitter-Injection (RX-Path)"), details: Some("0: Triangular 1: Flattened"), lo: 2, hi: 3 });
        regs.insert("SERDES6G_DFT_CFG2", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("SERDES6G DFT Configuration register 2"), details: Some("Configuration register 2 for SERDES6G DFT functions (RX direction)"), fields });
        let mut fields = HashMap::new();
        fields.insert("GP", Field { brief: Some("General purpose bits, reserved for future use."), details: None, lo: 16, hi: 19 });
        fields.insert("SIGDET_AST", Field { brief: Some("Signal detect assertion time"), details: Some("0: 0 us 1: 35 us 2: 70 us 3: 105 us 4: 140 us 5..7: reserved"), lo: 3, hi: 6 });
        fields.insert("SIGDET_DST", Field { brief: Some("Signal detect de-assertion time"), details: Some("0: 0 us 1: 250 us 2: 350 us 3: 450 us 4: 550 us 5..7: reserved"), lo: 0, hi: 3 });
        fields.insert("SIGDET_TESTMODE", Field { brief: Some("Reserved for test purposes. SigDet timer values are divided by 2^6"), details: Some("1: Enable division 0: Normal operation"), lo: 6, hi: 7 });
        fields.insert("TX_BIT_DOUBLING_MODE_ENA", Field { brief: Some("Select bit doubling mode"), details: Some("0: (20 bit) Data word contains two byte constant for 2 UI 1: Every bit is streched to two UI."), lo: 7, hi: 8 });
        regs.insert("SERDES6G_DIG_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("SERDES6G Digital Configuration register"), details: Some("Configuration register for SERDES6G digital functions"), fields });
        let mut fields = HashMap::new();
        fields.insert("DES_100FX_CPMD_ENA", Field { brief: Some("Enable deserializer cp/md handling for 100fx mode"), details: Some("0: Disable 1: Enable"), lo: 8, hi: 9 });
        fields.insert("DES_100FX_CPMD_MODE", Field { brief: Some("Select simple 100fx mode"), details: Some("0: Normal mode 1: Simple mode"), lo: 9, hi: 10 });
        fields.insert("DES_100FX_CPMD_SWAP", Field { brief: Some("Swap cp/md signals in 100fx mode"), details: Some("0: No swapping of cp and md 1: Swap cp and md"), lo: 10, hi: 11 });
        fields.insert("DES_100FX_KICK_MODE", Field { brief: Some("Select mode of kick-out-of-180-degree functionality"), details: None, lo: 11, hi: 13 });
        fields.insert("LANE_RST", Field { brief: Some("Lane Reset"), details: Some("0: No reset 1: Reset (not self-clearing)"), lo: 0, hi: 1 });
        fields.insert("RX_BUS_FLIP_ENA", Field { brief: Some("Enable flipping rx databus (MSB - LSB)"), details: None, lo: 7, hi: 8 });
        fields.insert("RX_DATA_INV_ENA", Field { brief: Some("Enable data inversion received from Deserializer"), details: Some("0: Disable 1: Enable"), lo: 3, hi: 4 });
        fields.insert("RX_LPI_MODE_ENA", Field { brief: Some("Enable RX-Low-Power feature (Power control by LPI-FSM in connected PCS)"), details: Some("0: Disable 1: Enable"), lo: 5, hi: 6 });
        fields.insert("SEL_RECO_CLK", Field { brief: Some("Select recovered clock divider"), details: Some("0: No clock dividing 1: Divide clock by 5 2: Divide clock by 4 3: Reserved"), lo: 13, hi: 15 });
        fields.insert("TX_BUS_FLIP_ENA", Field { brief: Some("Enable flipping tx databus (MSB - LSB)"), details: None, lo: 6, hi: 7 });
        fields.insert("TX_DATA_INV_ENA", Field { brief: Some("Enable data inversion sent to Serializer"), details: Some("0: Disable 1: Enable"), lo: 2, hi: 3 });
        fields.insert("TX_LPI_MODE_ENA", Field { brief: Some("Enable TX-Low-Power feature (Power control by LPI-FSM in connected PCS)"), details: Some("0: Disable 1: Enable"), lo: 4, hi: 5 });
        regs.insert("SERDES6G_MISC_CFG", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("SERDES6G Misc Configuration"), details: Some("Configuration register for miscellaneous functions"), fields });
        let mut fields = HashMap::new();
        fields.insert("PLL_BIST_ENA", Field { brief: Some("Enables the BIST for the RC-PLL"), details: None, lo: 20, hi: 21 });
        fields.insert("PLL_BIST_FBS_HIGH", Field { brief: Some("Feedback divider setting for closed loop test at high frequency. B3: Div4, B2: Ena_rot, B1: Rot_dir, B0: Rot_frq"), details: None, lo: 16, hi: 20 });
        fields.insert("PLL_BIST_HIGH", Field { brief: Some("Higher frequnecy for the RC-PLL BIST"), details: None, lo: 8, hi: 16 });
        fields.insert("PLL_BIST_LOW", Field { brief: Some("Lower frequnecy for the RC-PLL BIST"), details: None, lo: 0, hi: 8 });
        regs.insert("SERDES6G_RC_PLL_BIST_CFG", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("SERDES6G RCPLL BIST Configuration"), details: Some("Configuration register for the 6G RC-PLL BIST"), fields });
        let mut fields = HashMap::new();
        fields.insert("STATIC_PATTERN0", Field { brief: Some("Static pattern tranferred in fixed pattern test mode, LSB is transferred first"), details: None, lo: 0, hi: 20 });
        regs.insert("SERDES6G_TP_CFG0", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("SERDES6G Test Pattern Configuration"), details: Some("Test bits (pattern) for SERDES6G lane. These bits are used when Lane_Test_cfg.Test_mode is set to 2 (fixed pattern)"), fields });
        let mut fields = HashMap::new();
        fields.insert("STATIC_PATTERN1", Field { brief: Some("Static pattern 2nd part only used in 20 bit mode, LSB is transferred first"), details: None, lo: 0, hi: 20 });
        regs.insert("SERDES6G_TP_CFG1", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("SERDES6G Test Pattern Configuration"), details: Some("Test bits (pattern) for SERDES6G lane. These bits are used when Lane_Test_cfg.Test_mode is set to 2 (fixed pattern) and Lane_cfg.hr_mode_ena = '0'. In 20 bit modes bits from static_pattern and static_pattern2 are transmitted alternating."), fields });
        groups.insert("SERDES6G_DIG_CFG", RegisterGroup { addr: Address { base: 59, count: 1, width: 9 }, desc: "SERDES6G Digital Configuration Registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("BIST_ACTIVE", Field { brief: Some("BIST activity"), details: Some("0: BIST inactive 1: BIST active"), lo: 3, hi: 4 });
        fields.insert("BIST_COMPLETE_N", Field { brief: Some("BIST completion state (low-active)"), details: Some("0: BIST completed 1: not completed"), lo: 1, hi: 2 });
        fields.insert("BIST_ERROR", Field { brief: Some("BIST result"), details: Some("0: No error found 1: Errors during BIST found"), lo: 0, hi: 1 });
        fields.insert("BIST_NOSYNC", Field { brief: Some("BIST sync result"), details: Some("0: Synchronization successful 1: Synchronization on BIST data failed"), lo: 2, hi: 3 });
        fields.insert("PLL_BIST_FAILED", Field { brief: Some("RC-PLL BIST result"), details: Some("0: No error found 1: Errors during BIST found"), lo: 6, hi: 7 });
        fields.insert("PLL_BIST_NOT_DONE", Field { brief: Some("RC-PLL BIST not done flag"), details: Some("0: BIST done 1: BIST not started or active"), lo: 7, hi: 8 });
        fields.insert("PLL_BIST_TIMEOUT_ERR", Field { brief: Some("RC-PLL BIST timeout error flag"), details: Some("0: No timeout occured 1: Timeout occured"), lo: 5, hi: 6 });
        fields.insert("PRBS_SYNC_STAT", Field { brief: Some("PRBS synchronization status"), details: Some("0: PRBS checker not synchronized 1: PRBS checker synchronized"), lo: 8, hi: 9 });
        regs.insert("SERDES6G_DFT_STATUS", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("SERDES6G DFT Status"), details: Some("Status register of SERDES6G DFT functions"), fields });
        let mut fields = HashMap::new();
        fields.insert("PRBS_ERR_CNT", Field { brief: Some("PRBS error counter"), details: None, lo: 0, hi: 16 });
        regs.insert("SERDES6G_ERR_CNT", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("SERDES6G Error Counter"), details: Some("Error counter for SERDES6G PRBS"), fields });
        let mut fields = HashMap::new();
        fields.insert("AN_OB_ENA_CAS", Field { brief: Some("ANEG overwrite value for SERDES6G_OB_CFG1.ob_ena_cas"), details: None, lo: 6, hi: 9 });
        fields.insert("AN_OB_LEV", Field { brief: Some("ANEG overwrite value for SERDES6G_OB_CFG1.ob_lev"), details: None, lo: 0, hi: 6 });
        fields.insert("AN_OB_POST0", Field { brief: Some("ANEG overwrite value for SERDES6G_OB_CFG.post0"), details: None, lo: 23, hi: 29 });
        fields.insert("AN_OB_POST1", Field { brief: Some("ANEG overwrite value for SERDES6G_OB_CFG.post1"), details: None, lo: 18, hi: 23 });
        fields.insert("AN_OB_PREC", Field { brief: Some("ANEG overwrite value for SERDES6G_OB_CFG.prec"), details: None, lo: 13, hi: 18 });
        regs.insert("SERDES6G_OB_ANEG_CFG", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("SERDES6G OB ANEG Configuration"), details: Some("Configuration register for ANEG Output Buffer overwrite parameter. The values are used during Backplane Ethernet Auto-Negotiation when the output level of transmitter (OB output) have to be reduced."), fields });
        groups.insert("SERDES6G_DIG_STATUS", RegisterGroup { addr: Address { base: 68, count: 1, width: 3 }, desc: "SERDES6G Digital Status Register", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("BUSY", Field { brief: Some("Resistor comparison activity"), details: Some("0: resistor measurement finished or inactive 1: resistor measurement in progress"), lo: 12, hi: 13 });
        fields.insert("DELTA_ALERT", Field { brief: Some("Alarm signal if rcomp isn't best choice anymore"), details: Some("0: inactive 1: active"), lo: 7, hi: 8 });
        fields.insert("RCOMP", Field { brief: Some("Measured resistor value"), details: Some("0: maximum resistance value 15: minimum resistance value"), lo: 0, hi: 4 });
        regs.insert("RCOMP_STATUS", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("RCOMP Status"), details: Some("Status register bits for the RCOMP"), fields });
        let mut fields = HashMap::new();
        fields.insert("RECO_CLK_ENA", Field { brief: Some("Set to enable recovered clock pad"), details: Some("0: Disable (high-impedance) 1: Enable (output recovered clock)"), lo: 0, hi: 1 });
        fields.insert("SEL_RECO_CLK_DIV", Field { brief: Some("Select recovered clock divider."), details: Some("0: No clock dividing 1: Divide clock by 5 2: Divide clock by 4 3: Reserved"), lo: 1, hi: 3 });
        fields.insert("SEL_RECO_CLK_SRC", Field { brief: Some("Select recovered clock source."), details: Some("0 through 8: Select SD1G 0 through 8. 9 through 24: Select SD6G 0 through 15. 25 through 28: Select SD10G 0 through 3. 29 through 36: Select SD6G 16 through 23. 37 selects LCPLL2 CPU clock output. Other values are reserved."), lo: 3, hi: 9 });
        regs.insert("SYNC_ETH_CFG", Register { addr: Address { base: 0, count: 4, width: 1 }, brief: Some("SYNC ETH Configuration"), details: Some("This register is replicated once per recovered clock output."), fields });
        let mut fields = HashMap::new();
        fields.insert("CPU_CLK_DIV", Field { brief: Some("This field is used instead of HSIO::PLL5G_CFG0.CPU_CLK_DIV for the PLL number 2."), details: None, lo: 2, hi: 8 });
        fields.insert("PLL2_AUTO_SQUELCH_ENA", Field { brief: Some("Enable auto-squelching for sync. ethernet clock output: when set the clock output will stop toggling (keep its last value constantly) when PLL is out of lock."), details: None, lo: 0, hi: 1 });
        fields.insert("PLL2_RECO_CLK_DIV", Field { brief: Some("Divider setting for the PLL number 2's recovered clock output. These settings are applied prior to sending recovered clock to the optional PAD-divder (see HSIO::SYNC_ETH_CFG.SEL_RECO_CLK_DIV.)"), details: Some("0: No clock dividing 1: Divide clock by 2"), lo: 1, hi: 2 });
        regs.insert("SYNC_ETH_PLL2_CFG", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Configuration of recovered clock from 2'nd PLL"), details: None, fields });
        groups.insert("SYNC_ETH_CFG", RegisterGroup { addr: Address { base: 34, count: 1, width: 9 }, desc: "SYNC_ETH Configuration Registers", regs });
        out.insert("HSIO", Target { desc: "Register Collection for Control of Macros (SERDES1G, SERDES6G, LCPLL)", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("BOOT_MODE_ENA", Field { brief: Some("Use this field to change from Boot mode to Normal mode. In Boot mode, the reset vector of the VCore CPU maps to CS0 on the FLASH interface. When in Normal mode, this address maps instead to the DRAM Controller. The DRAM Controller must be operational before disabling Boot mode. After setting Boot mode, this register must be read back. The change in Boot mode takes effect during read."), details: Some("0: The VCore memory map is in Normal mode. 1: The VCore memory map is in Boot mode."), lo: 0, hi: 1 });
        fields.insert("CPU_8051_IROM_ENA", Field { brief: Some("The default value of this field depends on strapping of the VCore. Set this field to make the 8051 boot from internal ROM image, the purpose of this boot-mode is implementing simple startup procedure for chips w.o. internal CPU running."), details: None, lo: 13, hi: 14 });
        fields.insert("CPU_BE_ENA", Field { brief: Some("The default value of this field depends on strapping of the VCore. Set this field to force the MIPS VCore CPU into Big-Endian mode."), details: None, lo: 2, hi: 3 });
        fields.insert("CPU_BUSIF_SLEEP_DIS", Field { brief: Some("Set this field to disable sleep of the VCore CPU bus interface."), details: None, lo: 15, hi: 16 });
        fields.insert("CPU_BUSIF_WERR_ENA", Field { brief: Some("Set this field to enable interrupt from the VCore CPU bus interface in case of write errors on the internal bus. Clear this field to clear pending write-error interrupts (then reenable field to receive new interrupts)."), details: None, lo: 14, hi: 15 });
        fields.insert("CPU_DIS", Field { brief: Some("The default value of this field depends on strapping of the VCore. Clear this field to allow booting of the VCore CPU, while this field is set the VCore CPU is held in reset."), details: Some("0: VCore CPU is allowed to boot 1: VCore CPU is forced in reset"), lo: 1, hi: 2 });
        fields.insert("CPU_MIPS_DIS", Field { brief: Some("Set this field to disable the MIPS core (and instead enable 8051)."), details: None, lo: 12, hi: 13 });
        fields.insert("IF_MIIM_SLV_ENA", Field { brief: Some("The default value of this field depends on strapping of the VCore. Set this field to enable the MIIM slave-interface on the GPIOs."), details: None, lo: 11, hi: 12 });
        fields.insert("IF_PI_MST_ENA", Field { brief: Some("The default value of this field depends on strapping of the VCore. Set this field to force PI interfaces into master mode (and enable PI on GPIOs)."), details: None, lo: 9, hi: 10 });
        fields.insert("IF_PI_SLV_DONEPOL", Field { brief: Some("The default value of this field depends on strapping of the VCore (the PI_nDone signal)."), details: None, lo: 10, hi: 11 });
        fields.insert("IF_PI_SLV_ENA", Field { brief: Some("The default value of this field depends on strapping of the VCore. Set this field to force PI interfaces into slave mode (and enable PI on GPIOs)."), details: None, lo: 8, hi: 9 });
        fields.insert("IF_SI1_OWNER", Field { brief: Some("Select the owner of the GPIO overlaid SI interface."), details: Some("0: SI Slave 1: SI Boot Master 2: SI Master Controller"), lo: 4, hi: 6 });
        fields.insert("IF_SI_OWNER", Field { brief: Some("The default value of this field depends on strapping of the VCore. Select the owner of the SI interface."), details: Some("0: SI Slave 1: SI Boot Master 2: SI Master Controller"), lo: 6, hi: 8 });
        fields.insert("SIMC_SSP_ENA", Field { brief: Some("Set this field when enabling SI Master Controller for SSP protocol. See SIMC::CTRLR0.FRF for more information."), details: None, lo: 3, hi: 4 });
        regs.insert("GENERAL_CTRL", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("General control"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("GPR", Field { brief: Some("General purpose 8 times 32-bit registers for software development and debug. Note: This register is only reset by the device's reset input, i.e. it is not affected by soft reset!"), details: None, lo: 0, hi: 32 });
        regs.insert("GPR", Register { addr: Address { base: 0, count: 8, width: 1 }, brief: Some("General Purpose Register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CORE_RST_CPU_ONLY", Field { brief: Some("Set this field to enable VCore System reset protection. It is possible to protect the VCore System from soft-reset (issued via RESET.CORE_RST_FORCE) and watchdog-timeout. When this field is set the aforementioned resets only reset the VCore CPU, not the VCore System."), details: Some("0: Soft-reset and WDT-event and reset entire VCore 1: Soft-reset and WDT-event only reset the VCore CPU"), lo: 3, hi: 4 });
        fields.insert("CORE_RST_FORCE", Field { brief: Some("Set this field to generate a soft reset for the VCore. This field will be cleared when the reset has taken effect. It is possible to protect the VCore system (everyhing else than the VCore CPU) from reset via  RESET.CORE_RST_CPU_ONLY."), details: Some("0: VCore is not reset 1: Initiate soft reset of the VCore"), lo: 1, hi: 2 });
        fields.insert("CORE_RST_PROTECT", Field { brief: Some("Set this field to enable VCore reset protection. It is possible to protect the entire VCore from chip-level soft-reset (issued via DEVCPU_GCB::SOFT_RST.SOFT_CHIP_RST). Setting this field does not protect agains hard-reset of the chip (by asserting the reset pin)."), details: Some("0: No reset protection 1: VCore is protected from chip-level-soft-reset"), lo: 2, hi: 3 });
        fields.insert("MEM_RST_FORCE", Field { brief: Some("Clear this field to release the DDR2/3 controller from reset."), details: Some("0: Memory controller is not reset 1: Memory controller is forced in reset"), lo: 0, hi: 1 });
        regs.insert("RESET", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("Reset Settings"), details: None, fields });
        groups.insert("CPU_SYSTEM_CTRL", RegisterGroup { addr: Address { base: 0, count: 1, width: 11 }, desc: "Configurations for the CPU system.", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CH_ACTIVATE", Field { brief: Some("Enables specific FDMA channels, there is one bit per channel. Setting a bit in this field will clear a corresponding pending ICPU_CFG::FDMA_CH_DISABLE.CH_DISABLE request. Bits in this field are cleared immediately when set."), details: None, lo: 0, hi: 10 });
        regs.insert("FDMA_CH_ACTIVATE", Register { addr: Address { base: 52, count: 1, width: 1 }, brief: Some("Activate specific channels"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CH_INJ_GRP", Field { brief: Some("This field is only applicable to injection channels. Use this field to map the injection channel to an injection group."), details: None, lo: 6, hi: 7 });
        fields.insert("CH_PRIO", Field { brief: Some("The FDMA implements a strict priority scheme between all channels - both injection and extraction. Observe: The FDMA does not directly control the order in which ports are serviced in the Queuing System. In order to adjust for this (and to avoid head of line blocking) all extraction channels are automatically assigned the highest priority of the extraction channels with available data. If multiple channels are configured with equal priorities then the following strict scheme is in place: Higher channel number takes priority over lower channel number. This implies that injection takes priority over extraction."), details: None, lo: 2, hi: 6 });
        fields.insert("DONEEOF_STOP_ENA", Field { brief: Some("Set this field to automatically disable the channel after completing any DCB with EOF indication. The channel will disable after saving DCB status. An LLP-event will be generated at the same time as the channel is disabled. Be careful when using this feature, extraction channels may head-of-line block other extraction channels if not immediately re-activated."), details: None, lo: 0, hi: 1 });
        fields.insert("DONE_STOP_ENA", Field { brief: Some("Set this field to automatically disable the channel after completing any DCB. The channel will disable after saving DCB status. An LLP-event will be generated at the same time as the channel is disabled. Be careful when using this feature, extraction channels may head-of-line block other extraction channels if not immediately re-activated."), details: None, lo: 1, hi: 2 });
        fields.insert("STAT_IN_DATA_ENA", Field { brief: Some("When this field is set the FDMA will save the STAT-word to the DATAP-address instead of the DCB's STAT-word position. The DCB's DATAP field will be incremented by 4 (bytes) when the DCB is loaded (the FDMA will continue as if the DATAP field was DATAP+4). This feature is meant to be used for channels that extract or inject from PCIe mapped memory. The ICPU_CFG::FDMA_DCB_LLP_PREV field is repurposed as DATAP pointer and can no longer be used when this field is set."), details: None, lo: 7, hi: 8 });
        regs.insert("FDMA_CH_CFG", Register { addr: Address { base: 99, count: 10, width: 1 }, brief: Some("Channel specific configurations"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CH_CNT_DCB", Field { brief: Some("This field is incremented every time the channel loads a DCB. This counter can be modified safely while the corresponding channel is safe (see ICPU_CFG::FDMA_CH_SAFE.CH_SAFE for more information)."), details: None, lo: 8, hi: 16 });
        fields.insert("CH_CNT_FRM", Field { brief: Some("This field is incremented every time the channel saves status for a DCB that has EOF. This counter can only be modified safely when the corresponding channel is disabled (see ICPU_CFG::FDMA_CH_STAT.CH_STAT for more information)."), details: None, lo: 16, hi: 32 });
        fields.insert("CH_CNT_SIG", Field { brief: Some("This field is incremented every time the channel loads a DCB that has the SIG field set. The FDMA can generate interrupt whenever this counter is incremented (see ICPU_CFG::FDMA_INTR_SIG.INTR_SIG for more information). This counter can be modified safely while the corresponding channel is safe (see ICPU_CFG::FDMA_CH_SAFE.CH_SAFE for more information)."), details: None, lo: 0, hi: 8 });
        regs.insert("FDMA_CH_CNT", Register { addr: Address { base: 55, count: 10, width: 1 }, brief: Some("Channel counters"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CH_DISABLE", Field { brief: Some("Schedules specific FDMA channels to be disabled, there is one bit per channel. The channel will finish the current DCB and then disable (after writing the DCB status word). Bits in this field is cleared either when the channel disables or by writing ICPU_CFG::FDMA_CH_ACTIVATE.CH_ACTIVATE)."), details: None, lo: 0, hi: 10 });
        regs.insert("FDMA_CH_DISABLE", Register { addr: Address { base: 53, count: 1, width: 1 }, brief: Some("Disable specific channels"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CH_FORCEDIS", Field { brief: Some("Immediately disable specific FDMA channels, there is one bit per channel. Unlike ICPU_CFG::FDMA_CH_DISABLE using CH_FORCEDIS will not take the state of the channel into account, if the channel is actively extracting or injecting from/to QS there is no guarantee that it will be functional after disabling the channel."), details: None, lo: 0, hi: 10 });
        regs.insert("FDMA_CH_FORCEDIS", Register { addr: Address { base: 54, count: 1, width: 1 }, brief: Some("Ungraceful disable of specific channels"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CH_INJ_TOKEN_CNT", Field { brief: Some("Every time a channel activates with a DCB that has the TOKEN field set this counter is decremented by one. Channels that loads a DCB with the TOKEN field set cannot activate unless this counter is different from zero. This counter can be writen by software, or incremented automatically by using the token tick counter (see ICPU_CFG::FDMA_CH_INJ_TOKEN_TICK_CNT for more information). This counter can be modified safely when automatic incrementing is not enabled and the corresponding injection channel is in safe mode (see ICPU_CFG::FDMA_CH_INJ_TOKEN_CNT and ICPU_CFG::FDMA_CH_SAFE.CH_SAFE for more information)."), details: None, lo: 0, hi: 8 });
        regs.insert("FDMA_CH_INJ_TOKEN_CNT", Register { addr: Address { base: 65, count: 8, width: 1 }, brief: Some("Injection channel token counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CH_INJ_TOKEN_TICK_CNT", Field { brief: Some("Down-counter, when enabled by ICPU_CFG::FDMA_CH_INJ_TOKEN_TICK_RLD this field is decremented by one every 200ns. When zero is reached one token will be added to ICPU_CFG::FDMA_CH_INJ_TOKEN_CNT and this counted will load the value from ICPU_CFG::FDMA_CH_INJ_TOKEN_TICK_RLD (subtract one and continue decrementing from that value)."), details: None, lo: 0, hi: 32 });
        regs.insert("FDMA_CH_INJ_TOKEN_TICK_CNT", Register { addr: Address { base: 81, count: 8, width: 1 }, brief: Some("Injection channel token tick counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CH_INJ_TOKEN_TICK_RLD", Field { brief: Some("Automatic incrementing of the token counter is enabled by setting this field different from 0. This field holds the reload value for the ICPU_CFG::FDMA_CH_INJ_TOKEN_TICK_CNT. Note: When changing the value of this field the same value should also be written to the ICPU_CH_INJ_TOKEN_TICK_CNT field, this is needed for speeding up token counter increments when changing from a high reload value to a low reload value."), details: Some("0: Token tick counter is disabled n: Add one token every n * 200ns clock cycles"), lo: 0, hi: 32 });
        regs.insert("FDMA_CH_INJ_TOKEN_TICK_RLD", Register { addr: Address { base: 73, count: 8, width: 1 }, brief: Some("Injection channel token tick counter reload value"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CH_SAFE", Field { brief: Some("When set it is safe for software to read/modify/write ICPU_CFG::FDMA_DCB_LLP.LLP, ICPU_CFG::FDMA_CH_CNT.CH_CNT_SIG, ICPU_CFG::FDMA_CH_CNT.CH_CNT_DCB, and ICPU_CFG::FDMA_CH_INJ_TOKEN_CNT.CH_INJ_TOKEN_CNT. There is one bit per channel. This field is set when a channel is a) disabled or b) active and scheduled for disabling."), details: None, lo: 0, hi: 10 });
        regs.insert("FDMA_CH_SAFE", Register { addr: Address { base: 51, count: 1, width: 1 }, brief: Some("Current channel safe-status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CH_STAT", Field { brief: Some("Shows status for all FDMA channels, there is one bit per channel."), details: Some("0:Disabled 1:Updating, or Active"), lo: 0, hi: 10 });
        regs.insert("FDMA_CH_STAT", Register { addr: Address { base: 50, count: 1, width: 1 }, brief: Some("Current channel status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DATAL", Field { brief: Some("For debug, current data-length."), details: None, lo: 0, hi: 16 });
        fields.insert("TOKEN", Field { brief: Some("For debug, current token-indication."), details: None, lo: 17, hi: 18 });
        regs.insert("FDMA_DCB_DATAL", Register { addr: Address { base: 20, count: 10, width: 1 }, brief: Some("Length of data block"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DATAP", Field { brief: Some("For debug, current data-pointer."), details: None, lo: 0, hi: 32 });
        regs.insert("FDMA_DCB_DATAP", Register { addr: Address { base: 10, count: 10, width: 1 }, brief: Some("Pointer to data block"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LLP", Field { brief: Some("This field is used by the FDMA for tracking lists of DCBs. This field is updated automatically when the FDMA load DCBs from memory. This field can only be modified when the channel is in safe mode, see ICPU_CFG::FDMA_CH_SAFE.CH_SAFE for more information."), details: None, lo: 0, hi: 32 });
        regs.insert("FDMA_DCB_LLP", Register { addr: Address { base: 0, count: 10, width: 1 }, brief: Some("Pointer to next DCB"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LLP_PREV", Field { brief: Some("This field holds the pointer to current DCB (the previous ICPU_CFG::FDMA_DCB_LLP.LLP)."), details: None, lo: 2, hi: 32 });
        regs.insert("FDMA_DCB_LLP_PREV", Register { addr: Address { base: 40, count: 10, width: 1 }, brief: Some("Pointer to current DCB"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ABORT", Field { brief: Some("Abort indication."), details: None, lo: 18, hi: 19 });
        fields.insert("BLOCKL", Field { brief: Some("Block size in bytes, excluding offset (as specified in ICPU_CFG::FDMA_DCB_STAT.BLOCKO). For frames that span multiple DCBs, this field only shows the amount of data in the current DCB."), details: None, lo: 0, hi: 16 });
        fields.insert("BLOCKO", Field { brief: Some("Block offset in bytes, the value of this field is loaded from the DCB."), details: None, lo: 20, hi: 32 });
        fields.insert("EOF", Field { brief: Some("Set when the current DCB contains end-of-frame."), details: None, lo: 17, hi: 18 });
        fields.insert("PD", Field { brief: Some("Pruned/Done indication."), details: None, lo: 19, hi: 20 });
        fields.insert("SOF", Field { brief: Some("Set when the current DCB contains start-of-frame."), details: None, lo: 16, hi: 17 });
        regs.insert("FDMA_DCB_STAT", Register { addr: Address { base: 30, count: 10, width: 1 }, brief: Some("Status word"), details: Some("This register is updated by the FDMA during extraction or injection. Software cannot rely on the value of this register."), fields });
        let mut fields = HashMap::new();
        fields.insert("EVT_ERR", Field { brief: Some("Shows if an Error-event has occurred, there is one bit per channel. See ICPU_CFG::FDMA_EVT_ERR_CODE.EVT_ERR_CODE for description of errors for which the FDMA implements run-time checks."), details: None, lo: 0, hi: 10 });
        regs.insert("FDMA_EVT_ERR", Register { addr: Address { base: 89, count: 1, width: 1 }, brief: Some("Error event"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("EVT_ERR_CODE", Field { brief: Some("This field shows information about Error-events that has been recorded by the FDMA, this can be used for software development and debugging. If multiple errors happen in succession, only the newest of the err-codes is shown."), details: Some("0:Default (no error has occurred) 1:CH_ACTIVATE set for channel w. DCB_LLP==NULL 2:Got DCB w. DATAP==NULL 3:Got extraction DCB w. DATAL==0 4:Got extraction DCB w. DATAL<=BLOCKO 5:Got injection DCB w. BLOCKL==0 6:Got injection DCB w. SOF for already active channel 7:Activate attempted for channel w. error indication. 8:Activate attempted for channel enabled for manual mode. 9:Manual mode enabled for channel in active FDMA mode."), lo: 0, hi: 4 });
        regs.insert("FDMA_EVT_ERR_CODE", Register { addr: Address { base: 90, count: 1, width: 1 }, brief: Some("Additional error information"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INJ_RF_WM", Field { brief: Some("Injection resync FIFO fill-level watermark, when exceeded backpressure will be asserted towards SBA. The maximum fill-level for the FIFO is reported via ICPU_CFG::FDMA_GSTAT.INJ_RF_HIGH."), details: Some("n: backpressure when n+1 or more words in buffer."), lo: 7, hi: 12 });
        fields.insert("PD_IGNORE", Field { brief: Some("Set this field to make the FDMA ignore the value of the DCB's PD field when injecting frames. By default the FDMA will treat the PD field in the same way as ABORT."), details: None, lo: 0, hi: 1 });
        fields.insert("XTR_AVAIL_EXT_DIS", Field { brief: Some("Set this field to disable extending of data available indications in the extraction direction of the FDMA."), details: None, lo: 2, hi: 3 });
        fields.insert("XTR_PRIO_BP_DIS", Field { brief: Some("Set this field to disable extraction group backpressure based on priorities of groups that has data available. By default the FDMA will assert backpressure on low priority extraction channels when a higher priority channel has data available."), details: None, lo: 1, hi: 2 });
        fields.insert("XTR_RF_WM", Field { brief: Some("Extraction resync fifo fill-level watermark, when exceeded backpressure will be asserted towards towards QS. The maximum fill-level for the fifo is reported via ICPU_CFG::FDMA_GSTAT.XTR_RF_HIGH. This field must not be modified at the same time as frames are extracted through the FDMA."), details: Some("n: backpressure when n+1 or more words in buffer."), lo: 3, hi: 7 });
        regs.insert("FDMA_GCFG", Register { addr: Address { base: 109, count: 1, width: 1 }, brief: Some("General FDMA configurations"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INJ_RF_HIGH", Field { brief: Some("This field shows the highest fill level that the injection resync FIFO has experienced since reset of the injection logic. The depth of the FIFO is 32 words, reaching a fill-level of 33 (or more) means that overflow has occurred."), details: None, lo: 5, hi: 11 });
        fields.insert("XTR_RF_HIGH", Field { brief: Some("This field shows the highest fill level that the extraction resync FIFO has experienced since reset of the extraction logic. The depth of the FIFO is 16 words, reaching a fill-level of 17 (or more) means that overflow has occurred. This field is read directly from other clock-domain; software must keep reading this field until same value has been returned by two consecutive read accesses."), details: None, lo: 0, hi: 5 });
        regs.insert("FDMA_GSTAT", Register { addr: Address { base: 110, count: 1, width: 1 }, brief: Some("General FDMA status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("IDLECNT", Field { brief: Some("The counter is reset whenever a channel is enabled and when FDMA moves frame data to or from the queuing system. When the FDMA is idle this counter is incremented once every 200ns. The counter saturates at maximum value (approx 3.3 seconds of idle time)."), details: None, lo: 0, hi: 24 });
        regs.insert("FDMA_IDLECNT", Register { addr: Address { base: 111, count: 1, width: 1 }, brief: Some("FDMA idle Counter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INTR_ENA", Field { brief: Some("Enables propagation of enabled channel LLP-event, FRM-event and SIG-event as interrupt, there is one bit per channel. ERR-events are always propagated when interrupt is enabled for a channel."), details: None, lo: 0, hi: 10 });
        regs.insert("FDMA_INTR_ENA", Register { addr: Address { base: 97, count: 1, width: 1 }, brief: Some("Channel interrupt enable"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INTR_FRM", Field { brief: Some("Shows if a FRM-event has occurred, there is one bit per channel. See the data sheet for information on when this event can occur."), details: None, lo: 0, hi: 10 });
        regs.insert("FDMA_INTR_FRM", Register { addr: Address { base: 93, count: 1, width: 1 }, brief: Some("FRM-event"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INTR_FRM_ENA", Field { brief: Some("Enables FRM-event to be propagated as interrupt, there is one bit per channel. See ICPU_CFG::FDMA_INTR_FRM.INTR_FRM for additional information."), details: None, lo: 0, hi: 10 });
        regs.insert("FDMA_INTR_FRM_ENA", Register { addr: Address { base: 94, count: 1, width: 1 }, brief: Some("FRM-event interrupt enable"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INTR_IDENT", Field { brief: Some("Shows currently interrupting channels, there is one bit per channel."), details: None, lo: 0, hi: 10 });
        regs.insert("FDMA_INTR_IDENT", Register { addr: Address { base: 98, count: 1, width: 1 }, brief: Some("Currently interrupting channels"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INTR_LLP", Field { brief: Some("Shows if an LLP-event has occurred, there is one bit per channel. See the data sheet for information on when this event can occur."), details: None, lo: 0, hi: 10 });
        regs.insert("FDMA_INTR_LLP", Register { addr: Address { base: 91, count: 1, width: 1 }, brief: Some("LLP-event"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INTR_LLP_ENA", Field { brief: Some("Enables LLP-event to be propagated as interrupt, there is one bit per channel. See ICPU_CFG::FDMA_INTR_LLP.INTR_LLP for additional information."), details: None, lo: 0, hi: 10 });
        regs.insert("FDMA_INTR_LLP_ENA", Register { addr: Address { base: 92, count: 1, width: 1 }, brief: Some("LLP-event interrupt enable"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INTR_SIG", Field { brief: Some("Shows if a SIG-event has occurred, there is one bit per channel. See the data sheet for information on when this event can occur."), details: None, lo: 0, hi: 10 });
        regs.insert("FDMA_INTR_SIG", Register { addr: Address { base: 95, count: 1, width: 1 }, brief: Some("SIG-event"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INTR_SIG_ENA", Field { brief: Some("Enables SIG-event to be propagated as interrupt, there is one bit per channel. See ICPU_CFG::FDMA_INTR_SIG.INTR_SIG for additional information."), details: None, lo: 0, hi: 10 });
        regs.insert("FDMA_INTR_SIG_ENA", Register { addr: Address { base: 96, count: 1, width: 1 }, brief: Some("SIG-event interrupt enable"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SPIKE_FILTER_CFG", Field { brief: Some("Configuration of the spike filter width on the SCL and SDA inputs. Filters spikes with a width of (SPIKE_FILTER_CFG+1)*SYSTEM_CLK or less."), details: None, lo: 0, hi: 5 });
        regs.insert("TWI_SPIKE_FILTER_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("TWI spike filter configuration"), details: None, fields });
        groups.insert("FDMA", RegisterGroup { addr: Address { base: 112, count: 1, width: 113 }, desc: "Frame DMA", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("DEV_INTR_BYPASS", Field { brief: Some("This register allows bypass of ICPU_CFG::DEV_INTR_STICKY for individual device interrupt sources. When a device interrupt source is in bypass mode then ICPU_CFG::DEV_INTR_RAW is used instead of ICPU_CFG::DEV_INTR_STICKY. See note on bypass in ICPU_CFG::INTR_BYPASS."), details: None, lo: 0, hi: 32 });
        regs.insert("DEV_INTR_BYPASS", Register { addr: Address { base: 31, count: 1, width: 1 }, brief: Some("Device interrupt bypass enable"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DEV_INTR_BYPASS1", Field { brief: Some("See ICPU_CFG::DEV_INTR_BYPASS for description, this register holds bits above 32."), details: None, lo: 0, hi: 21 });
        regs.insert("DEV_INTR_BYPASS1", Register { addr: Address { base: 32, count: 1, width: 1 }, brief: Some("Device interrupt bypass enable"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DEV_INTR_ENA", Field { brief: Some("Set to enable propagation of individual device interrupt sources to the main interrupt controller."), details: None, lo: 0, hi: 32 });
        regs.insert("DEV_INTR_ENA", Register { addr: Address { base: 33, count: 1, width: 1 }, brief: Some("Device interrupt enable"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DEV_INTR_ENA1", Field { brief: Some("See ICPU_CFG::DEV_INTR_ENA for description, this register holds bits above 32."), details: None, lo: 0, hi: 21 });
        regs.insert("DEV_INTR_ENA1", Register { addr: Address { base: 34, count: 1, width: 1 }, brief: Some("Device interrupt enable"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DEV_INTR_IDENT", Field { brief: Some("Shows the currently active interrupt sources. For interrupt sources that are not bypassed this register is a result of AND'ing ICPU_CFG::DEV_INTR_STICKY with ICPU_CFG::DEV_INTR_ENA."), details: None, lo: 0, hi: 32 });
        regs.insert("DEV_INTR_IDENT", Register { addr: Address { base: 35, count: 1, width: 1 }, brief: Some("Currently active device interrupts"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DEV_INTR_POL", Field { brief: Some("Set individual bits in this register to configure polarity of the corresponding device interrupt."), details: Some("0: Device interrupt is active low 1: Device interrupt is active high"), lo: 0, hi: 32 });
        regs.insert("DEV_INTR_POL", Register { addr: Address { base: 21, count: 1, width: 1 }, brief: Some("Device interrupt polarity"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DEV_INTR_POL1", Field { brief: Some("See ICPU_CFG::DEV_INTR_POL for description, this register holds bits above 32."), details: None, lo: 0, hi: 21 });
        regs.insert("DEV_INTR_POL1", Register { addr: Address { base: 22, count: 1, width: 1 }, brief: Some("Device interrupt polarity"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DEV_INTR_RAW", Field { brief: Some("Shows the current value of individual device interrupt sources. All sources are active high (sources have been corrected for polarity as configured in ICPU_CFG::DEV_INTR_POL)."), details: None, lo: 0, hi: 32 });
        regs.insert("DEV_INTR_RAW", Register { addr: Address { base: 23, count: 1, width: 1 }, brief: Some("Device interrupt raw status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DEV_INTR_RAW1", Field { brief: Some("See ICPU_CFG::DEV_INTR_RAW for description, this register holds bits above 32."), details: None, lo: 0, hi: 21 });
        regs.insert("DEV_INTR_RAW1", Register { addr: Address { base: 24, count: 1, width: 1 }, brief: Some("Device interrupt raw status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DEV_INTR_STICKY", Field { brief: Some("This register is set based on device interrupt sourec events. See ICPU_CFG::DEV_INTR_TRIGGER for more information. Bits in this register remains set until cleared by software."), details: None, lo: 0, hi: 32 });
        regs.insert("DEV_INTR_STICKY", Register { addr: Address { base: 29, count: 1, width: 1 }, brief: Some("Device interrupt sticky status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DEV_INTR_STICKY1", Field { brief: Some("See ICPU_CFG::DEV_INTR_STICKY for description, this register holds bits above 32."), details: None, lo: 0, hi: 21 });
        regs.insert("DEV_INTR_STICKY1", Register { addr: Address { base: 30, count: 1, width: 1 }, brief: Some("Device interrupt sticky status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DEV_INTR_TRIGGER", Field { brief: Some("Configure trigger mode of individual device interrupt sources. The trigger mode determines how the value of the ICPU_CFG::DEV_INTR_RAW register is transfered to the ICPU_CFG::DEV_INTR_STICKY register. This register is replicated, the first replication controls bit 0 in the encoding, the second replication controls bit 1 in the encoding. I.e. to configure edge-triggered interrupt for device 3; set ICPU_CFG::DEV_INTR_TRIGGER[0][3]='1' and ICPU_CFG::DEV_INTR_TRIGGER[1][3]='0'. For level-triggered interrupts ICPU_CFG::DEV_INTR_STICKY is set for as long as the corresponding bit in ICPU_CFG::DEV_INTR_RAW is high - i.e. is not possible to clear a bit in ICPU_CFG::DEV_INTR_STICKY until the corresponding ICPU_CFG::DEV_INTR_RAW is zero. For edge-triggeded interrupts ICPU_CFG::DEV_INTR_STICKY is set when the corresponding bit in ICPU_CFG::DEV_INTR_RAW changes value. For falling-edge-triggeded interrupts ICPU_CFG::DEV_INTR_STICKY is set when the corresponding bit in ICPU_CFG::DEV_INTR_RAW changes from '1' to '0'. For rising-edge-triggeded interrupts ICPU_CFG::DEV_INTR_STICKY is set when the corresponding bit in ICPU_CFG::DEV_INTR_RAW changes from '0' to '1'."), details: Some("0: Interrupt is level-activated 1: Interrupt is edge-triggered 2: Interrupt is falling-edge-triggered 3: Interrupt is rising-edge-triggered"), lo: 0, hi: 32 });
        regs.insert("DEV_INTR_TRIGGER", Register { addr: Address { base: 25, count: 2, width: 1 }, brief: Some("Device interrupt trigger mode"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DEV_INTR_TRIGGER1", Field { brief: Some("See ICPU_CFG::DEV_INTR_TRIGGER for description, this register holds bits above 32."), details: None, lo: 0, hi: 21 });
        regs.insert("DEV_INTR_TRIGGER1", Register { addr: Address { base: 27, count: 2, width: 1 }, brief: Some("Device interrupt trigger mode"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DST_INTR_IDENT", Field { brief: Some("Shows the currently active interrupt sources per destination interrupt. The contents of this register is equal to ICPU_CFG::INTR_IDENT AND'ed with the corresponding ICPU_CFG::DST_INTR_MAP. If any bit is set in this register the corresponding destination interrupt is asserted."), details: None, lo: 0, hi: 29 });
        regs.insert("DST_INTR_IDENT", Register { addr: Address { base: 14, count: 4, width: 1 }, brief: Some("Currently active interrupt sources per destination"), details: Some("Replicated per destination interrupt."), fields });
        let mut fields = HashMap::new();
        fields.insert("DST_INTR_MAP", Field { brief: Some("Set to enable mapping of individual interrupt sources to interrupt destinations. This register is replicated once for each destination interrupt."), details: None, lo: 0, hi: 29 });
        regs.insert("DST_INTR_MAP", Register { addr: Address { base: 10, count: 4, width: 1 }, brief: Some("Mapping of source to destination interrupts"), details: Some("Replicated per destination interrupt."), fields });
        let mut fields = HashMap::new();
        fields.insert("EXT_DST_INTR_DRV", Field { brief: Some("This register configures drive mode of the corresponding external destination interrupt."), details: Some("0: Only drive external interrupt output when asserted (tristate when inactive) 1: External interrupt output is always driven"), lo: 0, hi: 2 });
        regs.insert("EXT_DST_INTR_DRV", Register { addr: Address { base: 20, count: 1, width: 1 }, brief: Some("External interrupt destination output drive mode"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("EXT_DST_INTR_POL", Field { brief: Some("Set individual bits in this register to configure polarity of the corresponding external destination interrupt."), details: Some("0: External interrupt output is active low 1: External interrupt output is active high"), lo: 0, hi: 2 });
        regs.insert("EXT_DST_INTR_POL", Register { addr: Address { base: 19, count: 1, width: 1 }, brief: Some("External destination interrupt polarity"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("EXT_SRC_INTR_POL", Field { brief: Some("Set individual bits in this register to configure polarity of the corresponding external source interrupt."), details: Some("0: External interrupt input is active low 1: External interrupt input is active high"), lo: 0, hi: 2 });
        regs.insert("EXT_SRC_INTR_POL", Register { addr: Address { base: 18, count: 1, width: 1 }, brief: Some("External source interrupt polarity"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INTR_BYPASS", Field { brief: Some("This register allows bypass of ICPU_CFG::INTR_STICKY for individual interrupt sources. When an interrupt source is in bypass mode then ICPU_CFG::INTR_RAW is used instead of ICPU_CFG::INTR_STICKY. Note: Enabling bypass does not make sense for all interrupt sources. It should only be used when the corresponding interrupt is sticky at the soruce. For example manual extraction data available interrupts can be configured to bypass, because the interrupt will remain asserted until the available data has been extracted. Note: The device interrupt is bypassed per default, \"stickyness\" is already implemented by ICPU_CFG::DEV_INTR_STICKY."), details: None, lo: 0, hi: 29 });
        regs.insert("INTR_BYPASS", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Interrupt bypass enable"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INTR_ENA", Field { brief: Some("Set to enable propagation of individual interrupt sources to destinations. Atomic access to this register (needed in a multithreaded system) can be implemented by the ICPU_CFG::INTR_ENA_CLR and ICPU_CFG::INTR_ENA_SET registers."), details: None, lo: 0, hi: 29 });
        regs.insert("INTR_ENA", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Interrupt enable"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INTR_ENA_CLR", Field { brief: Some("Set bit(s) in this register to clear the corresponding bits in ICPU_CFG::INTR_ENA. This register can be used for atomic access to ICPU_CFG::INTR_ENA register."), details: None, lo: 0, hi: 29 });
        regs.insert("INTR_ENA_CLR", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Atomic clear of interrupt enable"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INTR_ENA_SET", Field { brief: Some("Set bit(s) in this register to set the corresponding bits in ICPU_CFG::INTR_ENA. This register can be used for atomic access to ICPU_CFG::INTR_ENA register."), details: None, lo: 0, hi: 29 });
        regs.insert("INTR_ENA_SET", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("Atomic set of interrupt"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INTR_FORCE", Field { brief: Some("Set to force corresponding ICPU_CFG::INTR_STICKY bits. This field may be useful during development of software interrupt handler functions."), details: None, lo: 0, hi: 29 });
        regs.insert("INTR_FORCE", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Interrupt force sticky event"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INTR_IDENT", Field { brief: Some("Shows the currently active interrupt sources. For interrupt sources that are not bypassed this register is a result of AND'ing ICPU_CFG::INTR_STICKY with ICPU_CFG::INTR_ENA."), details: None, lo: 0, hi: 29 });
        regs.insert("INTR_IDENT", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("Currently active interrupt sources"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INTR_RAW", Field { brief: Some("Shows the current value of individual interrupt sources. All sources are active high (the external interrupts has been corrected for polarity as configured in ICPU_CFG::EXT_SRC_INTR_POL)."), details: None, lo: 0, hi: 29 });
        regs.insert("INTR_RAW", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Interrupt raw status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INTR_STICKY", Field { brief: Some("This register is set based on source interrupt events or by debug-force. See ICPU_CFG::INTR_TRIGGER and ICPU_CFG::INTR_FORCE for more information. Bits in this register remains set until cleared by software."), details: None, lo: 0, hi: 29 });
        regs.insert("INTR_STICKY", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Interrupt sticky status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INTR_TRIGGER", Field { brief: Some("Configure trigger mode of individual interrupt sources. The trigger mode determines how the value of the ICPU_CFG::INTR_RAW register is transfered to the ICPU_CFG::INTR_STICKY register. This register is replicated, the first replication controls bit 0 in the encoding, the second replication controls bit 1 in the encoding. I.e. to configure falling-edge-triggered interrupt for interrupt source 5; set ICPU_CFG::INTR_TRIGGER[0][5]='0' and ICPU_CFG::INTR_TRIGGER[1][5]='1'. For level-triggered interrupts ICPU_CFG::INTR_STICKY is set for as long as the corresponding bit in ICPU_CFG::INTR_RAW is high - i.e. is not possible to clear a bit in ICPU_CFG::INTR_STICKY until the corresponding ICPU_CFG::INTR_RAW is zero. For edge-triggeded interrupts ICPU_CFG::INTR_STICKY is set when the corresponding bit in ICPU_CFG::INTR_RAW changes value. For falling-edge-triggeded interrupts ICPU_CFG::INTR_STICKY is set when the corresponding bit in ICPU_CFG::INTR_RAW changes from '1' to '0'. For rising-edge-triggeded interrupts ICPU_CFG::INTR_STICKY is set when the corresponding bit in ICPU_CFG::INTR_RAW changes from '0' to '1'."), details: Some("0: Interrupt is level-activated 1: Interrupt is edge-triggered 2: Interrupt is falling-edge-triggered 3: Interrupt is rising-edge-triggered"), lo: 0, hi: 29 });
        regs.insert("INTR_TRIGGER", Register { addr: Address { base: 1, count: 2, width: 1 }, brief: Some("Interrupt trigger mode"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ROM_OFFSET", Field { brief: Some("This Field specifies the offset into AHB space from which the 8051 must fetch its IROM code during firmware startup."), details: None, lo: 16, hi: 32 });
        regs.insert("MPU8051_IROM", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("8051 ROM configuration"), details: None, fields });
        groups.insert("INTR", RegisterGroup { addr: Address { base: 28, count: 1, width: 37 }, desc: "Interrupt controller", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("INJ_ENA", Field { brief: Some("Set to enable manual injection by using FDMA channel number 9. When manual injection is enabled; the FDMA cannot be used for regular FDMA injection operations (on any injection channel)."), details: None, lo: 1, hi: 2 });
        fields.insert("INJ_SWAP_ENA", Field { brief: Some("Set to swap endianess of data injected to the MANUAL_INJ region. The manual injection status word is never swapped."), details: None, lo: 3, hi: 4 });
        fields.insert("XTR_ENA", Field { brief: Some("Set to enable manual extraction by using FDMA channel number 1. When manual extraction is enabled; the FDMA cannot be used for regular FDMA extraction operations (on any extraction channel)."), details: None, lo: 0, hi: 1 });
        fields.insert("XTR_FLUSH_DIS", Field { brief: Some("Set to disable flushing/abort mechanism when manual extraction is enabled via ICPU_CFG::MANUAL_CFG.XTR_ENA. When manually extracting via 8051 SFR registers this field must be set."), details: None, lo: 4, hi: 5 });
        fields.insert("XTR_SWAP_ENA", Field { brief: Some("Set to byte-swap endianess of data extracted from the MANUAL_XTR region. The manual extraction status word is never swapped."), details: None, lo: 2, hi: 3 });
        regs.insert("MANUAL_CFG", Register { addr: Address { base: 8192, count: 1, width: 1 }, brief: Some("Manual extraction and injection configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INJ", Field { brief: Some("Manual injection is done by writing to this block of registers. The manual injection status word is located at the first word-address in this block. Manual injection has to be enabled via ICPU_CFG::MANUAL_CFG.INJ_ENA."), details: None, lo: 0, hi: 32 });
        regs.insert("MANUAL_INJ", Register { addr: Address { base: 4096, count: 4096, width: 1 }, brief: Some("Manual injection replicated register-array"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INTR_INJ_RDY", Field { brief: Some("Set when there is room for more injection data-words in injection fifo."), details: None, lo: 2, hi: 3 });
        fields.insert("INTR_XTR_ANY_RDY", Field { brief: Some("Set when any extraction word is ready for extraction."), details: None, lo: 1, hi: 2 });
        fields.insert("INTR_XTR_SOF_RDY", Field { brief: Some("Set when there is an extraction word containing SOF ready for extraction."), details: None, lo: 0, hi: 1 });
        regs.insert("MANUAL_INTR", Register { addr: Address { base: 8193, count: 1, width: 1 }, brief: Some("Manual extraction and injection interrupt indications"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INTR_INJ_RDY_ENA", Field { brief: Some("Set to enable FDMA interrupt while there is room for more injection data. This interrupt is asserted for as long as there is free space in the injection buffers."), details: None, lo: 2, hi: 3 });
        fields.insert("INTR_XTR_ANY_RDY_ENA", Field { brief: Some("Set to enable FDMA interrupt while any data is ready for manual extraction. This interrupt is asserted for as long as there is data ready in the extraction buffer."), details: None, lo: 1, hi: 2 });
        fields.insert("INTR_XTR_SOF_RDY_ENA", Field { brief: Some("Set to enable FDMA interrupt when a new frame is waiting to be extracted. This event is asserted when a frame-word with sof set is waiting to be extracted. If a previous frame is only partially extracted then no interrupt will be generated until the previous frame is completely extracted."), details: None, lo: 0, hi: 1 });
        regs.insert("MANUAL_INTR_ENA", Register { addr: Address { base: 8194, count: 1, width: 1 }, brief: Some("Manual extraction and injection interrupt enables"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("XTR", Field { brief: Some("Manual extraction is done by reading from this block of registers. The manual extraction status word is accessed by reading the last word-address in this block. Manual extraction has to be enabled via ICPU_CFG::MANUAL_CFG.XTR_ENA."), details: None, lo: 0, hi: 32 });
        regs.insert("MANUAL_XTR", Register { addr: Address { base: 0, count: 4096, width: 1 }, brief: Some("Manual extraction replicated register-array"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INTR_PENDING_FALLING", Field { brief: None, details: None, lo: 1, hi: 2 });
        fields.insert("INTR_PENDING_RISING", Field { brief: None, details: None, lo: 0, hi: 1 });
        regs.insert("PCIE_INTR_STAT", Register { addr: Address { base: 20, count: 2, width: 1 }, brief: Some("PCIe outbound MSI interrupt status"), details: Some("Replicated per EXT_DST interrupt."), fields });
        groups.insert("MANUAL_XTRINJ", RegisterGroup { addr: Address { base: 4096, count: 1, width: 8195 }, desc: "Manual extraction and injection via FDMA", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("BANK_CNT", Field { brief: Some("Number of banks in the SDRAM configuration being used."), details: Some("0 : 4 banks 1 : 8 banks"), lo: 8, hi: 9 });
        fields.insert("BURST_LEN", Field { brief: Some("The burst size that is used by the SDRAM controller. The SDRAM must be configured with the corresponding burst size (through the ICPU_CFG::MEMCTRL_MR0_VAL register.) Note: The number of data-bytes that is transmitted during one burst must be encoded in the ICPU_CFG::MEMCTRL_CFG.BURST_SIZE field."), details: Some("0 : BURST4 1 : BURST8"), lo: 9, hi: 10 });
        fields.insert("BURST_SIZE", Field { brief: Some("The number of data-bytes that is transmitted during one burst (of the defined burst length: ICPU_CFG::MEMCTRL_CFG.BURST_LEN)."), details: Some("0: 8 data-bytes per burst. 1: 16 data-bytes per burst."), lo: 10, hi: 11 });
        fields.insert("DDR_512MBYTE_PLUS", Field { brief: Some("Set this field to enable support for more than 512MByte SDRAM."), details: None, lo: 16, hi: 17 });
        fields.insert("DDR_ECC_COR_ENA", Field { brief: Some("Set this field to enable propagation of ECC corrections to SBA by generating bus-error event when ECC correction is detected. This field may not be set unless ICPU_CFG::MEMCTRL_CFG.DDR_ECC_ENA is also set."), details: None, lo: 14, hi: 15 });
        fields.insert("DDR_ECC_ENA", Field { brief: Some("This field enables ECC mode of the SDRAM controller. This field may only be set when ICPU_CFG::MEMCTRL_CFG.DDR_WIDTH is configured for 16bit. In ECC mode byte lane 1 is used for ECC information and byte lane 0 is used for data. When using ECC mode, then the amount of random-access memory availble to an application is half of the physically attatched memory."), details: None, lo: 13, hi: 14 });
        fields.insert("DDR_ECC_ERR_ENA", Field { brief: Some("Set this field to enable propagation of ECC errors to SBA by generating bus-error event when ECC error is detected. This field may not be set unless ICPU_CFG::MEMCTRL_CFG.DDR_ECC_ENA is also set."), details: None, lo: 15, hi: 16 });
        fields.insert("DDR_MODE", Field { brief: Some("This field configures the operating mode of the SDRAM controller."), details: Some("0: DDR2 1: DDR3"), lo: 11, hi: 12 });
        fields.insert("DDR_WIDTH", Field { brief: Some("This field configures the interface width of the SDRAM controller. If 8bit is selected then byte lane 0 must be populated by external SDRAM memory."), details: Some("0: 8bit 1: 16bit"), lo: 12, hi: 13 });
        fields.insert("MSB_COL_ADDR", Field { brief: Some("Set to 1 less than the number of column address bits for the SDRAM configuration in use. For example; for a memory that is using column addresses {A11, A9-A0} this field must be set to 10."), details: None, lo: 0, hi: 4 });
        fields.insert("MSB_ROW_ADDR", Field { brief: Some("Set to 1 less than the number of row address bits for the SDRAM configuration in use."), details: None, lo: 4, hi: 8 });
        regs.insert("MEMCTRL_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("DDR2/3 configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INITIALIZE", Field { brief: Some("Set this field to force the memory controller to initialize the SDRAM. This field is automatically cleared after the controller has started initialization of the SDRAM. Wait for ICPU_CFG::MEMCTRL_STAT.INIT_DONE before performing read/write operations on the controller. Note: The ICPU_CFG::MEMCTRL_CFG, ICPU_CFG::MEMCTRL_REF_PERIOD, ICPU_CFG::MEMCTRL_TIMING*, and ICPU_CFG::MEMCTRL_MR* registers must be configured appropriately before setting this field."), details: None, lo: 0, hi: 1 });
        fields.insert("MDSET", Field { brief: Some("Set this field to do memory register write command. The register to write is defined by ICPU_CFG::MEMCTRL_MR0_VAL[15:14], the data to write is defined by ICPU_CFG::MEMCTRL_MR0_VAL[15:0]."), details: None, lo: 2, hi: 3 });
        fields.insert("PWR_DOWN", Field { brief: Some("Set this field to force the memory module into low power self refresh mode. The ICPU_CFG::MEMCTRL_STAT.PWR_DOWN_ACK is set when the controller has executed the command. Clear this field to bring the controller back to normal operation. Note: Before using power-down the ICPU_CFG::MEMCTRL_TIMING2.INIT_DLY must be reconfigured, see field description for more information."), details: None, lo: 3, hi: 4 });
        fields.insert("STALL_REF_ENA", Field { brief: Some("Set this field to temporarily give software unhindered access to memory; two things changes in the controller: a) Refreshes are postponed until ICPU_CFG::MEMCTRL_REF_PERIOD.MAX_PEND_REF is exceeded. b) Only a single refresh will be issued when exceeding ICPU_CFG::MEMCTRL_REF_PERIOD.MAX_PEND_REF. When this field is NOT set (the normal case) the memory controller try to do refreshes during controller idle periods, also once refresh has started - all pending refreshes will be performed. Note: Interrupt routines and other high-priority tasks can use this field to ensure uninterrupted access to the memory, such routines must clear this field when memory access is no longer critical."), details: None, lo: 1, hi: 2 });
        regs.insert("MEMCTRL_CTRL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("DDR2/3 control"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DDRDFT_A10", Field { brief: None, details: None, lo: 4, hi: 5 });
        fields.insert("DDRDFT_ENA", Field { brief: Some("Set this field to enable testmode."), details: Some("0: Disabled 1: Enabled"), lo: 0, hi: 1 });
        fields.insert("DDRDFT_GATE_ENA", Field { brief: Some("Set to force the DQS gate open (and no flushing)."), details: None, lo: 6, hi: 7 });
        fields.insert("DDRDFT_LBW", Field { brief: Some("Set this field to disable check for data in every clock cycle during the DDR read test. Setting this field makes it possible to send in data with a slower rate than the internal clock frequency and thus allowing for input voltage to stabilize prior to toggeling DQS when checking for voltages."), details: None, lo: 7, hi: 8 });
        fields.insert("DDRDFT_MODE", Field { brief: Some("Set this field to configure a specific testmode. For the SSO output pattern address output A10 will be forced to the value that is set in ICPU_CFG::MEMCTRL_DFT.DDRDFT_A10 (to be used for measuring swing)."), details: Some("0: Sample (expect signiture pattern) 1: Drive all-zeros (where possible) 2: Drive all-ones (where possible) 3: Drive SSO pattern (A10 value is determined by DDRDFT_A10)"), lo: 1, hi: 3 });
        fields.insert("DDRDFT_STAT", Field { brief: Some("Status for ReadTest."), details: Some("0: Err 1: Pass"), lo: 3, hi: 4 });
        fields.insert("DDRDFT_TERM_ENA", Field { brief: Some("Set to force enable of the local-term."), details: None, lo: 5, hi: 6 });
        regs.insert("MEMCTRL_DFT", Register { addr: Address { base: 15, count: 1, width: 1 }, brief: Some("Design for test features"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DQS_AUTO_DOWN", Field { brief: Some("This field is set when an down-ajusting happens. If this field is set and DQS_AUTO_ENA is also set, then the MEMCTRL_DQS_DLY.DQS_DLY has been decremented."), details: None, lo: 1, hi: 2 });
        fields.insert("DQS_AUTO_ENA", Field { brief: Some("Set this field to enable automatic detection of drifting read-data-window. Drifting of the DQS read window occurs as the chip is heating/cooling. When this field is set MEMCTRL_DQS_DLY.DQS_DLY field will automatically be ajusted when a drift is detected by the hardware."), details: None, lo: 0, hi: 1 });
        fields.insert("DQS_AUTO_SRC", Field { brief: Some("Selects either DQS or nDQS to be monitored for automatic drift detection."), details: Some("0: DQS is monitored 1: nDQS is monitored"), lo: 3, hi: 4 });
        fields.insert("DQS_AUTO_UP", Field { brief: Some("This field is set when an up-ajusting happens. If this field is set and DQS_AUTO_ENA is also set, then the MEMCTRL_DQS_DLY.DQS_DLY has been increased."), details: None, lo: 2, hi: 3 });
        fields.insert("DQS_DRIFT", Field { brief: Some("Resynced DQS (or nDQS) drift indication."), details: None, lo: 6, hi: 8 });
        fields.insert("DQS_OVERFLOW", Field { brief: Some("This field is set if the automatic read-window drift detection causes an overflow in the MEMCTRL_DQS_DLY.DQS_DLY field. If this occurs during runtime, the memory controller must be configured to provide the read-indication later."), details: None, lo: 5, hi: 6 });
        fields.insert("DQS_UNDERFLOW", Field { brief: Some("This field is set if the automatic read-window drift detection causes an underflow in the MEMCTRL_DQS_DLY.DQS_DLY field. If this occurs during runtime, the memory controller must be configured to provide the read-indication earlier."), details: None, lo: 4, hi: 5 });
        regs.insert("MEMCTRL_DQS_AUTO", Register { addr: Address { base: 18, count: 2, width: 1 }, brief: Some("DQS window automatic drift detect/ajust"), details: Some("This register has the same replication scheme as ICPU_CFG::MEMCTRL_DQS_DLY."), fields });
        let mut fields = HashMap::new();
        fields.insert("DQS_DLY", Field { brief: Some("This field configures read-window delay as an offset in 1/4 clock cycles from the fixed read-delay configured in MEMCTRL_TIMING0.RD_DATA_XFR_DLY."), details: None, lo: 0, hi: 5 });
        fields.insert("DQS_DLY_TRM0", Field { brief: Some("This field allows fine tuning of the DQS signal (1'st DDR data-set) read-window delay (configured by DQS_DLY) by adding/removing an offset in steps of 25ps (typical)."), details: Some("0: -3 steps. 1: -2 steps. 2: -1 steps. 3: Norminal delay. 4: +1 steps. 5: +2 steps. 6: +3 steps. 7: +4 steps."), lo: 5, hi: 8 });
        fields.insert("DQS_DLY_TRM1", Field { brief: Some("The functionality of this field is the same as DQS_DLY_TRM, just for the nDQS signal (2'nd DDR data-set). See DQS_DLY_TRM for description and encoding."), details: None, lo: 8, hi: 11 });
        fields.insert("TRAIN_DQ_ENA", Field { brief: Some("Set this field if training of individual data bit is required. When this field is set, data will not automatically be realligned during read from SDRAM. This enables training of the read-timing for individual data-bits inside the byte-lanes. The actual procedure for training is TBA (targeted for future high-speed implementations)."), details: None, lo: 11, hi: 12 });
        regs.insert("MEMCTRL_DQS_DLY", Register { addr: Address { base: 16, count: 2, width: 1 }, brief: Some("DQS window configuration"), details: Some("This register is replicated two times, once for each Byte Lane (first replication corresponds to Byte Lane 0)."), fields });
        let mut fields = HashMap::new();
        fields.insert("MR0_VAL", Field { brief: Some("Value to be programmed into the mode register (0) during SDRAM initialization. During initialization bit 8 (DLL Reset) of this register must be set to 0, the memory controller automatically sets this bit when required during the initialization procedure. After initialization this field is used for sending custom MDSET commands. If ICPU_CFG::MEMCTRL_CTRL.MDSET is set then the value of this field is writtten to the register defined by bit [15:14]."), details: None, lo: 0, hi: 16 });
        regs.insert("MEMCTRL_MR0_VAL", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("Mode register 0 value"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MR1_VAL", Field { brief: Some("Value to be programmed into mode register 1 / extended mode register during SDRAM initialization. Bits 7 thorugh 9 (OCD Calibration Program) of this register must be set to 0x7, the memory controller sets this field when required during the initialization procedure."), details: None, lo: 0, hi: 16 });
        regs.insert("MEMCTRL_MR1_VAL", Register { addr: Address { base: 11, count: 1, width: 1 }, brief: Some("Mode register 1 value"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MR2_VAL", Field { brief: Some("Value to be programmed into mode register 2 / extended mode register 2 during SDRAM initialization."), details: None, lo: 0, hi: 16 });
        regs.insert("MEMCTRL_MR2_VAL", Register { addr: Address { base: 12, count: 1, width: 1 }, brief: Some("Mode register 2 value"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MR3_VAL", Field { brief: Some("Value to be programmed into mode register 3 / extended mode register 3 during SDRAM initialization."), details: None, lo: 0, hi: 16 });
        regs.insert("MEMCTRL_MR3_VAL", Register { addr: Address { base: 13, count: 1, width: 1 }, brief: Some("Mode register 3 value"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MAX_PEND_REF", Field { brief: Some("Maximum number of refreshes that are allowed to be outstanding at any time. If the number of outstanding refreshes exceeds this value, the memory controller will stop data accesses, and issue refreshes. If no outstanding refreshes is allowed then set this field to 0."), details: None, lo: 16, hi: 20 });
        fields.insert("REF_PERIOD", Field { brief: Some("Refresh interval of the SDRAM expressed in number of clock cycles. This value is calculated by dividing the average periodic refresh interval (tREFI) by the clock period."), details: None, lo: 0, hi: 16 });
        regs.insert("MEMCTRL_REF_PERIOD", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Refresh configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INIT_DONE", Field { brief: Some("This field is set after initialization of the SDRAM is done. When this field is set then read/write operations can be performed."), details: None, lo: 0, hi: 1 });
        fields.insert("PWR_DOWN_ACK", Field { brief: Some("Is set once the memory controller has put the SDRAM in low power self refresh mode (result of setting ICPU_CFG::MEMCTRL_CTRL.PWR_DOWN). When this field is set SDRAM interface signal may turned off (all signals except the CKE and ODT) may be left floating."), details: None, lo: 1, hi: 2 });
        fields.insert("RDATA_DUMMY", Field { brief: Some("Set if the controller has inserted missing data-set towards the SBA (too few data words received from SDRAM). This field may be set during training. If this event occurs during normal operation then the DQS window may be wrongly configured."), details: None, lo: 4, hi: 5 });
        fields.insert("RDATA_ECC_COR", Field { brief: Some("Set if the controller is enabled for ECC and a dataset has been corrected (a correctable error has been corrected)."), details: None, lo: 2, hi: 3 });
        fields.insert("RDATA_ECC_ERR", Field { brief: Some("Set if the controller is enabled for ECC and an uncorrectable error has been detected."), details: None, lo: 3, hi: 4 });
        fields.insert("RDATA_MASKED", Field { brief: Some("Set if the controller has masked a data-set towards the SBA (too many data words received from SDRAM). This field may be set during training. If this event occurs during normal operation then the DQS window may be wrongly configured."), details: None, lo: 5, hi: 6 });
        regs.insert("MEMCTRL_STAT", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("DDR2/3 status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LOCAL_ODT_RD_ENA", Field { brief: Some("Set to enable local termination during a read operation."), details: None, lo: 0, hi: 1 });
        fields.insert("LOCAL_ODT_RD_EXT", Field { brief: Some("Set this field to extend the local termination by one clock during read operations."), details: None, lo: 1, hi: 2 });
        fields.insert("ODT_RD_ENA", Field { brief: Some("Set to enable ODT output during read operations."), details: Some("0: Reading will not assert ODT 1: Assert ODT for CS0 read 2: Assert ODT for CS1 read 3: Assert ODT for any read Other values are reserved"), lo: 7, hi: 11 });
        fields.insert("ODT_RD_EXT", Field { brief: Some("Set this field to extend the ODT termination output by one clock during read operations."), details: None, lo: 11, hi: 12 });
        fields.insert("ODT_WR_ENA", Field { brief: Some("Set to assert ODT output(s) during write operations."), details: Some("0: Writing will not assert ODT 1: Assert ODT for CS1 write 2: Assert ODT for CS0 write 3: Assert ODT for any write Others values are reserved"), lo: 2, hi: 6 });
        fields.insert("ODT_WR_EXT", Field { brief: Some("Set this field to extend the ODT termination output by one clock during write operations."), details: None, lo: 6, hi: 7 });
        regs.insert("MEMCTRL_TERMRES_CTRL", Register { addr: Address { base: 14, count: 1, width: 1 }, brief: Some("On-die-termination configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RAS_TO_PRECH_DLY", Field { brief: Some("Delay from RAS to precharge."), details: Some("tRAS_min-1"), lo: 16, hi: 20 });
        fields.insert("RD_CS_CHANGE_DLY", Field { brief: Some("Delay from read to read on different chip selects."), details: Some("BL"), lo: 20, hi: 24 });
        fields.insert("RD_DATA_XFR_DLY", Field { brief: Some("Delay from read command to data. Important; this delay is further increased by the DQS delay logic - see ICPU_CFG::MEMCTRL_DQS_DLY for more information."), details: Some("RL-3"), lo: 0, hi: 4 });
        fields.insert("RD_TO_PRECH_DLY", Field { brief: Some("Delay from read to precharge."), details: Some("BL-1"), lo: 8, hi: 12 });
        fields.insert("RD_TO_WR_DLY", Field { brief: Some("Delay from read to write on same chip select."), details: Some("RL+BL+1-WL"), lo: 28, hi: 32 });
        fields.insert("WR_CS_CHANGE_DLY", Field { brief: Some("Delay from write to write on different chip selects. If ICPU_CFG::MEMCTRL_TERMRES_CTRL.ODT_WR_ENA==9 then increase this field by 2 (to allow ODT handover between destination devices)."), details: Some("BL-1"), lo: 24, hi: 28 });
        fields.insert("WR_DATA_XFR_DLY", Field { brief: Some("Delay from write command to data."), details: Some("WL-1"), lo: 4, hi: 8 });
        fields.insert("WR_TO_PRECH_DLY", Field { brief: Some("Delay from write to precharge."), details: Some("WL+BL+tWR-1"), lo: 12, hi: 16 });
        regs.insert("MEMCTRL_TIMING0", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Timing configuration"), details: Some("The Following parameters are needed for configuration of the ICPU_CFG::MEMCTRL_TIMING* registers. All asynchronous delays should be converted (round up) to the corresponding number of DDR controller clock cycles. Note that DDR modules may specify a minimum number of clock cycles for some parameters: RL=CL BL=2 for burst4, 4 for burst8 Additional for DDR2 memories: WL=RL-1 MD=tMRD ID=400ns SD=tXSRD OW=WL-2 OR=RL-3 RP=tRP for 4-bank modules, tRPA for 8-bank modules FAW=1 for 4-bank modules, tFAW for 8-bank modules Additional for DDR3 memories: WL=CWL MD=tMOD ID=tXPR SD=tDLLK OW=2 OR=2 RP=tRP FAW=tFAW"), fields });
        let mut fields = HashMap::new();
        fields.insert("BANK8_FAW_DLY", Field { brief: Some("Four bank activate period."), details: Some("FAW-1"), lo: 16, hi: 24 });
        fields.insert("PRECH_TO_RAS_DLY", Field { brief: Some("Delay from precharge to RAS."), details: Some("tRP-1"), lo: 12, hi: 16 });
        fields.insert("RAS_TO_CAS_DLY", Field { brief: Some("Delay from RAS to CAS."), details: Some("tRCD-1"), lo: 4, hi: 8 });
        fields.insert("RAS_TO_RAS_DLY", Field { brief: Some("Delay from RAS to RAS."), details: Some("tRRD-1"), lo: 8, hi: 12 });
        fields.insert("RAS_TO_RAS_SAME_BANK_DLY", Field { brief: Some("Delay from RAS to RAS within same bank."), details: Some("tRC-1"), lo: 24, hi: 32 });
        fields.insert("WR_TO_RD_DLY", Field { brief: Some("Delay from write to read."), details: Some("WL+BL+tWTR-1"), lo: 0, hi: 4 });
        regs.insert("MEMCTRL_TIMING1", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Timing configuration"), details: Some("See ICPU_CFG::MEMCTRL_TIMING0 for description of important parameters."), fields });
        let mut fields = HashMap::new();
        fields.insert("INIT_DLY", Field { brief: Some("Delay for initialization (see ICPU_CFG::MEMCTRL_CTRL.INITIALIZE)."), details: Some("Before initialization: ID-1 After initialization: SD-1"), lo: 0, hi: 16 });
        fields.insert("MDSET_DLY", Field { brief: Some("Delay after register-write."), details: Some("MD-1"), lo: 24, hi: 28 });
        fields.insert("PRECH_ALL_DLY", Field { brief: Some("Delay after precharge all."), details: Some("RP-1"), lo: 28, hi: 32 });
        fields.insert("REF_DLY", Field { brief: Some("Delay after refresh."), details: Some("tRFC-1"), lo: 16, hi: 24 });
        regs.insert("MEMCTRL_TIMING2", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Timing configuration"), details: Some("See ICPU_CFG::MEMCTRL_TIMING0 for description of important parameters."), fields });
        let mut fields = HashMap::new();
        fields.insert("LOCAL_ODT_RD_DLY", Field { brief: Some("Delay from read to local read-termination activate. Important; this delay is further increased by the DQS delay logic - see ICPU_CFG::MEMCTRL_DQS_DLY for more information. Local read-termination is enabled by ICPU_CFG::MEMCTRL_TERMRES_CTRL.LOCAL_ODT_RD_ENA."), details: Some("RL-3"), lo: 4, hi: 8 });
        fields.insert("ODT_RD_DLY", Field { brief: Some("Delay from read to ODT assert. External ODT assert for read commands is enabled by ICPU_CFG::MEMCTRL_TERMRES_CTRL.ODT_RD_ENA."), details: Some("OR-1"), lo: 12, hi: 16 });
        fields.insert("ODT_WR_DLY", Field { brief: Some("Delay from write to ODT assert. External ODT assert for write commands is enabled by ICPU_CFG::MEMCTRL_TERMRES_CTRL.ODT_WR_ENA."), details: Some("OW-1"), lo: 8, hi: 12 });
        fields.insert("RMW_DLY", Field { brief: Some("Read-modify-write is not used by this device."), details: None, lo: 16, hi: 20 });
        fields.insert("WR_TO_RD_CS_CHANGE_DLY", Field { brief: Some("Delay from write to write on different chip selects."), details: Some("WL+tWTR-1"), lo: 0, hi: 4 });
        regs.insert("MEMCTRL_TIMING3", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("Timing configuration"), details: Some("See ICPU_CFG::MEMCTRL_TIMING0 for description of important parameters."), fields });
        let mut fields = HashMap::new();
        fields.insert("ZQCAL_INIT_DLY", Field { brief: Some("Delay for initial ZQ calibration."), details: Some("max(tZQinit, tDLLK)-3"), lo: 20, hi: 32 });
        fields.insert("ZQCAL_LONG_DLY", Field { brief: Some("Delay for long ZQ calibration."), details: Some("tZQoper-3"), lo: 8, hi: 20 });
        fields.insert("ZQCAL_SHORT_DLY", Field { brief: Some("Delay for short ZQ calibration."), details: Some("tZQCS-3"), lo: 0, hi: 8 });
        regs.insert("MEMCTRL_TIMING4", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("Timing configuration"), details: Some("See ICPU_CFG::MEMCTRL_TIMING0 for description of important parameters."), fields });
        let mut fields = HashMap::new();
        fields.insert("ZQCAL_LONG", Field { brief: Some("Set this field to issue long ZQ calibration command. This field is cleared when calibration has been performed."), details: None, lo: 1, hi: 2 });
        fields.insert("ZQCAL_SHORT", Field { brief: Some("Set this field to issue short ZQ calibration command. This field is cleared when calibration has been performed."), details: None, lo: 0, hi: 1 });
        regs.insert("MEMCTRL_ZQCAL", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("DDR3 ZQ-calibration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PHY_CK_OE", Field { brief: Some("Set to enable output drive of the CK/nCK and CKE outputs."), details: None, lo: 3, hi: 4 });
        fields.insert("PHY_CL_OE", Field { brief: Some("Set to enable output drive of the Command Lane outputs."), details: None, lo: 2, hi: 3 });
        fields.insert("PHY_DLL_BL_RST", Field { brief: Some("Soft-reset to the byte lane DLLs in the memory controller physical interface."), details: Some("0: PHY DLLs is in working mode. 1: PHY DLLs is forced in reset."), lo: 6, hi: 7 });
        fields.insert("PHY_DLL_CL_RST", Field { brief: Some("Soft-reset to the Command lane DLL in the memory controller physical interface."), details: Some("0: PHY DLL is in working mode. 1: PHY DLL is forced in reset."), lo: 5, hi: 6 });
        fields.insert("PHY_DQS_EXT", Field { brief: Some("Set this field to extend the read-data-window by one clock-cycle (two DDR data slots)."), details: None, lo: 8, hi: 9 });
        fields.insert("PHY_FIFO_RST", Field { brief: Some("Soft-reset to the FIFO blocks in the memory controller physical interface. Leave at default value."), details: Some("0: PHY FIFOs is in working mode. 1: PHY FIFOs is forced in reset."), lo: 7, hi: 8 });
        fields.insert("PHY_FLUSH_DIS", Field { brief: Some("Set to disable flushing of write- and read-data during controller idle time."), details: None, lo: 10, hi: 11 });
        fields.insert("PHY_ODT_OE", Field { brief: Some("Set to enable output drive of the ODT output."), details: None, lo: 4, hi: 5 });
        fields.insert("PHY_RD_ADJ_DIS", Field { brief: Some("Set this field to disable masking or dummy insert of receive data words. During normal operation this is not needed, but during DQS/DQ training this feature makes sure the SBA get the number of datasets that has been requested."), details: None, lo: 9, hi: 10 });
        fields.insert("PHY_RST", Field { brief: Some("Master reset to the memory controller physical interface."), details: Some("0: PHY is in working mode. 1: PHY is forced in reset."), lo: 0, hi: 1 });
        fields.insert("PHY_SSTL_ENA", Field { brief: Some("Set this field to enable the SSTL mode for the memory controllers physical interfaces."), details: None, lo: 1, hi: 2 });
        regs.insert("MEMPHY_CFG", Register { addr: Address { base: 20, count: 1, width: 1 }, brief: Some("SSTL configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PHY_AT_OE", Field { brief: Some("Set to enable the ATO (Analog Test Output) driver."), details: None, lo: 1, hi: 2 });
        fields.insert("PHY_DLL_BYPASS", Field { brief: Some("Set to force the DLLs into bypass mode."), details: None, lo: 2, hi: 3 });
        fields.insert("PHY_DT_SSTL_ENA", Field { brief: Some("Set to enable SSTL drivers/receivers in the DTO (Digital Test Outputs) drivers."), details: None, lo: 0, hi: 1 });
        regs.insert("MEMPHY_DFT", Register { addr: Address { base: 21, count: 1, width: 1 }, brief: Some("Design for test features"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DLLCFG_BIAS_TRM0", Field { brief: Some("Master bias generator frequency trim."), details: Some("0: Fmax trim: minimum adjust. 7: Fmax trim: maximum adjust."), lo: 12, hi: 15 });
        fields.insert("DLLCFG_BIAS_TRM1", Field { brief: Some("Master bias generator control voltage trim."), details: Some("0: Vc level trim: minimum adjust. 7: Vc level trim: maximum adjust."), lo: 16, hi: 19 });
        fields.insert("DLLCFG_BIAS_TRM2", Field { brief: Some("Slave bias generator frequency trim."), details: Some("0: Fmax trim: minimum adjust. 7: Fmax trim: maximum adjust."), lo: 20, hi: 23 });
        fields.insert("DLLCFG_BIAS_TRM3", Field { brief: Some("Slave bias generator control voltage trim."), details: Some("0: Vc level trim: minimum adjust. 7: Vc level trim: maximum adjust."), lo: 24, hi: 27 });
        fields.insert("DLLCFG_IPUMP_TRM", Field { brief: Some("Charge pump current trim."), details: Some("0: Maximum current. 7: Minimum current."), lo: 2, hi: 5 });
        fields.insert("DLLCFG_LOCK_DET_EN", Field { brief: Some("Lock detector enable."), details: Some("0: Disable lock detector. 1: Enable lock detector."), lo: 29, hi: 30 });
        fields.insert("DLLCFG_RES0", Field { brief: Some("Reserved."), details: None, lo: 0, hi: 2 });
        fields.insert("DLLCFG_RES1", Field { brief: Some("Reserved."), details: None, lo: 11, hi: 12 });
        fields.insert("DLLCFG_RES2", Field { brief: Some("Reserved."), details: None, lo: 15, hi: 16 });
        fields.insert("DLLCFG_RES3", Field { brief: Some("Reserved."), details: None, lo: 19, hi: 20 });
        fields.insert("DLLCFG_RES4", Field { brief: Some("Reserved."), details: None, lo: 23, hi: 24 });
        fields.insert("DLLCFG_RES5", Field { brief: Some("Reserved."), details: None, lo: 27, hi: 29 });
        fields.insert("DLLCFG_RES6", Field { brief: Some("Reserved."), details: None, lo: 30, hi: 32 });
        fields.insert("DLLCFG_TEST_CTRL_A", Field { brief: Some("Analog test control. Selects the analog signal to be viewed at ATO (Analog Test Output) when enabled by DLLCFG_TEST_CTRL_EN and MEMPHY_DLLCFG1.DLLCFG_TEST_HIZB_A."), details: Some("0: Filter output (Vc). 1: Replica bias output for NMOS (Vbn). 2: Replica bias output for PMOS (Vbp). 3: VDD."), lo: 9, hi: 11 });
        fields.insert("DLLCFG_TEST_CTRL_D", Field { brief: Some("Digital test control. Selects the digital signal to be viewed at DTO[1] (Digital Test Output), DTO[0] always output clk_0 when enabled by DLLCFG_TEST_CTRL_EN."), details: Some("0: 0deg output clock (clk_0). 1: 90deg output clock (clk_90). 2: 180deg output clock (clk_180). 3: 270deg output clock (clk_270). 4: 360deg internal clock (clk_360_int). 5: Speed-up pulse (spdup). 6: Slow-down pulse (slwdn). 7: Output clock (cclk_0)."), lo: 6, hi: 9 });
        fields.insert("DLLCFG_TEST_CTRL_EN", Field { brief: Some("Test control enable for ATO and DTO (Analog and Digital Test Outputs)."), details: Some("0: Digital and Analog test outputs are disabled and drive 0/VSS."), lo: 5, hi: 6 });
        regs.insert("MEMPHY_DLLCFG0", Register { addr: Address { base: 22, count: 3, width: 1 }, brief: Some("DLL configuration"), details: Some("This register is replicated three times, replication-0 controls the Command Lane DLL, replication-1 controls the Lower Byte Lane DLL, and replication-2 controls the Upper Byte Lane DLL."), fields });
        let mut fields = HashMap::new();
        fields.insert("DLLCFG_FB_TRM", Field { brief: Some("Feed-back delay adjust."), details: Some("0:Minimum additional delay 7:Maximum additional delay"), lo: 6, hi: 9 });
        fields.insert("DLLCFG_FF_TRM", Field { brief: Some("Feed-forward delay adjust."), details: Some("0:Minimum additional delay 7:Maximum additional delay"), lo: 9, hi: 12 });
        fields.insert("DLLCFG_RES7", Field { brief: Some("Reserved."), details: None, lo: 0, hi: 6 });
        fields.insert("DLLCFG_RES8", Field { brief: Some("Reserved."), details: None, lo: 12, hi: 18 });
        fields.insert("DLLCFG_RES9", Field { brief: Some("Reserved."), details: None, lo: 19, hi: 20 });
        fields.insert("DLLCFG_TEST_HIZB_A", Field { brief: Some("Analog test output tri-stated control. Observe, all the DLLs are connected to the same analog test output. Only one DLL must have ATO enabled at any point in time."), details: Some("0: ATO is tri-stated (High-Z). 1: ATO is driven."), lo: 18, hi: 19 });
        regs.insert("MEMPHY_DLLCFG1", Register { addr: Address { base: 25, count: 3, width: 1 }, brief: Some("DLL configuration"), details: Some("This register has the same replication scheme as ICPU_CFG::MEMPHY_DLLCFG0."), fields });
        let mut fields = HashMap::new();
        fields.insert("PHY_DQ_DLY_TRM", Field { brief: Some("Data input window placement trim for data latched on DQS and nDQS. Each DQ has 4 bit of associated trim-settings, these are replicated for each of the DQ pins. Bits 3:0 controls DQ0, bits 7:4 controls DQ1 and so on. Inside the 4 bits of trim configurations; [1:0] configrues strobe placement trim for data latched by DQS and [3:2] controls strobe placement trim for data latched by nDQS."), details: Some("0: nominal delay. 1: nominal delay + 1 step. 2: nominal delay + 2 steps. 3: nominal delay + 3 steps."), lo: 0, hi: 32 });
        regs.insert("MEMPHY_DQ_DLY_TRM", Register { addr: Address { base: 28, count: 2, width: 1 }, brief: Some("DQ window configuration"), details: Some("This register has the same replication scheme as ICPU_CFG::MEMCTRL_DQS_DLY."), fields });
        let mut fields = HashMap::new();
        fields.insert("ZCAL_CLK_SEL", Field { brief: Some("Controls speed of the automatic impedance calibration."), details: Some("0: Fast 1: Slow"), lo: 9, hi: 10 });
        fields.insert("ZCAL_ENA", Field { brief: Some("Set this field to start automatic SSTL output and ODT drive-strength calibration. This field is cleared when the automatic calibration has completed."), details: None, lo: 0, hi: 1 });
        fields.insert("ZCAL_PROG", Field { brief: Some("Together with the external reference resistor this field configures the SSTL output drive-strength. This field must be configured prior to, or at the same time as, setting the ICPU_CFG::MEMPHY_ZCAL.ZCAL_ENA field."), details: Some("2: 150ohms 3: 120ohms 5: 75ohms 7: 60ohms 8: 50ohms 11: 40ohms 13: 34ohms Other values are reserved."), lo: 1, hi: 5 });
        fields.insert("ZCAL_PROG_ODT", Field { brief: Some("Together with the external reference resistor this field configures the SSTL On-Die-Termination (ODT) impedance. This field must be configured prior to, or at the same time as, setting the ICPU_CFG::MEMPHY_ZCAL.ZCAL_ENA field."), details: Some("2: 150ohms 3: 120ohms 5: 75ohms 7: 60ohms 8: 50ohms 11: 40ohms 13: 34ohms Other values are reserved."), lo: 5, hi: 9 });
        regs.insert("MEMPHY_ZCAL", Register { addr: Address { base: 30, count: 1, width: 1 }, brief: Some("SSTL drive-strength calibration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ZCAL_ENACLR_DIS", Field { brief: Some("Debug field that allows the feedback from done indication to clearing of MEMPHY_ZCAL.ZCAL_ENA to be broken. That is; when this field is set ZCAL_ENA will never be cleared."), details: None, lo: 2, hi: 3 });
        fields.insert("ZCAL_OVR_DATA", Field { brief: Some("Value for manual override of impedance control."), details: None, lo: 12, hi: 32 });
        fields.insert("ZCAL_OVR_ENA", Field { brief: Some("Set to force override value MEMCTRl_ZCAL_OVR.ZCAL_OVR_DATA instead of automatic calibration result."), details: None, lo: 0, hi: 1 });
        fields.insert("ZCAL_ZCOMP", Field { brief: Some("The zcomp input from the IO ring. Is read directly from other clock domain, keep reading until same value returned twice in a row."), details: None, lo: 1, hi: 2 });
        regs.insert("MEMPHY_ZCAL_OVR", Register { addr: Address { base: 32, count: 1, width: 1 }, brief: Some("SSTL drive-strength override"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ZCAL_DONE", Field { brief: Some("Set when the automatic impedance calibration indicates done."), details: None, lo: 0, hi: 1 });
        fields.insert("ZCAL_ERR", Field { brief: Some("Set if an error occurs during automatic impedance calibration."), details: None, lo: 1, hi: 2 });
        fields.insert("ZCAL_STAT_ODTPD", Field { brief: Some("Status of On-Die-termination pull-down calibration."), details: Some("0: Completed with no errors 1: Overflow error 2: Underflow errror 3: Calibration in progress"), lo: 6, hi: 8 });
        fields.insert("ZCAL_STAT_ODTPU", Field { brief: Some("Status of On-Die-termination pull-up calibration."), details: Some("0: Completed with no errors 1: Overflow error 2: Underflow errror 3: Calibration in progress"), lo: 8, hi: 10 });
        fields.insert("ZCAL_STAT_PD", Field { brief: Some("Status of pull-down calibration."), details: Some("0: Completed with no errors 1: Overflow error 2: Underflow errror 3: Calibration in progress"), lo: 2, hi: 4 });
        fields.insert("ZCAL_STAT_PU", Field { brief: Some("Status of pull-up calibration."), details: Some("0: Completed with no errors 1: Overflow error 2: Underflow errror 3: Calibration in progress"), lo: 4, hi: 6 });
        fields.insert("ZCAL_ZCTRL", Field { brief: Some("Current value of impedance control."), details: None, lo: 12, hi: 32 });
        regs.insert("MEMPHY_ZCAL_STAT", Register { addr: Address { base: 31, count: 1, width: 1 }, brief: Some("SSTL drive-strength status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FORCE_RELOAD", Field { brief: Some("Set this field to force the reload of the timer, this will set the TIMER_VALUE to TIMER_RELOAD_VALUE for the corresponding timer. This field can be set at the same time as enabeling the counter, in that case the counter will be reloaded and then enabled for counting."), details: None, lo: 0, hi: 1 });
        fields.insert("MAX_FREQ_ENA", Field { brief: Some("When set the timer will count continously (increment in each clock cycle) with out regard to the timer-tick generator. This feature is used for timing validation of the VCore system."), details: None, lo: 3, hi: 4 });
        fields.insert("ONE_SHOT_ENA", Field { brief: Some("When set the timer will automatically disable itself after it has generated interrupt."), details: None, lo: 2, hi: 3 });
        fields.insert("TIMER_ENA", Field { brief: Some("When enabled, the correponding timer decrements at each timer-tick. If TIMER_CTRL.ONE_SHOT_ENA is set this field is cleared when the timer reach 0 and interrupt is generated."), details: Some("0: Timer is disabled 1: Timer is enabled"), lo: 1, hi: 2 });
        regs.insert("TIMER_CTRL", Register { addr: Address { base: 8, count: 3, width: 1 }, brief: Some("Timer control"), details: None, fields });
        groups.insert("MEMCTRL", RegisterGroup { addr: Address { base: 76, count: 1, width: 34 }, desc: "DDR2/3 memory controller", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("MEMACC_START", Field { brief: Some("Starting 32-bit word address when loading or examining the onchip 8051 memory."), details: None, lo: 2, hi: 16 });
        fields.insert("MEMACC_STOP", Field { brief: Some("Ending 32-bit word address when loading or examining the onchip 8051 memory, the value of this field must be equal to or higher than the MEMACC.MEMACC_START field."), details: None, lo: 18, hi: 32 });
        regs.insert("MEMACC", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("8051 memory offset configuration"), details: Some("When loading (or examining) onchip 8051 memory, then it is only possible to move 32-bit words. This is why bits [17:16] and [1:0] of this register is not implemented. Setting START and STOP addresses determines how many words that are loaded (or examined). For example, when loading programs of less than 64KBytes, decreasing the stop address will speed up the load time. When manually loading or examining the onchip 8051 memory via an external CPU the data has to be put somewhere in SBA memory space on its way into or out-of the onchip 8051 memory, for this the 8 x 32-bit general purpose registers starting at 0x70000000 is a good choice. By using all (or some) of these registers it is possible to move up to 8 32-bit words to/from the onchip memory per access."), fields });
        let mut fields = HashMap::new();
        fields.insert("MEMACC_DO", Field { brief: Some("Set this field to start an access with the parameters specified by MEMACC_CTRL.MEMACC_EXAMINE, MEMACC.MEMACC_START, MEMACC.MEMACC_STOP, and MEMACC_SBA.MEMACC_SBA_START. This field is cleared when the requested number of 32-bit words has been transfered."), details: None, lo: 0, hi: 1 });
        fields.insert("MEMACC_EXAMINE", Field { brief: Some("This field controls if the onchip 8051 memory is either loaded (written) or examined (read)."), details: Some("0: Load data from SBA to onchip memory. 1: Examine data from onchip memory to SBA."), lo: 1, hi: 2 });
        regs.insert("MEMACC_CTRL", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("8051 memory load/examine configuration/status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MEMACC_SBA_START", Field { brief: Some("This field determines where in the SBA memory space (32-bit alligned) the automatic load/examine mechanims reads/writes data to/from the onchip 8051 memory."), details: None, lo: 2, hi: 32 });
        regs.insert("MEMACC_SBA", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("SBA memory offset configuration"), details: Some("There is no stop address in the SBA address space. The number of 32-bit words which is moved per access is determined by the MEMACC.MEMACC_START and MEMACC.MEMACC_STOP."), fields });
        let mut fields = HashMap::new();
        fields.insert("UART_SYS_ENA", Field { brief: Some("This field controls if the VCore UART or the 8051's internal UART is conencted to the chip IOs. The default, when the UART is always used. By clearing this field the 8051's internal UART will be connected to the chip IOs, this field only applies to an 8051 enabled system - clearing this field has no effect in a MIPS based VCore System."), details: None, lo: 0, hi: 1 });
        regs.insert("MPU8051_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("8051 configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MAP_CODE_HIGH", Field { brief: Some("Set to map 8051 code-accesses in the high 32KByte memory range to on-chip memory instead of FLASH."), details: None, lo: 3, hi: 4 });
        fields.insert("MAP_CODE_LOW", Field { brief: Some("Set to map 8051 code-accesses in the low 32KByte memory range to on-chip memory instead of FLASH."), details: None, lo: 2, hi: 3 });
        fields.insert("MAP_DATA_HIGH", Field { brief: Some("Set to map 8051 data-accesses in the high 32KByte memory range to on-chip memory instead of FLASH."), details: None, lo: 1, hi: 2 });
        fields.insert("MAP_DATA_LOW", Field { brief: Some("Set to map 8051 data-accesses in the low 32KByte memory range to on-chip memory instead of FLASH."), details: None, lo: 0, hi: 1 });
        fields.insert("MSADDR_CODE_HIGH", Field { brief: Some("Configure which half of the on-chip memory an 8051 data-accesses in the low 32KByte memory range (when mapped to on-chip memory) actually use. When set to 0, the low half of the on-chip 64KByte is accessed, when set to 1 the high half is accessed."), details: None, lo: 7, hi: 8 });
        fields.insert("MSADDR_CODE_LOW", Field { brief: Some("Configure which half of the on-chip memory an 8051 code-accesses in the low 32KByte memory range (when mapped to on-chip memory) actually use. When set to 0, the low half of the on-chip 64KByte is accessed, when set to 1 the high half is accessed."), details: None, lo: 6, hi: 7 });
        fields.insert("MSADDR_DATA_HIGH", Field { brief: Some("Configure which half of the on-chip memory an 8051 data-accesses in the high 32KByte memory range (when mapped to on-chip memory) actually use. When set to 0, the low half of the on-chip 64KByte is accessed, when set to 1 the high half is accessed."), details: None, lo: 5, hi: 6 });
        fields.insert("MSADDR_DATA_LOW", Field { brief: Some("Configure which half of the on-chip memory an 8051 data-accesses in the low 32KByte memory range (when mapped to on-chip memory) actually use. When set to 0, the low half of the on-chip 64KByte is accessed, when set to 1 the high half is accessed."), details: None, lo: 4, hi: 5 });
        regs.insert("MPU8051_MMAP", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("8051 memory mapping mechanism"), details: Some("The MAP_* and MSADDR_* fields in this register is similar to the corresponding 8051 SFR register for control mapping the on-chip memory into the 8051 memory space. These fields must be used to configure 8051 memory mapping if the 8051 on-chip memory is loaded manually via an external processor. If the 8051 program itself does loading of on-chip memory then it must instead use the SFR equivalents."), fields });
        let mut fields = HashMap::new();
        fields.insert("MPU8051_GPR", Field { brief: Some("A read-only copy of the 8051 GPR register at SFR address 0xF0."), details: None, lo: 0, hi: 8 });
        fields.insert("MPU8051_SBA_ERR", Field { brief: Some("This field is set if the 8051 get a shared bus error while fetching code or data from offchip memory, this field can only be cleared by a reset of the 8051."), details: None, lo: 9, hi: 10 });
        fields.insert("MPU8051_STOP", Field { brief: Some("Set when the 8051 has stopped itself by setting bit 2 in the PCON SFR register."), details: None, lo: 8, hi: 9 });
        regs.insert("MPU8051_STAT", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("8051 status"), details: Some("These read only fields can be used for debugging 8051 programs."), fields });
        let mut fields = HashMap::new();
        fields.insert("SW_PIN_CTRL_MODE", Field { brief: Some("Set to enable software pin control mode (Bit banging), when set software has direct control of the SPI interface. This mode is used for writing into flash."), details: None, lo: 13, hi: 14 });
        fields.insert("SW_SPI_CS", Field { brief: Some("Value to drive on SI_nEn outputs, each bit in this field maps to a corresponding chip-select (0 though 3). This field is only used if SW_MODE.SW_PIN_CTRL_MODE is set. Note: Chip selects 1 though 3 are available as alternate GPIO functions."), details: None, lo: 5, hi: 9 });
        fields.insert("SW_SPI_CS_OE", Field { brief: Some("This field has not effect, chip selects are always driven."), details: None, lo: 1, hi: 5 });
        fields.insert("SW_SPI_SCK", Field { brief: Some("Value to drive on SI_Clk output. This field is only used if SW_MODE.SW_PIN_CTRL_MODE is set."), details: None, lo: 12, hi: 13 });
        fields.insert("SW_SPI_SCK_OE", Field { brief: Some("Set to enable drive of SI_Clk output. This field is only used if SW_MODE.SW_PIN_CTRL_MODE is set."), details: None, lo: 11, hi: 12 });
        fields.insert("SW_SPI_SDI", Field { brief: Some("Current value of the SI_DI input."), details: None, lo: 0, hi: 1 });
        fields.insert("SW_SPI_SDO", Field { brief: Some("Value to drive on SI_DO output. This field is only used if SW_MODE.SW_PIN_CTRL_MODE is set."), details: None, lo: 10, hi: 11 });
        fields.insert("SW_SPI_SDO_OE", Field { brief: Some("Set to enable drive of SI_DO output. This field is only used if SW_MODE.SW_PIN_CTRL_MODE is set."), details: None, lo: 9, hi: 10 });
        regs.insert("SW_MODE", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Manual control of the SPI interface"), details: Some("Note: There are 4 chip selects in total, but only chip select 0 is mapped to IO-pin (SI_nEn). The rest of the SPI chip selects are available as alternate functions on GPIOs, these must be enabled in the GPIO controller before they can be controlled via this register."), fields });
        groups.insert("MPU8051", RegisterGroup { addr: Address { base: 21, count: 1, width: 7 }, desc: "Configuration/status for the 8051", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CH_INJ_CNT", Field { brief: Some("The number of injection channels."), details: None, lo: 8, hi: 16 });
        fields.insert("CH_XTR_CNT", Field { brief: Some("The number of extraction channels."), details: None, lo: 0, hi: 8 });
        regs.insert("FDMA_CONST", Register { addr: Address { base: 112, count: 1, width: 1 }, brief: Some("Constants for this FDMA implementation."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BAR1_MASK", Field { brief: Some("See ICPU_CFG::PCIEMST_BAR1_OFFSET.BAR1_OFFSET for more information."), details: None, lo: 8, hi: 32 });
        regs.insert("PCIEMST_BAR1_MASK", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("BAR1 offset mask into SBA address space"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BAR1_OFFSET", Field { brief: Some("PCIe BAR1 is a 16MByte region that, by default maps to FLASH memory space. It can be reconfigured to point at an other region in SBA by using this field. The upper 24 bit of the address can be overwritten by setting this field. The corresponding mask-field determines which bits to actually overwrite (see ICPU_CFG::PCIEMST_BAR1_MASK.BAR1_MASK), the default-value of the mask field \"enables\" the upper 8 bit of this field."), details: None, lo: 8, hi: 32 });
        regs.insert("PCIEMST_BAR1_OFFSET", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("BAR1 offset into SBA address space"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BAR2_MASK", Field { brief: Some("See ICPU_CFG::PCIEMST_BAR2_OFFSET.BAR2_OFFSET for more information."), details: None, lo: 24, hi: 32 });
        regs.insert("PCIEMST_BAR2_MASK", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("BAR2 offset mask into SBA address space"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BAR2_OFFSET", Field { brief: Some("PCIe BAR2 is a 128MByte region that, by default maps to DDR interface. It can be reconfigured to point at an other region in SBA by using this field. The upper 8 bit of the address can be overwritten by setting this field. The corresponding mask-field determines which bits to actually overwrite (see ICPU_CFG::PCIEMST_BAR2_MASK.BAR2_MASK), the default-value of the mask field \"enables\" the upper 5 bit of this field."), details: None, lo: 24, hi: 32 });
        regs.insert("PCIEMST_BAR2_OFFSET", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("BAR2 offset into SBA address space"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MST_REPLY_INFO", Field { brief: Some("This field allows additional PCIe-transaction settings in addition to those provided via SBA. The settings in this register is applied to all PCIe inbound accesses."), details: Some("[0] SBA Response with bad EOT. Cause drop of inbound response. [1] EP-field. [2] TD-field. [4:3] Reserved, must be \"01\"."), lo: 0, hi: 5 });
        regs.insert("PCIEMST_REPLY_INFO", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Additional inbound reply information"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BEACON_MAX_DIS", Field { brief: Some("Set to disable the BEACON_MAX_DLY feature, when set beacon will be generated until reply from upsteam port is received."), details: None, lo: 15, hi: 16 });
        fields.insert("BEACON_MAX_DLY", Field { brief: Some("Set this field to the maximum number of PCIe (transmit) clock cycles for which beacon may be asserted. The standard says beacon must not be asserted for longer than 32 us."), details: None, lo: 0, hi: 15 });
        fields.insert("BEACON_VAL", Field { brief: Some("10bit value to transmit during PCIe-beacon signaling, if 0x3E becaon will be 250Mhz alternating signal. Special, if all-zeros PCS will generate a 125MHz alternating signal."), details: None, lo: 16, hi: 26 });
        regs.insert("PCIEPCS_BEACON", Register { addr: Address { base: 13, count: 1, width: 1 }, brief: Some("PCIe beacon parameters"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BEACON_DIS", Field { brief: Some("Set this field to disable outband PCIe beacon signalling when attempting to wake from D3. When beacon is disabled the WAKE# signal (available as alternate GPIO function) must be used instead."), details: None, lo: 0, hi: 1 });
        fields.insert("BEACON_FORCE", Field { brief: Some("Set this field to force beacon signal to be transmitted on serdes output."), details: None, lo: 18, hi: 19 });
        fields.insert("IDLE_DATA_DIS", Field { brief: Some("Set this field to disable drive of constant TBI data (zeros) during IDLE indication."), details: None, lo: 8, hi: 9 });
        fields.insert("IDLE_DIS", Field { brief: Some("Set this field to disable support for outband idle signalling."), details: None, lo: 7, hi: 8 });
        fields.insert("IDLE_DLY", Field { brief: Some("Set this field allows skewing TBI DATA vs. IDLE signals. When configured to -1 then IDLE_DATA_DIS will also need to be set, else first symbol transmitted will just be 0s'."), details: Some("0: No delay of IDLE. 1: Delay IDLE by 1 symbol. 2: Delay IDLE by 2 symbols. 3: Delay IDLE by -1 symbol (is delaying data by 1 symbol)."), lo: 5, hi: 7 });
        fields.insert("RXINV_ENA", Field { brief: Some("Set to enable RX inversion from serdes to PCS block. This is for test only, the PCS handles inversion internally when ever this is requested by the PCIe MAC."), details: None, lo: 11, hi: 12 });
        fields.insert("RXLP_FORCE", Field { brief: Some("Set this field to (always) signal receive lowpower towards the serdes."), details: None, lo: 4, hi: 5 });
        fields.insert("RXRST_FORCE", Field { brief: Some("Set this field to force the value of the receive reset from serdes to PCS to the value of ICPU_CFG::PCIEPCS_CFG.RXRST_VAL."), details: None, lo: 17, hi: 18 });
        fields.insert("RXRST_VAL", Field { brief: Some("See ICPU_CFG::PCIEPCS_CFG.RXRST_FORCE for more information."), details: Some("0: Reset is asserted 1: Reset is not asserted"), lo: 16, hi: 17 });
        fields.insert("RXSDET_FORCE", Field { brief: Some("Set this field to force the value of the signal-detect from serdes to PCS to the value of ICPU_CFG::PCIEPCS_CFG.RXSDET_XOR."), details: None, lo: 12, hi: 13 });
        fields.insert("RXSDET_XOR", Field { brief: Some("Set this field to invert the value of the signal-detect from serdes to PCS."), details: None, lo: 13, hi: 14 });
        fields.insert("RXSWAP_ENA", Field { brief: Some("Set this field to swap TBI from serdes to PCS block (crossover bit 0 to 9, 1 to 8, etc.)"), details: None, lo: 10, hi: 11 });
        fields.insert("SDETCOM_DIS", Field { brief: Some("Set to disable reset of comma-detection logic when loss of rx signal is \"detected\"."), details: None, lo: 19, hi: 20 });
        fields.insert("SDETCOM_PERM", Field { brief: Some("Set to enable contineous reset of comma-detection logic during loss of rx signal. SDETCOM_DIS must be cleared for this to work."), details: None, lo: 20, hi: 21 });
        fields.insert("TXLP_FORCE", Field { brief: Some("Set this field to (always) signal transmit lowpower towards the serdes."), details: None, lo: 3, hi: 4 });
        fields.insert("TXRST_FORCE", Field { brief: Some("Set this field to force the value of the transmit reset from serdes to PCS to the value of ICPU_CFG::PCIEPCS_CFG.TXRST_VAL."), details: None, lo: 15, hi: 16 });
        fields.insert("TXRST_VAL", Field { brief: Some("See ICPU_CFG::PCIEPCS_CFG.TXRST_FORCE for more information."), details: Some("0: Reset is asserted 1: Reset is not asserted"), lo: 14, hi: 15 });
        fields.insert("TXRX_DETECT", Field { brief: Some("Configure receiver detection result (when requested by PCIe MAC on pipe-if)"), details: Some("0: Receiver detected 1: Receiver not detected"), lo: 21, hi: 22 });
        fields.insert("TXSWAP_ENA", Field { brief: Some("Set this field to swap TBI from PCS to serdes block (crossover bit 0 to 9, 1 to 8, etc.)"), details: None, lo: 9, hi: 10 });
        fields.insert("WAKE_OE", Field { brief: Some("Set to permanently drive PCIe WAKE output, by default the WAKE output is only driven when active and thusly allowing pull-resistor network."), details: Some("0: Only drive output when active. 1: Always drive output."), lo: 1, hi: 2 });
        fields.insert("WAKE_POL", Field { brief: Some("Polarity of the PCIe WAKE output, WAKE is typically an active low output - but if an amplifier is needed for driving a large WAKE net then polarity may need to be changed."), details: Some("0: Active low 1: Active high"), lo: 2, hi: 3 });
        regs.insert("PCIEPCS_CFG", Register { addr: Address { base: 12, count: 1, width: 1 }, brief: Some("PCIe PCS configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FDMA_ATTR", Field { brief: Some("This field allows configuration of outbound PCIe-transaction ATTR field. This is applied to all FDMA initiated outbound PCIe accesses."), details: None, lo: 2, hi: 4 });
        fields.insert("FDMA_OFFSET", Field { brief: Some("The FDMA has access to one 1GByte region (0xC0000000 though 0xFFFFFFFF) that maps accesses to PCIe interface. The value of this field is used for address-bits [31:30] towards the PCIe endpoint."), details: Some("Set this field to 1."), lo: 0, hi: 2 });
        fields.insert("FDMA_TC", Field { brief: Some("This field allows configuration of outbound PCIe-transaction TC field. This is applied to all FDMA initiated outbound PCIe accesses."), details: None, lo: 4, hi: 7 });
        regs.insert("PCIESLV_FDMA", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("FDMA access into PCIe address space"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SBA_ATTR", Field { brief: Some("This field allows configuration of outbound PCIe-transaction ATTR field. This is applied to all SBA (non-FDMA) initiated outbound PCIe accesses."), details: None, lo: 10, hi: 12 });
        fields.insert("SBA_BE", Field { brief: Some("This field allows configuration of outbound PCIe-transaction Byte-Enable field. This is applied to all SBA (non-FDMA) initiated outbound PCIe accesses. This field is not used for TYPE=MRr/MWr/MRdLk accesses. Byte-enables are needed in order to support Zero-byte and non-contiguous byte IO and CFG transfers and Zero-byte Messages."), details: None, lo: 24, hi: 28 });
        fields.insert("SBA_EP", Field { brief: Some("This field allows configuration of outbound PCIe-transaction EP field. This is applied to all SBA (non-FDMA) initiated outbound PCIe accesses."), details: None, lo: 8, hi: 9 });
        fields.insert("SBA_MSG_CODE", Field { brief: Some("This field allows configuration of outbound PCIe-transaction MSG field. This is applied to all SBA (non-FDMA) initiated outbound PCIe accesses."), details: None, lo: 15, hi: 23 });
        fields.insert("SBA_OFFSET", Field { brief: Some("SBA masters (non-FDMA) has access to one 1GByte region (0xC0000000 though 0xFFFFFFFF) that maps accesses to PCIe interface. The value of this field is used for address-bits [31:30] towards the PCIe endpoint."), details: Some("Set this field to 0."), lo: 0, hi: 2 });
        fields.insert("SBA_RESERVED0", Field { brief: Some("Reserved, must be 0."), details: None, lo: 7, hi: 8 });
        fields.insert("SBA_RESERVED1", Field { brief: Some("Reserved, must be 0."), details: None, lo: 23, hi: 24 });
        fields.insert("SBA_TC", Field { brief: Some("This field allows configuration of outbound PCIe-transaction TC field. This is applied to all SBA (non-FDMA) initiated outbound PCIe accesses."), details: None, lo: 12, hi: 15 });
        fields.insert("SBA_TD", Field { brief: Some("This field allows configuration of outbound PCIe-transaction TD field. This is applied to all SBA (non-FDMA) initiated outbound PCIe accesses."), details: None, lo: 9, hi: 10 });
        fields.insert("SBA_TYPE", Field { brief: Some("This field allows configuration of outbound PCIe-transaction TYPE field. This is applied to all SBA (non-FDMA) initiated outbound PCIe accesses."), details: Some("Encoding as defined by PCIe standard."), lo: 2, hi: 7 });
        regs.insert("PCIESLV_SBA", Register { addr: Address { base: 11, count: 1, width: 1 }, brief: Some("SBA access into PCIe address space"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("AUX_POWER_VAL", Field { brief: Some("Set to force \"detection\" of PCIe auxiliary power."), details: None, lo: 0, hi: 1 });
        regs.insert("PCIE_AUX_CFG", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Auxiliary power configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CG_DIS", Field { brief: Some("Set to disable clock gating requests from PCIe core."), details: None, lo: 5, hi: 6 });
        fields.insert("CONF_REQ_RETRY_ENA", Field { brief: Some("Set to defer incomming configuration requests with a Configuration Request Retry Status."), details: None, lo: 3, hi: 4 });
        fields.insert("LTSSM_DIS", Field { brief: Some("Set this field to disable initliazation of the PCIe link. By default the PCIe core will start up and try to acchieve link when the SERDES is started, by setting this field before starting the SERDES it is possible to make changes to the PCIe configruration/registers prior to linking with the root complex."), details: None, lo: 1, hi: 2 });
        fields.insert("MEM_CG_DIS", Field { brief: Some("Set to disable clock gating in PCIe core memories."), details: None, lo: 4, hi: 5 });
        fields.insert("MEM_RING_CORE_ENA", Field { brief: Some("Set to add the PCIe core memories to the RAM integrity ring."), details: None, lo: 0, hi: 1 });
        fields.insert("PCIE_BAR_WR_ENA", Field { brief: Some("Set this field to enable write of PCIe BAR masks via PCIE register target. Only registers PCIE::BAR0, PCIE::BAR1, and PCIE::BAR2 may be written while this field is set. The minimum size for Memory and IO BARs are 64K (mask 0xFFFF). Note: The low 4 bits of all BARs can be written via the PCIe target when this field is not set."), details: None, lo: 2, hi: 3 });
        regs.insert("PCIE_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("PCIe endpoint configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("POWERUP", Field { brief: Some("Set this field to send out PME from the controller, this is only possible if PME is enabled in the PCIe EP core. This field is cleared automatically after controller has received the request. In the D3 state the controller will transmit beacon and/or assert #WAKE (see ICPU_CFG::PCIEPCS_CFG.BEACON_DIS for more information). In other states the link will be transitioned to L0 (when applicable) and PME event will then be transmitted upsteam."), details: None, lo: 0, hi: 1 });
        regs.insert("PCIE_CTRL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("PCIe endpoint control"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DATA_LINK_LAYER_UP", Field { brief: Some("Set when the PCIe Data Link Layer is up and ready to receive/transmit packages. This value is read directly from other clock domain, keep reading until same value was read twice in a row - then read was sucessful."), details: None, lo: 0, hi: 1 });
        fields.insert("PM_L2_EXIT", Field { brief: Some("Set when the Power Management is exiting L2 state. This value is read directly from other clock domain, keep reading until same value was read twice in a row - then read was sucessful."), details: None, lo: 1, hi: 2 });
        fields.insert("TBI_RX_CE", Field { brief: Some("This field is set when the PCIe receive path detects 8b10b decoder errors."), details: None, lo: 14, hi: 15 });
        fields.insert("TBI_RX_DATA", Field { brief: Some("This field just returns the TBI DATA value returned from the Serdes macro. This field is read directly from another clock domain, during normal operation the value presented in this field will be garbage."), details: None, lo: 2, hi: 12 });
        fields.insert("TBI_RX_LOS", Field { brief: Some("This field is a sticky loss of signal indication that is set whenever ICPU_CFG::PCIE_DBG_STAT.TBI_RX_SDET is low."), details: None, lo: 13, hi: 14 });
        fields.insert("TBI_RX_SDET", Field { brief: Some("This field returns the TBI SDET value returned from the Serdes macro."), details: None, lo: 12, hi: 13 });
        regs.insert("PCIE_DBG_STAT", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("PCIe endpoint debug status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INTR_BAR1_RD", Field { brief: Some("This event is set whenever an external CPU reads from BAR1 region."), details: None, lo: 1, hi: 2 });
        fields.insert("INTR_BAR1_WR", Field { brief: Some("This event is set whenever an external CPU writes to BAR1 region."), details: None, lo: 2, hi: 3 });
        fields.insert("INTR_LINK_STATE", Field { brief: Some("This event is set whenever the ICPU_CFG::PCIE_STAT.LINK_STATE field is changed."), details: None, lo: 3, hi: 4 });
        fields.insert("INTR_LTSSM_STATE", Field { brief: Some("This event is set whenever the ICPU_CFG::PCIE_STAT.LTSSM_STATE field is changed."), details: None, lo: 4, hi: 5 });
        fields.insert("INTR_PM_STATE", Field { brief: Some("This event is set whenever the ICPU_CFG::PCIE_STAT.PM_STATE field is changed."), details: None, lo: 0, hi: 1 });
        regs.insert("PCIE_INTR", Register { addr: Address { base: 14, count: 1, width: 1 }, brief: Some("PCIe events"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FALLING_VECTOR_VAL", Field { brief: Some("Configure MSI interrupt vector for falling edge of corresponding EXT_DST interrupt."), details: None, lo: 7, hi: 12 });
        fields.insert("FUNCTION_NUMBER", Field { brief: Some("Reserved, must be 0."), details: None, lo: 15, hi: 18 });
        fields.insert("INTR_FALLING_ENA", Field { brief: Some("Set to enable MSI interrupt on falling edge of corresponding EXT_DST interrupt."), details: None, lo: 1, hi: 2 });
        fields.insert("INTR_RISING_ENA", Field { brief: Some("Set to enable MSI interrupt on rising edge of corresponding EXT_DST interrupt."), details: None, lo: 0, hi: 1 });
        fields.insert("RISING_VECTOR_VAL", Field { brief: Some("Configure MSI interrupt vector for rising edge of corresponding EXT_DST interrupt."), details: None, lo: 2, hi: 7 });
        fields.insert("TRAFFIC_CLASS", Field { brief: Some("Configure MSI interrupt traffic class for corresponding EXT_DST interrupt."), details: None, lo: 12, hi: 15 });
        regs.insert("PCIE_INTR_CFG", Register { addr: Address { base: 18, count: 2, width: 1 }, brief: Some("PCIe outbound MSI interrupt configuration"), details: Some("Replicated per EXT_DST interrupt."), fields });
        let mut fields = HashMap::new();
        fields.insert("LEGACY_MODE_INTR_SEL", Field { brief: Some("Select the external interrupt from the VCore interrupt controller that must be used to generate PCIe legacy interrupt."), details: Some("0: Use EXT_DST0 1: Use EXT_DST1"), lo: 1, hi: 2 });
        fields.insert("PCIE_INTR_ENA", Field { brief: Some("Set to enable PCIe interrupts. The PCIe endpoint's MSI Capability Register Set must have been configured before enabling interrupts."), details: None, lo: 0, hi: 1 });
        fields.insert("WAKEUP_ON_INTR_DIS", Field { brief: Some("Set to disable wake-up on interrupt. By default the PCIe endpoint will attempt to wake up from powerdown when a change in interrupt state is detected."), details: None, lo: 2, hi: 3 });
        regs.insert("PCIE_INTR_COMMON_CFG", Register { addr: Address { base: 17, count: 1, width: 1 }, brief: Some("PCIe outbound interrupt configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INTR_BAR1_RD_ENA", Field { brief: Some("Set to enable propagation of the BAR1_RD interrupt."), details: None, lo: 1, hi: 2 });
        fields.insert("INTR_BAR1_WR_ENA", Field { brief: Some("Set to enable propagation of the BAR1_WR interrupt."), details: None, lo: 2, hi: 3 });
        fields.insert("INTR_LINK_STATE_ENA", Field { brief: Some("Set to enable propagation of the LINK_STATE interrupt."), details: None, lo: 3, hi: 4 });
        fields.insert("INTR_LTSSM_STATE_ENA", Field { brief: Some("Set to enable propagation of the LTSSM_STATE interrupt."), details: None, lo: 4, hi: 5 });
        fields.insert("INTR_PM_STATE_ENA", Field { brief: Some("Set to enable propagation of the PM_STATE interrupt."), details: None, lo: 0, hi: 1 });
        regs.insert("PCIE_INTR_ENA", Register { addr: Address { base: 15, count: 1, width: 1 }, brief: Some("PCIe interrupt enable"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INTR_BAR1_RD_IDENT", Field { brief: Some("Set if the BAR1_RD interrupt is currently active."), details: None, lo: 1, hi: 2 });
        fields.insert("INTR_BAR1_WR_IDENT", Field { brief: Some("Set if the BAR1_WR interrupt is currently active."), details: None, lo: 2, hi: 3 });
        fields.insert("INTR_LINK_STATE_IDENT", Field { brief: Some("Set if the LINK_STATE interrupt is currently active."), details: None, lo: 3, hi: 4 });
        fields.insert("INTR_LTSSM_STATE_IDENT", Field { brief: Some("Set if the LTSSM_STATE interrupt is currently active."), details: None, lo: 4, hi: 5 });
        fields.insert("INTR_PM_STATE_IDENT", Field { brief: Some("Set if the PM_STATE interrupt is currently active."), details: None, lo: 0, hi: 1 });
        regs.insert("PCIE_INTR_IDENT", Register { addr: Address { base: 16, count: 1, width: 1 }, brief: Some("Currently active PCIe interrupts"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LINK_STATE", Field { brief: Some("Current Link State of the PCIe core."), details: Some("0: L0 (or not working, check LTSSM) 1: L0s 2: L1 3: L2 4: L3"), lo: 3, hi: 6 });
        fields.insert("LTSSM_STATE", Field { brief: Some("The current LTSSM state of the PCIe core."), details: Some("0x00: DETECT_QUIET 0x01: DETECT_ACT 0x02: POLL_ACTIVE 0x03: POLL_COMPLIANCE 0x04: POLL_CONFIG 0x05: PRE_DETECT_QUIET 0x06: DETECT_WAIT 0x07: CFG_LINKWD_START 0x08: CFG_LINKWD_ACEPT 0x09: CFG_LANENUM_WAIT 0x0A: CFG_LANENUM_ACEPT 0x0B: CFG_COMPLETE 0x0C: CFG_IDLE 0x0D: RCVRY_LOCK 0x0E: RCVRY_SPEED 0x0F: RCVRY_RCVRCFG 0x10: RCVRY_IDLE 0x20: RCVRY_EQ0 0x21: RCVRY_EQ1 0x22: RCVRY_EQ2 0x23: RCVRY_EQ3 0x11: L0 0x12: L0S 0x13: L123_SEND_EIDLE 0x14: L1_IDLE 0x15: L2_IDLE 0x16: L2_WAKE 0x17: DISABLED_ENTRY 0x18: DISABLED_IDLE 0x19: DISABLED 0x1A: LPBK_ENTRY 0x1B: LPBK_ACTIVE 0x1C: LPBK_EXIT 0x1D: LPBK_EXIT_TIMEOUT 0x1E: HOT_RESET_ENTRY 0x1F: HOT_RESET"), lo: 6, hi: 12 });
        fields.insert("PM_STATE", Field { brief: Some("The current power managment state of the PCIe core."), details: Some("0: D0 1: D1 2: D2 3: D3 4: D0-Uninitialized"), lo: 0, hi: 3 });
        fields.insert("SLV_ERROR_REPLY", Field { brief: Some("Set when the PCIe outbound request interface returns a non-ok SBA reply, ie. ERROR."), details: None, lo: 12, hi: 13 });
        regs.insert("PCIE_STAT", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("PCIe endpoint status"), details: None, fields });
        groups.insert("PCIE", RegisterGroup { addr: Address { base: 225, count: 1, width: 22 }, desc: "PCIe endpoint", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CPU_SLEEP", Field { brief: Some("This field is set if the VCore CPU has entered sleep mode."), details: None, lo: 0, hi: 1 });
        fields.insert("PI_SLV_RD_ERR", Field { brief: Some("This field is set if the PI slave interface has received error indication from the SBA fabric during a read access. The PI slave will have returned 0x88888888 for the offending read."), details: None, lo: 8, hi: 9 });
        fields.insert("PI_SLV_WR_ERR", Field { brief: Some("This field is set if the PI slave interface has received error indication from the SBA fabric during a write access."), details: None, lo: 9, hi: 10 });
        fields.insert("REG_IF_ERR", Field { brief: Some("Debug information for checking register read/write problems. This is a read-only field which can only be cleared by reset of the VCore System."), details: Some("0: No errors detected. 1: Non-32bit access to VCore or SwC registers, access has been discarded, read returns 0x8888 or 0x88. 2: SwC registers not ready when accessed, access has been discarded, read returns 0x88888888. 3: SwC registers reported error, check DEVCPU_ORG::ERR_CNTS for error, read returns 0x88888888. 4: Unimplemented VCore register, access has been discarded, read returns 0x88888888."), lo: 1, hi: 4 });
        fields.insert("VCORE_CFG", Field { brief: Some("Shows the value of the VCore Cfg strapping inputs."), details: None, lo: 4, hi: 8 });
        regs.insert("GENERAL_STAT", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("General status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ATE_MODE_DIS", Field { brief: Some("Disable Automatic Tester Equipment mode for the parallel interface. This mode is used during production testing for controlled loading of CPU."), details: None, lo: 7, hi: 8 });
        fields.insert("CLK_DIV", Field { brief: Some("Controls the clock for the PI Controller. Setting this field to 0 or 1 value is illegal."), details: Some("The PI interface frequency is: 250MHz/CLK_DIV."), lo: 0, hi: 5 });
        fields.insert("CLK_POL", Field { brief: Some("Controls the clock-polarity of the PI Master."), details: Some("0: Rising edge of the clock sets and samples signals. 1: Falling edge of the clock sets and samples signals."), lo: 6, hi: 7 });
        fields.insert("TRISTATE_CTRL", Field { brief: Some("Controls drive of address and control signals between transfers. See also PI_MST_CTRL.CS_TRISTATE_CTRL."), details: Some("0: Address and control signals are high-Z between transfers. 1: Address and control signals are driven between transfers."), lo: 5, hi: 6 });
        regs.insert("PI_MST_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("PI Master Configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CSCC", Field { brief: Some("Number of PI_Clk cycles from address driven to PI_nCS[x] low."), details: None, lo: 5, hi: 7 });
        fields.insert("CS_TRISTATE_CTRL", Field { brief: Some("Controls drive of PI_nCS[x] between transfers."), details: Some("0: PI_nCS[x] is high-Z between transfers. 1: PI_nCS[x] is driven inactive between transfers."), lo: 17, hi: 18 });
        fields.insert("DEVICE_PACED_TIMEOUT", Field { brief: Some("Determines the number of PI_Clk cycles from the start of a transfer until a timeout occurs. This field is only valid when timeout for device-paced transfer is enabled."), details: Some("000: 16 PI_Clk cycles 001: 32 PI_Clk cycles 010: 64 PI_Clk cycles 011: 128 PI_Clk cycles 100: 256 PI_Clk cycles 101: 512 PI_Clk cycles 110: 1024 PI_Clk cycles 111: 2048 PI_Clk cycles"), lo: 18, hi: 21 });
        fields.insert("DEVICE_PACED_TIMEOUT_ENA", Field { brief: Some("Enable timeout on device-paced transfers. If enabled, a device_paced_transfer transfer does not wait indefinitely for assertion of PI_nDone. If a timeout occurs, the TIMEOUT_ERR_STICKY bit is set in the status register and the current transfer is terminated (read-data will be invalid)."), details: None, lo: 21, hi: 22 });
        fields.insert("DEVICE_PACED_XFER_ENA", Field { brief: Some("Device-paced transfer enable. When enabled, use PI_nDone to end a transfer."), details: Some("0: Disabled 1: Enabled"), lo: 22, hi: 23 });
        fields.insert("DONE_POL", Field { brief: Some("Polarity of PI_nDone for device-paced transfers."), details: Some("0: PI_nDone is active low 1: PI_nDone is active high"), lo: 16, hi: 17 });
        fields.insert("HLDCC", Field { brief: Some("Number of PI_Clk cycles to insert at the end of a transfer."), details: None, lo: 0, hi: 3 });
        fields.insert("OECC", Field { brief: Some("Number of PI_Clk cycles from PI_nCS[x] low to PI_nOE low."), details: None, lo: 3, hi: 5 });
        fields.insert("SMPL_ON_DONE", Field { brief: Some("Controls when data is sampled in relation to assertion of PI_nDone for device-paced reads."), details: Some("0: Data is sampled one PI_Clk cycle after PI_nDone goes active. 1: Data is sampled on the same PI_Clk cycle where PI_nDone goes active."), lo: 15, hi: 16 });
        fields.insert("WAITCC", Field { brief: Some("Number of wait states measured in PI_Clk cycles on both read and write transfers."), details: None, lo: 7, hi: 15 });
        regs.insert("PI_MST_CTRL", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("PI Master Control Register"), details: Some("This is a replicated register, where each replication holds the configurations for one chip select. Changes to a value in one of the replicated instances apply only to that chip select."), fields });
        let mut fields = HashMap::new();
        fields.insert("TIMEOUT_ERR_STICKY", Field { brief: Some("If a timeout is enabled and timeout occurs during a device-paced transfer, this bit is set."), details: None, lo: 0, hi: 1 });
        regs.insert("PI_MST_STATUS", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("PI Master Status Registers"), details: Some("This is a replicated register, where each replication holds the status for one chip select."), fields });
        groups.insert("PI_MST", RegisterGroup { addr: Address { base: 11, count: 1, width: 4 }, desc: "Parallel Interface Configuration", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("BIGENDIAN", Field { brief: Some("Set to configure PI interface for big-endian mode."), details: None, lo: 22, hi: 23 });
        fields.insert("CSWAIT", Field { brief: Some("Configures number of clock cycles after detecting asserted CS to control/data is sampled."), details: Some("n: Wait n clocks after detecting CS before sampling control/data."), lo: 0, hi: 8 });
        fields.insert("DONEPARK", Field { brief: Some("Configure a minimum number of cycles after release of NCS until ndone is no longer driven by device. The device will deassert ndone value when NCS is released, this setting allows parking of the ndone at inactive level before releasing drive of output."), details: Some("0: Immediate release of ndone (async path from CS input). n: Wait at least n+1 clocks after CS release until ndone is released."), lo: 16, hi: 22 });
        fields.insert("DONEPOL_SET", Field { brief: Some("Set this field to force the value in ICPU_CFG::PI_SLV_CFG.DONEPOL_VAL into ICPU_CFG::GENERAL_CTRL.IF_PI_SLV_DONEPOL. This field is immediately cleared."), details: None, lo: 23, hi: 24 });
        fields.insert("DONEPOL_VAL", Field { brief: Some("See ICPU_CFG::PI_SLV_CFG.DONEPOL_SET for more information."), details: None, lo: 24, hi: 25 });
        fields.insert("DONEWAIT", Field { brief: Some("Configures number of clock cycles to delay nDone indication for read operations after accerss is done."), details: Some("n: Wait n clocks after read data ready before asserting nDone indication."), lo: 8, hi: 16 });
        regs.insert("PI_SLV_CFG", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("PI Slave Configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("A32B_ENA", Field { brief: Some("Set to enable 32bit address mode. In 32bit addressing mode only CS0 is used, the SPI address region is limited to 256MByte reserved for the SI interface."), details: Some("0: Use 24bit addressing with 4 different CS. 1: Use 32bit addressing on CS0, max 256MByte"), lo: 11, hi: 12 });
        fields.insert("CLK_DIV", Field { brief: Some("Controls the clock frequency for the SPI interface (SI_Clk). The clock frequency is VCore system clock divided by the value of this field. Setting this field to 0 or 1 value is illegal."), details: Some("The SPI interface frequency is: 250MHz/CLK_DIV."), lo: 0, hi: 5 });
        fields.insert("CS_DESELECT_TIME", Field { brief: Some("The minimum number of SPI clock cycles for which the SPI chip select (SI_nEn) must be deasserted in between transfers. Typical value of this is 100 ns. Setting this field to 0 is illegal."), details: None, lo: 5, hi: 10 });
        fields.insert("FAST_READ_ENA", Field { brief: Some("The type of read-instruction that the SPI Controller generates for reads."), details: Some("0: READ (slow read - Instruction code - 0x03) 1: FAST READ (fast read - Instruction code - 0x0B)"), lo: 10, hi: 11 });
        regs.insert("SPI_MST_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("SPI boot master configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("UNSUP_ERR", Field { brief: Some("Upsupported operation has been performed on the SPI master from AHB slave."), details: None, lo: 0, hi: 1 });
        regs.insert("SPI_MST_STATUS", Register { addr: Address { base: 1, count: 4, width: 1 }, brief: Some("SPI boot master status"), details: Some("This is a replicated register, where each replication holds the status for one chip select."), fields });
        groups.insert("SPI_MST", RegisterGroup { addr: Address { base: 15, count: 1, width: 6 }, desc: "SPI boot master", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("DEV_INTR_IDENT1", Field { brief: Some("See ICPU_CFG::DEV_INTR_IDENT for description, this register holds bits above 32."), details: None, lo: 0, hi: 21 });
        regs.insert("DEV_INTR_IDENT1", Register { addr: Address { base: 36, count: 1, width: 1 }, brief: Some("Currently active device interrupts"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RELOAD_VAL", Field { brief: Some("The contents of this field are loaded into the corresponding timer (TIMER_VALUE) when it wraps (decrements a zero)."), details: None, lo: 0, hi: 32 });
        regs.insert("TIMER_RELOAD_VALUE", Register { addr: Address { base: 5, count: 3, width: 1 }, brief: Some("Timer reload value"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TIMER_TICK_DIV", Field { brief: Some("The timer tick generator runs from the VCore System frequency. By default, the divider value generates a timer tick every 100 us (10KHz). The timer tick is used for all of the timers (except the WDT). This field must not be set to generate a timer tick of less than 0.1 us (higher than 10MHz). If this field is changed, it may take up to 2ms before the timers are running stable at the new frequency."), details: Some("The timer tick frequency is: 250MHz/(TIMER_TICK_DIV+1)."), lo: 0, hi: 18 });
        regs.insert("TIMER_TICK_DIV", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Timer tick divider"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TIMER_VAL", Field { brief: Some("The current value of the timer. When enabled via TIMER_CTRL.TIMER_ENA the timer decrements at every timer tick (see TIMER_TICK_DIV for more info on timer tick frequency). When the timer has reached 0, and a timer-tick is received, then an interrupt is generated. For example; If a periodic interrupt is needed every 1ms, and the timer tick is generated every 100us then the TIMER_VALUE (and TIMER_RELOAD_VALUE) must be configured to 9. By default the timer will reload from the TIMER_RELOAD_VALUE when interrupt is generated, and then continue decrementing from the reloaded value. It is possible to make the timer stop after generating interrupt by setting TIMER_CTRL.ONE_SHOT_ENA."), details: None, lo: 0, hi: 32 });
        regs.insert("TIMER_VALUE", Register { addr: Address { base: 2, count: 3, width: 1 }, brief: Some("Timer value"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("WDT_ENABLE", Field { brief: Some("Use this field to enable or disable the watchdog timer. When the WDT is enabled, it causes a reset after 2 seconds if it is not periodically reset. This field is only read by the WDT after a sucessful lock sequence (see ICPU_CFG::WDT.WDT_LOCK)."), details: Some("0: WDT is disabled 1: WDT is enabled"), lo: 8, hi: 9 });
        fields.insert("WDT_LOCK", Field { brief: Some("Use this field to configure and reset the WDT. When writing 0xBE to this field immediately followed by writing 0xEF, the WDT resets and configurations are read from this register (as provided when the 0xEF is written). When the WDT is enabled, writing any value other than 0xBE or 0xEF after 0xBE is written, causes a WDT reset as if the timer had run out."), details: None, lo: 0, hi: 8 });
        fields.insert("WDT_STATUS", Field { brief: Some("Shows whether the last reset was caused by a watchdog timer reset. This field is updated during reset, therefore it is always valid."), details: Some("0: Reset was not caused by WDT 1: Reset was caused by WDT timeout"), lo: 9, hi: 10 });
        regs.insert("WDT", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Watchdog timer"), details: None, fields });
        groups.insert("TIMERS", RegisterGroup { addr: Address { base: 65, count: 1, width: 11 }, desc: "Timers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ZCAL_FORCE_ENA", Field { brief: Some("Set to force override of calibration signals."), details: None, lo: 0, hi: 1 });
        fields.insert("ZCAL_FORCE_ZCAL", Field { brief: Some("ZCAL value when forcing calibration signals."), details: None, lo: 2, hi: 4 });
        fields.insert("ZCAL_FORCE_ZQ_OFF", Field { brief: Some("ZQ_OFF value when forcing calibration signals."), details: None, lo: 1, hi: 2 });
        regs.insert("MEMPHY_ZCAL_FORCE", Register { addr: Address { base: 33, count: 1, width: 1 }, brief: Some("SSTL drive-strength force"), details: None, fields });
        groups.insert("TWI_DELAY", RegisterGroup { addr: Address { base: 110, count: 1, width: 1 }, desc: "TWI hold time configuration", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("TWI_CNT_RELOAD", Field { brief: Some("Configure the hold time delay to apply to SDA after SCK when transmitting from the device. This delay is expressed in a number of VCore System clock cycles. The delay value should be as close to 300ns as possible without going below 300ns."), details: Some("Set to (300ns/4.8ns + 2) = 65"), lo: 1, hi: 9 });
        fields.insert("TWI_DELAY_ENABLE", Field { brief: Some("Set this field to enable hold time on the TWI SDA output. When enabled the TWI_CONFIG.TWI_CNT_RELOAD field determines the amount of hold time to apply to SDA."), details: None, lo: 0, hi: 1 });
        regs.insert("TWI_CONFIG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("TWI hold time configuration"), details: None, fields });
        groups.insert("TWI_SPIKE_FILTER", RegisterGroup { addr: Address { base: 111, count: 1, width: 1 }, desc: "TWI spike filter configuration", regs });
        out.insert("ICPU_CFG", Target { desc: "VCore Configuration", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("OBCFG_ADDR", Field { brief: Some("Address of OB tap configuration settings"), details: None, lo: 0, hi: 7 });
        regs.insert("OBCFG_ADDR", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training ROM address for end and obcfg"), details: None, fields });
        groups.insert("APC_TMR", RegisterGroup { addr: Address { base: 32, count: 1, width: 1 }, desc: "Not documented", regs });
        let regs = HashMap::new();
        groups.insert("KR_1X0096", RegisterGroup { addr: Address { base: 2, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("TR_ENABLE", Field { brief: Some("Training enable"), details: Some("1: Enable KR start-up protocol 0: Disable KR start-up protocol"), lo: 1, hi: 2 });
        fields.insert("TR_RESTART", Field { brief: Some("Restart training (SC)"), details: Some("1: Reset KR start-up protocol 0: Normal operation"), lo: 0, hi: 1 });
        regs.insert("KR_1X0096", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("KR PMD control"), details: None, fields });
        groups.insert("KR_1X0097", RegisterGroup { addr: Address { base: 11, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("FRLOCK", Field { brief: Some("Frame lock"), details: Some("1: Training frame delineation detected, 0: Training frame delineation not detected"), lo: 1, hi: 2 });
        fields.insert("RCVR_RDY", Field { brief: Some("Receiver status"), details: Some("1: Receiver trained and ready to receive data 0: Receiver training"), lo: 0, hi: 1 });
        fields.insert("STPROT", Field { brief: Some("Startup protocol status"), details: Some("1: Start-up protocol in progress 0: Start-up protocol complete"), lo: 2, hi: 3 });
        fields.insert("TR_FAIL", Field { brief: Some("Training failure"), details: Some("1: Training failure has been detected 0: Training failure has not been detected"), lo: 3, hi: 4 });
        regs.insert("KR_1X0097", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("KR PMD status"), details: None, fields });
        groups.insert("KR_1X0098", RegisterGroup { addr: Address { base: 3, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("LPCOEF", Field { brief: Some("Received coefficient update field"), details: None, lo: 0, hi: 16 });
        regs.insert("KR_1X0098", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("KR LP coefficient update"), details: None, fields });
        groups.insert("KR_1X0099", RegisterGroup { addr: Address { base: 4, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("LPSTAT", Field { brief: Some("Received status report field"), details: None, lo: 0, hi: 16 });
        regs.insert("KR_1X0099", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("KR LP status report"), details: None, fields });
        groups.insert("KR_1X009A", RegisterGroup { addr: Address { base: 5, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("LDCOEF", Field { brief: Some("Transmitted coefficient update field"), details: None, lo: 0, hi: 16 });
        regs.insert("KR_1X009A", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("KR LD coefficient update"), details: None, fields });
        groups.insert("KR_1X009B", RegisterGroup { addr: Address { base: 6, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("MW_TMR_LSW", Field { brief: Some("maxwait_timer, when training expires and failure declared. 500ms"), details: None, lo: 0, hi: 16 });
        regs.insert("MW_TMR_LSW", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training maxwait_timer lsw"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("WT_TMR", Field { brief: Some("wait_timer for training state machine to allow extra training frames to be exchanged"), details: None, lo: 0, hi: 16 });
        regs.insert("WT_TMR", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training wait_timer"), details: None, fields });
        groups.insert("MW_TMR", RegisterGroup { addr: Address { base: 34, count: 1, width: 2 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("BRKMASK_MSW", Field { brief: Some("Select lptrain state machine breakpoints. Each bit correpsonds to a state (see design doc)"), details: None, lo: 0, hi: 16 });
        regs.insert("BRKMASK_MSW", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("VS training break_mask msw"), details: None, fields });
        groups.insert("OBCFG_ADDR", RegisterGroup { addr: Address { base: 31, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("BER_ERR_TH", Field { brief: Some("Only consider error count > ber_err_th"), details: None, lo: 8, hi: 16 });
        fields.insert("BER_WID_TH", Field { brief: Some("Only consider errored range > ber_wid_th"), details: None, lo: 0, hi: 8 });
        regs.insert("TR_BER_THR", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training BER threshold settings"), details: None, fields });
        groups.insert("TR_BER_OFS", RegisterGroup { addr: Address { base: 27, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("MTHD_C0", Field { brief: Some("Training method for remote C(0)"), details: None, lo: 8, hi: 10 });
        fields.insert("MTHD_CM", Field { brief: Some("Training method for remote C(-1)"), details: None, lo: 6, hi: 8 });
        fields.insert("MTHD_CP", Field { brief: Some("Training method for remote C(+1)"), details: Some("0 : BER method 1 : Gain method 2 : DFE method"), lo: 10, hi: 12 });
        fields.insert("ORD1", Field { brief: Some("remote tap to optimize first"), details: Some("0 : C(-1) 1 : C(0) 2 : C(+1)"), lo: 4, hi: 6 });
        fields.insert("ORD2", Field { brief: Some("remote tap to optimize second"), details: None, lo: 2, hi: 4 });
        fields.insert("ORD3", Field { brief: Some("remote tap to optimize third"), details: None, lo: 0, hi: 2 });
        regs.insert("TR_MTHD", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training method"), details: None, fields });
        groups.insert("TR_BER_THR", RegisterGroup { addr: Address { base: 26, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("BRKMASK_LSW", Field { brief: Some("Select lptrain state machine breakpoints. Each bit correpsonds to a state (see design doc)"), details: None, lo: 0, hi: 16 });
        regs.insert("BRKMASK_LSW", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training break_mask lsw"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LUT_CLR", Field { brief: Some("Clears LUT table"), details: None, lo: 12, hi: 13 });
        fields.insert("LUT_ROW", Field { brief: Some("Selects LUT table entry (0 to 63)."), details: None, lo: 3, hi: 9 });
        fields.insert("LUT_SEL", Field { brief: Some("Selects LUT for lut_o"), details: Some("0: Gain 1: DFE_1 2: DFE_2 3: DFE_avg_1 4: DFE_avg_2 5: BER_1 6: BER_2 7: BER_3"), lo: 0, hi: 3 });
        regs.insert("TR_LUTSEL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training LUT selection"), details: None, fields });
        groups.insert("TR_BRKMASK", RegisterGroup { addr: Address { base: 29, count: 1, width: 2 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("LDSTAT", Field { brief: Some("Transmitted status report field"), details: None, lo: 0, hi: 16 });
        regs.insert("KR_1X009B", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("KR LD status report"), details: None, fields });
        groups.insert("TR_CFG0", RegisterGroup { addr: Address { base: 12, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("LD_PRE_INIT", Field { brief: Some("Set local taps starting point"), details: Some("0: Set to INITIALIZE 1: Set to PRESET"), lo: 4, hi: 5 });
        fields.insert("LP_PRE_INIT", Field { brief: Some("Send first LP request"), details: Some("0: Send   INITIALIZE 1: Send   PRESET"), lo: 3, hi: 4 });
        fields.insert("NOSUM", Field { brief: Some("Update taps regardless of v2,vp sum."), details: None, lo: 2, hi: 3 });
        fields.insert("PART_CFG_EN", Field { brief: Some("Enable partial OB tap configuration."), details: None, lo: 1, hi: 2 });
        fields.insert("RX_INV", Field { brief: Some("Invert recieved prbs11 within training frame"), details: None, lo: 10, hi: 11 });
        fields.insert("SM_HIST_CLR", Field { brief: Some("Clear all state machine history"), details: None, lo: 5, hi: 6 });
        fields.insert("TAPCTL_EN", Field { brief: Some("Allow LP to to control tap settings."), details: None, lo: 0, hi: 1 });
        fields.insert("TMR_DVDR", Field { brief: Some("Clock divider value for timer clocks."), details: None, lo: 12, hi: 16 });
        fields.insert("TX_INV", Field { brief: Some("Invert transmitted prbs11 within training frame"), details: None, lo: 9, hi: 10 });
        regs.insert("TR_CFG0", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training config 0"), details: None, fields });
        groups.insert("TR_CFG1", RegisterGroup { addr: Address { base: 13, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("TMR_HOLD", Field { brief: Some("Freeze timers. Bit set..."), details: Some("0: wait 1: max_wait 2: 1g 3: 3g 4: 10g 5: training 6: pgdet 7: link_pass 8: link_fail 9: an_wait 10: break_link"), lo: 0, hi: 11 });
        regs.insert("TR_CFG1", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training config 1"), details: None, fields });
        groups.insert("TR_CFG2", RegisterGroup { addr: Address { base: 14, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("V2_MIN", Field { brief: Some("min\tsettings for v2 sum."), details: None, lo: 0, hi: 6 });
        fields.insert("VP_MAX", Field { brief: Some("max\tsettings for vp sum."), details: None, lo: 6, hi: 12 });
        regs.insert("TR_CFG2", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training config 2"), details: None, fields });
        groups.insert("TR_CFG3", RegisterGroup { addr: Address { base: 15, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CP_MAX", Field { brief: Some("max\tsettings for local transmitter."), details: None, lo: 6, hi: 12 });
        fields.insert("CP_MIN", Field { brief: Some("min\tsettings for local transmitter."), details: None, lo: 0, hi: 6 });
        regs.insert("TR_CFG3", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training config 3"), details: None, fields });
        groups.insert("TR_CFG4", RegisterGroup { addr: Address { base: 16, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("C0_MAX", Field { brief: Some("max\tsettings for local transmitter."), details: None, lo: 6, hi: 12 });
        fields.insert("C0_MIN", Field { brief: Some("min\tsettings for local transmitter."), details: None, lo: 0, hi: 6 });
        regs.insert("TR_CFG4", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training config 4"), details: None, fields });
        groups.insert("TR_CFG5", RegisterGroup { addr: Address { base: 17, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CM_MAX", Field { brief: Some("max\tsettings for local transmitter."), details: None, lo: 6, hi: 12 });
        fields.insert("CM_MIN", Field { brief: Some("min\tsettings for local transmitter."), details: None, lo: 0, hi: 6 });
        regs.insert("TR_CFG5", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training config 5"), details: None, fields });
        groups.insert("TR_CFG6", RegisterGroup { addr: Address { base: 18, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("C0_INIT", Field { brief: Some("initialize settings for local transmitter."), details: None, lo: 0, hi: 6 });
        fields.insert("CP_INIT", Field { brief: Some("initialize settings for local transmitter."), details: None, lo: 6, hi: 12 });
        regs.insert("TR_CFG6", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training config 6"), details: None, fields });
        groups.insert("TR_CFG7", RegisterGroup { addr: Address { base: 19, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CM_INIT", Field { brief: Some("initialize settings for local transmitter."), details: None, lo: 6, hi: 12 });
        fields.insert("DFE_OFS", Field { brief: Some("Signed value to adjust final LP C(+1) tap position from calculated optimal setting."), details: None, lo: 0, hi: 6 });
        regs.insert("TR_CFG7", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training config 7"), details: None, fields });
        groups.insert("TR_CFG8", RegisterGroup { addr: Address { base: 20, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("WT1", Field { brief: Some("Weighted average calculation of DFE tap 1"), details: None, lo: 6, hi: 8 });
        fields.insert("WT2", Field { brief: Some("Weighted average calculation of DFE tap 2"), details: None, lo: 4, hi: 6 });
        fields.insert("WT3", Field { brief: Some("Weighted average calculation of DFE tap 3"), details: None, lo: 2, hi: 4 });
        fields.insert("WT4", Field { brief: Some("Weighted average calculation of DFE tap 4"), details: None, lo: 0, hi: 2 });
        regs.insert("TR_CFG8", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training config 8"), details: None, fields });
        groups.insert("TR_CFG9", RegisterGroup { addr: Address { base: 21, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("GAIN_MARG", Field { brief: Some("LP C(0) optimized when GAIN is gain_targ +/- 2*gain_marg"), details: None, lo: 10, hi: 16 });
        fields.insert("GAIN_TARG", Field { brief: Some("Target value of GAIN setting during LP C(0) optimization."), details: None, lo: 0, hi: 10 });
        regs.insert("TR_GAIN", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training gain target and margin values"), details: None, fields });
        groups.insert("TR_COEF_OVRD", RegisterGroup { addr: Address { base: 23, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("LUT_MSW", Field { brief: Some("Measured value of selected LUT."), details: None, lo: 0, hi: 16 });
        regs.insert("LUT_MSW", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("VS training lut_read msw"), details: None, fields });
        groups.insert("TR_ERRCNT", RegisterGroup { addr: Address { base: 41, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("FRSENT_LSW", Field { brief: Some("Number of training frames sent to complete training."), details: None, lo: 0, hi: 16 });
        regs.insert("FRSENT_LSW", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training frames_sent lsw"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CP_VAL", Field { brief: Some("CP value"), details: None, lo: 0, hi: 7 });
        regs.insert("TR_CPVAL", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("VS tap CP value"), details: None, fields });
        groups.insert("TR_FRAMES_SENT", RegisterGroup { addr: Address { base: 0, count: 1, width: 2 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("FRCNT_BER", Field { brief: Some("Number of training frames used for BER calculation."), details: None, lo: 0, hi: 16 });
        regs.insert("TR_CFG9", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training config 9"), details: None, fields });
        groups.insert("TR_GAIN", RegisterGroup { addr: Address { base: 22, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("FRSENT_MSW", Field { brief: Some("Number of training frames sent to complete training."), details: None, lo: 0, hi: 16 });
        regs.insert("FRSENT_MSW", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("VS training frames_sent lsw"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LUT_LSW", Field { brief: Some("Measured value of selected LUT."), details: None, lo: 0, hi: 16 });
        regs.insert("LUT_LSW", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training lut_read lsw"), details: None, fields });
        groups.insert("TR_LUT", RegisterGroup { addr: Address { base: 39, count: 1, width: 2 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("C0_BER_OFS", Field { brief: Some("Signed value to adjust final c0 tap position from calculated optimal setting."), details: None, lo: 5, hi: 10 });
        fields.insert("CM_BER_OFS", Field { brief: Some("Signed value to adjust final cm tap position from calculated optimal setting."), details: None, lo: 0, hi: 5 });
        fields.insert("CP_BER_OFS", Field { brief: Some("Signed value to adjust final cp tap position from calculated optimal setting."), details: None, lo: 10, hi: 15 });
        regs.insert("TR_BER_OFS", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training BER offset setting"), details: None, fields });
        groups.insert("TR_LUTSEL", RegisterGroup { addr: Address { base: 28, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("STEP", Field { brief: Some("Step to next lptrain state (if at breakpoint) (SC)"), details: None, lo: 0, hi: 1 });
        regs.insert("TR_STEP", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training state step"), details: None, fields });
        groups.insert("TR_MTHD", RegisterGroup { addr: Address { base: 25, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("STAT_OVRD", Field { brief: Some("Override Stat_report field to transmit"), details: None, lo: 0, hi: 16 });
        regs.insert("TR_STAT_OVRD", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training status report override"), details: None, fields });
        groups.insert("TR_OVRD", RegisterGroup { addr: Address { base: 7, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("LPTSM_HIST_MSW", Field { brief: Some("lptrain state machine history"), details: None, lo: 0, hi: 2 });
        fields.insert("SM_HIST", Field { brief: Some("training state machine history"), details: None, lo: 4, hi: 11 });
        regs.insert("HIST_MSW", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("VS training lptrain state machine history msw"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("C0_DME_REC", Field { brief: Some("Recorded position of DME_viol event for C0"), details: None, lo: 0, hi: 7 });
        regs.insert("TR_C0_DME_REC", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("VS recorded dme violation positions for C0"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("C0_MAX_REC", Field { brief: Some("Recorded position of MAX event for C0"), details: None, lo: 8, hi: 15 });
        fields.insert("C0_MIN_REC", Field { brief: Some("Recorded position of MIN event for C0"), details: None, lo: 0, hi: 7 });
        regs.insert("TR_C0_LIM_REC", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("VS recorded min,max positions for C0"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CM_DME_REC", Field { brief: Some("Recorded position of DME_viol event for CM"), details: None, lo: 0, hi: 7 });
        regs.insert("TR_CM_DME_REC", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("VS recorded dme violation positions for CM"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CM_MAX_REC", Field { brief: Some("Recorded position of MAX event for CM"), details: None, lo: 8, hi: 15 });
        fields.insert("CM_MIN_REC", Field { brief: Some("Recorded position of MIN event for CM"), details: None, lo: 0, hi: 7 });
        regs.insert("TR_CM_LIM_REC", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS recorded min,max positions for CM"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CP_DME_REC", Field { brief: Some("Recorded position of DME_viol event for CP"), details: None, lo: 0, hi: 7 });
        regs.insert("TR_CP_DME_REC", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("VS recorded dme violation positions for CP"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CP_MAX_REC", Field { brief: Some("Recorded position of MAX event for CP"), details: None, lo: 8, hi: 15 });
        fields.insert("CP_MIN_REC", Field { brief: Some("Recorded position of MIN event for CP"), details: None, lo: 0, hi: 7 });
        regs.insert("TR_CP_LIM_REC", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("VS recorded min,max positions for CP"), details: None, fields });
        groups.insert("TR_REC", RegisterGroup { addr: Address { base: 44, count: 1, width: 6 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("LPTSM_HIST_LSW", Field { brief: Some("lptrain state machine history"), details: None, lo: 0, hi: 16 });
        regs.insert("HIST_LSW", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS lptrain state machine history lsw"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ERRCNT", Field { brief: Some("bit error count of prbs11 checker"), details: None, lo: 0, hi: 16 });
        regs.insert("TR_ERRCNT", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training prbs11 error_count"), details: None, fields });
        groups.insert("TR_SM_HIST", RegisterGroup { addr: Address { base: 42, count: 1, width: 2 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("COEF_OVRD", Field { brief: Some("Override Coef_update field to transmit"), details: None, lo: 0, hi: 16 });
        regs.insert("TR_COEF_OVRD", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training coefficient update override"), details: None, fields });
        groups.insert("TR_STAT_OVRD", RegisterGroup { addr: Address { base: 24, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("BER_EN_OVRD", Field { brief: Some("Generate BER enable pulse (SC)"), details: None, lo: 2, hi: 3 });
        fields.insert("COEF_OVRD_VLD", Field { brief: Some("Generate Coef_update_valid pulse (SC)"), details: None, lo: 1, hi: 2 });
        fields.insert("OVRD_EN", Field { brief: Some("Enable manual training"), details: None, lo: 4, hi: 5 });
        fields.insert("RXTRAINED_OVRD", Field { brief: Some("Control of rx_trained variable for training SM"), details: None, lo: 3, hi: 4 });
        fields.insert("STAT_OVRD_VLD", Field { brief: Some("Generate Stat_report_valid pulse (SC)"), details: None, lo: 0, hi: 1 });
        regs.insert("TR_OVRD", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training override"), details: None, fields });
        groups.insert("TR_STEP", RegisterGroup { addr: Address { base: 8, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("MW_TMR_MSW", Field { brief: Some("maxwait_timer, when training expires and failure declared. 500ms"), details: None, lo: 0, hi: 16 });
        regs.insert("MW_TMR_MSW", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("VS training maxwait_timer msw"), details: None, fields });
        groups.insert("TR_STS1", RegisterGroup { addr: Address { base: 9, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("BER_BUSY", Field { brief: Some("Indicates prbs11 checker is active"), details: None, lo: 12, hi: 13 });
        fields.insert("DME_VIOL", Field { brief: Some("Indicates a DME violation has occured (LH)"), details: None, lo: 1, hi: 2 });
        fields.insert("FRLOSS", Field { brief: Some("Indicates loss of training frames (LH)"), details: None, lo: 13, hi: 14 });
        fields.insert("GAIN_FAIL", Field { brief: Some("Indicates gain_target was not reached during LP training"), details: None, lo: 3, hi: 4 });
        fields.insert("LPT_SM", Field { brief: Some("LP training state machine"), details: None, lo: 4, hi: 9 });
        fields.insert("TRAINING", Field { brief: Some("training variable from training state machine"), details: None, lo: 2, hi: 3 });
        fields.insert("TR_DONE", Field { brief: Some("Indicates that local and remote training has completed"), details: None, lo: 0, hi: 1 });
        fields.insert("TR_SM", Field { brief: Some("Training state machine"), details: None, lo: 9, hi: 12 });
        regs.insert("TR_STS1", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training status 1"), details: None, fields });
        groups.insert("TR_STS2", RegisterGroup { addr: Address { base: 10, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("C0_VAL", Field { brief: Some("C0 value"), details: None, lo: 0, hi: 7 });
        regs.insert("TR_C0VAL", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("VS tap C0 value"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CM_VAL", Field { brief: Some("CM value"), details: None, lo: 0, hi: 7 });
        regs.insert("TR_CMVAL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS tap CM value"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("C0_RANGE_ERR", Field { brief: Some("C0 range error (LH)"), details: None, lo: 1, hi: 2 });
        fields.insert("CM_RANGE_ERR", Field { brief: Some("CM range error (LH)"), details: None, lo: 0, hi: 1 });
        fields.insert("CP_RANGE_ERR", Field { brief: Some("CP range error (LH)"), details: None, lo: 2, hi: 3 });
        regs.insert("TR_STS2", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training status 2"), details: None, fields });
        groups.insert("TR_TAPVAL", RegisterGroup { addr: Address { base: 36, count: 1, width: 3 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("APC_TMR", Field { brief: Some("Delay between LP tap update, and capture of direct-connect apc values"), details: None, lo: 0, hi: 16 });
        regs.insert("APC_TMR", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS training apc_timer"), details: None, fields });
        groups.insert("WT_TMR", RegisterGroup { addr: Address { base: 33, count: 1, width: 1 }, desc: "Not documented", regs });
        out.insert("KR_DEV1", Target { desc: "\\see vtss_target_KR_DEV1_e", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("AN_BP_ABLE", Field { brief: Some("BP AN ability"), details: None, lo: 0, hi: 1 });
        fields.insert("AN_NEG_CR10", Field { brief: Some("10G CR10   negotiated"), details: None, lo: 8, hi: 9 });
        fields.insert("AN_NEG_CR4", Field { brief: Some("10G CR4    negotiated"), details: None, lo: 6, hi: 7 });
        fields.insert("AN_NEG_FEC", Field { brief: Some("10G KR FEC negotiated"), details: None, lo: 4, hi: 5 });
        fields.insert("AN_NEG_KR", Field { brief: Some("10G KR     negotiated"), details: None, lo: 3, hi: 4 });
        fields.insert("AN_NEG_KR4", Field { brief: Some("10G KR4    negotiated"), details: None, lo: 5, hi: 6 });
        fields.insert("AN_NEG_KX", Field { brief: Some("1G  KX     negotiated"), details: None, lo: 1, hi: 2 });
        fields.insert("AN_NEG_KX4", Field { brief: Some("10G KX4    negotiated"), details: None, lo: 2, hi: 3 });
        regs.insert("KR_7X0030", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Backplane ethernet status"), details: None, fields });
        groups.insert("AN_CFG0", RegisterGroup { addr: Address { base: 18, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("KR1G_TMR_MSW", Field { brief: Some("rate_detect_1g_timer setting"), details: None, lo: 0, hi: 16 });
        regs.insert("KR1G_MSW", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("VS AN rate_detect_1g timer msw"), details: None, fields });
        groups.insert("AN_HIST", RegisterGroup { addr: Address { base: 39, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("AN_SM_HIST", Field { brief: Some("AN state machine history"), details: None, lo: 0, hi: 15 });
        regs.insert("AN_HIST", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS AN arb state mach history"), details: None, fields });
        groups.insert("AN_SM", RegisterGroup { addr: Address { base: 9, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ABDET_CNT", Field { brief: Some("ABILITY_DETECT state counter"), details: None, lo: 4, hi: 8 });
        fields.insert("AN_SM", Field { brief: Some("AN state machine"), details: None, lo: 0, hi: 4 });
        regs.insert("AN_SM", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS AN arb state machine"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INCP_LINK", Field { brief: Some("Incompatible link (LH)"), details: None, lo: 7, hi: 8 });
        fields.insert("LINE_RATE", Field { brief: Some("speed setting"), details: Some("0: 10G 1: 1G 2: 3G"), lo: 0, hi: 2 });
        fields.insert("LINK_CTL", Field { brief: Some("AN link_control variable"), details: Some("0: ENABLE 1: DISABLE 2: SCAN_FOR_CARRIER"), lo: 2, hi: 4 });
        fields.insert("LINK_HCD", Field { brief: Some("Negotiated HCD"), details: Some("0: KX_1G 1: KX4_10G 2: KR_10G 3: KR4_40G 4: CR4_40G 5: CR10_100G"), lo: 4, hi: 7 });
        fields.insert("NONCE_MATCH", Field { brief: Some("Nonce match (LH)"), details: None, lo: 8, hi: 9 });
        fields.insert("SYNC10G", Field { brief: Some("10G sync status of local detector"), details: None, lo: 9, hi: 10 });
        fields.insert("SYNC8B10B", Field { brief: Some("1G or 3G sync status of local detector"), details: None, lo: 10, hi: 11 });
        regs.insert("AN_STS0", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS AN status 0"), details: None, fields });
        groups.insert("AN_STS0", RegisterGroup { addr: Address { base: 10, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("AW_TMR_LSW", Field { brief: Some("an_wait_timer setting"), details: None, lo: 0, hi: 16 });
        regs.insert("AW_LSW", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS AN aneg_wait timer lsw"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BL_TMR_MSW", Field { brief: Some("break_link_timer setting"), details: None, lo: 0, hi: 16 });
        regs.insert("BL_MSW", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("VS AN break_link timer msw"), details: None, fields });
        groups.insert("AW_TMR", RegisterGroup { addr: Address { base: 21, count: 1, width: 2 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ABDET_CLR", Field { brief: Some("Clear ABILITY_DETECT state counter"), details: None, lo: 6, hi: 7 });
        fields.insert("AN_SM_HIST_CLR", Field { brief: Some("Clear AN state machine history"), details: None, lo: 5, hi: 6 });
        fields.insert("CLKG_DISABLE", Field { brief: Some("Disable clock gating"), details: None, lo: 4, hi: 5 });
        fields.insert("SYNC10G_SEL", Field { brief: Some("Select source of 10G sync signal"), details: Some("0: KR internal 1: External"), lo: 2, hi: 3 });
        fields.insert("SYNC8B10B_SEL", Field { brief: Some("Select source of 3G and 1G sync signal"), details: Some("0: KR internal 1: External"), lo: 1, hi: 2 });
        fields.insert("TR_DISABLE", Field { brief: Some("Bypass training if 10G negotiated"), details: None, lo: 3, hi: 4 });
        regs.insert("AN_CFG0", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS AN config 0"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BL_TMR_LSW", Field { brief: Some("break_link_timer setting"), details: None, lo: 0, hi: 16 });
        regs.insert("BL_LSW", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS AN break_link timer lsw"), details: None, fields });
        groups.insert("BL_TMR", RegisterGroup { addr: Address { base: 19, count: 1, width: 2 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("KR10G_TMR_LSW", Field { brief: Some("rate_detect_10g_timer setting"), details: None, lo: 0, hi: 16 });
        regs.insert("KR10G_LSW", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS AN rate_detect_10g timer lsw"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PD_TMR_MSW", Field { brief: Some("page_detect_timer setting"), details: None, lo: 0, hi: 16 });
        regs.insert("PD_MSW", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("VS AN page_detect timer msw"), details: None, fields });
        groups.insert("KR10G_TMR", RegisterGroup { addr: Address { base: 33, count: 1, width: 2 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("KR1G_TMR_LSW", Field { brief: Some("rate_detect_1g_timer setting"), details: None, lo: 0, hi: 16 });
        regs.insert("KR1G_LSW", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS AN rate_detect_1g timer lsw"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("KR3G_TMR_MSW", Field { brief: Some("rate_detect_3g_timer setting"), details: None, lo: 0, hi: 16 });
        regs.insert("KR3G_MSW", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("VS AN rate_detect_3g timer msw"), details: None, fields });
        groups.insert("KR1G_TMR", RegisterGroup { addr: Address { base: 37, count: 1, width: 2 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("KR10G_TMR_MSW", Field { brief: Some("rate_detect_10g_timer setting"), details: None, lo: 0, hi: 16 });
        regs.insert("KR10G_MSW", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("VS AN rate_detect_10g timer msw"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("KR3G_TMR_LSW", Field { brief: Some("rate_detect_3g_timer setting"), details: None, lo: 0, hi: 16 });
        regs.insert("KR3G_LSW", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS AN rate_detect_3g timer lsw"), details: None, fields });
        groups.insert("KR3G_TMR", RegisterGroup { addr: Address { base: 35, count: 1, width: 2 }, desc: "Not documented", regs });
        let regs = HashMap::new();
        groups.insert("KR_7X0000", RegisterGroup { addr: Address { base: 4, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("AN_ENABLE", Field { brief: Some("AN enable"), details: None, lo: 12, hi: 13 });
        fields.insert("AN_RESET", Field { brief: Some("AN reset   (SC)"), details: None, lo: 15, hi: 16 });
        fields.insert("AN_RESTART", Field { brief: Some("AN restart (SC)"), details: None, lo: 9, hi: 10 });
        fields.insert("NPCTL", Field { brief: Some("Extended next page control"), details: None, lo: 13, hi: 14 });
        regs.insert("KR_7X0000", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("AN control"), details: None, fields });
        groups.insert("KR_7X0001", RegisterGroup { addr: Address { base: 5, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("LP_NP_ADV2", Field { brief: Some("LP next page ability D[47:32]"), details: None, lo: 0, hi: 16 });
        regs.insert("KR_7X001B", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("LP next page ability 47-32"), details: None, fields });
        groups.insert("KR_7X0030", RegisterGroup { addr: Address { base: 17, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("AN_ABLE", Field { brief: Some("AN ability"), details: None, lo: 3, hi: 4 });
        fields.insert("AN_COMPLETE", Field { brief: Some("AN complete"), details: None, lo: 5, hi: 6 });
        fields.insert("AN_LP_ABLE", Field { brief: Some("LP AN ability"), details: None, lo: 0, hi: 1 });
        fields.insert("LINKSTAT", Field { brief: Some("Link status (LL)"), details: None, lo: 2, hi: 3 });
        fields.insert("NPSTAT", Field { brief: Some("Extended next page status"), details: None, lo: 7, hi: 8 });
        fields.insert("PARDETFLT", Field { brief: Some("Parallel detection fault (LH)"), details: None, lo: 9, hi: 10 });
        fields.insert("PG_RCVD", Field { brief: Some("Page received (LH)"), details: None, lo: 6, hi: 7 });
        fields.insert("REM_FLT", Field { brief: Some("Remote fault (LH)"), details: None, lo: 4, hi: 5 });
        regs.insert("KR_7X0001", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("AN status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ADV0", Field { brief: Some("Local advertised abilities D[15:0]"), details: None, lo: 0, hi: 16 });
        regs.insert("KR_7X0010", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("LD advertised abilities 15-0"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ADV1", Field { brief: Some("Local advertised abilities D[31:16]"), details: None, lo: 0, hi: 16 });
        regs.insert("KR_7X0011", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("LD advertised abilities 31-16"), details: None, fields });
        groups.insert("LD_ADV", RegisterGroup { addr: Address { base: 11, count: 1, width: 3 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("LP_BP_ADV2", Field { brief: Some("LP advertised abilities D[47:32]"), details: None, lo: 0, hi: 16 });
        regs.insert("KR_7X0015", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("LP base page advertised abilities 47-32"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("NP_TX0", Field { brief: Some("Next page to transmit D[15:0]"), details: None, lo: 0, hi: 16 });
        regs.insert("KR_7X0016", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("NxtPg transmit 15-0"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("NP_TX1", Field { brief: Some("Next page to transmit D[31:16]"), details: None, lo: 0, hi: 16 });
        regs.insert("KR_7X0017", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("NxtPg transmit 31-16"), details: None, fields });
        groups.insert("LD_NEXT_PAGE", RegisterGroup { addr: Address { base: 14, count: 1, width: 3 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("AW_TMR_MSW", Field { brief: Some("an_wait_timer setting"), details: None, lo: 0, hi: 16 });
        regs.insert("AW_MSW", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("VS AN aneg_wait timer msw"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LFLONG_TMR_LSW", Field { brief: Some("10g link_fail_inhibit_timer setting"), details: None, lo: 0, hi: 16 });
        regs.insert("LFLONG_LSW", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS AN link_fail_inhibit timer lsw"), details: None, fields });
        groups.insert("LFLONG_TMR", RegisterGroup { addr: Address { base: 23, count: 1, width: 2 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("LFLONG_TMR_MSW", Field { brief: Some("10g link_fail_inhibit_timer setting"), details: None, lo: 0, hi: 16 });
        regs.insert("LFLONG_MSW", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("VS AN link_fail_inhibit_long timer msw"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LFSHORT_TMR_LSW", Field { brief: Some("1g link_fail_inhibit_timer setting"), details: None, lo: 0, hi: 16 });
        regs.insert("LFSHORT_LSW", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS AN link_fail_inhibit_short timer lsw"), details: None, fields });
        groups.insert("LFSHORT_TMR", RegisterGroup { addr: Address { base: 25, count: 1, width: 2 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ADV2", Field { brief: Some("Local advertised abilities D[47:32]"), details: None, lo: 0, hi: 16 });
        regs.insert("KR_7X0012", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("LD advertised abilities 47-32"), details: None, fields });
        groups.insert("LP_BASE_PAGE_0", RegisterGroup { addr: Address { base: 6, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("LP_BP_ADV0", Field { brief: Some("LP advertised abilities D[15:0]"), details: None, lo: 0, hi: 16 });
        regs.insert("KR_7X0013", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("LP base page advertised abilities 15-0"), details: None, fields });
        groups.insert("LP_BASE_PAGE_1", RegisterGroup { addr: Address { base: 7, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("LP_BP_ADV1", Field { brief: Some("LP advertised abilities D[31:16]"), details: None, lo: 0, hi: 16 });
        regs.insert("KR_7X0014", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("LP base page advertised abilities 31-16"), details: None, fields });
        groups.insert("LP_BASE_PAGE_2", RegisterGroup { addr: Address { base: 8, count: 1, width: 1 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("NP_TX2", Field { brief: Some("Next page to transmit D[47:32]"), details: None, lo: 0, hi: 16 });
        regs.insert("KR_7X0018", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("NxtPg transmit 47-32"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LP_NP_ADV0", Field { brief: Some("LP next page  ability D[15:0]"), details: None, lo: 0, hi: 16 });
        regs.insert("KR_7X0019", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("LP next page ability 15-0"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LP_NP_ADV1", Field { brief: Some("LP next page ability D[31:16]"), details: None, lo: 0, hi: 16 });
        regs.insert("KR_7X001A", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("LP next page ability 31-16"), details: None, fields });
        groups.insert("LP_NEXT_PAGE", RegisterGroup { addr: Address { base: 0, count: 1, width: 4 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("LFSHORT_TMR_MSW", Field { brief: Some("1g link_fail_inhibit_timer setting"), details: None, lo: 0, hi: 16 });
        regs.insert("LFSHORT_MSW", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("VS AN link_fail_inhibit_short timer msw"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LP_TMR_LSW", Field { brief: Some("link_pass_inhibit_timer setting"), details: None, lo: 0, hi: 16 });
        regs.insert("LP_LSW", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS AN link_pass_inhibit timer lsw"), details: None, fields });
        groups.insert("LP_TMR", RegisterGroup { addr: Address { base: 27, count: 1, width: 2 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("PD_TMR_LSW", Field { brief: Some("page_detect_timer setting"), details: None, lo: 0, hi: 16 });
        regs.insert("PD_LSW", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS AN page_detect timer lsw"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TR_TMR_MSW", Field { brief: Some("training_state_timer setting"), details: None, lo: 0, hi: 16 });
        regs.insert("TR_MSW", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("VS AN training state timer msw"), details: None, fields });
        groups.insert("PD_TMR", RegisterGroup { addr: Address { base: 31, count: 1, width: 2 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("LP_TMR_MSW", Field { brief: Some("link_pass_inhibit_timer setting"), details: None, lo: 0, hi: 16 });
        regs.insert("LP_MSW", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("VS AN link_pass_inhibit timer msw"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TR_TMR_LSW", Field { brief: Some("training_state_timer setting"), details: None, lo: 0, hi: 16 });
        regs.insert("TR_LSW", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VS AN training state timer lsw"), details: None, fields });
        groups.insert("TR_TMR", RegisterGroup { addr: Address { base: 29, count: 1, width: 2 }, desc: "Not documented", regs });
        out.insert("KR_DEV7", Target { desc: "\\see vtss_target_KR_DEV7_e", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("PERIOD_VAL", Field { brief: Some("Time in units between automatic ageing of an entry. If otherwise subject to ageing, an inactive entry is removed after between 3*AGE_PERIOD_VAL and 4*AGE_PERIOD_VAL."), details: Some("0: Disabled n: Age period = n * UNIT_SIZE"), lo: 0, hi: 28 });
        fields.insert("UNIT_SIZE", Field { brief: Some("Sets the unit time. Setting UNIT_SIZE to zero effectively disables ageing."), details: Some("0: Disable age scan 1: 100 us (fastest possible scan is bestcase 150 us so increase AUTOAGE_PERIOD_VAL to 2) 2: 10 ms 3: 1 s"), lo: 28, hi: 30 });
        regs.insert("AUTOAGE_CFG", Register { addr: Address { base: 8, count: 4, width: 1 }, brief: Some("Automated age scan configuration"), details: Some("Configures automated age scan of MAC table. This register is replicated for the four age intervals supported. Age interval are configured for auto leared entries through: LRN:COMMON:AUTO_LRN_CFG.AUTO_AGE_INTERVAL Age intervals are configured for CPU learned entries through: LRN:COMMON:MAC_ACCESS_CFG_2.MAC_ENTRY_AGE_INTERVAL"), fields });
        let mut fields = HashMap::new();
        fields.insert("CELLS_BETWEEN_ENTRY_SCAN", Field { brief: Some("Specifies the number of clk cycle before another autoage access can be attempted."), details: None, lo: 15, hi: 25 });
        fields.insert("CLK_PERIOD_01NS", Field { brief: Some("Specifies the clock period in NS x 10."), details: Some("64: 6,4ns 192: 19,2 ns"), lo: 7, hi: 15 });
        fields.insert("FORCE_HW_SCAN_SHOT", Field { brief: Some("Triggers an instant hardware autoage scan (once current scan completes -which can be ensured using FORCE_HW_SCAN_STOP_ENA). The bit is cleared by HW when a new automated scan begins."), details: Some("0: No force 1: Force start of autoage scan"), lo: 2, hi: 6 });
        fields.insert("FORCE_HW_SCAN_STOP_SHOT", Field { brief: Some("Triggers forced stop of current autoage scan The bit is cleared by HW when scan stop is obtained"), details: Some("0: No force 1: Force autoage SCAN stop"), lo: 1, hi: 2 });
        fields.insert("FORCE_IDLE_ENA", Field { brief: Some("Configures automated age scan stop after current automated scan completes."), details: Some("0: No force 1: SCAN stop after current scan completes and stays stopped."), lo: 0, hi: 1 });
        fields.insert("PAUSE_AUTO_AGE_ENA", Field { brief: Some("Pause current autoage scan."), details: None, lo: 25, hi: 26 });
        fields.insert("USE_PORT_FILTER_ENA", Field { brief: Some("Configures automated ageing of all port or only port not disabled in ANA_L2::FILTER_OTHER_CTRL and ANA_L2::FILTER_LOCAL_CTRL."), details: Some("0: Disable use additional port filter 1: Enable use of additional port filter"), lo: 6, hi: 7 });
        regs.insert("AUTOAGE_CFG_1", Register { addr: Address { base: 12, count: 1, width: 1 }, brief: Some("Automated age scan configuration and status"), details: Some("Configures automated age scan of MAC table"), fields });
        let mut fields = HashMap::new();
        fields.insert("NEXT_ROW", Field { brief: Some("Current autoage row. Changed on every autoage command. Indicate the MAC table row to be autoaged aged next. Incremented by hardware during auto ageing."), details: Some("0: Row 0 1: Row 1 ... n: Row n."), lo: 4, hi: 18 });
        fields.insert("SCAN_ONGOING_STATUS", Field { brief: Some("High when AUTOAGE is ongoing for the given AGE interval."), details: Some("0: No event has occured 1: AUTOAGE scan ongoing."), lo: 0, hi: 4 });
        regs.insert("AUTOAGE_CFG_2", Register { addr: Address { base: 13, count: 1, width: 1 }, brief: Some("Automated age scan configuration and status"), details: Some("Configures automated age scan of MAC table"), fields });
        let mut fields = HashMap::new();
        fields.insert("AUTO_AGE_INTERVAL", Field { brief: Some("The AGE interval for auto-learned entries will be set to the value configured in this field."), details: None, lo: 1, hi: 3 });
        fields.insert("AUTO_LRN_CPU_COPY", Field { brief: Some("The CPU_COPY flag for auto-learned entries will be set to the value configured in this field."), details: Some("0: Disable 1: Enable."), lo: 4, hi: 5 });
        fields.insert("AUTO_LRN_CPU_QU", Field { brief: Some("The CPU_QU for auto-learned entries will be set to the value configured in this field."), details: Some("0: Disable 1: Enable."), lo: 5, hi: 8 });
        fields.insert("AUTO_LRN_ENA", Field { brief: Some("Additional control for autonomous Learning."), details: Some("0: Disable 1: Enable."), lo: 0, hi: 1 });
        fields.insert("AUTO_LRN_IGNORE_VLAN", Field { brief: Some("The VLAN_IGNORE flag for auto-learned entries will be set to the value configured in this field."), details: Some("0: VLAN mask is used 1: VLAN mask is ignored."), lo: 8, hi: 9 });
        fields.insert("AUTO_LRN_MIRROR", Field { brief: Some("The MIRROR flag for auto-learned entries will be set to the value configured in this field."), details: Some("0: Disable 1: Enable."), lo: 3, hi: 4 });
        fields.insert("AUTO_LRN_SRC_KILL_FWD", Field { brief: Some("The SRC_KILL_FWD flag for auto-learned entries will be set to the value configured in this field."), details: Some("0: Disable 1: Enable."), lo: 9, hi: 10 });
        regs.insert("AUTO_LRN_CFG", Register { addr: Address { base: 14, count: 1, width: 1 }, brief: Some("Auto Learn Options"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CPU_ACCESS_CMD", Field { brief: Some("Configures the MAC table access command: LEARN, UNLEARN, and LOOKUP Command accesses a MAC_ENTRY at the HASH(VID/FID,MAC) index. MAC and FID/VID must to be written to the respective bitgroups in registers MAC_ACCESS_CFG_[0|1|2]. READ and WRITE Command accesses a MAC_ENTRY at the index specified by means of CPU_ACCESS_DIRECT_ROW,  CPU_ACCESS_DIRECT_COL and CPU_ACCESS_DIRECT_TYPE fields. SCAN Command access traverses the entire MAC table and handle all found entries depending on configuration and filter settings. If any set of filters is enabled then only entries matching the enabled filters are affected / found. Refer to description of bitgroups found in LRN::SCAN_NEXT_CFG-\tNote that it is possible to configure the scan to FIND ALL or FIND first using LRN::SCAN_NEXT_CFG.SCAN_NEXT_UNTIL_FOUND_ENA. FIND SMALLEST Command traverses the entire table and returns the MAC_ENTRY with the smallest FID/VID,MAC which is larger than a configured starting FID/VID,MAC value (configured in MAC_ACCESS_CFG_[0|1|2].). FID/VID take precedence over MAC. CLEAR ALL Command traverses the entire table and resets all entries."), details: Some("0: LEARN 1: UNLEARN 2: LOOKUP 3: READ 4: WRITE 5: SCAN (AGE or FIND NEXT) 6: FIND SMALLEST 7: CLEAR ALL"), lo: 1, hi: 5 });
        fields.insert("CPU_ACCESS_DIRECT_COL", Field { brief: Some("Configures the MAC table bucket or column index that holds the MAC_ENTRY that is accessed when CPU_ACCESS_CMD command is READ or WRITE."), details: Some("0: Column (bucket) 0 1: Column (bucket) 1 ... n: Column (bucket) n."), lo: 20, hi: 22 });
        fields.insert("CPU_ACCESS_DIRECT_ROW", Field { brief: Some("Configures the MAC table row index that holds the MAC_ENTRY that is accessed when CPU_ACCESS_CMD command is READ or WRITE. Configures the MAC table starting row index when CPU_ACCESS_CMD command is FIND NEXT. If the Command succeeds in finding a matching entry this field is updated with the row index for the (last) matching entry."), details: Some("0: Row 0 1: Row 1 ... n: Row n."), lo: 5, hi: 19 });
        fields.insert("CPU_ACCESS_DIRECT_TYPE", Field { brief: Some("Configures the MAC table type that holds the MAC_ENTRY that is accessed when CPU_ACCESS_CMD command is READ or WRITE. Configures the MAC table starting type when CPU_ACCESS_CMD command is FIND NEXT. If the Command succeeds in finding a matching entry this field is updated with the type for the (last) matching entry."), details: Some("0: MAC table 1: MAC CAM (CPU_ACCESS_DIRECT_ROW is not used)"), lo: 19, hi: 20 });
        fields.insert("MAC_TABLE_ACCESS_SHOT", Field { brief: Some("Perform the access command specified by CPU_ACCESS_CMD. Cleared when the access completes. Interrupt upon access completion can be configured using: ANA_L2::INTR_ENA.LRN_ACCESS_COMPLETE_INTR_ENA"), details: Some("0: Idle 1: Initiate CPU ACCESS The bit is cleared upon completion"), lo: 0, hi: 1 });
        regs.insert("COMMON_ACCESS_CTRL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("MAC Table Control"), details: Some("Configures command and access parameters when accessing the MAC table."), fields });
        let mut fields = HashMap::new();
        fields.insert("AUTOAGE_AGED_STICKY", Field { brief: Some("Set if a MAC address entry has been aged due to an autoage operation."), details: Some("0: No entries have been aged due to autoage. 1: At least 1 entry has been aged due to autoage. Write '1' to clear this field."), lo: 22, hi: 23 });
        fields.insert("AUTOAGE_REMOVE_STICKY", Field { brief: Some("Set if a MAC address entry has been removed due to an autoage operation."), details: Some("0: No entries have been removed due to autoage. 1: At least 1 entry has been removed due to autoage. Write '1' to clear this field."), lo: 21, hi: 22 });
        fields.insert("AUTOAGE_SCAN_COMPLETED_STICKY", Field { brief: Some("Set when AUTOAGE scan completes."), details: Some("0: No event has occured 1: AUTOAGE scan completes Bit is cleared by writing a 1 to this position."), lo: 28, hi: 29 });
        fields.insert("AUTOAGE_SCAN_STARTED_STICKY", Field { brief: Some("Set when Autoage scan starts."), details: Some("0: No event has occured 1: AUTOAGE scan started Bit is cleared by writing a 1 to this position."), lo: 27, hi: 28 });
        fields.insert("AUTOAGE_START_DELAYED_STICKY", Field { brief: Some("Set when Autoage scan should be started before the last scan completed."), details: Some("0: No event has occured 1: AUTOAGE could not start before the current scan completed Bit is cleared by writing a 1 to this position."), lo: 26, hi: 27 });
        fields.insert("AUTO_LRN_FAILED_STICKY", Field { brief: Some("Set if an autonomous learning operation has failed due to hash table depletion (i.e. all entries in a row were locked). Write '1' to clear this field."), details: Some("0: No autonomous learning operations have failed. 1: An autonomous learning operation has failed. Write '1' to clear this field."), lo: 17, hi: 18 });
        fields.insert("AUTO_LRN_FID_LIMIT_EXCEEDED_STICKY", Field { brief: Some("Set if AUTO learn failed due to FID learn limit exceeded. Write '1' to clear this field."), details: Some("0: No change. 1: Fid Learn limit has caused CPU based learning to fail."), lo: 18, hi: 19 });
        fields.insert("AUTO_LRN_INSERT_CAM_STICKY", Field { brief: Some("Set if a MAC address entry has been inserted into the MAC CAM. Write '1' to clear this field."), details: Some("0: No entries have been inserted into empty buckets 1: An entry has been inserted into an empty bucket."), lo: 16, hi: 17 });
        fields.insert("AUTO_LRN_INSERT_STICKY", Field { brief: Some("Set if a MAC address entry has been inserted into a MAC address table column (bucket). Write '1' to clear this field."), details: Some("0: No entries have been inserted into empty buckets 1: An entry has been inserted into an empty bucket."), lo: 15, hi: 16 });
        fields.insert("AUTO_LRN_REFRESH_STICKY", Field { brief: Some("Set if MAC entry has been updated. Write '1' to clear this field."), details: Some("0: No entries have been refreshed. 1: An entry has been refreshed."), lo: 14, hi: 15 });
        fields.insert("AUTO_LRN_REPLACE_FAILED_STICKY", Field { brief: Some("Set if a randomly selected non-locked and valid MAC address entry can not be overwritten by a new (VID, SMAC). Write '1' to clear this field."), details: Some("0: No entries have been replaced. 1: An entry has not been replaced due to configuration."), lo: 13, hi: 14 });
        fields.insert("AUTO_LRN_REPLACE_STICKY", Field { brief: Some("Set if a randomly selected non-locked and valid MAC address entry has been overwritten by a new (VID, SMAC). Write '1' to clear this field."), details: Some("0: No entries have been replaced. 1: An entry has been replaced."), lo: 12, hi: 13 });
        fields.insert("CPU_LOOKUP_FAILED_STICKY", Field { brief: Some("Set if a CPU MAC LOOKUP operation has failed due to not found an entry. Write '1' to clear this field."), details: Some("0:  No fail 1: CPU lookup operation failed."), lo: 8, hi: 9 });
        fields.insert("CPU_LOOKUP_STICKY", Field { brief: Some("Set if a CPU MAC LOOKUP operation has succeeded. Write '1' to clear this field."), details: Some("0:  No successful lookup 1: Successful lookup."), lo: 7, hi: 8 });
        fields.insert("CPU_LRN_FAILED_STICKY", Field { brief: Some("Set if an CPU learning operation has failed due to hash table depletion (i.e. all entries in a row were locked). Write '1' to clear this field."), details: Some("0: No CPU LEARN operations has failed. 1: A CPU LEARN operation has failed."), lo: 0, hi: 1 });
        fields.insert("CPU_LRN_FID_LIMIT_EXCEEDED_STICKY", Field { brief: Some("Set if CPU learn failed due to FID learn limit exceeded. Write '1' to clear this field."), details: Some("0: No change. 1: Fid Learn limit has caused CPU based learning to fail."), lo: 23, hi: 24 });
        fields.insert("CPU_LRN_INSERT_STICKY", Field { brief: Some("Set if a MAC entry has been inserted into an empty MAC table row,column (=bucket). Write '1' to clear this field."), details: Some("0: No entries have been inserted into an empty bucket 1: An entry has been inserted into an empty bucket."), lo: 1, hi: 2 });
        fields.insert("CPU_LRN_REFRESH_STICKY", Field { brief: Some("Set if a valid MAC entry has been updated (refreshed), i.e. a write access to the same bucket with the same MAC and VID has occured. Write '1' to clear this field."), details: Some("0: No entries have been refreshed. 1: An entry has been refreshed."), lo: 3, hi: 4 });
        fields.insert("CPU_LRN_REPLACE_FAILED_STICKY", Field { brief: Some("Set if CPU learn replace can not be performed due to configuration. Write '1' to clear this field."), details: Some("0: No learn based replacement failed. 1: The replacement of 1 or more entries failed."), lo: 4, hi: 5 });
        fields.insert("CPU_LRN_REPLACE_STICKY", Field { brief: Some("Set if a valid MAC entry has been overwritten, i.e. a write access to the same bucket with a changed MAC and/or VID has occured. Write '1' to clear this field."), details: Some("0: No entries have been replaced. 1: An entry has been replaced."), lo: 2, hi: 3 });
        fields.insert("CPU_READ_DIRECT_STICKY", Field { brief: Some("Set when a direct CPU MAC READ operation has occured. Write '1' to clear this field."), details: Some("0:  No update 1: CPU read direct operation has occured."), lo: 10, hi: 11 });
        fields.insert("CPU_UNLEARN_FAILED_STICKY", Field { brief: Some("Set if a CPU MAC UNLEARN operation has failed because the respective (valid) entry was not found. Write '1' to clear this field."), details: Some("0:  No UNLEARN operation failed 1: CPU UNLEARN operation failed."), lo: 6, hi: 7 });
        fields.insert("CPU_UNLEARN_STICKY", Field { brief: Some("Set if a CPU MAC UNLEARN operation has succeeded. Write '1' to clear this field."), details: Some("0:  No CPU MAC UNLEARN operation took place 1:  CPU UNLEARN operations has succeeded."), lo: 5, hi: 6 });
        fields.insert("CPU_WRITE_DIRECT_STICKY", Field { brief: Some("Set when a direct CPU MAC WRITE operation has occured. Write '1' to clear this field."), details: Some("0:  No update 1: CPU write direct operation has occured."), lo: 9, hi: 10 });
        fields.insert("LRN_MOVE_STICKY", Field { brief: Some("Set when a learn move has occured (move from CAM row to MAC table). Write '1' to clear this field."), details: Some("0:  No update 1: Learn move operation has occured."), lo: 11, hi: 12 });
        fields.insert("LRN_QUEUE_DATA_AVAIL_STICKY", Field { brief: Some("A non empty learn queue must be signalled."), details: Some("0:  Empty 1:  Non empty"), lo: 24, hi: 25 });
        fields.insert("LRN_QUEUE_OVERFLOW_STICKY", Field { brief: Some("A sticky bit must be set when a learn request arrives to an already full queue."), details: Some("0: No overflow 1:  Overflow Write '1' to clear bit."), lo: 25, hi: 26 });
        fields.insert("ROW_WITH_SCAN_ENTRY_STICKY", Field { brief: Some("Set if a row matching the scan condition has been found. (Check after MAC_TABLE_ACCESS_SHOT went to 0)."), details: Some("0: No entry has been found. 1: An entry has been found. Write '1' to clear this field."), lo: 20, hi: 21 });
        fields.insert("SCAN_REMOVED_STICKY", Field { brief: Some("Set if a MAC address entry has been removed due to a scan operation."), details: Some("0: No entries have been removed due to scan. 1: At least 1 entry has been removed due to scan. Write '1' to clear this field."), lo: 19, hi: 20 });
        regs.insert("EVENT_STICKY", Register { addr: Address { base: 15, count: 1, width: 1 }, brief: Some("Sticky diagnostic status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LATEST_COL", Field { brief: Some("This field holds the current (i.e. latest accessed) column number after a CPU_ACCESS_CMD has been finished."), details: Some("0: Column (bucket) 0 1: Column (bucket) 1 ... n: Column (bucket) n"), lo: 0, hi: 2 });
        fields.insert("LATEST_ROW", Field { brief: Some("This field holds the current (i.e. latest accessed) MAC table row number after a CPU_ACCESS_CMD has been finished."), details: Some("0: Row 0 1: Row 1 ... n: Row n"), lo: 4, hi: 18 });
        fields.insert("LATEST_TYPE", Field { brief: Some("This field holds the current (i.e. latest accessed) type after a CPU_ACCESS_CMD has been finished."), details: Some("0: MAC table 1: CAM MAC table"), lo: 24, hi: 25 });
        fields.insert("SCAN_NEXT_STATUS", Field { brief: Some("Gives the scan result per bucket of the last row scanned (bitgroup contains 1 bit per bucket of an entire row)."), details: Some("Per bucket: 0: Bucket does not match filter condition 1: Bucket does match filter condition Bit is cleared by writing a '1' to this position."), lo: 18, hi: 22 });
        regs.insert("LATEST_POS_STATUS", Register { addr: Address { base: 16, count: 1, width: 1 }, brief: Some("Learn Diagnostic"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MAC_ENTRY_FID", Field { brief: Some("Configures FID/VID for the MAC_ENTRY. This values is a FID for unicast entries and CL-VID for multicast entries. Can also be used as FID/VID filter value during SCAN or FIND SMALLEST Command."), details: None, lo: 16, hi: 29 });
        fields.insert("MAC_ENTRY_MAC_MSB", Field { brief: Some("Configures 16 MSB bits of the MAC address for the MAC_ENTRY. Used as starting MAC value during FIND SMALLEST Command."), details: Some("Upper 16 bits of MAC address."), lo: 0, hi: 16 });
        regs.insert("MAC_ACCESS_CFG_0", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("MAC entry Data 0"), details: Some("Configures MAC address and FID/VID when accessing the MAC table."), fields });
        let mut fields = HashMap::new();
        fields.insert("MAC_ENTRY_MAC_LSB", Field { brief: Some("Configures 32 LSB bits of the MAC address for the MAC_ENTRY. Used as starting MAC value during FIND SMALLEST Command."), details: Some("0xXXXXXXXX: Lower 32 bits of MAC address."), lo: 0, hi: 32 });
        regs.insert("MAC_ACCESS_CFG_1", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("MAC entry Data 1"), details: Some("Configures MAC address when accessing the MAC table."), fields });
        let mut fields = HashMap::new();
        fields.insert("MAC_ENTRY_ADDR", Field { brief: Some("Configures the ADDRESS for the MAC_ENTRY. Encoding of this field is determined by MAC_ENTRY_ADDR_TYPE. Can be used as filter value during SCAN or FIND SMALLEST Command."), details: Some("MAC_ENTRY_ADDR_TYPE= UPSID_PN: MAC_ENTRY_ADDR(9:5) = UPSID MAC_ENTRY_ADDR(4:0) = UPSPN Specifies unicast forwarding to port: UPSPN in device: UPSID. MAC_ENTRY_ADDR_TYPE = UPSID_CPU_OR_INT: MAC_ENTRY_ADDR(9:5) = UPSID MAC_ENTRY_ADDR(3:0) = CPU queue number when MAC_ENTRY_ADDR(11) = 0 MAC_ENTRY_ADDR(3:0) = Internal port number when MAC_ENTRY_ADDR(11) = 1 0xe: Internal port number (intpn_router) 0xf: Local lookup at destination upsid (ntpn_dlookup) MAC_ENTRY_ADDR_TYPE = GLAG MAC_ENTRY_ADDR = GLAGID Specifies unicast forwarding to the global aggregated port group: GLAGID. MAC_ENTRY_ADDR_TYPE = MC_IDX: MAC_ENTRY_ADDR = MC_IDX Specifies forwarding according to ANA_AC:PGID[32 + MC_IDX)"), lo: 0, hi: 12 });
        fields.insert("MAC_ENTRY_ADDR_TYPE", Field { brief: Some("Configures MAC_ENTRY address type. Can be used as filter value during SCAN or FIND SMALLEST Command."), details: Some("0: UPSID_PN 1: UPSID_CPU_OR_INT 2: GLAG 3: MC_IDX"), lo: 12, hi: 15 });
        fields.insert("MAC_ENTRY_AGE_FLAG", Field { brief: Some("MAC_ENTRY AGE flag used to identify if a MAC_ENTRY is active of not. Cleared by HW when a entry is used as source entry. Used to ensure that entries associated with inactive stations can be located and discarded. The MAC table can be aged by HW either a CPU Scan command or through Automatic ageing (LRN::AUTOAGE_CFG)."), details: Some("0:  Not aged n:  Aged n times."), lo: 19, hi: 21 });
        fields.insert("MAC_ENTRY_AGE_INTERVAL", Field { brief: Some("MAC_ENTRY AGE Interval is used to select which age timer is associated with the entry. The MAC table can be aged by HW either a CPU Scan command or through Automatic ageing (LRN::AUTOAGE_CFG)."), details: None, lo: 17, hi: 19 });
        fields.insert("MAC_ENTRY_CPU_COPY", Field { brief: Some("Configures MAC_ENTRY CPU copy flag. Used together with ANA_L2::FWD_CFG.CPU_DMAC_COPY_ENA to determine if a CPU copy should be send when the entry found as forwarding entry. Used together with ANA_L2::LRN_CFG.CPU_SMAC_COPY_ENA to determine if a CPU copy should be send when the entry found as source entry."), details: None, lo: 23, hi: 24 });
        fields.insert("MAC_ENTRY_CPU_QU", Field { brief: Some("Configures MAC_ENTRY CPU Queue number if MAC_ENTRY_CPU_COPY is set."), details: None, lo: 24, hi: 27 });
        fields.insert("MAC_ENTRY_LOCKED", Field { brief: Some("Configures the MAC_ENTRY locked flag. Used to install static MAC table entries that can not be removed by learning and ageing."), details: Some("0: Not locked 1: Locked."), lo: 16, hi: 17 });
        fields.insert("MAC_ENTRY_MIRROR", Field { brief: Some("Configures the MAC_ENTRY mirror flag. Used to configure MAC entries that are candidates for mirroring. See: ANA_AC:MIRROR_PROBE:PROBE_CFG.PROBE_MAC_MODE."), details: None, lo: 21, hi: 22 });
        fields.insert("MAC_ENTRY_NXT_LRN_ALL", Field { brief: Some("Configures MAC_ENTRY NXT_LRN_ALL flag. This is used to ensure MAC entries are learned consistend in a multi device configuration. Cleared by HW when a frame is received for a (IFID, SMAC) matching this entry."), details: Some("0:  Disabled 1:  Next learn all."), lo: 27, hi: 28 });
        fields.insert("MAC_ENTRY_SRC_KILL_FWD", Field { brief: Some("Configures MAC_ENTRY SRC_KILL_FWD flag. Used to discard forwarding of frames from this source."), details: Some("0: Disable 1: Enable (Frames with this entry MAC address as SMAC are killed)"), lo: 28, hi: 29 });
        fields.insert("MAC_ENTRY_VLAN_IGNORE", Field { brief: Some("Configures MAC_ENTRY VLAN ignore flag. Can be used to ignore VLAN mask or Source mask during forwarding based on ANA_L2::FWD_CFG.FILTER_MODE_SEL."), details: Some("0: no effect 1: VLAN mask or source mask is ignored."), lo: 22, hi: 23 });
        fields.insert("MAC_ENTRY_VLD", Field { brief: Some("Configures the MAC_ENTRY valid flag. Used to indicate that this entry is active. This bit can be cleared for non locked entries by auto learning or through the CPU_ACCESS_CMD UNLEARN command."), details: Some("0: Invalid 1: Valid."), lo: 15, hi: 16 });
        regs.insert("MAC_ACCESS_CFG_2", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("MAC entry Data 2"), details: Some("Configures warious MAC_ENTRY parameters when accessing the MAC table"), fields });
        let mut fields = HashMap::new();
        fields.insert("SCAN_LAST_ROW", Field { brief: Some("Configures the last row to be part of scan. ignored if set to all ones."), details: Some("0: Scan completes at row 0 ... n: Scan completes at row n"), lo: 0, hi: 14 });
        regs.insert("SCAN_LAST_ROW_CFG", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Configures last scan row"), details: Some("Configures an ending row for scan access."), fields });
        let mut fields = HashMap::new();
        fields.insert("ADDR_FILTER_ENA", Field { brief: Some("Specifies whether ADDR values is dont care or will only affect entries with a specific ADDR value during FIND SMALLEST or SCAN commands (refer also to MAC_ENTRY_ADDR, MAC_ENTRY_ADDR_TYPE and FID_FILTER_ENA / MAC_ENTRY_ADDR)."), details: Some("0: Disable. SCAN and FIND_SMALLEST commands will treat MAC_ENTRY_ADDR and MAC_ENTRY_ADDR_TYPE values as don't care.. 1: Enable MAC_ENTRY_ADDR and MAC_ENTRY_ADDR_TYPE filter. SCAN and FIND_SMALLEST commands will only search for entries with Address value corresponding to MAC_ENTRY_ADDR and MAC_ENTRY_ADDR_TYPE taking LRN::SCAN_NEXT_CFG_1.SCAN_ENTRY_ADDR_MASK into account)."), lo: 0, hi: 1 });
        fields.insert("FID_FILTER_ENA", Field { brief: Some("Configures if FIND SMALLEST command or SCAN command cares about FID values or not. It is possible to configure additional FID filters through: ANA_L2:COMMON:SCAN_FID_CTRL.SCAN_FID_ENA and ANA_L2:COMMON:SCAN_FID_CFG.SCAN_FID_VAL"), details: Some("0: Disable FID/VID filters (and ignore FID/VID) during SCAN and FIND_SMALLEST commands. 1: Enable FID/VID filter(s) during SCAN and FIND_SMALLEST. Only entries with FID/VID value equal to LRN::MAC_ACCESS_CFG_0.MAC_ENTRY_FID or optionally also values configured in ANA_L2:COMMON:SCAN_FID_CFG.SCAN_FID_VAL will be found."), lo: 1, hi: 2 });
        fields.insert("NXT_LRN_ALL_FILTER_ENA", Field { brief: Some("Configures whether NXT_LRN_ALL values is don't care or entries with a specific NXT_LRN_ALL/CCM_CHG value are found during FIND SMALLEST or SCAN commands."), details: Some("0: SCAN and FIND_SMALLEST commands don't care about MAC_ENTRY_NXT_LRN_ALL. 1: Enable filter. SCAN and FIND_SMALLEST commands will only search for entries with NXT_LRN_ALL set according to MAC_ENTRY_NXT_LRN_ALL."), lo: 12, hi: 13 });
        fields.insert("SCAN_AGE_FILTER_SEL", Field { brief: Some("Specify how MAC_ENTRY_AGE is matched during scan commands."), details: Some("0: Ignore 1: Find entries with MAC_ENTRY_AGE equal to MAC_ACCESS_CFG_2.MAC_ENTRY_AGE_FLAG or larger 2: Find entries with MAC_ENTRY_AGE equal to MAC_ACCESS_CFG_2.MAC_ENTRY_AGE_FLAG or smaller 3: Find entries with MAC_ENTRY_AGE equal to MAC_ACCESS_CFG_2.MAC_ENTRY_AGE_FLAG."), lo: 14, hi: 16 });
        fields.insert("SCAN_AGE_FLAG_UPDATE_SEL", Field { brief: Some("Controls update of MAC_ENTRY_AGE_FLAG for found entries. Field is ignored if SCAN_NEXT_INC_AGE_BITS_ENA is set"), details: Some("0: No change to MAC_ENTRY_AGE_FLAG 1: Clear MAC_ENTRY_AGE_FLAG 2: Set MAC_ENTRY_AGE_FLAG 3: MAC_ENTRY_AGE_FLAG 4: MAC_ENTRY_AGE_FLAG"), lo: 18, hi: 21 });
        fields.insert("SCAN_AGE_INTERVAL_MASK", Field { brief: Some("Specifies age intervals are taken into account during FIND SMALLEST or SCAN commands ."), details: Some("x0: Don't find entries in the corresponding age interval. 0x: Entries with the corresponding interval are taken into account."), lo: 2, hi: 6 });
        fields.insert("SCAN_NEXT_AGED_ONLY_ENA", Field { brief: Some("Specify whether AGE flags are ignored during scan commands."), details: Some("0: Ignore the MAC_ENTRY_AGE_FLAG duting scan. 1: Find only entries with MAC_ENTRY_AGE_FLAG set."), lo: 7, hi: 8 });
        fields.insert("SCAN_NEXT_IGNORE_LOCKED_ENA", Field { brief: Some("Configures whether locked entries are ignored during a FIND SMALLEST or SCAN commands or not."), details: Some("0: Consider only unlocked (entries with MAC_ENTRY_LOCKED cleared) entries during FIND SMALLEST or SCAN commands. 1: Ignore MAC_ENTRY_LOCKED flag during FIND SMALLEST or SCAN commands."), lo: 6, hi: 7 });
        fields.insert("SCAN_NEXT_INC_AGE_BITS_ENA", Field { brief: Some("Configures whether the MAC_ENTRY_AGE_FLAG will be incremented during scan commands or not."), details: Some("0: Find next will keep entries intact. 1: Find next will increment MAC_ENTRY_AGE_FLAG for entries matching the filter conditions. Refer also to bitgroup SCAN_NEXT_REMOVE_FOUND_ENA"), lo: 8, hi: 9 });
        fields.insert("SCAN_NEXT_MOVE_FOUND_ENA", Field { brief: Some("Controls update of MAC_ENTRY_ADDR_TYPE and MAC_ENTRY_ADDR for entries matched during a SCAN command. (Will only have effect if SCAN_NEXT_UNTIL_FOUND_ENA is disabled). Allows all MAC addresses learned on a specific port to be moved to another port. Refer also to PORT_MOVE_NEW_ADDR and SCAN_ENTRY_ADDR_MASK"), details: Some("0: MAC_ENTRY_ADDR and MAC_ENTRY_ADDR_TYPE will be kept unaffected. 1: Entries matching the condition will have MAC_ENTRY_ADDR and MAC_ENTRY_ADDR_TYPE updated."), lo: 13, hi: 14 });
        fields.insert("SCAN_NEXT_REMOVE_FOUND_ENA", Field { brief: Some("Controls whether scan removes entries matching the condition or not. CPU Age scan: if SCAN_NEXT_REMOVE_FOUND_ENA==1 and SCAN_NEXT_INC_AGE_BITS_ENA == 1 and SCAN_NEXT_AGED_ONLY_ENA==0 then non aged entries (MAC_ENTRY_AGE_FLAG less than max configured through ANA_L2::LRN_CFG.AGE_SIZE) will be aged (MAC_ENTRY_AGE_FLAG incremented) and aged entries  (MAC_ENTRY_AGE_FLAG set to MAX) will be removed. CPU cleanup scan: if SCAN_NEXT_REMOVE_FOUND_ENA==1 and SCAN_NEXT_INC_AGE_BITS_ENA ==0 then all entries matching the enabled filtering conditions will be removed. (Will only have effect if SCAN_NEXT_UNTIL_FOUND_ENA is disabled)."), details: Some("0: No entries will be removed. 1: Entries matching the condition will be removed (or MAC_ENTRY_AGE_FLAG will be incremented based on SCAN_NEXT_INC_AGE_BITS_ENA)"), lo: 10, hi: 11 });
        fields.insert("SCAN_NEXT_UNTIL_FOUND_ENA", Field { brief: Some("Specify whether the scan stops at the next row which matches the condition during scan commands."), details: Some("0: SCAN command scans through the complete table. 1: Scan stops at the first row with one or more entries matching the filter conditions."), lo: 9, hi: 10 });
        fields.insert("SCAN_NXT_LRN_ALL_UPDATE_SEL", Field { brief: Some("Controls update of MAC_ENTRY_NXT_LRN_ALL for found entries."), details: Some("0: No change to MAC_ENTRY_NXT_LRN_ALL 1: Clear MAC_ENTRY_NXT_LRN_ALL 2: Set MAC_ENTRY_NXT_LRN_ALL."), lo: 16, hi: 18 });
        fields.insert("SCAN_USE_PORT_FILTER_ENA", Field { brief: Some("Configures scanning of all port or only port not disabled in ANA_L2::FILTER_OTHER_CTRL and ANA_L2::FILTER_LOCAL_CTRL."), details: Some("0: Disable 1: Enable."), lo: 11, hi: 12 });
        regs.insert("SCAN_NEXT_CFG", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Scan parameters"), details: Some("Configures various filters and associated actions when scanning the MAC table through CPU Scan Command."), fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_MOVE_NEW_ADDR", Field { brief: Some("NEW ADDRESS when doing port move scan. This specifies the MAC_ENTRY_ADDR with don't care positions (i.e. only care positions are replaced)."), details: None, lo: 16, hi: 31 });
        fields.insert("SCAN_ENTRY_ADDR_MASK", Field { brief: Some("ADDRESS mask when doing port scan. This correspond to specify MAC_ENTRY_ADDR with dont care positions (MSB-1 controls two additional type bits). To scan for all upsid_pn entries set MAC_ENTRY_ADDR_TYPE= UPSID_PN and SCAN_ENTRY_ADDR_MASK(14:12)=\"111\" and remaining SCAN_ENTRY_ADDR_MASK bits to ALL_ZEROS"), details: Some("0: The corresponding bit is treated as dont care (ignore bit value) 1: The corresponding bit is treated as care"), lo: 0, hi: 15 });
        regs.insert("SCAN_NEXT_CFG_1", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Age Filter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SCAN_NEXT_CNT", Field { brief: Some("Counter with number of found scan entries."), details: None, lo: 0, hi: 16 });
        regs.insert("SCAN_NEXT_CNT", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Age Filter"), details: None, fields });
        groups.insert("COMMON", RegisterGroup { addr: Address { base: 0, count: 1, width: 17 }, desc: "Common configurations and status for all ports", regs });
        out.insert("LRN", Target { desc: "Learn block", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ECRC_CHECK_CAP", Field { brief: None, details: None, lo: 7, hi: 8 });
        fields.insert("ECRC_CHECK_EN", Field { brief: None, details: None, lo: 8, hi: 9 });
        fields.insert("ECRC_GEN_CAP", Field { brief: None, details: None, lo: 5, hi: 6 });
        fields.insert("ECRC_GEN_EN", Field { brief: None, details: None, lo: 6, hi: 7 });
        fields.insert("FIRST_ERR_POINTER", Field { brief: None, details: None, lo: 0, hi: 5 });
        regs.insert("ADV_ERR_CAP_CTRL", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Word offset 6"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CAP_ID", Field { brief: None, details: None, lo: 0, hi: 16 });
        fields.insert("CAP_VERSION", Field { brief: None, details: None, lo: 16, hi: 20 });
        fields.insert("NEXT_OFFSET", Field { brief: None, details: None, lo: 20, hi: 32 });
        regs.insert("AER_EXT_CAP_HDR", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Word offset 0"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ADVISORY_NON_FATAL_ERR_MASK", Field { brief: None, details: None, lo: 13, hi: 14 });
        fields.insert("BAD_DLLP_MASK", Field { brief: None, details: None, lo: 7, hi: 8 });
        fields.insert("BAD_TLP_MASK", Field { brief: None, details: None, lo: 6, hi: 7 });
        fields.insert("CORRECTED_INT_ERR_MASK", Field { brief: None, details: None, lo: 14, hi: 15 });
        fields.insert("REPLAY_NO_ROLEOVER_MASK", Field { brief: None, details: None, lo: 8, hi: 9 });
        fields.insert("RPL_TIMER_TIMEOUT_MASK", Field { brief: None, details: None, lo: 12, hi: 13 });
        fields.insert("RX_ERR_MASK", Field { brief: None, details: None, lo: 0, hi: 1 });
        regs.insert("CORR_ERR_MASK", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Word offset 5"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ADVISORY_NON_FATAL_ERR_STATUS", Field { brief: None, details: None, lo: 13, hi: 14 });
        fields.insert("BAD_DLLP_STATUS", Field { brief: None, details: None, lo: 7, hi: 8 });
        fields.insert("BAD_TLP_STATUS", Field { brief: None, details: None, lo: 6, hi: 7 });
        fields.insert("CORRECTED_INT_ERR_STATUS", Field { brief: None, details: None, lo: 14, hi: 15 });
        fields.insert("REPLAY_NO_ROLEOVER_STATUS", Field { brief: None, details: None, lo: 8, hi: 9 });
        fields.insert("RPL_TIMER_TIMEOUT_STATUS", Field { brief: None, details: None, lo: 12, hi: 13 });
        fields.insert("RX_ERR_STATUS", Field { brief: None, details: None, lo: 0, hi: 1 });
        regs.insert("CORR_ERR_STATUS", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Word offset 4"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FIRST_DWORD", Field { brief: None, details: None, lo: 0, hi: 32 });
        regs.insert("HDR_LOG_REG_0", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Word offset 7"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SECOND_DWORD", Field { brief: None, details: None, lo: 0, hi: 32 });
        regs.insert("HDR_LOG_REG_1", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("Word offset 8"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("THIRD_DWORD", Field { brief: None, details: None, lo: 0, hi: 32 });
        regs.insert("HDR_LOG_REG_2", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("Word offset 9"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PCIE_CAP_CURR_DEEMPHASIS", Field { brief: None, details: None, lo: 16, hi: 17 });
        fields.insert("PCIE_CAP_EQ_CPL", Field { brief: None, details: None, lo: 17, hi: 18 });
        fields.insert("PCIE_CAP_EQ_CPL_P1", Field { brief: None, details: None, lo: 18, hi: 19 });
        fields.insert("PCIE_CAP_EQ_CPL_P2", Field { brief: None, details: None, lo: 19, hi: 20 });
        fields.insert("PCIE_CAP_EQ_CPL_P3", Field { brief: None, details: None, lo: 20, hi: 21 });
        fields.insert("PCIE_CAP_LINK_EQ_REQ", Field { brief: None, details: None, lo: 21, hi: 22 });
        regs.insert("LINK_CONTROL2_LINK_STATUS2", Register { addr: Address { base: 12, count: 1, width: 1 }, brief: Some("Word offset 12"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ATOMIC_EGRESS_BLOCKED_ERR_MASK", Field { brief: None, details: None, lo: 24, hi: 25 });
        fields.insert("CMPLT_ABORT_ERR_MASK", Field { brief: None, details: None, lo: 15, hi: 16 });
        fields.insert("CMPLT_TIMEOUT_ERR_MASK", Field { brief: None, details: None, lo: 14, hi: 15 });
        fields.insert("DL_PROTOCOL_ERR_MASK", Field { brief: None, details: None, lo: 4, hi: 5 });
        fields.insert("ECRC_ERR_MASK", Field { brief: None, details: None, lo: 19, hi: 20 });
        fields.insert("FC_PROTOCOL_ERR_MASK", Field { brief: None, details: None, lo: 13, hi: 14 });
        fields.insert("INTERNAL_ERR_MASK", Field { brief: None, details: None, lo: 22, hi: 23 });
        fields.insert("MALF_TLP_ERR_MASK", Field { brief: None, details: None, lo: 18, hi: 19 });
        fields.insert("POIS_TLP_ERR_MASK", Field { brief: None, details: None, lo: 12, hi: 13 });
        fields.insert("REC_OVERFLOW_ERR_MASK", Field { brief: None, details: None, lo: 17, hi: 18 });
        fields.insert("SUR_DWN_ERR_MASK", Field { brief: None, details: None, lo: 5, hi: 6 });
        fields.insert("UNEXP_CMPLT_ERR_MASK", Field { brief: None, details: None, lo: 16, hi: 17 });
        fields.insert("UNSUPPORTED_REQ_ERR_MASK", Field { brief: None, details: None, lo: 20, hi: 21 });
        regs.insert("UNCORR_ERR_MASK", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Word offset 2"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ATOMIC_EGRESS_BLOCKED_ERR_SEVERITY", Field { brief: None, details: None, lo: 24, hi: 25 });
        fields.insert("CMPLT_ABORT_ERR_SEVERITY", Field { brief: None, details: None, lo: 15, hi: 16 });
        fields.insert("CMPLT_TIMEOUT_ERR_SEVERITY", Field { brief: None, details: None, lo: 14, hi: 15 });
        fields.insert("DL_PROTOCOL_ERR_SEVERITY", Field { brief: None, details: None, lo: 4, hi: 5 });
        fields.insert("ECRC_ERR_SEVERITY", Field { brief: None, details: None, lo: 19, hi: 20 });
        fields.insert("FC_PROTOCOL_ERR_SEVERITY", Field { brief: None, details: None, lo: 13, hi: 14 });
        fields.insert("INTERNAL_ERR_SEVERITY", Field { brief: None, details: None, lo: 22, hi: 23 });
        fields.insert("MALF_TLP_ERR_SEVERITY", Field { brief: None, details: None, lo: 18, hi: 19 });
        fields.insert("POIS_TLP_ERR_SEVERITY", Field { brief: None, details: None, lo: 12, hi: 13 });
        fields.insert("REC_OVERFLOW_ERR_SEVERITY", Field { brief: None, details: None, lo: 17, hi: 18 });
        fields.insert("SUR_DWN_ERR_SEVERITY", Field { brief: None, details: None, lo: 5, hi: 6 });
        fields.insert("UNEXP_CMPLT_ERR_SEVERITY", Field { brief: None, details: None, lo: 16, hi: 17 });
        fields.insert("UNSUPPORTED_REQ_ERR_SEVERITY", Field { brief: None, details: None, lo: 20, hi: 21 });
        regs.insert("UNCORR_ERR_SEV", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Word offset 3"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ATOMIC_EGRESS_BLOCKED_ERR_STATUS", Field { brief: None, details: None, lo: 24, hi: 25 });
        fields.insert("CMPLT_ABORT_ERR_STATUS", Field { brief: None, details: None, lo: 15, hi: 16 });
        fields.insert("CMPLT_TIMEOUT_ERR_STATUS", Field { brief: None, details: None, lo: 14, hi: 15 });
        fields.insert("DL_PROTOCOL_ERR_STATUS", Field { brief: None, details: None, lo: 4, hi: 5 });
        fields.insert("ECRC_ERR_STATUS", Field { brief: None, details: None, lo: 19, hi: 20 });
        fields.insert("FC_PROTOCOL_ERR_STATUS", Field { brief: None, details: None, lo: 13, hi: 14 });
        fields.insert("INTERNAL_ERR_STATUS", Field { brief: None, details: None, lo: 22, hi: 23 });
        fields.insert("MALF_TLP_ERR_STATUS", Field { brief: None, details: None, lo: 18, hi: 19 });
        fields.insert("POIS_TLP_ERR_STATUS", Field { brief: None, details: None, lo: 12, hi: 13 });
        fields.insert("REC_OVERFLOW_ERR_STATUS", Field { brief: None, details: None, lo: 17, hi: 18 });
        fields.insert("SUR_DWN_ERR_STATUS", Field { brief: None, details: None, lo: 5, hi: 6 });
        fields.insert("UNEXP_CMPLT_ERR_STATUS", Field { brief: None, details: None, lo: 16, hi: 17 });
        fields.insert("UNSUPPORTED_REQ_ERR_STATUS", Field { brief: None, details: None, lo: 20, hi: 21 });
        regs.insert("UNCORR_ERR_STATUS", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Word offset 1"), details: None, fields });
        groups.insert("PCIE_AER_CAP", RegisterGroup { addr: Address { base: 64, count: 1, width: 3 }, desc: "PCIe Advanced Error Capability and Control", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("PCIE_CAP_EP_L0S_ACCPT_LATENCY", Field { brief: None, details: None, lo: 6, hi: 9 });
        fields.insert("PCIE_CAP_EP_L1_ACCPT_LATENCY", Field { brief: None, details: None, lo: 9, hi: 12 });
        fields.insert("PCIE_CAP_EXT_TAG_SUPP", Field { brief: None, details: None, lo: 5, hi: 6 });
        fields.insert("PCIE_CAP_FLR_CAP", Field { brief: None, details: None, lo: 28, hi: 29 });
        fields.insert("PCIE_CAP_MAX_PAYLOAD_SIZE", Field { brief: None, details: None, lo: 0, hi: 3 });
        fields.insert("PCIE_CAP_PHANTOM_FUNC_SUPPORT", Field { brief: None, details: None, lo: 3, hi: 5 });
        fields.insert("PCIE_CAP_ROLE_BASED_ERR_REPORT", Field { brief: None, details: None, lo: 15, hi: 16 });
        regs.insert("DEVICE_CAPABILITIES", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Word offset 1"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PCIE_CAP_128_CAS_CPL_SUPP", Field { brief: None, details: None, lo: 9, hi: 10 });
        fields.insert("PCIE_CAP_32_ATOMIC_CPL_SUPP", Field { brief: None, details: None, lo: 7, hi: 8 });
        fields.insert("PCIE_CAP_64_ATOMIC_CPL_SUPP", Field { brief: None, details: None, lo: 8, hi: 9 });
        fields.insert("PCIE_CAP_ARI_FORWARD_SUPPORT", Field { brief: None, details: None, lo: 5, hi: 6 });
        fields.insert("PCIE_CAP_ATOMIC_ROUTING_SUPP", Field { brief: None, details: None, lo: 6, hi: 7 });
        fields.insert("PCIE_CAP_CPL_TIMEOUT_DISABLE_SUPPORT", Field { brief: None, details: None, lo: 4, hi: 5 });
        fields.insert("PCIE_CAP_CPL_TIMEOUT_RANGE", Field { brief: None, details: None, lo: 0, hi: 4 });
        fields.insert("PCIE_CAP_LTR_SUPP", Field { brief: None, details: None, lo: 11, hi: 12 });
        fields.insert("PCIE_CAP_NO_RO_EN_PR2PR_PAR", Field { brief: None, details: None, lo: 10, hi: 11 });
        fields.insert("PCIE_CAP_OBFF_SUPPORT", Field { brief: None, details: None, lo: 18, hi: 20 });
        fields.insert("PCIE_CAP_TPH_CMPLT_SUPPORT_0", Field { brief: None, details: None, lo: 12, hi: 13 });
        fields.insert("PCIE_CAP_TPH_CMPLT_SUPPORT_1", Field { brief: None, details: None, lo: 13, hi: 14 });
        regs.insert("DEVICE_CAPABILITIES2", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("Word offset 9"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PCIE_CAP_ARI_FORWARD_SUPPORT_CS", Field { brief: None, details: None, lo: 5, hi: 6 });
        fields.insert("PCIE_CAP_CPL_TIMEOUT_DISABLE", Field { brief: None, details: None, lo: 4, hi: 5 });
        regs.insert("DEVICE_CONTROL2_DEVICE_STATUS2", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("Word offset 10"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PCIE_CAP_AUX_POWER_DETECTED", Field { brief: None, details: None, lo: 20, hi: 21 });
        fields.insert("PCIE_CAP_AUX_POWER_PM_EN", Field { brief: None, details: None, lo: 10, hi: 11 });
        fields.insert("PCIE_CAP_CORR_ERR_DETECTED", Field { brief: None, details: None, lo: 16, hi: 17 });
        fields.insert("PCIE_CAP_CORR_ERR_REPORT_EN", Field { brief: None, details: None, lo: 0, hi: 1 });
        fields.insert("PCIE_CAP_EN_NO_SNOOP", Field { brief: None, details: None, lo: 11, hi: 12 });
        fields.insert("PCIE_CAP_EN_REL_ORDER", Field { brief: None, details: None, lo: 4, hi: 5 });
        fields.insert("PCIE_CAP_EXT_TAG_EN", Field { brief: None, details: None, lo: 8, hi: 9 });
        fields.insert("PCIE_CAP_FATAL_ERR_DETECTED", Field { brief: None, details: None, lo: 18, hi: 19 });
        fields.insert("PCIE_CAP_FATAL_ERR_REPORT_EN", Field { brief: None, details: None, lo: 2, hi: 3 });
        fields.insert("PCIE_CAP_INITIATE_FLR", Field { brief: None, details: None, lo: 15, hi: 16 });
        fields.insert("PCIE_CAP_MAX_PAYLOAD_SIZE_CS", Field { brief: None, details: None, lo: 5, hi: 8 });
        fields.insert("PCIE_CAP_MAX_READ_REQ_SIZE", Field { brief: None, details: None, lo: 12, hi: 15 });
        fields.insert("PCIE_CAP_NON_FATAL_ERR_DETECTED", Field { brief: None, details: None, lo: 17, hi: 18 });
        fields.insert("PCIE_CAP_NON_FATAL_ERR_REPORT_EN", Field { brief: None, details: None, lo: 1, hi: 2 });
        fields.insert("PCIE_CAP_PHANTOM_FUNC_EN", Field { brief: None, details: None, lo: 9, hi: 10 });
        fields.insert("PCIE_CAP_TRANS_PENDING", Field { brief: None, details: None, lo: 21, hi: 22 });
        fields.insert("PCIE_CAP_UNSUPPORTED_REQ_DETECTED", Field { brief: None, details: None, lo: 19, hi: 20 });
        fields.insert("PCIE_CAP_UNSUPPORT_REQ_REP_EN", Field { brief: None, details: None, lo: 3, hi: 4 });
        regs.insert("DEVICE_CONTROL_DEVICE_STATUS", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Word offset 2"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PCIE_CAP_ACTIVE_STATE_LINK_PM_SUPPORT", Field { brief: None, details: None, lo: 10, hi: 12 });
        fields.insert("PCIE_CAP_ASPM_OPT_COMPLIANCE", Field { brief: None, details: None, lo: 22, hi: 23 });
        fields.insert("PCIE_CAP_CLOCK_POWER_MAN", Field { brief: None, details: None, lo: 18, hi: 19 });
        fields.insert("PCIE_CAP_DLL_ACTIVE_REP_CAP", Field { brief: None, details: None, lo: 20, hi: 21 });
        fields.insert("PCIE_CAP_L0S_EXIT_LATENCY", Field { brief: None, details: None, lo: 12, hi: 15 });
        fields.insert("PCIE_CAP_L1_EXIT_LATENCY", Field { brief: None, details: None, lo: 15, hi: 18 });
        fields.insert("PCIE_CAP_LINK_BW_NOT_CAP", Field { brief: None, details: None, lo: 21, hi: 22 });
        fields.insert("PCIE_CAP_MAX_LINK_SPEED", Field { brief: None, details: None, lo: 0, hi: 4 });
        fields.insert("PCIE_CAP_MAX_LINK_WIDTH", Field { brief: None, details: None, lo: 4, hi: 10 });
        fields.insert("PCIE_CAP_PORT_NUM", Field { brief: None, details: None, lo: 24, hi: 32 });
        fields.insert("PCIE_CAP_SURPRISE_DOWN_ERR_REP_CAP", Field { brief: None, details: None, lo: 19, hi: 20 });
        regs.insert("LINK_CAPABILITIES", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Word offset 3"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PCIE_CAP_CROSS_LINK_SUPPORT", Field { brief: None, details: None, lo: 8, hi: 9 });
        fields.insert("PCIE_CAP_SUPPORT_LINK_SPEED_VECTOR", Field { brief: None, details: None, lo: 1, hi: 8 });
        regs.insert("LINK_CAPABILITIES2", Register { addr: Address { base: 11, count: 1, width: 1 }, brief: Some("Word offset 11"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PCIE_CAP_ACTIVE_STATE_LINK_PM_CONTROL", Field { brief: None, details: None, lo: 0, hi: 2 });
        fields.insert("PCIE_CAP_COMMON_CLK_CONFIG", Field { brief: None, details: None, lo: 6, hi: 7 });
        fields.insert("PCIE_CAP_DLL_ACTIVE", Field { brief: None, details: None, lo: 29, hi: 30 });
        fields.insert("PCIE_CAP_EN_CLK_POWER_MAN", Field { brief: None, details: None, lo: 8, hi: 9 });
        fields.insert("PCIE_CAP_EXTENDED_SYNCH", Field { brief: None, details: None, lo: 7, hi: 8 });
        fields.insert("PCIE_CAP_LINK_AUOT_BW_STATUS", Field { brief: None, details: None, lo: 31, hi: 32 });
        fields.insert("PCIE_CAP_LINK_AUTO_BW_INT_EN", Field { brief: None, details: None, lo: 11, hi: 12 });
        fields.insert("PCIE_CAP_LINK_BW_MAN_INT_EN", Field { brief: None, details: None, lo: 10, hi: 11 });
        fields.insert("PCIE_CAP_LINK_BW_MAN_STATUS", Field { brief: None, details: None, lo: 30, hi: 31 });
        fields.insert("PCIE_CAP_LINK_DISABLE", Field { brief: None, details: None, lo: 4, hi: 5 });
        fields.insert("PCIE_CAP_LINK_SPEED", Field { brief: None, details: None, lo: 16, hi: 20 });
        fields.insert("PCIE_CAP_LINK_TRAINING", Field { brief: None, details: None, lo: 27, hi: 28 });
        fields.insert("PCIE_CAP_NEGO_LINK_WIDTH", Field { brief: None, details: None, lo: 20, hi: 25 });
        fields.insert("PCIE_CAP_RCB", Field { brief: None, details: None, lo: 3, hi: 4 });
        fields.insert("PCIE_CAP_RETRAIN_LINK", Field { brief: None, details: None, lo: 5, hi: 6 });
        fields.insert("PCIE_CAP_SLOT_CLK_CONFIG", Field { brief: None, details: None, lo: 28, hi: 29 });
        regs.insert("LINK_CONTROL_LINK_STATUS", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Word offset 4"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PCI_MSI_PENDING_BIT", Field { brief: None, details: None, lo: 0, hi: 32 });
        regs.insert("MSI_PENDING_BIT", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Word offset 5"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PCIE_CAP", Field { brief: None, details: None, lo: 16, hi: 20 });
        fields.insert("PCIE_CAP_ID", Field { brief: None, details: None, lo: 0, hi: 8 });
        fields.insert("PCIE_CAP_NEXT_PTR", Field { brief: None, details: None, lo: 8, hi: 16 });
        fields.insert("PCIE_DEV_PORT_TYPE", Field { brief: None, details: None, lo: 20, hi: 24 });
        fields.insert("PCIE_INT_MSG_NUM", Field { brief: None, details: None, lo: 25, hi: 30 });
        fields.insert("PCIE_SLOT_IMP", Field { brief: None, details: None, lo: 24, hi: 25 });
        fields.insert("RSVD", Field { brief: None, details: None, lo: 30, hi: 31 });
        regs.insert("PCIE_CAP_ID_PCIE_NEXT_CAP_PTR_PCIE_CAP", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Word offset 0"), details: None, fields });
        groups.insert("PCIE_CAP", RegisterGroup { addr: Address { base: 28, count: 1, width: 3 }, desc: "PCIe Capability Register Set", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("B2_B3_SUPPORT", Field { brief: None, details: None, lo: 22, hi: 23 });
        fields.insert("BUS_PWR_CLK_CON_EN", Field { brief: None, details: None, lo: 23, hi: 24 });
        fields.insert("DATA_REG_ADD_INFO", Field { brief: None, details: None, lo: 24, hi: 32 });
        fields.insert("DATA_SCALE", Field { brief: None, details: None, lo: 13, hi: 15 });
        fields.insert("DATA_SELECT", Field { brief: None, details: None, lo: 9, hi: 13 });
        fields.insert("NO_SOFT_RST", Field { brief: None, details: None, lo: 3, hi: 4 });
        fields.insert("PME_ENABLE", Field { brief: None, details: None, lo: 8, hi: 9 });
        fields.insert("PME_STATUS", Field { brief: None, details: None, lo: 15, hi: 16 });
        fields.insert("POWER_STATE", Field { brief: None, details: None, lo: 0, hi: 2 });
        regs.insert("CON_STATUS", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Word offset 1"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PCI_MSI_LOWER_32", Field { brief: None, details: None, lo: 2, hi: 32 });
        regs.insert("MSI_LOWER_32", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Word offset 1"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PCI_MSI_UPPER_32", Field { brief: None, details: None, lo: 0, hi: 32 });
        regs.insert("MSI_UPPER_32", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Word offset 2"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PCI_MSI_64_BIT_ADDR_CAP", Field { brief: None, details: None, lo: 23, hi: 24 });
        fields.insert("PCI_MSI_CAP_ID", Field { brief: None, details: None, lo: 0, hi: 8 });
        fields.insert("PCI_MSI_CAP_NEXT_OFFSET", Field { brief: None, details: None, lo: 8, hi: 16 });
        fields.insert("PCI_MSI_ENABLE", Field { brief: None, details: None, lo: 16, hi: 17 });
        fields.insert("PCI_MSI_MULTIPLE_MSG_CAP", Field { brief: None, details: None, lo: 17, hi: 20 });
        fields.insert("PCI_MSI_MULTIPLE_MSG_EN", Field { brief: None, details: None, lo: 20, hi: 23 });
        fields.insert("PCI_PVM_SUPPORT", Field { brief: None, details: None, lo: 24, hi: 25 });
        regs.insert("PCI_MSI_CAP_ID_NEXT_CTRL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Word offset 0"), details: None, fields });
        groups.insert("PCIE_MSI_CAP", RegisterGroup { addr: Address { base: 20, count: 1, width: 3 }, desc: "PCIe Message Signaled Interrupts", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("AUX_CURR", Field { brief: None, details: None, lo: 22, hi: 25 });
        fields.insert("D1_SUPPORT", Field { brief: None, details: None, lo: 25, hi: 26 });
        fields.insert("D2_SUPPORT", Field { brief: None, details: None, lo: 26, hi: 27 });
        fields.insert("DSI", Field { brief: None, details: None, lo: 21, hi: 22 });
        fields.insert("PME_CLK", Field { brief: None, details: None, lo: 19, hi: 20 });
        fields.insert("PME_SUPPORT", Field { brief: None, details: None, lo: 27, hi: 32 });
        fields.insert("PM_CAP_ID", Field { brief: None, details: None, lo: 0, hi: 8 });
        fields.insert("PM_NEXT_POINTER", Field { brief: None, details: None, lo: 8, hi: 16 });
        fields.insert("PM_SPEC_VER", Field { brief: None, details: None, lo: 16, hi: 19 });
        regs.insert("CAP_ID_NXT_PTR", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Word offset 0"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INT_LINE", Field { brief: None, details: None, lo: 0, hi: 8 });
        fields.insert("INT_PIN", Field { brief: None, details: None, lo: 8, hi: 16 });
        regs.insert("MAX_LATENCY_MIN_GRANT_INTERRUPT_PIN_INTERRUPT_LINE", Register { addr: Address { base: 15, count: 1, width: 1 }, brief: Some("Word offset 15"), details: None, fields });
        groups.insert("PCIE_PM_CAP", RegisterGroup { addr: Address { base: 16, count: 1, width: 3 }, desc: "PCIe Power Management Interface", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ACK_FREQ", Field { brief: None, details: None, lo: 0, hi: 8 });
        fields.insert("ACK_N_FTS", Field { brief: None, details: None, lo: 8, hi: 16 });
        fields.insert("COMMON_CLK_N_FTS", Field { brief: None, details: None, lo: 16, hi: 24 });
        fields.insert("ENTER_ASPM", Field { brief: None, details: None, lo: 30, hi: 31 });
        fields.insert("L0_ENTRANCE_LATENCY", Field { brief: None, details: None, lo: 24, hi: 27 });
        fields.insert("L1_ENTRANCE_LATENCY", Field { brief: None, details: None, lo: 27, hi: 30 });
        regs.insert("ACK_F_ASPM_CTRL", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Ack Frequency and L0-L1 ASPM Control"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("REPLAY_TIME_LIMIT", Field { brief: None, details: None, lo: 16, hi: 32 });
        fields.insert("ROUND_TRIP_LATENCY_TIME_LIMIT", Field { brief: None, details: None, lo: 0, hi: 16 });
        regs.insert("ACK_LATENCY_TIMER", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Ack Latency Timer and Replay Timer"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("AMBA_ERROR_RESPONSE_DEFAULT", Field { brief: None, details: None, lo: 0, hi: 4 });
        regs.insert("AMBA_ERROR_RESPONSE_DEFAULT", Register { addr: Address { base: 116, count: 1, width: 1 }, brief: Some("Amba Error Response Default"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("IB_OB_RD_SPLIT_BURST_EN", Field { brief: None, details: None, lo: 0, hi: 2 });
        regs.insert("AMBA_MUL_OB_DECOMP_NP_SUB_REQ_CTRL", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("Outbound Decomponsed Subrequests Control"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ATU_BASE_ADDR_HIGH", Field { brief: Some("Outbound: Not used. Inbound: Bits 63:32 of the starting address of the address region to be translated."), details: None, lo: 0, hi: 32 });
        regs.insert("ATU_BASE_ADDR_HIGH", Register { addr: Address { base: 132, count: 1, width: 1 }, brief: Some("Address translation upper base address"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ATU_BASE_ADDR_LOW", Field { brief: Some("Bits 31:16 of the starting address of the address region to be translated."), details: None, lo: 16, hi: 32 });
        regs.insert("ATU_BASE_ADDR_LOW", Register { addr: Address { base: 131, count: 1, width: 1 }, brief: Some("Address translation lower base address"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ATU_AT", Field { brief: None, details: None, lo: 16, hi: 18 });
        fields.insert("ATU_ATTR", Field { brief: Some("When the address of an outbound TLP is matched to this region, then the ATTR field of the TLP is changed to the value in this register."), details: None, lo: 9, hi: 11 });
        fields.insert("ATU_FN", Field { brief: Some("Must be 0."), details: None, lo: 20, hi: 25 });
        fields.insert("ATU_TC", Field { brief: Some("When the address of an outbound TLP is matched to this region, then the TC field of the TLP is changed to the value in this register."), details: None, lo: 5, hi: 8 });
        fields.insert("ATU_TD", Field { brief: Some("When the address of an outbound TLP is matched to this region, then the TD field of the TLP is changed to the value in this register."), details: None, lo: 8, hi: 9 });
        fields.insert("ATU_TYPE", Field { brief: Some("When the address of an outbound TLP is matched to this region, then the TYPE field of the TLP is changed to the value in this register."), details: Some("0: MRd/MWr 1: MRdLk 2: IORd/IOWr 4: CfgRd0/CfgWr0 5: CfgRd1/CfgWr1 16-23: Msg/MsgD"), lo: 0, hi: 5 });
        regs.insert("ATU_CFG1", Register { addr: Address { base: 129, count: 1, width: 1 }, brief: Some("Address translation configuration register 1"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ATU_CFG_SHIFT_ENA", Field { brief: None, details: None, lo: 28, hi: 29 });
        fields.insert("ATU_FN_MATCH_ENA", Field { brief: Some("Must be 0."), details: None, lo: 19, hi: 20 });
        fields.insert("ATU_INVERT_ENA", Field { brief: None, details: None, lo: 29, hi: 30 });
        fields.insert("ATU_MSG_CODE", Field { brief: Some("When the address of an outbound TLP is matched to this region, and the translated TLP TYPE field is Msg or MsgD; then the Message field of the TLP is changed to the value in this register."), details: None, lo: 0, hi: 8 });
        fields.insert("ATU_REGION_ENA", Field { brief: Some("This bit must be set for address translation to take place."), details: None, lo: 31, hi: 32 });
        regs.insert("ATU_CFG2", Register { addr: Address { base: 130, count: 1, width: 1 }, brief: Some("Address translation configuration register 2"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("VF_ACTIVE", Field { brief: None, details: None, lo: 31, hi: 32 });
        fields.insert("VF_NUMBER", Field { brief: None, details: None, lo: 0, hi: 1 });
        regs.insert("ATU_CFG3", Register { addr: Address { base: 136, count: 1, width: 1 }, brief: Some("Address translation configuration register 3"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ATU_LIMIT_ADDR", Field { brief: Some("Bits 31:16 of the ending address of the address region to be translated."), details: None, lo: 16, hi: 32 });
        fields.insert("RESERVED_3", Field { brief: None, details: None, lo: 0, hi: 16 });
        regs.insert("ATU_LIMIT_ADDR", Register { addr: Address { base: 133, count: 1, width: 1 }, brief: Some("Address translation limit address"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ATU_DIRECTION", Field { brief: Some("Selects either inbound or outbound regions."), details: Some("0: Outbound. 1: Inbound."), lo: 31, hi: 32 });
        fields.insert("ATU_IDX", Field { brief: Some("Selects region index, set to 0 or 1."), details: None, lo: 0, hi: 3 });
        regs.insert("ATU_REGION", Register { addr: Address { base: 128, count: 1, width: 1 }, brief: Some("Address translation region"), details: Some("The address translation unit supports 2 outbound regions. The registers PCIE::ATU_CFG1, PCIE::ATU_CFG2, PCIE::ATU_BASE_ADDR_LOW, PCIE::ATU_BASE_ADDR_HIGH, PCIE::ATU_LIMIT_ADDR, PCIE::ATU_TGT_ADDR_LOW, and PCIE::ATU_TGT_ADDR_HIGH all maps to the currently configured region (as configured in this register)."), fields });
        let mut fields = HashMap::new();
        fields.insert("ATU_TGT_ADDR_HIGH", Field { brief: Some("Bits 63:32 of the new address of the translated region. Set to 0 to force new address into 32bit PCIe memory space."), details: None, lo: 0, hi: 32 });
        regs.insert("ATU_TGT_ADDR_HIGH", Register { addr: Address { base: 135, count: 1, width: 1 }, brief: Some("Address translation upper target address"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ATU_TGT_ADDR_LOW", Field { brief: Some("Bits 31:16 of the new address of the translated region."), details: None, lo: 16, hi: 32 });
        regs.insert("ATU_TGT_ADDR_LOW", Register { addr: Address { base: 134, count: 1, width: 1 }, brief: Some("Address translation lower target address"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("AUX_CLK_FREQ", Field { brief: None, details: None, lo: 0, hi: 10 });
        regs.insert("AUX_CLK_FREQ", Register { addr: Address { base: 272, count: 1, width: 1 }, brief: Some("Auxillary Clock Frequency"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("REMOTE_MAX_BRIDGE_TAG", Field { brief: None, details: None, lo: 8, hi: 16 });
        fields.insert("REMOTE_READ_REQ_SIZE", Field { brief: None, details: None, lo: 0, hi: 3 });
        regs.insert("AXI_MASTER_CTRL_REG_0", Register { addr: Address { base: 70, count: 1, width: 1 }, brief: Some("AXI Master Control 0"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RESIZE_MASTER_RESPONSE", Field { brief: None, details: None, lo: 0, hi: 1 });
        regs.insert("AXI_MASTER_CTRL_REG_1", Register { addr: Address { base: 71, count: 1, width: 1 }, brief: Some("AXI Master Control 1"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DEB_REG_0", Field { brief: None, details: None, lo: 0, hi: 32 });
        regs.insert("DEBUG_REG_0", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("Debug 0"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DEB_REG_1", Field { brief: None, details: None, lo: 0, hi: 32 });
        regs.insert("DEBUG_REG_1", Register { addr: Address { base: 11, count: 1, width: 1 }, brief: Some("Debug 1"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MASK_RADM_2", Field { brief: None, details: None, lo: 0, hi: 32 });
        regs.insert("FILTER_MASK_REG_2", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("Filter Mask 2"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("GEN1_EI_INFERENCE", Field { brief: None, details: None, lo: 21, hi: 22 });
        fields.insert("NUM_OF_LANES", Field { brief: None, details: None, lo: 8, hi: 17 });
        regs.insert("GEN2_CTRL", Register { addr: Address { base: 67, count: 1, width: 1 }, brief: Some("Link Width and Speed Change Control"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FOURTH_DWORD", Field { brief: None, details: None, lo: 0, hi: 32 });
        regs.insert("HDR_LOG_REG_3", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("Word offset 10"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ACK_NAK_DISABLE", Field { brief: None, details: None, lo: 25, hi: 26 });
        fields.insert("DISABLE_LANE_TO_LANE_DESKEW", Field { brief: None, details: None, lo: 31, hi: 32 });
        fields.insert("FLOW_CTRL_DISABLE", Field { brief: None, details: None, lo: 24, hi: 25 });
        fields.insert("INSERT_LANE_SKEW", Field { brief: None, details: None, lo: 0, hi: 24 });
        regs.insert("LANE_SKEW", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Lane Skew"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DBI_RO_WR_EN", Field { brief: None, details: None, lo: 0, hi: 1 });
        regs.insert("MISC_CONTROL_1", Register { addr: Address { base: 111, count: 1, width: 1 }, brief: Some("Misc Control"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PHY_CONTROL", Field { brief: None, details: None, lo: 0, hi: 32 });
        regs.insert("PHY_CONTROL", Register { addr: Address { base: 69, count: 1, width: 1 }, brief: Some("PHY Contol"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PHY_STATUS", Field { brief: None, details: None, lo: 0, hi: 32 });
        regs.insert("PHY_STATUS", Register { addr: Address { base: 68, count: 1, width: 1 }, brief: Some("PHY Status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CPL_SENT_COUNT", Field { brief: None, details: None, lo: 24, hi: 32 });
        fields.insert("FORCED_LTSSM", Field { brief: None, details: None, lo: 8, hi: 12 });
        fields.insert("LINK_NUM", Field { brief: None, details: None, lo: 0, hi: 8 });
        fields.insert("LINK_STATE", Field { brief: None, details: None, lo: 16, hi: 22 });
        regs.insert("PORT_FORCE", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Port Force Link"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BEACON_ENABLE", Field { brief: None, details: None, lo: 24, hi: 25 });
        fields.insert("CORRUPT_LCRC_ENABLE", Field { brief: None, details: None, lo: 25, hi: 26 });
        fields.insert("DLL_LINK_EN", Field { brief: None, details: None, lo: 5, hi: 6 });
        fields.insert("EXTENDED_SYNCH", Field { brief: None, details: None, lo: 26, hi: 27 });
        fields.insert("FAST_LINK_MODE", Field { brief: None, details: None, lo: 7, hi: 8 });
        fields.insert("LINK_CAPABLE", Field { brief: None, details: None, lo: 16, hi: 22 });
        fields.insert("LINK_DISABLE", Field { brief: None, details: None, lo: 6, hi: 7 });
        fields.insert("LINK_RATE", Field { brief: None, details: None, lo: 8, hi: 12 });
        fields.insert("LOOPBACK_ENABLE", Field { brief: None, details: None, lo: 2, hi: 3 });
        fields.insert("RESERVED0", Field { brief: None, details: None, lo: 4, hi: 5 });
        fields.insert("RESERVED1", Field { brief: None, details: None, lo: 12, hi: 16 });
        fields.insert("RESERVED2", Field { brief: None, details: None, lo: 22, hi: 24 });
        fields.insert("RESERVED3", Field { brief: None, details: None, lo: 28, hi: 32 });
        fields.insert("RESET_ASSERT", Field { brief: None, details: None, lo: 3, hi: 4 });
        fields.insert("SCRAMBLE_DISABLE", Field { brief: None, details: None, lo: 1, hi: 2 });
        fields.insert("TRANSMIT_LANE_REVERSALE_ENABLE", Field { brief: None, details: None, lo: 27, hi: 28 });
        fields.insert("VENDOR_SPECIFIC_DLLP_REQ", Field { brief: None, details: None, lo: 0, hi: 1 });
        regs.insert("PORT_LINK_CTRL", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Port Link Control"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_QUEUE_NON_EMPTY", Field { brief: None, details: None, lo: 2, hi: 3 });
        fields.insert("RX_TLP_FC_CREDIT_NON_RETURN", Field { brief: None, details: None, lo: 0, hi: 1 });
        fields.insert("TIMER_MOD_FLOW_CONTROL", Field { brief: None, details: None, lo: 16, hi: 29 });
        fields.insert("TIMER_MOD_FLOW_CONTROL_EN", Field { brief: None, details: None, lo: 31, hi: 32 });
        fields.insert("TX_RETRY_BUFFER_NE", Field { brief: None, details: None, lo: 1, hi: 2 });
        regs.insert("Q_STATUS", Register { addr: Address { base: 15, count: 1, width: 1 }, brief: Some("Queue Status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DISABLE_FC_WD_TIMER", Field { brief: None, details: None, lo: 15, hi: 16 });
        fields.insert("EIDLE_TIMER", Field { brief: None, details: None, lo: 11, hi: 15 });
        fields.insert("MASK_RADM_1", Field { brief: None, details: None, lo: 16, hi: 32 });
        fields.insert("SKP_INT_VAL", Field { brief: None, details: None, lo: 0, hi: 11 });
        regs.insert("SYMBOL_TIMER_FILTER_1", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Symbol Timer and Filter Mask 1"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MAX_FUNC_NUM", Field { brief: None, details: None, lo: 0, hi: 8 });
        fields.insert("TIMER_MOD_ACK_NAK", Field { brief: None, details: None, lo: 19, hi: 24 });
        fields.insert("TIMER_MOD_REPLAY_TIMER", Field { brief: None, details: None, lo: 14, hi: 19 });
        fields.insert("UPDATE_FREQ_TIMER", Field { brief: None, details: None, lo: 24, hi: 29 });
        regs.insert("TIMER_CTRL_MAX_FUNC_NUM", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Timer Control and Max Function Number"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_CPL_DATA_FC_CREDIT", Field { brief: None, details: None, lo: 0, hi: 12 });
        fields.insert("TX_CPL_HEADER_FC_CREDIT", Field { brief: None, details: None, lo: 12, hi: 20 });
        regs.insert("TX_CPL_FC_CREDIT_STATUS", Register { addr: Address { base: 14, count: 1, width: 1 }, brief: Some("Transmit Completion FC Credit Status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_NP_DATA_FC_CREDIT", Field { brief: None, details: None, lo: 0, hi: 12 });
        fields.insert("TX_NP_HEADER_FC_CREDIT", Field { brief: None, details: None, lo: 12, hi: 20 });
        regs.insert("TX_NP_FC_CREDIT_STATUS", Register { addr: Address { base: 13, count: 1, width: 1 }, brief: Some("Transmit Non-Posted FC Credit Status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_P_DATA_FC_CREDIT", Field { brief: None, details: None, lo: 0, hi: 12 });
        fields.insert("TX_P_HEADER_FC_CREDIT", Field { brief: None, details: None, lo: 12, hi: 20 });
        regs.insert("TX_P_FC_CREDIT_STATUS", Register { addr: Address { base: 12, count: 1, width: 1 }, brief: Some("Transmit Posted FC Credit Status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RESERVED8", Field { brief: None, details: None, lo: 20, hi: 21 });
        fields.insert("RESERVED9", Field { brief: None, details: None, lo: 24, hi: 32 });
        fields.insert("VC0_CPL_DATA_CREDIT", Field { brief: None, details: None, lo: 0, hi: 12 });
        fields.insert("VC0_CPL_HEADER_CREDIT", Field { brief: None, details: None, lo: 12, hi: 20 });
        fields.insert("VC0_CPL_TLP_Q_MODE", Field { brief: None, details: None, lo: 21, hi: 24 });
        regs.insert("VC0_CPL_RX_Q_CTRL", Register { addr: Address { base: 20, count: 1, width: 1 }, brief: Some("Completion Receive Queue Control"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RESERVED6", Field { brief: None, details: None, lo: 20, hi: 21 });
        fields.insert("RESERVED7", Field { brief: None, details: None, lo: 24, hi: 32 });
        fields.insert("VC0_NP_DATA_CREDIT", Field { brief: None, details: None, lo: 0, hi: 12 });
        fields.insert("VC0_NP_HEADER_CREDIT", Field { brief: None, details: None, lo: 12, hi: 20 });
        fields.insert("VC0_NP_TLP_Q_MODE", Field { brief: None, details: None, lo: 21, hi: 24 });
        regs.insert("VC0_NP_RX_Q_CTRL", Register { addr: Address { base: 19, count: 1, width: 1 }, brief: Some("Non-Posted Receive Queue Control"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RESERVED4", Field { brief: None, details: None, lo: 20, hi: 21 });
        fields.insert("RESERVED5", Field { brief: None, details: None, lo: 24, hi: 30 });
        fields.insert("TLP_TYPE_ORDERING_VC0", Field { brief: None, details: None, lo: 30, hi: 31 });
        fields.insert("VC0_P_DATA_CREDIT", Field { brief: None, details: None, lo: 0, hi: 12 });
        fields.insert("VC0_P_HEADER_CREDIT", Field { brief: None, details: None, lo: 12, hi: 20 });
        fields.insert("VC0_P_TLP_Q_MODE", Field { brief: None, details: None, lo: 21, hi: 24 });
        fields.insert("VC_ORDERING_RX_Q", Field { brief: None, details: None, lo: 31, hi: 32 });
        regs.insert("VC0_P_RX_Q_CTRL", Register { addr: Address { base: 18, count: 1, width: 1 }, brief: Some("Posted Receive Queue Control"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("WRR_WEIGHT_VC_0", Field { brief: None, details: None, lo: 0, hi: 8 });
        fields.insert("WRR_WEIGHT_VC_1", Field { brief: None, details: None, lo: 8, hi: 16 });
        fields.insert("WRR_WEIGHT_VC_2", Field { brief: None, details: None, lo: 16, hi: 24 });
        fields.insert("WRR_WEIGHT_VC_3", Field { brief: None, details: None, lo: 24, hi: 32 });
        regs.insert("VC_TX_ARBI_REG_1", Register { addr: Address { base: 16, count: 1, width: 1 }, brief: Some("Transmit Arbitration 1"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("WRR_WEIGHT_VC_4", Field { brief: None, details: None, lo: 0, hi: 8 });
        fields.insert("WRR_WEIGHT_VC_5", Field { brief: None, details: None, lo: 8, hi: 16 });
        fields.insert("WRR_WEIGHT_VC_6", Field { brief: None, details: None, lo: 16, hi: 24 });
        fields.insert("WRR_WEIGHT_VC_7", Field { brief: None, details: None, lo: 24, hi: 32 });
        regs.insert("VC_TX_ARBI_REG_2", Register { addr: Address { base: 17, count: 1, width: 1 }, brief: Some("Transmit Arbitration 2"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("VENDOR_SPEC_DLLP", Field { brief: None, details: None, lo: 0, hi: 32 });
        regs.insert("VENDOR_SPEC_DLLP", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Vendor Specific DLLP"), details: None, fields });
        groups.insert("PCIE_PORT_LOGIC", RegisterGroup { addr: Address { base: 448, count: 1, width: 3 }, desc: "PCIe Port Logic", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("BAR0_MEM_IO", Field { brief: None, details: None, lo: 0, hi: 1 });
        fields.insert("BAR0_PREFETCH", Field { brief: None, details: None, lo: 3, hi: 4 });
        fields.insert("BAR0_START", Field { brief: None, details: None, lo: 4, hi: 32 });
        fields.insert("BAR0_TYPE", Field { brief: None, details: None, lo: 1, hi: 3 });
        regs.insert("BAR0", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Word offset 4"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BAR1_MEM_IO", Field { brief: None, details: None, lo: 0, hi: 1 });
        fields.insert("BAR1_PREFETCH", Field { brief: None, details: None, lo: 3, hi: 4 });
        fields.insert("BAR1_START", Field { brief: None, details: None, lo: 4, hi: 32 });
        fields.insert("BAR1_TYPE", Field { brief: None, details: None, lo: 1, hi: 3 });
        regs.insert("BAR1", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Word offset 5"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BAR2_MEM_IO", Field { brief: None, details: None, lo: 0, hi: 1 });
        fields.insert("BAR2_PREFETCH", Field { brief: None, details: None, lo: 3, hi: 4 });
        fields.insert("BAR2_START", Field { brief: None, details: None, lo: 4, hi: 32 });
        fields.insert("BAR2_TYPE", Field { brief: None, details: None, lo: 1, hi: 3 });
        regs.insert("BAR2", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Word offset 6"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BAR3_MEM_IO", Field { brief: None, details: None, lo: 0, hi: 1 });
        fields.insert("BAR3_PREFETCH", Field { brief: None, details: None, lo: 3, hi: 4 });
        fields.insert("BAR3_START", Field { brief: None, details: None, lo: 4, hi: 32 });
        fields.insert("BAR3_TYPE", Field { brief: None, details: None, lo: 1, hi: 3 });
        regs.insert("BAR3", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Word offset 7"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BAR4_MEM_IO", Field { brief: None, details: None, lo: 0, hi: 1 });
        fields.insert("BAR4_PREFETCH", Field { brief: None, details: None, lo: 3, hi: 4 });
        fields.insert("BAR4_START", Field { brief: None, details: None, lo: 4, hi: 32 });
        fields.insert("BAR4_TYPE", Field { brief: None, details: None, lo: 1, hi: 3 });
        regs.insert("BAR4", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("Word offset 8"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BAR5_MEM_IO", Field { brief: None, details: None, lo: 0, hi: 1 });
        fields.insert("BAR5_PREFETCH", Field { brief: None, details: None, lo: 3, hi: 4 });
        fields.insert("BAR5_START", Field { brief: None, details: None, lo: 4, hi: 32 });
        fields.insert("BAR5_TYPE", Field { brief: None, details: None, lo: 1, hi: 3 });
        regs.insert("BAR5", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("Word offset 9"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BIST", Field { brief: None, details: None, lo: 24, hi: 32 });
        fields.insert("CACHE_LINE_SIZE", Field { brief: None, details: None, lo: 0, hi: 8 });
        fields.insert("HEADER_TYPE", Field { brief: None, details: None, lo: 16, hi: 23 });
        fields.insert("LATENCY_MASTER_TIMER", Field { brief: None, details: None, lo: 8, hi: 16 });
        fields.insert("MULTI_FUNC", Field { brief: None, details: None, lo: 23, hi: 24 });
        regs.insert("BIST_HEADER_TYPE_LATENCY_CACHE_LINE_SIZE", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Word offset 3"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CARDBUS_CIS_POINTER", Field { brief: None, details: None, lo: 0, hi: 32 });
        regs.insert("CARDBUS_CIS_PTR", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("Word offset 10"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BASE_CLASS_CODE", Field { brief: None, details: None, lo: 24, hi: 32 });
        fields.insert("PROGRAM_INTERFACE", Field { brief: None, details: None, lo: 8, hi: 16 });
        fields.insert("REVISION_ID", Field { brief: None, details: None, lo: 0, hi: 8 });
        fields.insert("SUBCLASS_CODE", Field { brief: None, details: None, lo: 16, hi: 24 });
        regs.insert("CLASS_CODE_REVISION_ID", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Word offset 2"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PCI_TYPE0_DEVICE_ID", Field { brief: None, details: None, lo: 16, hi: 32 });
        fields.insert("PCI_TYPE0_VENDOR_ID", Field { brief: None, details: None, lo: 0, hi: 16 });
        regs.insert("DEVICE_ID_VENDOR_ID", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Word offset 0"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("EXP_ROM_BASE_ADDRESS", Field { brief: None, details: None, lo: 11, hi: 32 });
        fields.insert("ROM_BAR_ENABLE", Field { brief: None, details: None, lo: 0, hi: 1 });
        regs.insert("EXP_ROM_BASE_ADDR", Register { addr: Address { base: 12, count: 1, width: 1 }, brief: Some("Word offset 12"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CAP_POINTER", Field { brief: None, details: None, lo: 0, hi: 8 });
        regs.insert("PCI_CAP_PTR", Register { addr: Address { base: 13, count: 1, width: 1 }, brief: Some("Word offset 13"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CAP_LIST", Field { brief: None, details: None, lo: 20, hi: 21 });
        fields.insert("DETECTED_PARITY_ERR", Field { brief: None, details: None, lo: 31, hi: 32 });
        fields.insert("DEV_SEL_TIMING", Field { brief: None, details: None, lo: 25, hi: 27 });
        fields.insert("FAST_66MHZ_CAP", Field { brief: None, details: None, lo: 21, hi: 22 });
        fields.insert("FAST_B2B_CAP", Field { brief: None, details: None, lo: 23, hi: 24 });
        fields.insert("INT_STATUS", Field { brief: None, details: None, lo: 19, hi: 20 });
        fields.insert("MASTER_DPE", Field { brief: None, details: None, lo: 24, hi: 25 });
        fields.insert("PCI_TYPE0_BUS_MASTER_EN", Field { brief: None, details: None, lo: 2, hi: 3 });
        fields.insert("PCI_TYPE0_INT_EN", Field { brief: None, details: None, lo: 10, hi: 11 });
        fields.insert("PCI_TYPE0_IO_EN", Field { brief: None, details: None, lo: 0, hi: 1 });
        fields.insert("PCI_TYPE0_MEM_SPACE_EN", Field { brief: None, details: None, lo: 1, hi: 2 });
        fields.insert("PCI_TYPE0_PARITY_ERR_EN", Field { brief: None, details: None, lo: 6, hi: 7 });
        fields.insert("PCI_TYPE0_SERREN", Field { brief: None, details: None, lo: 8, hi: 9 });
        fields.insert("PCI_TYPE0_SPECIAL_CYCLE_OPERATION", Field { brief: None, details: None, lo: 3, hi: 4 });
        fields.insert("PCI_TYPE_IDSEL_STEPPING", Field { brief: None, details: None, lo: 7, hi: 8 });
        fields.insert("PCI_TYPE_MWI_ENABLE", Field { brief: None, details: None, lo: 4, hi: 5 });
        fields.insert("PCI_TYPE_RESERV", Field { brief: None, details: None, lo: 11, hi: 17 });
        fields.insert("PCI_TYPE_VGA_PALETTE_SNOOP", Field { brief: None, details: None, lo: 5, hi: 6 });
        fields.insert("RCVD_MASTER_ABORT", Field { brief: None, details: None, lo: 29, hi: 30 });
        fields.insert("RCVD_TARGET_ABORT", Field { brief: None, details: None, lo: 28, hi: 29 });
        fields.insert("SIGNALED_SYS_ERR", Field { brief: None, details: None, lo: 30, hi: 31 });
        fields.insert("SIGNALED_TARGET_ABORT", Field { brief: None, details: None, lo: 27, hi: 28 });
        regs.insert("STATUS_COMMAND", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Word offset 1"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SUBSYS_DEV_ID", Field { brief: None, details: None, lo: 16, hi: 32 });
        fields.insert("SUBSYS_VENDOR_ID", Field { brief: None, details: None, lo: 0, hi: 16 });
        regs.insert("SUBSYSTEM_ID_SUBSYSTEM_VENDOR_ID", Register { addr: Address { base: 11, count: 1, width: 1 }, brief: Some("Word offset 11"), details: None, fields });
        groups.insert("PCIE_TYPE0_HDR", RegisterGroup { addr: Address { base: 0, count: 1, width: 3 }, desc: "PCIe Header Type 0", regs });
        out.insert("PCIE", Target { desc: "PCIe Endpoint Configuration Space", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("RX_LPI_RECEIVED_MASK", Field { brief: Some("Mask for the RX_LPI_RECEIVED bit"), details: Some("0: Interrupt disabled 1: Interrupt enabled"), lo: 0, hi: 1 });
        fields.insert("TX_LPI_RECEIVED_MASK", Field { brief: Some("Mask for the TX_LPI_RECEIVED bit"), details: Some("0: Interrupt disabled 1: Interrupt enabled"), lo: 4, hi: 5 });
        regs.insert("EEE_INTR_MASK", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("10G Base-R PCS EEE interrupt mask register"), details: Some("Masks for 10G Base-R PCS EEE interrupt sources and sticky bits in EEE_STATUS"), fields });
        let mut fields = HashMap::new();
        fields.insert("CLOCK_STOP_CAPABLE", Field { brief: None, details: Some("1 = The MAC may stop the clock during LPI 0 = Clock not stoppable"), lo: 6, hi: 7 });
        fields.insert("RX_LPI_INDICATION", Field { brief: None, details: Some("1 = Rx PCS is currently receiving LPI 0 = PCS is not currently receiving LPI"), lo: 8, hi: 9 });
        fields.insert("RX_LPI_RECEIVED", Field { brief: Some("When read as a one, receive PCS has received LPI signaling one or more times since the register was last read. When read as a zero, PCS has not received LPI signaling"), details: Some("1 = Rx PCS has received LPI 0 = LPI not received"), lo: 10, hi: 11 });
        fields.insert("TX_LPI_INDICATION", Field { brief: None, details: Some("1 = Tx PCS is currently receiving LPI 0 = PCS is not currently receiving LPI"), lo: 9, hi: 10 });
        fields.insert("TX_LPI_RECEIVED", Field { brief: Some("When read as a one, transmit PCS has received LPI signaling one or more times since the register was last read. When read as a zero, PCS has not received LPI signaling."), details: Some("1 = Tx PCS has received LPI 0 = LPI not received"), lo: 11, hi: 12 });
        regs.insert("EEE_STATUS", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("EEE Status register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_WF_TIMER", Field { brief: Some("This holds no.of 64-bit PMA clocks required to achieve specified wake time fault time interval. As per IEEE 803.3az-2010, this value is: MAX: 10 ms = 1611328"), details: None, lo: 0, hi: 21 });
        regs.insert("RX_WF_TIMER_REG", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("EEE RX Sleep timer configuration register"), details: Some("This register value is used to elaps time in RX_WTF state of EEE RX-FSM as specified in IEEE802.3az-2010 clause 49."), fields });
        let mut fields = HashMap::new();
        fields.insert("WAKE_ERR_CNT", Field { brief: Some("This reflects wake_error_counter specifed in IEEE 802.3az-2010, 49.2.13.2.4 Value of this counter indicates how many times LPI RX FSM entered RX_WTF state. Note: 1. This counter is cleared when ever it is read. 2. Upon overflow its value remains at 0xFFFF."), details: None, lo: 0, hi: 16 });
        regs.insert("WAKE_ERR_CNT", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Wake Error Counter"), details: None, fields });
        groups.insert("EEE_STATS", RegisterGroup { addr: Address { base: 42, count: 1, width: 3 }, desc: "Register group to indicate EEE FSM status", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("FEC_CAPABLE", Field { brief: Some("This is a status bit indicating whether PHY supports FEC or not."), details: Some("0: This PHY device does not support FEC. 1: This PHY device supports FEC."), lo: 0, hi: 1 });
        regs.insert("KR_FEC_CAPABILITY", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("FEC ability register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ONE_US_TIMER", Field { brief: Some("This holds no.of 64-bit PMA clocks required to achieve 1 micro-second (1 us) time interval. As per IEEE 803.3az-2010, min and max values are as follows: MIN : 1.1 us = 178 MAX: 1.3 us = 209 Note: Default value is ~1.1 us = 178"), details: None, lo: 0, hi: 20 });
        regs.insert("ONE_US_TIMER_REG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("One micro-second timer configuration register"), details: Some("This register value is used to elaps 1us time as specified in IEEE802.3az-2010 clause 49."), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_TQ_TIMER", Field { brief: Some("This holds no.of 64-bit PMA clocks required to achieve specified sleep+quiet time interval. As per IEEE 803.3az-2010, min and max values are as follows: MIN : 2 ms = 322266 MAX: 3 ms = 483398 Note: Default value is ~2.5 ms = 402832"), details: None, lo: 0, hi: 21 });
        regs.insert("RX_TQ_TIMER_REG", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("EEE RX Quiet timer configuration register"), details: Some("This register value is used to elaps time in RX_SLEEP and RX_QUIET states of EEE RX-FSM as specified in IEEE802.3az-2010 clause 49."), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_TW_TIMER", Field { brief: Some("This holds no.of 64-bit PMA clocks required to achieve specified wake time interval. As per IEEE 803.3az-2010, this timer values are as follows: Without scrambler bypassed (or Without FEC): 11.5 us = 1853 With scrambler bypassed (or With FEC): 13.7 us = 2207 Note: Default value is ~11.5 us = 1853"), details: None, lo: 0, hi: 21 });
        regs.insert("RX_TW_TIMER_REG", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("EEE RX Wake timer configuration register"), details: Some("This register value is used to elaps time in RX_WAKE state of EEE RX-FSM as specified in IEEE802.3az-2010 clause 49."), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_TQ_TIMER", Field { brief: Some("This holds no.of 64-bit PMA clocks required to achieve specified quiet time interval. As per IEEE 803.3az-2010, min and max values are as follows: MIN : 1.7 ms = 273926 MAX: 1.8 ms = 290039 Note: Default value is ~1.7 ms = 273926"), details: None, lo: 0, hi: 20 });
        regs.insert("TX_TQ_TIMER_REG", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("EEE TX Quiet timer configuration register"), details: Some("This register value is used to elaps time in TX_QUIET state of EEE TX-FSM as specified in IEEE802.3az-2010 clause 49."), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_TS_TIMER", Field { brief: Some("This holds no.of 64-bit PMA clocks required to achieve specified sleep time interval. As per IEEE 803.3az-2010, min and max values are as follows: MIN : 4.9 us = 790 MAX: 5.1 us = 821 Note: Default value is ~5 us = 806"), details: None, lo: 0, hi: 20 });
        regs.insert("TX_TS_TIMER_REG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("EEE TX Sleep timer configuration register"), details: Some("This register value is used to elaps time in TX_SLEEP state of EEE TX-FSM as specified in IEEE802.3az-2010 clause 49."), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_TW_TIMER", Field { brief: Some("This holds no.of 64-bit PMA clocks required to achieve specified wake time interval. As per IEEE 803.3az-2010, min and max values are as follows: MIN : 10.9 us = 1757 MAX: 11.1 us = 1788 Note: Default value is ~11 us = 1773"), details: None, lo: 0, hi: 20 });
        regs.insert("TX_TW_TIMER_REG", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("EEE TX Wake timer configuration register"), details: Some("This register value is used to elaps time in TX_WAKE state of EEE TX-FSM as specified in IEEE802.3az-2010 clause 49."), fields });
        groups.insert("EEE_TIMER_CFG", RegisterGroup { addr: Address { base: 35, count: 1, width: 7 }, desc: "Register group for timer configurations related to EEE of 10G Base-R PCS", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("FEC_FIXED_ERROR_COUNT_ERROR_STATUS", Field { brief: Some("Result of comparing KR FEC's corrected block count (1x00AC/1x00AD) to the threshold setting in 3x8E0A/3x8E0B."), details: Some("0: count did not exceed threshold setting 1: count exceeded threshold setting"), lo: 1, hi: 2 });
        fields.insert("FEC_UNFIXABLE_ERROR_COUNT_ERROR_STATUS", Field { brief: Some("Result of comparing KR FEC's uncorrectable block count (1x00AE/1x00AF) to the threshold setting in 3x8E0C/3x8E0D."), details: Some("0: count did not exceed threshold setting 1: count exceeded threshold setting"), lo: 0, hi: 1 });
        regs.insert("KR_FEC_STATUS", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("KR FEC status register"), details: None, fields });
        groups.insert("KR_FEC_CAPABILITY", RegisterGroup { addr: Address { base: 34, count: 1, width: 1 }, desc: "KR FEC capability register group", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("RX_FSET_FIFO_DATA", Field { brief: Some("Register interface to the FIFO containing captured ordered sets. Each read of this register pops a 24-bit ordered set off the FIFO and increments the FIFO pointer."), details: None, lo: 8, hi: 32 });
        regs.insert("RX_FSET_FIFO_DATA", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("Rx ordered set FIFO data"), details: Some("The register interface to the ordered set data"), fields });
        groups.insert("KR_FEC_CFG", RegisterGroup { addr: Address { base: 26, count: 1, width: 1 }, desc: "KR FEC IEEE CONTROL REGISTER", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("FEC_CORRECTED_BLOCKS", Field { brief: Some("FEC corrected block count."), details: None, lo: 0, hi: 32 });
        regs.insert("KR_FEC_CORRECTED", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("FEC corrected block cout"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("UNFIXABLE_ERROR_COUNT_THRESHOLD", Field { brief: Some("When fixed error count exceeds or equal to this value, then FEC_UNFIXABLE_ERROR_COUNT_STICKY sticky bit is set and interrupt is generated if enabled through FEC_UNFIXABLE_ERROR_COUNT_STICKY_MASK"), details: None, lo: 0, hi: 32 });
        regs.insert("UNFIXABLE_ERROR_COUNT_THRESHOLD", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("FEC unfixable error count threshold value"), details: None, fields });
        groups.insert("KR_FEC_HA_STATUS", RegisterGroup { addr: Address { base: 29, count: 1, width: 2 }, desc: "KR FEC IEEE status registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("FEC_FIXED_ERROR_COUNT_STICKY", Field { brief: Some("This sticky bit is set whenever fixed error count crosses configured FIXED_ERROR_COUNT_THRESHOLD. Note: write '1' to clear this bit."), details: Some("0: Error counter has not exceeded threshold since the last time this bit was cleared. 1: Error count exceeded threshold since the last time this bit was cleared."), lo: 8, hi: 9 });
        fields.insert("FEC_FRAME_LOCK_STICKY", Field { brief: Some("FEC in frame lock indication This is a sticky bit that latches the low state."), details: Some("0: FEC decoder has not achieved lock 1: FEC decoder has achieved lock"), lo: 0, hi: 1 });
        fields.insert("FEC_UNFIXABLE_ERROR_COUNT_STICKY", Field { brief: Some("This sticky bit is set whenever fixed error count crosses configured UNFIXABLE_ERROR_COUNT_THRESHOLD. Note: write '1' to clear this bit."), details: Some("0: Error counter has not exceeded threshold since the last time this bit was cleared. 1: Error count exceeded threshold since the last time this bit was cleared."), lo: 4, hi: 5 });
        regs.insert("KR_FEC_STICKY", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Sticky bit register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FEC_FIXED_ERROR_COUNT_STICKY_MASK", Field { brief: Some("Enable interruput generation when FEC_FIXED_ERROR_COUNT_STICKY is set"), details: Some("0: Disable interrupt generation 1: Enable interrupt generation"), lo: 8, hi: 9 });
        fields.insert("FEC_FRAME_LOCK_STICKY_MASK", Field { brief: Some("Enable interruput generation when FEC_FRAME_LOCK_STICKY is set"), details: Some("0: Disable interrupt generation 1: Enable interrupt generation"), lo: 0, hi: 1 });
        fields.insert("FEC_UNFIXABLE_ERROR_COUNT_STICKY_MASK", Field { brief: Some("Enable interruput generation when FEC_UNFIXABLE_ERROR_COUNT_STICKY is set"), details: Some("0: Disable interrupt generation 1: Enable interrupt generation"), lo: 4, hi: 5 });
        regs.insert("KR_FEC_STICKY_MASK", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Sticky bit mask register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FEC_UNCORRECTED_BLOCKS", Field { brief: Some("FEC uncorrectable block count."), details: None, lo: 0, hi: 32 });
        regs.insert("KR_FEC_UNCORRECTED", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("KR FEC uncorrected block count"), details: None, fields });
        groups.insert("KR_FEC_STATUS", RegisterGroup { addr: Address { base: 31, count: 1, width: 3 }, desc: "KR FEC sticky bit regsiter", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("FIXED_ERROR_COUNT_THRESHOLD", Field { brief: Some("When fixed error count exceeds or equal to this value, then FEC_FIXED_ERROR_COUNT_STICKY sticky bit is set and interrupt is generated if enabled through FEC_FIXED_ERROR_COUNT_STICKY_MASK"), details: None, lo: 0, hi: 32 });
        regs.insert("FIXED_ERROR_COUNT_THRESHOLD", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("FEC fixed error count threshold value"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("AN_FEC_CTRL_ENA", Field { brief: Some("Enables enabling/disabling FEC using backplane Ethernet ANEG (Auto-Negotiation)"), details: Some("0: ANEG doesn't control Enable/Disable of FEC 1: ANEG controls Enable/Diable of FEC"), lo: 2, hi: 3 });
        fields.insert("ENABLE_ERROR_INDICATION", Field { brief: Some("Enables FEC decoder to indicate errors to PCS by sync bits"), details: Some("0: FEC Decoding errors have no effect on PCS sync bits 1: Enable FEC decoder to indicate errors to PCS sync bits"), lo: 16, hi: 17 });
        fields.insert("FEC_ENA", Field { brief: Some("Global FEC Enable/Disable configuration bit."), details: Some("0 = Disable FEC 1 = Enable FEC"), lo: 0, hi: 1 });
        fields.insert("RESET_MONITOR_COUNTERS", Field { brief: Some("When set FEC counters are reset."), details: Some("0: no effect 1: reset FEC counters"), lo: 12, hi: 13 });
        fields.insert("RX_DATA_FLIP", Field { brief: Some("Flip the data bus bits at PCS interface such that bit 65 is mapped to bit 0 and bit 0 to 65. i.e. the output bus (65 downto 0) is remapped to (0 to 65) and bit 65 is the first bit."), details: Some("0 = No flip (LSB first) 1 = Flip bus (MSB first)"), lo: 4, hi: 5 });
        fields.insert("TX_DATA_FLIP", Field { brief: Some("Flip the data bus bits at PCS interface such that bit 65 is mapped to bit 0 and bit 0 to 65. i.e. the output bus (65 downto 0) is remapped to (0 to 65) and bit 65 is the first bit."), details: Some("0 = No flip (LSB first) 1 = Flip bus (MSB first)"), lo: 8, hi: 9 });
        regs.insert("KR_FEC_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("KR FEC configuration regsiter"), details: None, fields });
        groups.insert("KR_FEC_THRESHOLD_CFG", RegisterGroup { addr: Address { base: 27, count: 1, width: 2 }, desc: "KR FEC counters threshold configurations", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("AN_LINK_CTRL_ENA", Field { brief: Some("Enable link control using backplane Ethernet ANEG (Auto-Negotiation)"), details: Some("0: Disable link control 1: Enable link control"), lo: 6, hi: 7 });
        fields.insert("LF_GEN_DIS", Field { brief: Some("Disable RX local fault generation when no alignment has been reached"), details: Some("0: Output local fault symbol at XGMII when not aligned 1: Output IDLE symbols at XGMII when not aligned"), lo: 14, hi: 15 });
        fields.insert("PCS_ENA", Field { brief: Some("Global PCS Enable/Disable configuration bit."), details: Some("0 = Disable PCS 1 = Enable PCS"), lo: 31, hi: 32 });
        fields.insert("PMA_LOOPBACK_ENA", Field { brief: Some("Enable PMA loopback operation. When set, Transmit PMA data is loopbacked to Receive PMA data."), details: Some("0 = Normal mode 1 = Loopback Tx PMA to Rx PMA"), lo: 30, hi: 31 });
        fields.insert("RESYNC_ENA", Field { brief: Some("Force re-synchronization of receive logic. When asserted, the receive sync state machine is forced into the LOCK_INIT state and block_lock is lost."), details: Some("0: Normal operation 1: Reset synchronization"), lo: 15, hi: 16 });
        fields.insert("RX_DATA_FLIP", Field { brief: Some("Flip the data bus bits at the WIS/PMA interface such that bit 63 is mapped to bit 0 and bit 0 to 63. i.e. the output bus (63 down to 0) is remapped to (0 to 63) and bit 63 is the first bit."), details: Some("0: No flip (LSB first) 1: Flip bus (MSB first)"), lo: 18, hi: 19 });
        fields.insert("RX_SCR_DISABLE", Field { brief: Some("Disable the descrambler. When disabled, the data is passed through without being descrambled."), details: Some("0: Decrambler active 1: Decrambler disabled"), lo: 12, hi: 13 });
        fields.insert("RX_TEST_MODE", Field { brief: Some("Enable test pattern checking mode."), details: Some("0: Normal operation 1: Test pattern mode"), lo: 13, hi: 14 });
        fields.insert("SH_CNT_MAX", Field { brief: Some("Number of sync headers required for block lock. The actual number used is this number plus 1. i.e. entering 63 implies a value of 64."), details: Some("Binary number"), lo: 24, hi: 30 });
        fields.insert("TX_DATA_FLIP", Field { brief: Some("Flip the data bus bits at the WIS/PMA interface such that bit 63 is mapped to bit 0 and bit 0 to 63. i.e. the output bus (63 downto 0) is remapped to (0 to 63) and bit 63 is the first bit."), details: Some("0 = No flip (LSB first) 1 = Flip bus (MSB first)"), lo: 7, hi: 8 });
        fields.insert("TX_SCR_DISABLE", Field { brief: Some("Disable the scrambler. When disabled, the data is passed through without being scrambled."), details: Some("0: Scrambler active 1: Scrambler disabled"), lo: 3, hi: 4 });
        fields.insert("TX_TEST_MODE", Field { brief: Some("Enable test pattern generation mode"), details: Some("0: Normal operation 1: Test pattern mode"), lo: 4, hi: 5 });
        regs.insert("PCS_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("PCS configuration"), details: Some("Configuration register"), fields });
        let mut fields = HashMap::new();
        fields.insert("C64B66B_ERR_MASK", Field { brief: Some("Mask for the C64B66B_ERR_STICKY bit"), details: Some("0: Interrupt disabled 1: Interrupt enabled"), lo: 4, hi: 5 });
        fields.insert("LOCK_CHANGED_MASK", Field { brief: Some("Mask for the LOCK_CHANGED_STICKY bit"), details: Some("0: Interrupt disabled 1: Interrupt enabled"), lo: 3, hi: 4 });
        fields.insert("RX_FSET_FIFO_FULL_MASK", Field { brief: Some("Mask for the RX_FSET_FIFO_FULL_STICKY bit"), details: Some("0: Interrupt disabled 1: Interrupt enabled"), lo: 12, hi: 13 });
        fields.insert("RX_FSET_MASK", Field { brief: Some("Mask for the RX_FSET_STICKY bit"), details: Some("0: Interrupt disabled 1: Interrupt enabled"), lo: 11, hi: 12 });
        fields.insert("RX_HI_BER_MASK", Field { brief: Some("Mask for the RX_HI_BER_STICKY bit"), details: Some("0: Interrupt disabled 1: Interrupt enabled"), lo: 0, hi: 1 });
        fields.insert("RX_OSET_FIFO_FULL_MASK", Field { brief: Some("Mask for RX_OSET_FIFO_FULL_STICKY"), details: Some("0: Interrupt disabled 1: Interrupt enabled"), lo: 6, hi: 7 });
        fields.insert("RX_OSET_MASK", Field { brief: Some("Mask for the RX_OSET_STICKY bit"), details: Some("0: Interrupt disabled 1: Interrupt enabled"), lo: 5, hi: 6 });
        fields.insert("XGMII_ERR_MASK", Field { brief: Some("Mask for the XGMII_ERR_STICKY bit"), details: Some("0: Interrupt disabled 1: Interrupt enabled"), lo: 10, hi: 11 });
        regs.insert("PCS_INTR_MASK", Register { addr: Address { base: 12, count: 1, width: 1 }, brief: Some("PCS interrupt mask register"), details: Some("Masks for PCS interrupt sources and sticky bits in PCS_INTR_STAT"), fields });
        let mut fields = HashMap::new();
        fields.insert("SD_ENA", Field { brief: Some("Signal Detect Enable"), details: Some("0: The Signal Detect input pin is ignored. The PCS assumes an active Signal Detect at all times 1: The Signal Detect input pin is used to determine if a signal is detected"), lo: 0, hi: 1 });
        fields.insert("SD_POL", Field { brief: Some("Signal detect polarity: The signal level on signal_detect input pin must be equal to SD_POL to indicate signal detection (SD_ENA must be set)"), details: Some("0: Signal Detect input pin must be '0' to indicate a signal detection 1: Signal Detect input pin must be '1' to indicate a signal detection"), lo: 4, hi: 5 });
        fields.insert("SD_SEL", Field { brief: Some("Signal detect selection (select input for internal signal_detect line)"), details: Some("0: Select signal_detect line from hardmacro 1: Select external signal_detect line"), lo: 8, hi: 9 });
        regs.insert("PCS_SD_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("PCS SignalDetect Configuration"), details: Some("PCS signal_detect configuration"), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_DATAPAT_LSB", Field { brief: Some("Least significant 32 bits of 64-bit data pattern used in pseudo-random and user-defined test pattern mode"), details: None, lo: 0, hi: 32 });
        regs.insert("RX_DATAPAT_LSB", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("LSB of test pattern"), details: Some("Least significant Rx bits of test pattern"), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_DATAPAT_MSB", Field { brief: Some("Most significant 32 bits of 64-bit data pattern used in pseudo-random and user-defined test pattern mode"), details: None, lo: 0, hi: 32 });
        regs.insert("RX_DATAPAT_MSB", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("MSB of test pattern"), details: Some("Most significant Rx bits of test pattern"), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_PRBS31_INIT", Field { brief: Some("PRBS31 initial value."), details: None, lo: 0, hi: 31 });
        regs.insert("RX_PRBS31_INIT", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("PRBS31 initialization"), details: Some("Initial value to load into the PRBS31 linear-feedback shift register"), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_DSBL_INV", Field { brief: Some("Disables inversion of seeds and data in the pseudo-random test pattern"), details: Some("0: Inversion enabled 1: Inversion disabled"), lo: 18, hi: 19 });
        fields.insert("RX_TESTPAT_SEL", Field { brief: Some("Select the test pattern used by the test pattern checker. This register is only used if RX_TEST_MODE is active."), details: Some("0: unused 1: Pseudo random 2: PRBS31 3: User defined"), lo: 16, hi: 18 });
        fields.insert("TX_DSBL_INV", Field { brief: Some("Disables inversion of seeds and data in the pseudo-random test pattern"), details: Some("0: Inversion enabled 1: Inversion disabled"), lo: 5, hi: 6 });
        fields.insert("TX_SQPW_4B", Field { brief: Some("Period of square wave. Value in the register is (Period-4). Valid values of period are 4 to 11."), details: Some("Period = (TX_SQPW_4B+4)"), lo: 2, hi: 5 });
        fields.insert("TX_TESTPAT_SEL", Field { brief: Some("Select the test pattern used by the test pattern generator. This register is only used if TX_TEST_MODE is active."), details: Some("0: Square wave 1: Pseudo random 2: PRBS31 3: User defined"), lo: 0, hi: 2 });
        regs.insert("TEST_CFG", Register { addr: Address { base: 11, count: 1, width: 1 }, brief: Some("Test pattern mode configuration"), details: Some("Select test patterns when test mode is enabled"), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_DATAPAT_LSB", Field { brief: Some("Least significant 32 bits of 64-bit data pattern used in pseudo-random and user-defined test pattern mode"), details: None, lo: 0, hi: 32 });
        regs.insert("TX_DATAPAT_LSB", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("LSB of test pattern"), details: Some("Least significant Tx bits of test pattern"), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_DATAPAT_MSB", Field { brief: Some("Most significant 32 bits of 64-bit data pattern used in pseudo-random and user-defined test pattern mode"), details: None, lo: 0, hi: 32 });
        regs.insert("TX_DATAPAT_MSB", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("MSB of test pattern"), details: Some("Most significant Tx bits of test pattern"), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_SEEDA_LSB", Field { brief: Some("Least significant bits of scrambler used to initialize it during test mode"), details: None, lo: 0, hi: 32 });
        regs.insert("TX_SEEDA_LSB", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Scrambler initialization"), details: Some("Least significant bits of the scrambler. Used in pseudo-random and PRBS31 modes."), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_SEEDA_MSB", Field { brief: Some("Most significant bits of scrambler used to initialize it during test mode"), details: None, lo: 0, hi: 26 });
        regs.insert("TX_SEEDA_MSB", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Scrambler initialization"), details: Some("Most significant bits of the scrambler"), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_SEEDB_LSB", Field { brief: Some("Least significant bits of scrambler used to initialize it during test mode"), details: None, lo: 0, hi: 32 });
        regs.insert("TX_SEEDB_LSB", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Scrambler initialization"), details: Some("Least significant bits of the scrambler"), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_SEEDB_MSB", Field { brief: Some("Most significant bits of scrambler used to initialize it during test mode"), details: None, lo: 0, hi: 26 });
        regs.insert("TX_SEEDB_MSB", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Scrambler initialization"), details: Some("Most significant bits of the scrambler"), fields });
        groups.insert("PCS_10GBR_CFG", RegisterGroup { addr: Address { base: 0, count: 1, width: 14 }, desc: "PCS configuration", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("RX_BLOCK_LOCK", Field { brief: Some("The block_lock status from the synchronization state machine"), details: Some("0: Not synchronized 1: Synchronized, lock obtained"), lo: 3, hi: 4 });
        fields.insert("RX_HI_BER", Field { brief: Some("Set by the Rx BER state machine when a high bit-error-rate condition is detected"), details: Some("0: Normal BER 1: High BER"), lo: 0, hi: 1 });
        fields.insert("TESTPAT_MATCH", Field { brief: Some("When in test pattern check mode, this bit will read 1 if the test pattern checker detects a match. When 0, the test pattern does not match. The test pattern error counts should still be used along with this register bit to determine proper test match status. The bit will read back 1 only when the test pattern is matching. This may happen even while test pattern errors are counted on other clock cycles."), details: Some("0: Test pattern mismatch 1: Test pattern match"), lo: 4, hi: 5 });
        regs.insert("PCS_STATUS", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("PCS status register"), details: Some("Contains status information from the PCS core"), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_BER_CNT", Field { brief: Some("ber_count from the BER state machine"), details: None, lo: 0, hi: 5 });
        regs.insert("RX_BER_CNT", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("ber_count"), details: Some("ber_count from IEEE802.3 section 49.2.14.2."), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_CHARERR_CNT", Field { brief: Some("Count of the number of invalid control characters"), details: None, lo: 0, hi: 32 });
        regs.insert("RX_CHARERR_CNT", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Invalid character counter"), details: Some("Counts the number of invalid control characters"), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_ERRBLK_CNT", Field { brief: Some("Count of the errored Rx blocks"), details: None, lo: 0, hi: 32 });
        regs.insert("RX_ERRBLK_CNT", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Rx errored block counter"), details: Some("Count of the Rx errored blocks"), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_FSET_FIFO_FULL", Field { brief: Some("Indicates if the FIFO is full"), details: Some("0: FIFO not full 1: FIFO full"), lo: 4, hi: 5 });
        fields.insert("RX_FSET_FIFO_NUM", Field { brief: Some("Number of valid ordered sets in the FIFO that can be read"), details: Some("Binary number"), lo: 0, hi: 3 });
        regs.insert("RX_FSET_FIFO_STAT", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("Status of Rx signal ordered set FIFO"), details: Some("Contains status information for the FIFO containing captured Rx ordered sets"), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_OSET_FIFO_DATA", Field { brief: Some("Register interface to the FIFO containing captured ordered sets. Each read of this register pops a 24-bit ordered set off the FIFO and increments the FIFO pointer."), details: None, lo: 8, hi: 32 });
        regs.insert("RX_OSET_FIFO_DATA", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Rx ordered set FIFO data"), details: Some("The register interface to the ordered set data"), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_OSET_FIFO_FULL", Field { brief: Some("Indicates if the FIFO is full"), details: Some("0: FIFO not full 1: FIFO full"), lo: 4, hi: 5 });
        fields.insert("RX_OSET_FIFO_NUM", Field { brief: Some("Number of valid ordered sets in the FIFO that can be read"), details: Some("Binary number"), lo: 0, hi: 3 });
        regs.insert("RX_OSET_FIFO_STAT", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Status of Rx sequence ordered set FIFO"), details: Some("Contains status information for the FIFO containing captured Rx ordered sets"), fields });
        let mut fields = HashMap::new();
        fields.insert("TEST_ERR_CNT", Field { brief: Some("Count of detected test pattern errors in Rx test pattern checker. Write 0 to clear."), details: None, lo: 0, hi: 32 });
        regs.insert("TEST_ERR_CNT", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Test pattern mode error counts"), details: Some("Count of the errors detected in test pattern mode"), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_CHARERR_CNT", Field { brief: Some("Count of the number of invalid control characters"), details: None, lo: 0, hi: 32 });
        regs.insert("TX_CHARERR_CNT", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Invalid character counter"), details: Some("Counts the number of invalid control characters"), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_ERRBLK_CNT", Field { brief: Some("Count of the errored Tx blocks"), details: None, lo: 0, hi: 32 });
        regs.insert("TX_ERRBLK_CNT", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Tx errored block counter"), details: Some("Count of the Tx errored blocks"), fields });
        groups.insert("PCS_10GBR_HA_STATUS", RegisterGroup { addr: Address { base: 16, count: 1, width: 10 }, desc: "PCS status registers and counters", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("C64B66B_ERR_STICKY", Field { brief: Some("Interrupt when an invalid Rx block is detected"), details: Some("0: No invalid blocks 1: Invalid block detected"), lo: 4, hi: 5 });
        fields.insert("LOCK_CHANGED_STICKY", Field { brief: Some("Lock (loss of synchronization) changed interrupt Interrupt occurs whenever there is ANY change in the underlying status of the LOCK signal"), details: Some("0: Synchronization has not changed 1: Synchronization (lock) status changed"), lo: 3, hi: 4 });
        fields.insert("RX_FSET_FIFO_FULL_STICKY", Field { brief: Some("Interrupt generated when the Rx signal ordered set FIFO is full or becomes not full Interrupt occurs whenever there is ANY change in the underlying status"), details: Some("0: Rx ordered set FIFO full status unchanged 1: Rx ordered set FIFO full status changed"), lo: 12, hi: 13 });
        fields.insert("RX_FSET_STICKY", Field { brief: Some("Interrupt indicating that a signal ordered set was received and captured (||Fsig||)"), details: Some("0: No ordered set captured 1: Ordered set captured in FIFO"), lo: 11, hi: 12 });
        fields.insert("RX_HI_BER_STICKY", Field { brief: Some("Set by the Rx BER state machine when a high bit error rate condition is detected or cleared Interrupt occurs whenever there is ANY change in the underlying status"), details: Some("0: High BER status unchanged 1: High BER status changed"), lo: 0, hi: 1 });
        fields.insert("RX_OSET_FIFO_FULL_STICKY", Field { brief: Some("Interrupt generated when the Rx sequence ordered set FIFO is full or becomes not full Interrupt occurs whenever there is ANY change in the underlying status"), details: Some("0: Rx ordered set FIFO full status unchanged 1: Rx ordered set FIFO full status changed"), lo: 6, hi: 7 });
        fields.insert("RX_OSET_STICKY", Field { brief: Some("Interrupt indicating that a sequence ordered set was received and captured (||Q||)"), details: Some("0: No ordered set captured 1: Ordered set captured in FIFO"), lo: 5, hi: 6 });
        fields.insert("XGMII_ERR_STICKY", Field { brief: Some("Interrupt if an invalid Tx XGMII character is detected"), details: Some("0: No invalid character 1: Invalid character detected"), lo: 10, hi: 11 });
        regs.insert("PCS_INTR_STAT", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("PCS interrupt status register"), details: Some("Contains the sticky bits representing interrupts from the PCS. Set by logic. Write 1 to clear."), fields });
        let mut fields = HashMap::new();
        fields.insert("TIMER_125", Field { brief: Some("Sets the maximum count for the 125 microsecond counter. Counts input clocks."), details: Some("16-bit binary number"), lo: 0, hi: 16 });
        regs.insert("TIMER_125", Register { addr: Address { base: 13, count: 1, width: 1 }, brief: Some("Counter for 125 microsecond period"), details: Some("This register sets the number of WIS/PMA divide-by-2 clocks in one 125 microsecond interval. The counter increments and wraps. It should be set to (125 * freq_Mhz/2) where freq_Mhz is the WIS/PMA frequency in Megahertz. 0 disables the counter."), fields });
        groups.insert("PCS_10GBR_STATUS", RegisterGroup { addr: Address { base: 14, count: 1, width: 2 }, desc: "PCS status", regs });
        out.insert("PCS_10GBASE_R", Target { desc: "\\see vtss_target_PCS_10GBASE_R_e PCS configuration and status registers and counters", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CPUQ_DISCARD", Field { brief: Some("Disable enqueuing of traffic to specific CPU queues."), details: Some("xxxxxxx1: Discard frames to CPU queue 0 xxxxxx1x: Discard frames to CPU queue 1 ... 1xxxxxxx: Discard frames to CPU queue 7"), lo: 0, hi: 8 });
        regs.insert("CPUQ_DISCARD", Register { addr: Address { base: 73, count: 1, width: 1 }, brief: Some("Discard frames destined for specific CPU queues"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FRMC_PORT_VAL", Field { brief: Some("Physical port to send the frame to. In case of replication 8 (Learn All frames), then the 2nd port used for Learn All frames is configured in FRAME_COPY_LRNA_CFG.FRMC_PORT_LRNA_VAL."), details: None, lo: 6, hi: 12 });
        fields.insert("FRMC_QOS_ENA", Field { brief: Some("Set to enable use of use FRMC_QOS_VAL. Otherwise classified priority is used."), details: None, lo: 2, hi: 3 });
        fields.insert("FRMC_QOS_VAL", Field { brief: Some("Selected QoS level to use in the egress queues"), details: None, lo: 3, hi: 6 });
        fields.insert("FRMC_SP_ENA", Field { brief: Some("Use super priority enqueuing. Note that even when SP is used, QoS value still controls from which pool resources are allocated, so it may be relevant to also set FRMC_QOS_ENA=1 and FRMC_QOS_VAL."), details: Some("0: Use normal queues 1: Use super priority queue bypassing all shapers 2: Use super priority queue obeying/updating port shaper 3: reserved"), lo: 0, hi: 2 });
        regs.insert("FRAME_COPY_CFG", Register { addr: Address { base: 58, count: 12, width: 1 }, brief: Some("Frame copying configuration"), details: Some("Configures how various frame copies are to be generated in the forwarding core. Frame copies are made when the CPU should get one or more copies (some CPU queues hit), when learn updates are to be generated, and when frame mirroring is requested. Per copy reason, it is configured to which physical port the frame is to be sent, and which QoS level to use in the egress queues. 0-7: Configuration for cpu queue N. 8: Configuration for learn updates. 9-11: Configuration for mirror probe 0-2."), fields });
        let mut fields = HashMap::new();
        fields.insert("FRMC_PORT_LRNA_VAL", Field { brief: Some("Physical port to send Learn All frame to."), details: None, lo: 0, hi: 6 });
        regs.insert("FRAME_COPY_LRNA_CFG", Register { addr: Address { base: 70, count: 1, width: 1 }, brief: Some("Frame copying configuration"), details: Some("Configures 2nd port for sending Learn All frame copies. If only one Learn All port is to be used, this port number MUST be configured to the same port as FRMC_PORT_VAL:8."), fields });
        let mut fields = HashMap::new();
        fields.insert("DROP_SINGLE", Field { brief: Some("Process only one discard per cycle, required for egress drop statistics mode. Side effect is a slower processing of multiple drops on the same frame, causing potential head-of-line blocking."), details: None, lo: 0, hi: 1 });
        fields.insert("FWD_AFI_HANDSHAKE", Field { brief: Some("Await an afi busy phase between enqueings to the AFI controller"), details: None, lo: 1, hi: 2 });
        regs.insert("FWD_CTRL", Register { addr: Address { base: 57, count: 1, width: 1 }, brief: Some("Forwarder mischeleaneous configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FWD_PRESS_DROP_CNT", Field { brief: Some("Counts number of frames discarded due to forward pressure, since queue system reset."), details: None, lo: 0, hi: 32 });
        regs.insert("FWD_PRESS_DROP_CNT", Register { addr: Address { base: 71, count: 1, width: 1 }, brief: Some("Counter for number of frames forwarding aborted due to forward pressure"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MIRROR_DISCARDS", Field { brief: Some("One bit per mirror probe enabling generation of mirror copies also for frames discarded due to buffer discards."), details: None, lo: 0, hi: 3 });
        regs.insert("MIRROR_CFG", Register { addr: Address { base: 72, count: 1, width: 1 }, brief: Some("Mirroring configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("EGRESS_DROP_MODE", Field { brief: Some("When enabled for a port, frames -to- that port are discarded when the controlling watermarks are hit. If disabled - the frame will stay in memory until resources are available. If INGRESS_DROP_MODE or EGRESS_DROP_MODE applies for a frame copy, it will be discared."), details: None, lo: 1, hi: 2 });
        fields.insert("EGRESS_RSRV_DIS", Field { brief: Some("Set this to clear (port) and (port,qos) reservations for the destination port. This is required to be able to move queues between ports."), details: None, lo: 0, hi: 1 });
        fields.insert("EGR_NO_SHARING", Field { brief: Some("Control whether frames forwarded to the port may use shared resources. If egress port or queue has reserved memory left to use, frame enqueuing is always allowed."), details: Some("0: Use shared memory as well 1: Do not use shared memory"), lo: 2, hi: 3 });
        fields.insert("FWD_URGENCY", Field { brief: Some("Set the switching speed per port. One forwarding guaranteed every this value of clock cycles has passed Example with 10: One forwarding per 10 cycles (at 6.4 ns every 64 ns - 10Gport minimum)"), details: None, lo: 9, hi: 17 });
        fields.insert("IGR_NO_SHARING", Field { brief: Some("Control whether frames received on the port may use shared resources. If ingress port or queue has reserved memory left to use, frame enqueuing is always allowed."), details: Some("0: Use shared memory as well 1: Do not use shared memory"), lo: 3, hi: 4 });
        fields.insert("INGRESS_DROP_MODE", Field { brief: Some("When enabled for a port, frames -from- that port are discarded when the controlling watermarks are hit. If disabled - the frame will stay in memory until resources are available. If INGRESS_DROP_MODE or EGRESS_DROP_MODE applies for a frame copy, it will be discared."), details: None, lo: 4, hi: 5 });
        fields.insert("PORT_ENA", Field { brief: Some("Enable port for any frame transfer. Frames to or from a port with PORT_ENA cleared are discarded."), details: None, lo: 17, hi: 18 });
        fields.insert("YEL_RSRVD", Field { brief: Some("Enable yellow traffic to use reserved ingress space."), details: None, lo: 5, hi: 9 });
        regs.insert("SWITCH_PORT_MODE", Register { addr: Address { base: 0, count: 57, width: 1 }, brief: Some("Various switch port mode settings"), details: None, fields });
        groups.insert("SYSTEM", RegisterGroup { addr: Address { base: 0, count: 1, width: 74 }, desc: "Switch configuration", regs });
        out.insert("QFWD", Target { desc: "Queue System Configuration", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("WM_HIGH", Field { brief: Some("Watermark for resource. Note, the default value depends on the index. Refer to the congestion scheme documentation for details."), details: Some("Bit 10:   Unit; 0:1, 1:16 Bits 9-0: Value to be multiplied with unit"), lo: 0, hi: 12 });
        regs.insert("RES_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Watermark configuration"), details: Some("The queue system tracks four resource consumptions: Resource 0: Memory tracked per source Resource 1: Frame references tracked per source Resource 2: Memory tracked per destination Resource 3: Frame references tracked per destination Before a frame is added to the queue system, some conditions must be met: - Reserved memory for the specific (SRC, PRIO) or for the specific SRC is available OR - Reserved memory for the specific (DST,PRIO) or for the specific DST is available OR - Shared memory is available The frame reference resources are checked for availability like the memory resources. Enqueuing of a frame is allowed if both the memory resource check and the frame reference resource check succeed. The extra resources consumed when enqueuing a frame are first taken from the reserved (SRC,PRIO), next from the reserved SRC, and last from the shared memory area. The same is done for DST. Both memory consumptions and frame reference consumptions are updated. The register is layed out the following way for source memory (resource 0): Index 0-xxx: Reserved amount for (SRC,PRIO) at index 8*SRC+PRIO Index 496-503: Maximum allowed use of the shared buffer for PRIO at index PRIO+496 Index 512-568: Reserved amount for SRC at index SRC+512. Index 510: Maximum allowed use of the shared buffer for frames with DP=1. Index 511: Maximum allowed use of the shared buffer for source. The layout is similar for resources 1, 2, and 3. Resource 1 uses indices 1024-2047, resource 2 uses indices 2048-3071, and resource 3 uses indices 3072-4095. The allocation size for memory tracking is 176 bytes. All frames are prepended with a 16-byte header."), fields });
        let mut fields = HashMap::new();
        fields.insert("RES_DLB_OFFS_VAL", Field { brief: Some("The watermarks for enabling DLB rate will be offset this value compared to the sensed resource. Ie. if shared priority 0 watermark is set to 40000 cells, the default value will allow higher rate shaping when 39950 cells has been used."), details: None, lo: 0, hi: 10 });
        regs.insert("RES_DLB_OFFSET", Register { addr: Address { base: 115, count: 1, width: 1 }, brief: Some("DLB shaping offset"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MAXUSE", Field { brief: Some("Maximum consumption since last read for corresponding watermark in RES_CFG."), details: None, lo: 0, hi: 21 });
        regs.insert("RES_STAT", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Resource status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("INUSE", Field { brief: Some("Current consumption for corresponding watermark in RES_CFG."), details: None, lo: 0, hi: 21 });
        regs.insert("RES_STAT_CUR", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Resource status"), details: None, fields });
        groups.insert("RES_CTRL", RegisterGroup { addr: Address { base: 0, count: 5120, width: 4 }, desc: "Watermarks and status for egress queue system", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("TX_PFC_ENA", Field { brief: Some("When set the MAC sends PRIO pause control frames in the Tx direction when congested."), details: None, lo: 1, hi: 9 });
        fields.insert("TX_PFC_MODE", Field { brief: Some("When set, a congested priority request pause of all lower priorities as well."), details: None, lo: 0, hi: 1 });
        regs.insert("PFC_CFG", Register { addr: Address { base: 58, count: 57, width: 1 }, brief: Some("Various switch port mode settings"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RES_QOS_RSRVD", Field { brief: Some("When a qos class is enabled in this mask, the class will have guaranteed shared space. The watermarks found in RES_CFG are used for setting the amount of space set aside."), details: None, lo: 0, hi: 8 });
        regs.insert("RES_QOS_MODE", Register { addr: Address { base: 57, count: 1, width: 1 }, brief: Some("Shared QOS resource mode"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("WRED_GROUP", Field { brief: Some("Frames towards a port is WRED discarded by the profiles for the group configured."), details: None, lo: 0, hi: 2 });
        regs.insert("WRED_GROUP", Register { addr: Address { base: 0, count: 57, width: 1 }, brief: Some("Random Early Discard (WRED) configuration"), details: Some("Configured the WRED group per port."), fields });
        let mut fields = HashMap::new();
        fields.insert("WM_RED_HIGH", Field { brief: Some("See WM_RED_LOW. Unit is 2816 bytes."), details: None, lo: 0, hi: 11 });
        fields.insert("WM_RED_LOW", Field { brief: Some("When enqueuing a frame, RED is active if the egress memory consumption for the applicaple profile is above WM_RED_LEVEL. The probability of random early discarding is calculated as: (Memory consumption - WM_RED_LOW)/(WM_RED_HIGH - WM_RED_LOW). Unit is 2816 bytes."), details: None, lo: 11, hi: 22 });
        regs.insert("WRED_PROFILE", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Random Early Discard (WRED) configuration"), details: Some("Configuration of Random Early Discard (RED) profile per RedGroup/QoS class/DP level. The profile index is calulated as Group*24+(DP-1)*8+QOS. There are no profiled for DP=0.."), fields });
        groups.insert("RES_QOS_ADV", RegisterGroup { addr: Address { base: 20552, count: 1, width: 116 }, desc: "Not documented", regs });
        let regs = HashMap::new();
        groups.insert("RES_WRED", RegisterGroup { addr: Address { base: 20480, count: 72, width: 1 }, desc: "Not documented", regs });
        out.insert("QRES", Target { desc: "Queue System Configuration", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CAL_AUTO", Field { brief: Some("Per port setting for internal bandwidth for 16 ports. Replication M, Bits 2N+1 and 2N is a two bit value for port M*16+N, encoded as seen below."), details: Some("00: Port not active 01: Port granted 1Gbps 10: Port granted 2.5Gbps 11: Port granted 10Gbps"), lo: 0, hi: 32 });
        regs.insert("CAL_AUTO", Register { addr: Address { base: 0, count: 4, width: 1 }, brief: Some("Automatic calendar setup"), details: Some("These four registers configures the automaric calendar for the next 16 ports from 'repl'*16."), fields });
        let mut fields = HashMap::new();
        fields.insert("CAL_SEQ_CUR_VAL", Field { brief: Some("Port to service in the cycle given by the CAL_SEQ_LEN value."), details: None, lo: 7, hi: 13 });
        fields.insert("CAL_SEQ_LEN", Field { brief: Some("Last entry in manual sequence. CAL_SEQ only accessible while calendar is halted."), details: None, lo: 13, hi: 22 });
        fields.insert("CAL_SEQ_PGM_ENA", Field { brief: Some("Enable update of the CAL_SEQ."), details: None, lo: 0, hi: 1 });
        fields.insert("CAL_SEQ_PGM_VAL", Field { brief: Some("The CAL_SEQ_PGM_VAL is written into the sequence entry CAL_SEQ_LEN."), details: None, lo: 1, hi: 7 });
        regs.insert("CAL_SEQ", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Manual calendar setup"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MMGT_TAILDROP_CNT", Field { brief: Some("Returns the number of buffer drops due to ATOP reached, or lack of free memory. Values returned for the port mapped in MMGT_PORT_VIEW. Counter wraps when maximum is reached reached."), details: None, lo: 0, hi: 16 });
        regs.insert("MMGT_TAILDROP_CNT", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: None, details: None, fields });
        groups.insert("CALCFG", RegisterGroup { addr: Address { base: 245, count: 1, width: 6 }, desc: "Not documented", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CM_ADDR", Field { brief: Some("Address selection within selected core memory (CMID register). Address is automatically advanced at every data access."), details: None, lo: 0, hi: 22 });
        fields.insert("CM_ID", Field { brief: Some("Refer to cmid.xls in the AS1000, misc_docs folder."), details: None, lo: 22, hi: 30 });
        regs.insert("CM_ADDR", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Address selection"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CM_DATA", Field { brief: Some("Data register for core memory access. Wider memories are big endian mapped into the 32 BIT inspection space."), details: None, lo: 0, hi: 32 });
        regs.insert("CM_DATA", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Data register for core memory access."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RAM_ENA", Field { brief: Some("Core memory controllers are enabled when this field is set."), details: None, lo: 0, hi: 1 });
        fields.insert("RAM_INIT", Field { brief: Some("Initialize core memories. Field is automatically cleared when operation is complete ( approx. 40 us)."), details: None, lo: 1, hi: 2 });
        regs.insert("RAM_INIT", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Core reset control"), details: Some("Controls reset and initialization of the switching core. Proper startup sequence is: - Enable memories - Initialize memories - Enable core"), fields });
        groups.insert("COREMEM", RegisterGroup { addr: Address { base: 0, count: 1, width: 2 }, desc: "Access core memory", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("DP", Field { brief: Some("Drop precedence N uses mapping table given by bit N in this field."), details: Some("xxx0: Map DP value 0 to DE value 0 xxx1: Map DP value 0 to DE value 1 ... 0xxx: Map DP value 3 to DE value 0 1xxx: Map DP value 3 to DE value 1"), lo: 0, hi: 4 });
        regs.insert("DP_MAP", Register { addr: Address { base: 62, count: 1, width: 1 }, brief: Some("Map DP values to color"), details: None, fields });
        groups.insert("MISC", RegisterGroup { addr: Address { base: 65, count: 1, width: 1 }, desc: "Miscellaneous", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ATOP_TOT", Field { brief: Some("Tail dropping is activate on a port when the port use has exceeded the ATOP watermark for the port, and the total memory use has exceeded this watermark."), details: Some("See RES_CFG"), lo: 0, hi: 12 });
        regs.insert("ATOP_TOT_CFG", Register { addr: Address { base: 172, count: 1, width: 1 }, brief: Some("Total raw memory use before tail dropping is activated"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FREECNT", Field { brief: Some("Number of 6 free memory words."), details: None, lo: 0, hi: 16 });
        fields.insert("RELCNT", Field { brief: Some("Number of 6 frames awaiting releasing."), details: None, lo: 16, hi: 32 });
        regs.insert("MMGT", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Packet memory status"), details: None, fields });
        groups.insert("MMGT", RegisterGroup { addr: Address { base: 239, count: 1, width: 2 }, desc: "Memory manager status", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("FREEVLD", Field { brief: Some("Number of words in the fast pool"), details: None, lo: 4, hi: 8 });
        fields.insert("RELVLD", Field { brief: Some("Number of frames awaiting release in the fast pool"), details: None, lo: 0, hi: 4 });
        regs.insert("MMGT_FAST", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Packet Memory Status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MMGT_IQ_SIZE", Field { brief: Some("Number of frame copies pending in the ingress queue"), details: None, lo: 0, hi: 20 });
        regs.insert("MMGT_IQ_STAT", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Ingress queue status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MMGT_PORT_USE", Field { brief: Some("Total consumption per port in the memory manager. Unit is one cell (176 bytes)."), details: None, lo: 0, hi: 16 });
        regs.insert("MMGT_PORT_USE", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Total consumption per ingress port"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MMGT_PORT_VIEW", Field { brief: Some("Select port to see consumption values for"), details: None, lo: 0, hi: 6 });
        regs.insert("MMGT_PORT_VIEW", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Port to see values for"), details: None, fields });
        groups.insert("MMGT_PORT", RegisterGroup { addr: Address { base: 241, count: 1, width: 4 }, desc: "Memory manager status", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ATOP", Field { brief: Some("When a source port consumes more than this level in the packet memory, frames are tail dropped, unconditionally of destination."), details: Some("See RES_CFG"), lo: 0, hi: 12 });
        regs.insert("ATOP", Register { addr: Address { base: 58, count: 57, width: 1 }, brief: Some("Tail dropping level"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("EV_FDC", Field { brief: Some("Look in the RTL!"), details: None, lo: 0, hi: 3 });
        fields.insert("EV_FWR", Field { brief: Some("Look in the RTL!"), details: None, lo: 3, hi: 4 });
        regs.insert("EVENTS_CORE", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Internal events for debugging only"), details: Some("Core events."), fields });
        let mut fields = HashMap::new();
        fields.insert("FWD_PRESSURE", Field { brief: Some("When ingress queue request count exceeds this level, maximum number of generated frame copies is limited to the FWD_PRESSURE_COPYCNT value."), details: Some("See RES_CFG"), lo: 3, hi: 15 });
        fields.insert("FWD_PRESSURE_COPYCNT", Field { brief: Some("Maximum frame copy count when fwd pressure is activated."), details: None, lo: 0, hi: 3 });
        regs.insert("FWD_PRESSURE", Register { addr: Address { base: 115, count: 57, width: 1 }, brief: Some("Forward pressure level"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PAUSE_ENA", Field { brief: Some("Enable pause feedback to the MAC, allowing transmission of pause frames or HDX collisions to limit ingress data rate."), details: None, lo: 0, hi: 1 });
        fields.insert("PAUSE_START", Field { brief: Some("Start pausing ingress stream when the amount of memory consumed by the port exceeds this watermark. The TOTPAUSE condition must also be met."), details: Some("See RES_CFG"), lo: 13, hi: 25 });
        fields.insert("PAUSE_STOP", Field { brief: Some("Stop pausing ingress stream when the amount of memory consumed by the port is below  this watermark."), details: Some("See RES_CFG."), lo: 1, hi: 13 });
        regs.insert("PAUSE_CFG", Register { addr: Address { base: 0, count: 57, width: 1 }, brief: Some("Watermarks for flow control condition per switch port."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PAUSE_TOT_START", Field { brief: Some("Assert TOTPAUSE condition when total memory allocation is above this watermark."), details: Some("See RES_CFG"), lo: 12, hi: 24 });
        fields.insert("PAUSE_TOT_STOP", Field { brief: Some("Deassert TOTPAUSE condition when total memory allocation is below this watermark."), details: Some("See RES_CFG"), lo: 0, hi: 12 });
        regs.insert("PAUSE_TOT_CFG", Register { addr: Address { base: 57, count: 1, width: 1 }, brief: Some("Configure total memory pause condition"), details: None, fields });
        groups.insert("PAUSE_CFG", RegisterGroup { addr: Address { base: 66, count: 1, width: 173 }, desc: "Watermarks for egress queue system", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CAL_AUTO_ERROR", Field { brief: Some("The automatic calendar failed to service all ports."), details: None, lo: 0, hi: 1 });
        fields.insert("CAL_AUTO_GRANT_RATE", Field { brief: Some("Configures the time between bus grants to 10g ports, in 0.1 nanosecond unit. Other speeds will be adjusted relative to the 10g setting. Default value of 8 matches the nominal minimum packet time on a 10g port."), details: None, lo: 1, hi: 11 });
        fields.insert("CAL_MODE", Field { brief: Some("The internal bus calendars can be set to a predefined port mode (settings 0-3), to an automatic sequence generated by the CAL_AUTO registers, or to a specific sequence programmed through the CAL_SEQ fields."), details: Some("0: 48x1G + 2x10G 1:  Reserved 2:  52x1G 3:  8x1G + 24x2.5G 4:  8x1G + 8x2.5G + 4x10G 5:  24x1G + 4x10G 8:  CAL_AUTO port setting 9:  Sequence program 10: Halt"), lo: 11, hi: 15 });
        regs.insert("CAL_CTRL", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Calendar configuration"), details: None, fields });
        groups.insert("RAM_CTRL", RegisterGroup { addr: Address { base: 251, count: 1, width: 1 }, desc: "Access core memory", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("EEE_FAST_QUEUES", Field { brief: Some("Queues set in this mask activate the egress port immediately when any of the queues have data available."), details: None, lo: 0, hi: 8 });
        regs.insert("EEE_CFG", Register { addr: Address { base: 0, count: 57, width: 1 }, brief: Some("Control Energy Efficient Ethernet operation per front port."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("EEE_HIGH_BYTES", Field { brief: Some("Maximum number of bytes in a queue before egress port is activated. Unit is 60 bytes."), details: None, lo: 8, hi: 16 });
        fields.insert("EEE_HIGH_FRAMES", Field { brief: Some("Maximum number of frames in a queue before the egress port is activated. Unit is 1 frame."), details: None, lo: 0, hi: 8 });
        regs.insert("EEE_THRES", Register { addr: Address { base: 57, count: 1, width: 1 }, brief: Some("Thresholds for delayed EEE queues"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MAX_AGE", Field { brief: Some("Frames are aged and removed from the queue system when the frame's age timer becomes two. The frame age timer is increased for all frames whenever the configured time, MAX_AGE,  has passed. Effectively, this means that a frame is aged when the frame has waited in the queue system between one or two times the period specified by MAX_AGE. The periodd configured by MAX_AGE is also termed an \"age era\". A value of zero disables frame aging. Frame aging related parameters: QSYS:SYSTEM:FRM_AGING.MAX_AGE HSCH:HSCH_MISC:PORT_MODE.AGE_DIS DSM:CFG:BUF_CFG.AGING_ENA"), details: Some("0: Disable frame aging. >=1: Era length in unit of 4us."), lo: 0, hi: 20 });
        regs.insert("FRM_AGING", Register { addr: Address { base: 60, count: 1, width: 1 }, brief: Some("Frame aging configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PMEM_SIZE", Field { brief: Some("Must be set before core reset is released. Unit is  bytes."), details: None, lo: 0, hi: 16 });
        regs.insert("PMEM_SIZE", Register { addr: Address { base: 59, count: 1, width: 1 }, brief: Some("Packet memory status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CORE_ENA", Field { brief: Some("Switch core is enabled when this field is set."), details: None, lo: 0, hi: 1 });
        regs.insert("RESET_CFG", Register { addr: Address { base: 58, count: 1, width: 1 }, brief: Some("Core reset control"), details: Some("Controls reset and initialization of the switching core. Proper startup sequence is: - Enable memories - Initialize memories - Enable core"), fields });
        let mut fields = HashMap::new();
        fields.insert("STAT_RX_TAILDROP_DIS", Field { brief: Some("Set to disable counting buffer drops (tail) in the designated tail drop counter. When disabled, the per priority buffer drop counter is used instead."), details: None, lo: 0, hi: 1 });
        regs.insert("STAT_CFG", Register { addr: Address { base: 61, count: 1, width: 1 }, brief: Some("Statistics configuration"), details: None, fields });
        groups.insert("SYSTEM", RegisterGroup { addr: Address { base: 2, count: 1, width: 63 }, desc: "Switch configuration", regs });
        out.insert("QSYS", Target { desc: "Queue System Configuration", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("EVENT_CNT_ALL", Field { brief: Some("If set to 1 events from all ports are counted. If 0 the port is selected by the 'EVENT_CNT_PORT' register"), details: Some("0: Count events from the port selected by 'EVENT_CNT_PORT' 1: Count events from all ports"), lo: 4, hi: 5 });
        fields.insert("EVENT_CNT_PORT", Field { brief: Some("Select from which source port events are counted."), details: Some("'n': Count events from source port n"), lo: 5, hi: 11 });
        fields.insert("STAT_CNT_FRM_ABORT_ENA", Field { brief: Some("Enable counting of frames discarded by the REW. The QSYS abort statistics counters are used. This bit only enables counting of frames discarded by ES0 or the SW_MIP. Frame discards done by the OAM MEP are not included."), details: Some("0: Disable counting 1: Enable counting"), lo: 2, hi: 3 });
        fields.insert("STAT_MODE", Field { brief: Some("Configures the egress service statistics mode. The following options for looking up the egress service counter set are available: In mode 0 and 1 yellow frames (DE=1) are counted separately In mode 2 and 3 multicast frames (DMAC bit 40 = 1) are counted separately Related parameters: ANA_AC:PS_COMMON:MISC_CTRL.USE_VID_AS_ISDX_ENA"), details: Some("0: Use ESDX from ES0 if hit, otherwise ISDX 1: Use ESDX from ES0 if hit, otherwise no counting 2: Use ISDX (ifh.vstax.misc.isdx as index) 3: Use classified VID (ifh.vstax.tag.vid)"), lo: 0, hi: 2 });
        fields.insert("VSTAX_STAT_ESDX_DIS", Field { brief: Some("Configure ESDX counting for stacking ports. If this bit is set and PORT_CTRL.VSTAX_HDR_ENA=1, all counting based on the ESDX value is disabled regardless of the CNT_CTRL.STAT_MODE configuration. Related parameters: ANA_AC:PS_COMMON:COMMON_VSTAX_CFG.VSTAX2_ISDX_STAT_DIS"), details: Some("0: Normal ESDX statistics mode 1: Disable ESDX statistics for stacking ports"), lo: 3, hi: 4 });
        regs.insert("CNT_CTRL", Register { addr: Address { base: 135, count: 1, width: 1 }, brief: Some("Control register for counter events"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FRM_CLR_PAD_ENA", Field { brief: Some("When padding is required after tag removal, also the FCS will be removed before zero padding and new FCS is added."), details: Some("0: Disable 1: Enable"), lo: 0, hi: 1 });
        fields.insert("INVLD_W16_POP_CNT_FRM_ABORT", Field { brief: Some("Control if frames are aborted if the IFH.ENCAP.WORD16_POP_CNT field is out of the supported range."), details: Some("0: Keep frame 1: Abort frame"), lo: 1, hi: 2 });
        fields.insert("L3_CLR_VSTAX_DST_RSV", Field { brief: Some("Used when frames are L3 forwarded to a stack port. When this bit is set, the reserved fields in the VSTAX.DST field is cleared"), details: Some("0: Keep VSTAX.DST field as received 1: Clear VSTAX.DST reserved fields when L3 forwarding"), lo: 7, hi: 8 });
        fields.insert("OWN_UPSID", Field { brief: Some("Configures own UPSID to be used for stacking. This must be configured consistently across the following registers: ANA_CL::UPSID_CFG.UPSID_NUM ANA_AC::COMMON_VSTAX_CFG.OWN_UPSID ANA_L2::VSTAX_CTRL.OWN_UPSID REW::COMMON_CTRL.OWN_UPSID"), details: Some("n: UPSID"), lo: 2, hi: 7 });
        regs.insert("COMMON_CTRL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Common Control configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DP", Field { brief: Some("Drop precedence N uses mapping table given by bit N in this field."), details: Some("xxx0: Map DP value 0 to DE value 0 xxx1: Map DP value 0 to DE value 1 ... 0xxx: Map DP value 3 to DE value 0 1xxx: Map DP value 3 to DE value 1"), lo: 0, hi: 4 });
        regs.insert("DP_MAP", Register { addr: Address { base: 68, count: 1, width: 1 }, brief: Some("Map drop precedence to drop eligible value"), details: Some("Drop precedence level for the frame is translated to a drop eligible value 0 or 1, selecting between _DE0 or _DE1 mapping tables, when translating the internal prio to TAG priorities. Mapped drop precedence/internal priority is used when selected by TAG control configuration (see TAG ctrl)"), fields });
        let mut fields = HashMap::new();
        fields.insert("DSCP_REMAP", Field { brief: Some("Full one to one DSCP remapping table common for all ports."), details: None, lo: 0, hi: 6 });
        regs.insert("DSCP_REMAP", Register { addr: Address { base: 69, count: 64, width: 1 }, brief: Some("Remap table of DSCP values."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ES0_BY_RLEG", Field { brief: Some("Enable ES0 router mode lookup when IFH.FWD.DST_MODE indicates routing. When enabled and IFH.FWD.DST_MODE = L3UC_ROUTING or IFH.FWD.DST_MODE = L3MC_ROUTING, the ES0 'VSI' key is set to all 1, the VID key field is set to IFH.DST.ERLEG and ES0 lookup is always done using VID key type. If IFH_FWD.DST_MODE does not indicate routing, the lookup is done normally regardless of the ES0_BY_RLEG configuration."), details: Some("0: Normal ES0 lookup 1: Enable router mode ES0 lookup"), lo: 1, hi: 2 });
        fields.insert("ES0_BY_RT_FWD", Field { brief: Some("Enable ES0 router mode lookup when IFH.ENCAP.RT_FWD indicates routing. When enabled and IFH.FWD.DST_MODE = ENCAP and IFH.ENCAP.RT_FWD = 1, the ES0 'VSI' key field is set to all 1, the VID key field is set to IFH.ENCAP.GEN_IDX and ES0 lookup is always done using VID key type. If IFH.ENCAP.RT_FWD does not indicate routing, the lookup is done normally regardless of the ES0_BY_RT_FWD configuration."), details: Some("0: Normal ES0 lookup 1: Enable router mode ES0 lookup"), lo: 2, hi: 3 });
        fields.insert("ES0_FRM_LBK_CFG", Field { brief: Some("Via ES0 it is possible to loop frames back to the Analyzer using the LOOP_ENA and FWD_SEL actions. If this bit is set, a frame can only be looped once by ES0."), details: Some("0: No ES0 frame loop limitation 1: Allow only one loop of frame"), lo: 3, hi: 4 });
        fields.insert("ES0_LU_ENA", Field { brief: Some("Enable lookup in VCAP_ES0 to control advanced frame modifications."), details: Some("0: VCAP_ES0 do not control frame modifications 1: VCAP_ES0 controls all frame rewrites"), lo: 0, hi: 1 });
        regs.insert("ES0_CTRL", Register { addr: Address { base: 57, count: 1, width: 1 }, brief: Some("Various configuration of ES0 in rewriter module"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("GCPU_DO_NOT_REW", Field { brief: Some("Used when GCPU frames are forwarded to a front port. Frame are not modified when forwarded to the GCPU expect for the optional tags configured in GCPU_CFG.GCPU_TAG_SEL"), details: Some("0: Allow normal rewrites of GCPU frames forwarded to front ports 1: Allow only addition of GCPU_TAGS to GCPU frames"), lo: 19, hi: 20 });
        fields.insert("GCPU_FWD_MODE", Field { brief: Some("Used when GCPU frames are forwarded to a stack port. Configure forward mode of GCPU frames on stack ports by selecting value of VSTAX.GEN.FWD_MODE."), details: Some("0: VSTAX.GEN.FWD_MODE = VS2_FWD_GCPU_UPS Forward the frame to a specific unit in the stack 1: VSTAX.GEN.FWD_MODE = VS2_FWD_PHYSICAL Forward the frame to a specific port on a specific unit in the stack."), lo: 16, hi: 17 });
        fields.insert("GCPU_KEEP_IFH", Field { brief: Some("Used when GCPU frames are forwarded to a front port. Frames are sent with the IFH preserved. The IFH is encapsulated according to the configuration. Setting GCPU_KEEP_IFH to a value different from 0 overrides the GCPU_TAG_SEL and GCPU_DO_NOT_REW settings for front ports. No other rewrites are done to the frame. The GCPU_KEEP_IFH setting is not active if PORT_CTRL.KEEP_IFH_SEL is different from 0 or if PORT_CTRL.VSTAX_HDR_ENA=1"), details: Some("0: Normal mode. 1: Keep IFH without modifications. Frames are not updated. IFH is kept 2: Encapsulate IFH. The frame's DMAC, SMAC and a fixed TAG with ETYPE=8880 (Vitesse) and EPID=0x0009 are inserted in front of the IFH: [FRM_DMAC][FRM_SMAC][0x8880][0x0009][IFH][FRAME] 3: Encapsulate IFH using the ENCAP table Use ES0 to generate an ENCAP_ID and insert the encapsulation in front of the IFH: [ENCAP][IFH][FRAME] ES0 controlled encapsulations will be used if the ENCAP_ID action is active, otherwise mode 2) is used."), lo: 20, hi: 22 });
        fields.insert("GCPU_TAG_SEL", Field { brief: Some("When a GCPU frame is forwarded to a stack port: Force a change of the VSTAX.TAG to the configured values in GCPU_TAG_CFG:0 When a GCPU frame is forwarded to a front port: Optionally add one or two Q-tags to the frame. The tags are configured using GCPU_TAG_CFG"), details: Some("0: Normal mode. No tags are added and VSTAX.TAG is equal to the outer most frame tag 1: Add one tag to GCPU frames forwarded to front ports. Set VSTAX.TAG to GCPU_TAG_CFG:0 for frames on a stack port 2: Add two tags to GCPU frames forwarded to front ports. Set VSTAX.TAG to GCPU_TAG_CFG:0 for frames on a stack port 3: Reserved"), lo: 17, hi: 19 });
        fields.insert("GCPU_UPSID", Field { brief: Some("Used when GCPU frames are forwarded to a stack port. DST_UPSID to be used as destination in the VSTAX header. Set VSTAX.DST.DST_UPSID to configured value."), details: Some("0: DST_UPSID 0 1: DST_UPSID 1 ... n: DST_UPSID n"), lo: 0, hi: 5 });
        fields.insert("GCPU_UPSPN", Field { brief: Some("Used when GCPU frames are forwarded to a stack port. DST_PN to be used as destination in the VSTAX header. Set VSTAX.DST.DST_PN to configured value."), details: Some("0: DST_PN 0 1: DST_PN 1 ... n: DST_PN n"), lo: 8, hi: 13 });
        regs.insert("GCPU_CFG", Register { addr: Address { base: 139, count: 8, width: 1 }, brief: Some("Global CPU configuration"), details: Some("Selected local CPU queues can be redirected to a global CPU (GCPU) located on front- and/or stack ports. Each of the eight local CPU queues are configured individually. CPU queue redirection is enabled in QFWD::FRAME_COPY_CFG.FRMC_PORT_VAL The CPU queue number assigned to a frame is the highest priority CPU queue bit set in IFH.MISC.CPU_MASK. The CPU queue number is used to select configuration per queue. The GCPU forward frame modifications are not done, if no bits are set in IFH.MISC.CPU_MASK."), fields });
        let mut fields = HashMap::new();
        fields.insert("TAG_DEI_VAL", Field { brief: Some("GCPU Q-tag DEI values"), details: Some("0: DEI bit = 0 1: DEI bit = 1"), lo: 4, hi: 5 });
        fields.insert("TAG_PCP_SEL", Field { brief: Some("Selection of GCPU Q-tag PCP values"), details: Some("0: Use classified PCP 1: Use TAG_PCP_VAL"), lo: 3, hi: 4 });
        fields.insert("TAG_PCP_VAL", Field { brief: Some("GCPU Q-tag PCP values."), details: Some("n: PCP n"), lo: 0, hi: 3 });
        fields.insert("TAG_TPID_SEL", Field { brief: Some("GCPU Q-tag Tag Protocol Identifiers(TPID)"), details: Some("0: 0x8100 1: 0x88A8 2: Custom1. REW::TPID_CFG[0].TPID_VAL 3: Custom2. REW::TPID_CFG[1].TPID_VAL 4: Custom3. REW::TPID_CFG[2].TPID_VAL 5: Select via ifh.vstax.tag_type and ifh.encap.tag_tpid If ifh.encap.tag_tipd = STD_TPID: If ifh.vstax.tag_type = 0 then 0x8100 else 0x88A8 If ifh.encap.tag_tipd = CUSTOM<n>: Custom<n> TPID 6-7: Reserved"), lo: 17, hi: 20 });
        fields.insert("TAG_VID_VAL", Field { brief: Some("GCPU Q-tag VID values"), details: Some("n: VID n"), lo: 5, hi: 17 });
        regs.insert("GCPU_TAG_CFG", Register { addr: Address { base: 149, count: 2, width: 1 }, brief: Some("Configure optional GCPU tagging"), details: Some("Configuration of QTags for GCPU frames. GCPU frames that are forwarded to a front port can optionally have one or two Qtags added. The tags will be placed in the outer most position after the SMAC. TAG_A is the outer tag. Idx0:  TAG_A, Idx1:\tTAG_B."), fields });
        let mut fields = HashMap::new();
        fields.insert("HIH_DEF_CKSM", Field { brief: Some("Default value for the CKSM field in transmitted HIH's."), details: None, lo: 0, hi: 4 });
        fields.insert("HIH_DEF_CL", Field { brief: Some("Default value for the CL field in transmitted HIH's."), details: None, lo: 8, hi: 24 });
        fields.insert("HIH_DEF_FLAGS", Field { brief: Some("Default value for the FLAGS field in transmitted HIH's."), details: None, lo: 4, hi: 8 });
        fields.insert("HIH_DEF_LPID", Field { brief: Some("Default value for the LPID field in transmitted HIH's."), details: None, lo: 24, hi: 32 });
        regs.insert("HIH_DEF_CFG", Register { addr: Address { base: 155, count: 1, width: 1 }, brief: Some("Default values for transmitted HIHS"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("HIH_LOCATION", Field { brief: Some("This register configures where the HiH is located for DEV10Gs. The HiH must be placed in the frame if PTP is enabled for the port."), details: Some("0: Place the HiH after frame SFD 1: DEV10G::MAC_MODE_CFG.MAC_PREAMBLE_CFG controls the placement."), lo: 0, hi: 1 });
        regs.insert("HIH_DEV10G_CFG", Register { addr: Address { base: 151, count: 4, width: 1 }, brief: Some("Device 10G specific HIH configuration"), details: Some("This register provides additional HIH configuration for 10G devices."), fields });
        let mut fields = HashMap::new();
        fields.insert("MIP_CCM_HMO_SET_SHOT", Field { brief: Some("Set all CCM Hit me once bits. Cleared when the access completes. Ref: REW:MIP_TBL:CCM_HMO_CTRL"), details: Some("0: Idle 1: Initiate setting all CCM_HMO_CTRL.CCM_COPY_ONCE_ENA where MIP_CCM_INTERVAL_MASK[CCM_HMO_CTRL.CCM_INTERVAL] is set The bit is cleared upon completion"), lo: 4, hi: 5 });
        fields.insert("MIP_CCM_INTERVAL_MASK", Field { brief: Some("Specifies which MIP CCM intervals that will have CCM_COPY_ONCE_ENA set."), details: Some("x0x: Interval is ignored x1x: REW:MIP_TBL:CCM_HMO_CTRL.CCM_COPY_ONCE_ENA  is set where MIP_CCM_INTERVAL_MASK[CCM_HMO_CTRL.CCM_INTERVAL] is set."), lo: 0, hi: 4 });
        regs.insert("MIP_CTRL", Register { addr: Address { base: 58, count: 1, width: 1 }, brief: Some("CCM hit me once auto set"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MIRROR_TX_PORT", Field { brief: Some("The TX port for the mirror_probe (From where rewrite configuration is taken)"), details: Some("0: Port 0 1: Port 1 . . . n: Port n"), lo: 12, hi: 18 });
        fields.insert("REMOTE_ENCAP_ID", Field { brief: Some("Select encapsulation ID to use for remote mirror frames."), details: Some("0: No encapsulation 1-n: Encapsulation ID n"), lo: 2, hi: 12 });
        fields.insert("REMOTE_MIRROR_CFG", Field { brief: Some("Enable encapsulation of mirrored frames. One or two Q-Tags (Q-in-Q) or the encapsulation table can be used. In tag mode the VLAN tags will be added in the outer most position after the SMAC. This will also be the case if a MPLS link layer is added to the frame. The tags will then be added after LL-SMAC. In encapsulation mode an entry in the ENCAP-table is used for encapsulation. This will override any encapsulation selected by ES0 for the frame."), details: Some("0: Local mirror port. No encapsulation 1: Add one VLAN tag. Configured by MIRROR_TAG_A_CFG 2: Add two VLAN tags. Configured by MIRROR_TAG_A_CFG and MIRROR_TAG_B_CFG 3: Use ENCAP table selected by REMOTE_ENCAP_ID"), lo: 0, hi: 2 });
        regs.insert("MIRROR_PROBE_CFG", Register { addr: Address { base: 59, count: 3, width: 1 }, brief: Some("Configure mirror probes"), details: Some("Related parameters: ANA_AC:MIRROR_PROBE"), fields });
        let mut fields = HashMap::new();
        fields.insert("TAG_A_DEI_VAL", Field { brief: Some("Mirror Q-tag A DEI value."), details: Some("0: DEI bit = 0 1: DEI bit = 1"), lo: 4, hi: 5 });
        fields.insert("TAG_A_PCP_SEL", Field { brief: Some("Selection of mirror Q-tag A PCP value."), details: Some("0: Use classified PCP 1: Use TAG_A_PCP_VAL"), lo: 3, hi: 4 });
        fields.insert("TAG_A_PCP_VAL", Field { brief: Some("Mirror Q-tag A PCP value."), details: Some("n: PCP n"), lo: 0, hi: 3 });
        fields.insert("TAG_A_TPID_SEL", Field { brief: Some("Mirror Q-tag A Tag Protocol Identifier(TPID)"), details: Some("0: 0x8100 1: 0x88A8 2: Custom1. REW::TPID_CFG[0].TPID_VAL 3: Custom2. REW::TPID_CFG[1].TPID_VAL 4: Custom3. REW::TPID_CFG[2].TPID_VAL 5: Select via ifh.vstax.tag_type and ifh.encap.tag_tpid If ifh.encap.tag_tipd = STD_TPID: If ifh.vstax.tag_type = 0 then 0x8100 else 0x88A8 If ifh.encap.tag_tipd = CUSTOM<n>: Custom<n> TPID 6-7: Reserved"), lo: 17, hi: 20 });
        fields.insert("TAG_A_VID_VAL", Field { brief: Some("Mirror Q-tag A VID value."), details: Some("n: VID n"), lo: 5, hi: 17 });
        regs.insert("MIRROR_TAG_A_CFG", Register { addr: Address { base: 62, count: 3, width: 1 }, brief: Some("Configure mirror probes"), details: Some("Configuration of mirror QTag A. Each mirror probe can be configured individually."), fields });
        let mut fields = HashMap::new();
        fields.insert("TAG_B_DEI_VAL", Field { brief: Some("Mirror Q-tag B DEI value."), details: Some("0: DEI bit = 0 1: DEI bit = 1"), lo: 4, hi: 5 });
        fields.insert("TAG_B_PCP_SEL", Field { brief: Some("Selection of mirror Q-tag B PCP value."), details: Some("0: Use classified PCP 1: Use TAG_B_PCP_VAL"), lo: 3, hi: 4 });
        fields.insert("TAG_B_PCP_VAL", Field { brief: Some("Mirror Q-tag B PCP value."), details: Some("n: PCP n"), lo: 0, hi: 3 });
        fields.insert("TAG_B_TPID_SEL", Field { brief: Some("Mirror Q-tag B Tag Protocol Identifier(TPID)"), details: Some("0: 0x8100 1: 0x88A8 2: Custom1. REW::TPID_CFG[0].TPID_VAL 3: Custom2. REW::TPID_CFG[1].TPID_VAL 4: Custom3. REW::TPID_CFG[2].TPID_VAL 5: Select via ifh.vstax.tag_type and ifh.encap.tag_tpid If ifh.encap.tag_tipd = STD_TPID: If ifh.vstax.tag_type = 0 then 0x8100 else 0x88A8 If ifh.encap.tag_tipd = CUSTOM<n>: Custom<n> TPID 6-7: Reserved"), lo: 17, hi: 20 });
        fields.insert("TAG_B_VID_VAL", Field { brief: Some("Mirror Q-tag B VID value."), details: Some("n: VID n"), lo: 5, hi: 17 });
        regs.insert("MIRROR_TAG_B_CFG", Register { addr: Address { base: 65, count: 3, width: 1 }, brief: Some("Configure mirror probes"), details: Some("Configuration of mirror QTag B. Each mirror probe can be configured individually."), fields });
        let mut fields = HashMap::new();
        fields.insert("ES0_LPORT_NUM", Field { brief: Some("Map the configuration port to a logical port number to be used by ES0 keys. The port used for the lookup can be Tx-mirrored. Use the unmapped port number, if the mapped value is outside port range (default)"), details: Some("0-10: Use this port number for ES0 lookup 11-15: Do not map port number"), lo: 24, hi: 30 });
        fields.insert("INJ_STAT_PIPELINE_PT", Field { brief: Some("Configures the injection statistics pipeline point. Frames injected after the configured pipeline point are not counted by the ESDX counters. Configuring the value 'REW_'VRAP will cause all injected frames to be counted."), details: Some("0: Reserved 1: REW_IN_MIP 2: REW_IN_SW 3: REW_IN_VOE 4: REW_OU_VOE 5: REW_OU_SW 6: REW_OU_MIP 7: REW_SAT 8: REW_PORT_VOE 9: REW_VRAP"), lo: 16, hi: 20 });
        fields.insert("KEEP_IFH_SEL", Field { brief: Some("Configure the rewriter IFH mode for the port. The configuration  is used by the physical port and is not changed for TX-Mirrored frames. See ASM::PORT_CFG.INJ_FORMAT_CFG"), details: Some("0: Normal mode. 1: Keep IFH without modifications. Frames are not updated. IFH is kept 2: Encapsulate IFH. The frame's DMAC, SMAC and a fixed TAG with ETYPE=8880 (Vitesse) and EPID=0x0009 are inserted in front of the IFH: [FRM_DMAC][FRM_SMAC][0x8880][0x0009][IFH][FRAME] 3: Encapsulate IFH using the ENCAP table Use ES0 to generate an ENCAP_ID and insert the encapsulation in front of the IFH: [ENCAP][IFH][FRAME] ES0 controlled encapsulations will be used if the ENCAP_ID action is active, otherwise mode 2) is used."), lo: 4, hi: 6 });
        fields.insert("PORT_VOE_DEFAULT_DEI", Field { brief: Some("Default DEI value used by the OAM port VOE. This value is used for port VOE counter updates when no outer Q-Tag is present in a frame. The configuration is used by the physical port and is not changed for TX-Mirrored frames."), details: Some("n: OAM default DEI value"), lo: 6, hi: 7 });
        fields.insert("PORT_VOE_DEFAULT_PCP", Field { brief: Some("Default PCP value used by the OAM port VOE. This value is used for port VOE counter updates when no outer Q-Tag is present in a frame. The configuration is used by the physical port and is not changed for TX-Mirrored frames."), details: Some("n: OAM default PCP value"), lo: 7, hi: 10 });
        fields.insert("PORT_VOE_TPID_AWARE_DIS", Field { brief: Some("This configuration applies to VLAN tag awareness in the port VOE for frames for which the rewriter is not pushing new VLAN tags or an MPLS link layer. Each bit corresponds to one of the known TPIDs. If the outgoing frame's outer tag contains a TPID for which PORT_VOE_TPID_AWARE_DIS is set, then the port VOE sees the frame as untagged. The configuration  is used by the physical port and is not changed for TX-Mirrored frames."), details: Some("Bit0: TPID = 0x8100. Bit1: TPID = 0x88A8 Bit2: TPID = REW::TPID_CFG[0].TPID_VAL Bit3: TPID = REW::TPID_CFG[1].TPID_VAL Bit4: TPID = REW::TPID_CFG[2].TPID_VAL"), lo: 10, hi: 15 });
        fields.insert("VSTAX2_MIRROR_OBEY_WAS_TAGGED", Field { brief: Some("Configure tagging of frames with VSTAX.GEN.FWD_MODE = VS2_FWD_GMIRROR. Only active on front ports for frames using this FWD_MODE. This is used to control the remote mirror tagging of frames that have been mirrored from one unit in the stack to another unit. The configuration  is used by the physical port and is not changed for TX-Mirrored frames."), details: Some("0: Always push the remote mirror tag carried VSTAX.TAG into the frame. No other tags are pushed. 1: Obey local port tag configuration."), lo: 3, hi: 4 });
        fields.insert("VSTAX2_MISC_ISDX_ENA", Field { brief: Some("Configure VSTAX MISC field decoding. The configuration can be Tx-mirrored."), details: Some("0: VSTAX MISC contains aggregation code 1: VSTAX MISC contains ISDX and COSID"), lo: 15, hi: 16 });
        fields.insert("VSTAX_HDR_ENA", Field { brief: Some("Enable insertion of stacking header in frame. The configuration is used by the physical port and is not changed for TX-Mirrored frames."), details: Some("0: Disable 1: Enable"), lo: 1, hi: 2 });
        fields.insert("VSTAX_PAD_ENA", Field { brief: Some("Enable padding of frames to 76 bytes. If a frame is smaller than 64 bytes when all rewrites are done, the frame is extended to 64 bytes to prevent under size frames leaving the chip. Setting this bit will cause all frames on the port to be extended to 76 bytes instead of 64 bytes. This should only optionally be enabled for stacking ports (PORT_CTRL.VSTAX_HDR_ENA = 1). Setting this bit will prevent frames from becoming under sized in a receiving switch, when the VStaX header is removed. The configuration is used by the physical port and is not changed for TX-Mirrored frames."), details: Some("0: Normal padding to 64 bytes 1: Pad to 76 bytes"), lo: 2, hi: 3 });
        fields.insert("VSTAX_STACK_GRP_SEL", Field { brief: Some("Select logical stacking port (or stacking port group) membership The configuration is used by the physical port and is not changed for TX-Mirrored frames."), details: Some("0: Stack A 1: Stack B"), lo: 0, hi: 1 });
        fields.insert("XTR_STAT_PIPELINE_PT", Field { brief: Some("Configures the extraction statistics pipeline point. Frames extracted before the configured pipeline point are not counted by the ESDX counters Configuring the value 'REW_IN_MIP' will cause all extracted frames to be counted."), details: Some("0: Reserved 1: REW_IN_MIP 2: REW_IN_SW 3: REW_IN_VOE 4: REW_OU_VOE 5: REW_OU_SW 6: REW_OU_MIP 7: REW_SAT 8: REW_PORT_VOE 9: REW_VRAP"), lo: 20, hi: 24 });
        regs.insert("PORT_CTRL", Register { addr: Address { base: 1, count: 53, width: 1 }, brief: Some("Port based configuration for rewriter"), details: Some("Configuration of rewriter ports."), fields });
        let mut fields = HashMap::new();
        fields.insert("RLEG_MAC_LSB", Field { brief: Some("Router leg base MAC address, least significant bits. In order to have different MAC addresses per router leg, the base address may be incremented using VID or VMID, ref. RLEG_MAC_TYPE_SEL. This must be configured consistently in ANA_L3::RLEG_CFG_0.RLEG_MAC_LSB."), details: Some("Bit 0: MAC address, bit 0 ... Bit 23: MAC address, bit 23"), lo: 0, hi: 24 });
        regs.insert("RLEG_CFG_0", Register { addr: Address { base: 133, count: 1, width: 1 }, brief: Some("Rewriter router leg configuration."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RLEG_MAC_MSB", Field { brief: Some("Router leg base MAC address, least significant bits. In order to have different MAC addresses per router leg, the base address may be incremented using VID or VMID, ref. RLEG_MAC_TYPE_SEL. This must be configured consistently in ANA_L3::RLEG_CFG_1.RLEG_MAC_MSB."), details: Some("Bit 0: MAC address, bit 24 ... Bit 23: MAC address, bit 47"), lo: 0, hi: 24 });
        fields.insert("RLEG_MAC_TYPE_SEL", Field { brief: Some("Configuration of router leg specific MAC address. This must be configured consistently in ANA_L3::RLEG_CFG_1.RLEG_MAC_TYPE_SEL."), details: Some("0: RLEG used to increment base MAC address: RLEG_MAC = RLEG_MAC_MSB(23:0) & ((RLEG_MAC_LSB(23:0) + IFH.ERLEG) mod 2**24) 1: EVID (VMID.RLEG_EVID) used to increment base MAC address: RLEG_MAC = RLEG_MAC_MSB(23:0) & ((RLEG_MAC_LSB(23:0) + RLEG_EVID) mod 2**24) 2: Base MAC address used for all router legs RLEG_MAC = RLEG_MAC_MSB[23:0] & RLEG_MAC_LSB[23:0] 3: Reserved"), lo: 24, hi: 26 });
        regs.insert("RLEG_CFG_1", Register { addr: Address { base: 134, count: 1, width: 1 }, brief: Some("Rewriter router leg configuration."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DSCP_REMAP_STICKY", Field { brief: Some("This bit is set if a DSCP remap event is detected"), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 7, hi: 8 });
        fields.insert("DSCP_REPLACE_STICKY", Field { brief: Some("This bit is set if a DSCP has been replaced event is detected"), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 6, hi: 7 });
        fields.insert("INVLD_IFH_FOR_PTP_FRM_STICKY", Field { brief: Some("This bit is set if the IFH is not correct for PTP frames"), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 5, hi: 6 });
        fields.insert("INVLD_POP_CNT_STICKY", Field { brief: Some("This bit is set if an invalid 'pop_cnt' value is received in the IFH"), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 15, hi: 16 });
        fields.insert("INVLD_W16_POP_CNT_STICKY", Field { brief: Some("This bit is set if an invalid 'pop_cnt' value is received in the IFH"), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 16, hi: 17 });
        fields.insert("IP4_MC_STICKY", Field { brief: Some("This bit is set if an IP4 frame has been L3 multicast forwarded"), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 10, hi: 11 });
        fields.insert("IP4_UC_STICKY", Field { brief: Some("This bit is set if an IP4 frame has unicast forwarded."), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 8, hi: 9 });
        fields.insert("IP6_MC_STICKY", Field { brief: Some("This bit is set if an IP6 frame has been L3 multicast forwarded"), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 11, hi: 12 });
        fields.insert("IP6_UC_STICKY", Field { brief: Some("This bit is set if an IP6 frame has been unicast forwarded."), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 9, hi: 10 });
        fields.insert("LINK_LAYER_ADDED_STICKY", Field { brief: Some("This bit is set if a new link layer has been added to a frame"), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 3, hi: 4 });
        fields.insert("LINK_LAYER_ERROR_STICKY", Field { brief: Some("This bit is set if a frames out of the REW is missing the link layer"), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 4, hi: 5 });
        fields.insert("REWRITE_OVERFLOW_STICKY", Field { brief: Some("Encapsulation overflow. Mismatching pop/push operations"), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 14, hi: 15 });
        fields.insert("VLAN_POP_CNT_STICKY", Field { brief: Some("This bit is set if a VLAN pop event is detected"), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 0, hi: 1 });
        fields.insert("VLAN_PRIO_TAGGED_STICKY", Field { brief: Some("Priority tagged frame event is detected"), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 12, hi: 13 });
        fields.insert("VLAN_TAG_STICKY", Field { brief: Some("This bit is set if a VLAN tag event is detected"), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 2, hi: 3 });
        fields.insert("VLAN_UNTAGGED_VID0_STICKY", Field { brief: Some("Untagged frame event due to VID=0 is detected"), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 13, hi: 14 });
        fields.insert("VLAN_UNTAG_STICKY", Field { brief: Some("This bit is set if a VLAN untag event is detected"), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 1, hi: 2 });
        regs.insert("STICKY_EVENT", Register { addr: Address { base: 138, count: 1, width: 1 }, brief: Some("Rewriter sticky bit register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DSCP_REMAP_STICKY_MASK", Field { brief: Some("Enable counting of the event"), details: Some("0: Sticky event will not be counted 1: Sticky event will be counted"), lo: 7, hi: 8 });
        fields.insert("DSCP_REPLACE_STICKY_MASK", Field { brief: Some("Enable counting of the event"), details: Some("0: Sticky event will not be counted 1: Sticky event will be counted"), lo: 6, hi: 7 });
        fields.insert("INVLD_IFH_FOR_PTP_FRM_STICKY_MASK", Field { brief: Some("Enable counting of the event"), details: Some("0: Sticky event will not be counted 1: Sticky event will be counted"), lo: 5, hi: 6 });
        fields.insert("INVLD_POP_CNT_STICKY_MASK", Field { brief: Some("Enable counting of the event"), details: Some("0: Sticky event will not be counted 1: Sticky event will be counted"), lo: 15, hi: 16 });
        fields.insert("INVLD_W16_POP_CNT_STICKY_MASK", Field { brief: Some("Enable counting of the event"), details: Some("0: Sticky event will not be counted 1: Sticky event will be counted"), lo: 16, hi: 17 });
        fields.insert("IP4_MC_STICKY_MASK", Field { brief: Some("Enable counting of the event"), details: Some("0: Sticky event will not be counted 1: Sticky event will be counted"), lo: 10, hi: 11 });
        fields.insert("IP4_UC_STICKY_MASK", Field { brief: Some("Enable counting of the event"), details: Some("0: Sticky event will not be counted 1: Sticky event will be counted"), lo: 8, hi: 9 });
        fields.insert("IP6_MC_STICKY_MASK", Field { brief: Some("Enable counting of the event"), details: Some("0: Sticky event will not be counted 1: Sticky event will be counted"), lo: 11, hi: 12 });
        fields.insert("IP6_UC_STICKY_MASK", Field { brief: Some("Enable counting of the event"), details: Some("0: Sticky event will not be counted 1: Sticky event will be counted"), lo: 9, hi: 10 });
        fields.insert("LINK_LAYER_ADDED_STICKY_MASK", Field { brief: Some("Enable counting of the event"), details: Some("0: Sticky event will not be counted 1: Sticky event will be counted"), lo: 3, hi: 4 });
        fields.insert("LINK_LAYER_ERROR_STICKY_MASK", Field { brief: Some("Enable counting of the event"), details: Some("0: Sticky event will not be counted 1: Sticky event will be counted"), lo: 4, hi: 5 });
        fields.insert("REWRITE_OVERFLOW_STICKY_MASK", Field { brief: Some("Enable counting of the event"), details: Some("0: Sticky event will not be counted 1: Sticky event will be counted"), lo: 14, hi: 15 });
        fields.insert("VLAN_POP_CNT_STICKY_MASK", Field { brief: Some("Enable counting of the event"), details: Some("0: Sticky event will not be counted 1: Sticky event will be counted"), lo: 0, hi: 1 });
        fields.insert("VLAN_PRIO_TAGGED_STICKY_MASK", Field { brief: Some("Enable counting of the event"), details: Some("0: Sticky event will not be counted 1: Sticky event will be counted"), lo: 12, hi: 13 });
        fields.insert("VLAN_TAG_STICKY_MASK", Field { brief: Some("Enable counting of the event"), details: Some("0: Sticky event will not be counted 1: Sticky event will be counted"), lo: 2, hi: 3 });
        fields.insert("VLAN_UNTAGGED_VID0_STICKY_MASK", Field { brief: Some("Enable counting of the event"), details: Some("0: Sticky event will not be counted 1: Sticky event will be counted"), lo: 13, hi: 14 });
        fields.insert("VLAN_UNTAG_STICKY_MASK", Field { brief: Some("Enable counting of the event"), details: Some("0: Sticky event will not be counted 1: Sticky event will be counted"), lo: 1, hi: 2 });
        regs.insert("STICKY_EVENT_CNT_MASK_CFG", Register { addr: Address { base: 137, count: 1, width: 1 }, brief: Some("Mask for the STICKY_EVENT_COUNT"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("STICKY_EVENT_COUNTER", Field { brief: Some("Counter with number of masked events. Multiple simultaneously events are counted as one."), details: Some("Counter can be written by SW."), lo: 0, hi: 32 });
        regs.insert("STICKY_EVENT_COUNT", Register { addr: Address { base: 136, count: 1, width: 1 }, brief: Some("Controls the common sticky event counter."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TPID_VAL", Field { brief: Some("Configure 3 custom TPID values. These must be configured identically in ANA_CL::VLAN_STAG_CFG.STAG_ETYPE_VAL. Related parameters: ANA_CL::VLAN_STAG_CFG.STAG_ETYPE_VAL"), details: Some("n: TPID value"), lo: 0, hi: 16 });
        regs.insert("TPID_CFG", Register { addr: Address { base: 54, count: 3, width: 1 }, brief: Some("Configure custom TPID values"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("VSTAX_LRN_ALL_HP_ENA", Field { brief: Some("Change priority for learn all frames."), details: Some("0: Disable 1: Enable (Learn all are send with highest priority)"), lo: 1, hi: 2 });
        fields.insert("VSTAX_MODE", Field { brief: Some("Control whether forwarding modes specific to VStaX AF shall be translated to BF forwarding modes. If set to 0, the following translation will be performed: fwd_logical -> fwd_lookup fwd_mc -> fwd_lookup If set to 1, no translation will be performed. Translation is only required for AF switches operating in a BF stack."), details: Some("0: Perform fwd_mode translation. 1: Do not perform fwd_mode translation."), lo: 0, hi: 1 });
        fields.insert("VSTAX_TTL", Field { brief: Some("Link TTL value"), details: None, lo: 4, hi: 9 });
        regs.insert("VSTAX_PORT_GRP_CFG", Register { addr: Address { base: 147, count: 2, width: 1 }, brief: Some("VSTAX Configuration per logical Stacking port"), details: None, fields });
        groups.insert("COMMON", RegisterGroup { addr: Address { base: 85760, count: 1, width: 157 }, desc: "Common configuration and status for all rewriter ports", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CM_ADDR", Field { brief: Some("Address selection within selected core memory (CMID register). Address is automatically advanced at every data access."), details: None, lo: 0, hi: 22 });
        fields.insert("CM_ID", Field { brief: Some("Refer to cmid.xls in the AS1000, misc_docs folder."), details: None, lo: 22, hi: 30 });
        regs.insert("CM_ADDR", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Address selection"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CM_DATA", Field { brief: Some("Data register for core memory access. Wider memories are big endian mapped into the 32 BIT inspection space."), details: None, lo: 0, hi: 32 });
        regs.insert("CM_DATA", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Data register for core memory access."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RAM_ENA", Field { brief: Some("Core memory controllers are enabled when this field is set."), details: None, lo: 0, hi: 1 });
        fields.insert("RAM_INIT", Field { brief: Some("Initialize core memories. Field is automatically cleared when operation is complete ( approx. 40 us)."), details: None, lo: 1, hi: 2 });
        regs.insert("RAM_INIT", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Core reset control"), details: Some("Controls reset and initialization of the switching core. Proper startup sequence is: - Enable memories - Initialize memories - Enable core"), fields });
        groups.insert("COREMEM", RegisterGroup { addr: Address { base: 85312, count: 1, width: 2 }, desc: "Access core memory", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CW_VAL", Field { brief: Some("Control Word value. The control word is always placed after the last MPLS label."), details: Some("x: Control Word"), lo: 0, hi: 32 });
        regs.insert("CW_VAL", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("MPLS label stack Control Word"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LABEL_VAL", Field { brief: Some("Label field value in MPLS  label N"), details: Some("x: Label field value"), lo: 12, hi: 32 });
        fields.insert("SBIT_VAL", Field { brief: Some("SBIT value in MPLS label N"), details: Some("x: SBIT field value"), lo: 8, hi: 9 });
        fields.insert("TC_VAL", Field { brief: Some("TC value in MPLS label N"), details: Some("x: TC field value"), lo: 9, hi: 12 });
        fields.insert("TTL_VAL", Field { brief: Some("TTL value in MPLS label N"), details: Some("x: TTL field value"), lo: 0, hi: 8 });
        regs.insert("LABEL_VAL", Register { addr: Address { base: 8, count: 3, width: 1 }, brief: Some("MPLS label stack field values"), details: Some("This register contains the MPLS label fields. Label 0 is always placed closest to the link layer MAC addresses: [LL] [LL][LBL0][CW] [LL][LBL0][LBL1][CW] [LL][LBL0][LBL1][LBL2][CW] The register MPLS_LABEL_CFG.LABEL_CNT controls the number of labels."), fields });
        let mut fields = HashMap::new();
        fields.insert("DMAC_LSB", Field { brief: Some("DMAC in Link layer. 32 LSB"), details: Some("n: DMAC LSB"), lo: 0, hi: 32 });
        regs.insert("LL_DMAC_LSB", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Configure DMAC of MPLS link layer"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DMAC_MSB", Field { brief: Some("DMAC in Link layer. 16 MSB"), details: Some("n: DMAC MSB"), lo: 0, hi: 16 });
        regs.insert("LL_DMAC_MSB", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Configure DMAC of MPLS link layer"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ETYPE", Field { brief: Some("Ethertype in Link layer"), details: Some("n: Ethertype"), lo: 0, hi: 16 });
        regs.insert("LL_ETYPE", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Configure ETYPE of MPLS link layer"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SMAC_LSB", Field { brief: Some("SMAC in Link layer. 32 LSB"), details: Some("n: SMAC LSB"), lo: 0, hi: 32 });
        regs.insert("LL_SMAC_LSB", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Configure SMAC of MPLS link layer"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SMAC_MSB", Field { brief: Some("SMAC in Link layer. 16 MSB"), details: Some("n: SMAC MSB"), lo: 0, hi: 16 });
        regs.insert("LL_SMAC_MSB", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Configure SMAC of MPLS link layer"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("IFH_ENCAP_MODE", Field { brief: Some("Enable IFH encapsulation mode for this entry. The frame link layer format is changed to: [LL_DMAC][LL_SMAC][0x8880][0x0009] Optionally one VLAN tag can be added if LL_TAG_CFG.TAG_CFG = 1 [LL_DMAC][LL_SMAC][LL_TAG:0][0x8880][0x0009] None of the other encapsulation fields are used in this mode"), details: Some("0: Normal encapsulation mode 1: IFH encapsulation mode"), lo: 2, hi: 3 });
        fields.insert("TAG_CFG", Field { brief: Some("Control VLAN tags in MPLS link layer"), details: Some("0: No tags in link layer 1: One tag after SMAC 2: Two tags after SMAC 3: Reserved"), lo: 0, hi: 2 });
        regs.insert("LL_TAG_CFG", Register { addr: Address { base: 15, count: 1, width: 1 }, brief: Some("Configure VLAN tags in MPLS link layer"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TAG_DEI_VAL", Field { brief: Some("DEI value in link layer tags"), details: Some("x: DEI value"), lo: 0, hi: 1 });
        fields.insert("TAG_PCP_VAL", Field { brief: Some("PCP value in link layer tags"), details: Some("x: PCP value"), lo: 1, hi: 4 });
        fields.insert("TAG_TPID", Field { brief: Some("TPID of link layer VLAN tags"), details: Some("x: TPID value"), lo: 16, hi: 32 });
        fields.insert("TAG_VID_VAL", Field { brief: Some("VID value in link layer tags"), details: Some("x: VID value"), lo: 4, hi: 16 });
        regs.insert("LL_TAG_VAL", Register { addr: Address { base: 16, count: 2, width: 1 }, brief: Some("MPLS label stack Control Word"), details: Some("This register contains the VLAN tags"), fields });
        let mut fields = HashMap::new();
        fields.insert("CW_ENA", Field { brief: Some("Configure Control Word (CW) in label stack"), details: Some("0: No Control Word 1: Add Control Word"), lo: 1, hi: 2 });
        fields.insert("INNER_LBL_SEL", Field { brief: Some("Select innermost label. Source can be ES0 or encapsulation RAM"), details: Some("0: Use label from encapsulation table 1: Use label from ES0"), lo: 0, hi: 1 });
        fields.insert("LABEL_CNT", Field { brief: Some("Configure the number of MPLS labels to use for this encapsulation entry"), details: Some("0: No Labels in encapsulation 1: One MPLS label 2: Two MPLS labels 3: Three MPLS labels"), lo: 2, hi: 4 });
        regs.insert("MPLS_LABEL_CFG", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Configure MPLS label"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LBL_SEL", Field { brief: Some("Configure the Label-field used in label N."), details: Some("0 : LABEL_VAL[N].LABEL_VAL 1-3: Reserved 4 : Mapped using mapping table 0 5 : Mapped using mapping table 1 6 : Mapped using mapping table 2 7 : Mapped using mapping table 3"), lo: 7, hi: 10 });
        fields.insert("SBIT_SEL", Field { brief: Some("Configure the S-bit used in label N."), details: Some("0: Classified SBIT (ISBIT) 1: Fixed: LABEL_VAL[N].SBIT_VAL 2: Mixed: Use Classified SBIT if IFH.DST.ENCAP.PDU_TYPE = OAM_MPLS_TP else LABEL_VAL[N].SBIT_VAL 3: Reserved"), lo: 2, hi: 4 });
        fields.insert("TC_SEL", Field { brief: Some("Configure the TC-field used in label N."), details: Some("0 : Classified TC 1 : LABEL_VAL[N].TC_VAL 2-3: Reserved 4: Mapped using mapping table 0, otherwise use LABEL_VAL[N].TC_VAL 5: Mapped using mapping table 1, otherwise use mapping table 0 6: Mapped using mapping table 2, otherwise use LABEL_VAL[N].TC_VAL 7: Mapped using mapping table 3, otherwise use mapping table 2"), lo: 4, hi: 7 });
        fields.insert("TTL_SEL", Field { brief: Some("Configure the TTL-field used in label N."), details: Some("0: Classified TTL (ITTL) 1: Fixed: LABEL_VAL[N].TTL_VAL 2: Mixed: Use Classified TTL if IFH.DST.ENCAP.PDU_TYPE = OAM_MPLS_TP else LABEL_VAL[N].TTL_VAL 3: Reserved"), lo: 0, hi: 2 });
        regs.insert("MPLS_REMARK_CFG", Register { addr: Address { base: 12, count: 3, width: 1 }, brief: Some("Configure MPLS label remarking"), details: Some("The rewriter can remark certain parameters in the pushed MPLS data. The following illustrates provides an overview of the available remark options."), fields });
        let mut fields = HashMap::new();
        fields.insert("PTP_RSRV_NOT_ZERO_1", Field { brief: Some("This register covers ports 32-56. See PTP_RSRV_NOT_ZERO for description."), details: None, lo: 0, hi: 25 });
        regs.insert("PTP_RSRV_NOT_ZERO_1", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("PTP reserved field check"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RSV_LBL_ENA", Field { brief: Some("Enable reserved MPLS label insertion for MPLS-OAM frames. When this bit is set, an additional MPLS label is inserted if CW insertion is disabled and IFH.DST.ENCAP.PDU_TYPE=OAM_MPLS_TP or IFH.DST.ENCAP.PDU_TYPE=Y1731 and IFH.DST.ENCAP.TYPE_AFTER_POP=CW Note: The reserved label can only be inserted if a CW is not inserted for the frame."), details: Some("0: Disabled 1: Add reserved label if allowed"), lo: 0, hi: 1 });
        fields.insert("RSV_LBL_POS", Field { brief: Some("Select position of the reserved label. It can be added before or after the last MPLS label"), details: Some("0: Add before last label 1: Add after last label like the CW"), lo: 1, hi: 2 });
        fields.insert("RSV_TC_SEL", Field { brief: Some("Configure TC-field used in the reserved label"), details: Some("0 : Classified TC 1 : RSV_LABEL_VAL.RSV_TC_VAL 2-3: Reserved 4: Mapped using mapping table 0, otherwise use RSV_LABEL_VAL.RSV_TC_VAL 5: Mapped using mapping table 1, otherwise use mapping table 0 6: Mapped using mapping table 2, otherwise use RSV_LABEL_VAL.RSV_TC_VAL 7: Mapped using mapping table 3, otherwise use mapping table 2"), lo: 2, hi: 5 });
        regs.insert("RSV_LABEL_CFG", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Configure MPLS label"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RSV_LBL_VAL", Field { brief: Some("Label field value in the reserved MPLS label"), details: Some("x: Label field value"), lo: 12, hi: 32 });
        fields.insert("RSV_SBIT_VAL", Field { brief: Some("SBIT value in reserved the MPLS label"), details: Some("x: SBIT field value"), lo: 8, hi: 9 });
        fields.insert("RSV_TC_VAL", Field { brief: Some("TC value in reserved the MPLS label"), details: Some("x: TC field value"), lo: 9, hi: 12 });
        fields.insert("RSV_TTL_VAL", Field { brief: Some("TTL value in reserved the MPLS label"), details: Some("x: TTL field value"), lo: 0, hi: 8 });
        regs.insert("RSV_LABEL_VAL", Register { addr: Address { base: 11, count: 1, width: 1 }, brief: Some("Reserved label field values"), details: Some("This register contains the reserved MPLS label fields. The reserved label can only be added if the control word (CW) is not enabled."), fields });
        groups.insert("ENCAP", RegisterGroup { addr: Address { base: 0, count: 1024, width: 32 }, desc: "Encapsulation RAM configuration", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("LBM_MAC_LOW", Field { brief: Some("Destination MAC address bit 31:0 used for LBM. See LBM_MAC_HIGH."), details: None, lo: 0, hi: 32 });
        regs.insert("LBM_MAC_LOW", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("MAC address configuration - bits 31:0"), details: None, fields });
        groups.insert("ISDX_TBL", RegisterGroup { addr: Address { base: 32768, count: 4096, width: 4 }, desc: "ISDX configuration table", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("DEI_VAL", Field { brief: Some("Mapped DEI value"), details: Some("n: New DEI value"), lo: 3, hi: 4 });
        fields.insert("DSCP_VAL", Field { brief: Some("Mapped DSCP value"), details: Some("n: New DSCP value"), lo: 4, hi: 10 });
        fields.insert("OAM_COLOR", Field { brief: Some("Mapped OAM COLOR value"), details: Some("n: New OAM COLOR value"), lo: 16, hi: 17 });
        fields.insert("OAM_COSID", Field { brief: Some("Mapped OAM COSID value"), details: Some("n: New OAM COSID value"), lo: 13, hi: 16 });
        fields.insert("PCP_VAL", Field { brief: Some("Mapped PCP value"), details: Some("n: New PCP value"), lo: 0, hi: 3 });
        fields.insert("TC_VAL", Field { brief: Some("Mapped TC value"), details: Some("n: New TC value"), lo: 10, hi: 13 });
        regs.insert("MAP_VAL_A", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Configuration of mapping tables 0 and 1"), details: Some("Lookup 0 and 1 values"), fields });
        let mut fields = HashMap::new();
        fields.insert("MIP_CCM_COPY_STICKY", Field { brief: Some("This bit is set if a CCM CPU is copied to CPU"), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 6, hi: 7 });
        fields.insert("MIP_GENERIC_STICKY", Field { brief: Some("This bit is set if a Generic PDU has been handled"), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 2, hi: 3 });
        fields.insert("MIP_LBM_DA_CHK_FAIL_STICKY", Field { brief: Some("This bit is set if a destination MAC address check has failed for LBM frame"), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 1, hi: 2 });
        fields.insert("MIP_LBM_REDIR_STICKY", Field { brief: Some("This bit is set if a LBM PDU has been redirected to the CPU"), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 5, hi: 6 });
        fields.insert("MIP_LTM_REDIR_STICKY", Field { brief: Some("This bit is set if a LTM PDU has been redirected to the CPU"), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 4, hi: 5 });
        fields.insert("MIP_MEL_CHK_FAIL_STICKY", Field { brief: Some("This bit is set if a MEL check has failed for enabled OAM frames"), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 0, hi: 1 });
        fields.insert("MIP_RAPS_STICKY", Field { brief: Some("This bit is set if a Ring APS PDU has been handled"), details: Some("0: No event 1: Event Bit is cleared by writing a 1 to this position."), lo: 3, hi: 4 });
        regs.insert("MIP_STICKY_EVENT", Register { addr: Address { base: 156, count: 1, width: 1 }, brief: Some("MIP sticky bit register"), details: Some("Event register common for all MIPs"), fields });
        groups.insert("MAP_RES_A", RegisterGroup { addr: Address { base: 49152, count: 4096, width: 2 }, desc: "Mapping resource A", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("LABEL_VAL", Field { brief: Some("Mapped MPLS label value"), details: Some("n: Label value"), lo: 0, hi: 20 });
        regs.insert("MAP_LBL_A", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Configuration of mapping tables 0 and 1. MPLS label"), details: Some("Lookup 0 and 1 values"), fields });
        let mut fields = HashMap::new();
        fields.insert("DEI_VAL", Field { brief: Some("Mapped DEI value"), details: Some("n: New DEI value"), lo: 3, hi: 4 });
        fields.insert("DSCP_VAL", Field { brief: Some("Mapped DSCP value"), details: Some("n: New DSCP value"), lo: 4, hi: 10 });
        fields.insert("OAM_COLOR", Field { brief: Some("Mapped OAM COLOR value"), details: Some("n: New OAM COLOR value"), lo: 16, hi: 17 });
        fields.insert("OAM_COSID", Field { brief: Some("Mapped OAM COSID value"), details: Some("n: New OAM COSID value"), lo: 13, hi: 16 });
        fields.insert("PCP_VAL", Field { brief: Some("Mapped PCP value"), details: Some("n: New PCP value"), lo: 0, hi: 3 });
        fields.insert("TC_VAL", Field { brief: Some("Mapped TC value"), details: Some("n: New TC value"), lo: 10, hi: 13 });
        regs.insert("MAP_VAL_B", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Configuration of mapping tables 2 and 3"), details: Some("Lookup 2 and 3 values"), fields });
        groups.insert("MAP_RES_B", RegisterGroup { addr: Address { base: 57344, count: 4096, width: 2 }, desc: "Mapping resource B", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CCM_COPY_ONCE_ENA", Field { brief: Some("Send the next received CCM frame to CPU. Cleared by HW when a CPU copy has been send to CPU"), details: None, lo: 0, hi: 1 });
        fields.insert("CCM_INTERVAL", Field { brief: Some("Interval used for automatically setting CCM_COPY_ONCE_ENA based on REW::MIP_CTRL.MIP_CCM_HMO_SET_SHOT CCM_COPY_ONCE_ENA are only set by hardware if MIP_CCM_INTERVAL_MASK[CCM_HMO_CTRL.CCM_INTERVAL] is set"), details: None, lo: 1, hi: 3 });
        regs.insert("CCM_HMO_CTRL", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Allows sending a single CCM frame to CPU"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("HIH_AUTO_CKSM", Field { brief: Some("Select the source of the HIH.CKSM field."), details: Some("0: Set HIH.CKSM to fixed default value (HIH_DEF_CKSM) 1: Calculate HIH.CKSM according to HIH contents."), lo: 0, hi: 1 });
        fields.insert("HIH_ENA", Field { brief: Some("Enables prepending of Host Interface Header (HIH) on the port. The HiH will be placed after the SFD and will be covered by the FCS. For 10G ports it is possible to place the HiH before the SFD (in the preamble). See HIH_DEV10G_CFG.HIH_LOCATION"), details: Some("0: Disable HiH functionality 1: Enable HiH insertion"), lo: 6, hi: 7 });
        fields.insert("HIH_FRM_CL", Field { brief: Some("Select source of the HIH.CL field."), details: Some("0: Always set HIH.CL to fixed default value = HIH_DEF_CL 1: Set HIH.CL to IFH.ENCAP.HIH_CL if IFH.FWD.DST_MODE = ENCAP else 0 2: Set HIH.CL to IFH.VSTAX.MISC.ISDX*4+1 if ISDX>0 else use mode 1 3: Reserved"), lo: 3, hi: 5 });
        fields.insert("HIH_FRM_FLAGS", Field { brief: Some("Select the source of the HIH.FLAGS field."), details: Some("0: Set HIH.FLAGS to fixed default value = HIH_DEF_FLAGS 1: Set HIH.FLAGS to frame IPRIO and COLOR bits. 2: Set HIH.FLAGS to frame COSID and COLOR bits. 3: Reserved"), lo: 1, hi: 3 });
        fields.insert("HIH_FRM_LPID", Field { brief: Some("Configure which value goes into the HIH.LPID field."), details: Some("0: Set LPID to fixed default value (HIH_DEF_CFG) 1: Set LPID according egress frame (Formatted by HIH_LPID_MODE)"), lo: 5, hi: 6 });
        fields.insert("HIH_LPID_MODE", Field { brief: Some("Set the format of the Logical Port ID (LPID) (Value put into the HIH will be determined by HIH_FRM_LPID)"), details: Some("0: Egress port number 1: Ingress port number"), lo: 7, hi: 8 });
        regs.insert("HIH_CTRL", Register { addr: Address { base: 43, count: 1, width: 1 }, brief: Some("Various Host Mode control"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LBM_MAC_HIGH", Field { brief: Some("Destination MAC address bits 47:32 used for LBM. If LBM_MAC_HIGH = 0 and LBM_MAC_LOW = 0, the MAC address check for LBM frames is disabled."), details: None, lo: 0, hi: 16 });
        regs.insert("LBM_MAC_HIGH", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("MAC address - bits 47:32"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CCM_COPY_ENA", Field { brief: Some("If set, OAM Y.1731 CCM frames with the correct encapsulation and the correct MEL are copied to the CPU."), details: None, lo: 18, hi: 19 });
        fields.insert("CPU_MIP_QU", Field { brief: Some("CPU extraction queue when frame is forwarded to CPU."), details: None, lo: 1, hi: 4 });
        fields.insert("GENERIC_OPCODE_CFG", Field { brief: Some("Handling of OAM Y.1731 frames with Opcode=GENERIC_OPCODE_VAL, correct encapsulation, and correct MEL."), details: Some("0: No handling 1: Copy to CPU 2: Redirect to CPU 3: Discard"), lo: 4, hi: 6 });
        fields.insert("GENERIC_OPCODE_VAL", Field { brief: Some("Generic Opcode. See GENERIC_OPCODE_CFG."), details: None, lo: 6, hi: 14 });
        fields.insert("LBM_REDIR_ENA", Field { brief: Some("If set, OAM Y.1731 LBM frames with the correct encapsulation, the correct MEL, and the correct destination MAC address are redirected to the CPU."), details: None, lo: 17, hi: 18 });
        fields.insert("LTM_REDIR_ENA", Field { brief: Some("If set, OAM Y.1731 LTM frames with the correct encapsulation and the correct MEL are redirected to the CPU."), details: None, lo: 16, hi: 17 });
        fields.insert("MEL_VAL", Field { brief: Some("MEL value for the MIP."), details: None, lo: 19, hi: 22 });
        fields.insert("PIPELINE_PT", Field { brief: Some("MIP location. This influences in particular the update of loss measurement statistics for MEPs."), details: Some("0: REW_IN_MIP 1: REW_OU_MIP"), lo: 0, hi: 1 });
        fields.insert("RAPS_CFG", Field { brief: Some("Handling of OAM Y.1731 frames with Opcode=RAPS, correct encapsulation, and correct MEL."), details: Some("0: No handling 1: Copy to CPU 2: Redirect to CPU 3: Discard"), lo: 14, hi: 16 });
        regs.insert("MIP_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("MIP configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("VID_SEL", Field { brief: Some("Outer VID check. Configure how the outer frame VID is matched before a frame is accepted as MIP."), details: Some("0: VID check is disabled. Frame is always accepted. 1: Accept untagged frames. Tagged frames are not accepted. 2: Accept single tagged frames with VID = VID_VAL. Untagged frames or frames with multiple VLAN tags are not accepted. 3: Accept untagged frames and single tagged frames with VID = VID_VAL. Frames with multiple VLAN tags are not accepted."), lo: 0, hi: 2 });
        fields.insert("VID_VAL", Field { brief: Some("Required outer VID to identify frame as MIP."), details: Some("n: Outer VID value"), lo: 2, hi: 14 });
        regs.insert("MIP_VID_CTRL", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Controls classified VID check"), details: None, fields });
        groups.insert("MIP_TBL", RegisterGroup { addr: Address { base: 65536, count: 1024, width: 8 }, desc: "MIP table", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CCM_LM_INFO_VLD", Field { brief: Some("Indicates whether this entry in the RAM contains valid CCM-LM sample values."), details: None, lo: 11, hi: 12 });
        fields.insert("CCM_LM_VOE_IDX", Field { brief: Some("The number of the VOE for which the LM information was received."), details: None, lo: 0, hi: 11 });
        regs.insert("CCM_LM_INFO_REG", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Temp CCM-LM info"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CCM_LM_TX_B", Field { brief: Some("Contains the sampled value of CCM_LM.tx_fc_b from the last valid CCM_LM frame."), details: None, lo: 0, hi: 32 });
        regs.insert("CCM_LM_TX_B_REG", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("CCM-LM sample"), details: Some("Contains the sampled value of CCM_LM.tx_fc_b from the last valid CCM_LM frame."), fields });
        let mut fields = HashMap::new();
        fields.insert("PATH_CNT_FRM", Field { brief: Some("Determines if the current frame should be counted by the Path LM counter, based on the color / mapping and possibly being killed in the ingress DLB."), details: None, lo: 0, hi: 1 });
        fields.insert("SRV_CNT_FRM", Field { brief: Some("Determines if the current frame should be counted by the Service LM counter, based on the color / mapping and possibly being killed in the ingress DLB."), details: None, lo: 1, hi: 2 });
        regs.insert("LM_CNT_FRAME", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Temp LM cnt"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_BYTE_CNT_LSB", Field { brief: Some("See Register Description."), details: None, lo: 0, hi: 32 });
        regs.insert("PORT_BYTE_CNT_LSB", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Byte count of all frames passing through the Port VOE (LSB)"), details: Some("Byte count of all frames passing through the Port VOE. Whenever this RAM is read, the value of this register will be sampled into the following register: * ANA_AC_OAM_MOD::RD_LAST_PORT_BYTE_CNT_LSB.RD_LAST_PORT_BYTE_CNT_LSB (ANA) * REW::RD_LAST_PORT_BYTE_CNT_LSB.RD_LAST_PORT_BYTE_CNT_LSB (REW)"), fields });
        let mut fields = HashMap::new();
        fields.insert("TEMP_CNT_VAL", Field { brief: None, details: None, lo: 0, hi: 16 });
        regs.insert("TEMP_CNT_REG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("LM temp count"), details: None, fields });
        groups.insert("OAM_PDU_MOD_CONT", RegisterGroup { addr: Address { base: 88064, count: 106, width: 8 }, desc: "VOE additional information", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CCM_LM_RX_B", Field { brief: Some("Contains the sampled value of CCM_LM.rx_fc_b from the last valid CCM_LM frame."), details: None, lo: 0, hi: 32 });
        regs.insert("CCM_LM_RX_B_REG", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("CCM-LM sample"), details: Some("Contains the sampled value of CCM_LM.rx_fc_b from the last valid CCM_LM frame."), fields });
        let mut fields = HashMap::new();
        fields.insert("PTP_DOMAIN", Field { brief: None, details: None, lo: 0, hi: 2 });
        regs.insert("DM_PTP_DOMAIN_CFG", Register { addr: Address { base: 0, count: 53, width: 1 }, brief: Some("Port PTP domain select"), details: Some("Jaguar2-R supports three PTP time domains. The Delay Measurements (Y.1731) uses the PTP timing for updating the DM PDUs. For this to work, each port on the switch must be configured for which PTP timedomain to use. This is done by configuring this register. The settings must be the same in the REW and the ANA_AC instatiation of the OAM_PDU_MOD block."), fields });
        let mut fields = HashMap::new();
        fields.insert("RD_LAST_PORT_BYTE_CNT_MSB", Field { brief: Some("See register description."), details: None, lo: 0, hi: 8 });
        regs.insert("RD_LAST_PORT_BYTE_CNT_MSB", Register { addr: Address { base: 55, count: 1, width: 1 }, brief: Some("PORT_BYTE_CNT_MSB sample register."), details: Some("Whenever either of the bit fields the following RAM are read: * ANA_AC_OAM_MOD:VOE_SRV_LM_CNT (ANA) * REW:VOE_SRV_LM_CNT (REW) this register will sample the value of the following bit field: * ANA_AC_OAM_MOD:VOE_PORT_LM_CNT:PORT_BYTE_CNT_MSB.PORT_BYTE_CNT_MSB (ANA) * REW:VOE_PORT_LM_CNT:PORT_BYTE_CNT_MSB.PORT_BYTE_CNT_MSB (REW)"), fields });
        let mut fields = HashMap::new();
        fields.insert("RD_LAST_PORT_FRM_CNT_LSB", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("RD_LAST_PORT_FRM_CNT_LSB", Register { addr: Address { base: 54, count: 1, width: 1 }, brief: Some("PORT_NON_LM_CNT_LSB sample register."), details: Some("Whenever either of the bit fields the following RAM are read: * ANA_AC_OAM_MOD:VOE_SRV_LM_CNT (ANA) * REW:VOE_SRV_LM_CNT (REW) this register will sample the value of the following bit field: * ANA_AC_OAM_MOD:VOE_PORT_LM_CNT:PORT_FRM_CNT_LSB.PORT_FRM_CNT_LSB (ANA) * REW:VOE_PORT_LM_CNT:PORT_FRM_CNT_LSB.PORT_FRM_CNT_LSB (REW)"), fields });
        let mut fields = HashMap::new();
        fields.insert("RD_LAST_PORT_LM_CNT_LSB", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("RD_LAST_PORT_LM_CNT_LSB", Register { addr: Address { base: 53, count: 1, width: 1 }, brief: Some("PORT_LM_CNT_LSB sample register."), details: Some("Whenever either of the bit fields the following RAM are read: * ANA_AC_OAM_MOD:VOE_SRV_LM_CNT (ANA) * REW:VOE_SRV_LM_CNT (REW) this register will sample the value of the following bit field: * ANA_AC_OAM_MOD:VOE_PORT_LM_CNT:PORT_LM_CNT_LSB.PORT_LM_CNT_LSB (ANA) * REW:VOE_PORT_LM_CNT:PORT_LM_CNT_LSB.PORT_LM_CNT_LSB (REW)"), fields });
        groups.insert("PDU_MOD_CFG", RegisterGroup { addr: Address { base: 85917, count: 1, width: 57 }, desc: "OAM_PDU_MOD misc. configuration", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("DEI_DE0", Field { brief: Some("Map internal priority to CFI/DEI value in tags. This table used for DP values mapped to 0 in PORT_DP_MAP."), details: None, lo: 0, hi: 1 });
        regs.insert("DEI_MAP_DE0", Register { addr: Address { base: 17, count: 8, width: 1 }, brief: Some("Map internal priority to tag value."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DEI_DE1", Field { brief: Some("Map internal priority to CFI/DEI value in tags. This table used for DP values mapped to 1 in PORT_DP_MAP."), details: None, lo: 0, hi: 1 });
        regs.insert("DEI_MAP_DE1", Register { addr: Address { base: 25, count: 8, width: 1 }, brief: Some("Map internal priority to tag value."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DSCP_REMAP_ENA", Field { brief: Some("Enable use of a shared DSCP remap table (DSCP_REMAP). Map DSCP value resulting from DSCP_UPDATE_ENA and IFH.QOS.UPDATE_DSCP using the common mapping table (DSCP_REMAP)."), details: Some("0 : No remapping. 1 : Remap DSCP using DSCP remap table (DSCP_REMAP)"), lo: 0, hi: 1 });
        fields.insert("DSCP_UPDATE_ENA", Field { brief: Some("Update DSCP with value from Analyzer, if allowed by analyzer. (IFH.QOS.UPDATE_DSCP)"), details: Some("0 : No update 1 : Allow update of DSCP"), lo: 1, hi: 2 });
        regs.insert("DSCP_MAP", Register { addr: Address { base: 34, count: 1, width: 1 }, brief: Some("Enable DSCP updates on the port."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LABEL_VAL", Field { brief: Some("Mapped MPLS label value"), details: Some("n: Label value"), lo: 0, hi: 20 });
        regs.insert("MAP_LBL_B", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Configuration of mapping tables 2 and 3. MPLS label"), details: Some("Lookup 2 and 3 values"), fields });
        let mut fields = HashMap::new();
        fields.insert("PCP_DE0", Field { brief: Some("Map internal priority to UPRIO/PCP value in tags. This table used for DP values mapped to 0 in PORT_DP_MAP."), details: None, lo: 0, hi: 3 });
        regs.insert("PCP_MAP_DE0", Register { addr: Address { base: 1, count: 8, width: 1 }, brief: Some("Map internal priority to tagged priority."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PCP_DE1", Field { brief: Some("Map internal priority to UPRIO/PCP value in tags. This table used for DP values mapped to 1 in PORT_DP_MAP."), details: None, lo: 0, hi: 3 });
        regs.insert("PCP_MAP_DE1", Register { addr: Address { base: 9, count: 8, width: 1 }, brief: Some("Map internal priority to tagged priority."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_DEI", Field { brief: Some("DEI field in the TCI."), details: Some("n: Port DEI value"), lo: 12, hi: 13 });
        fields.insert("PORT_PCP", Field { brief: Some("PCP field in the TCI."), details: Some("n: Port PCP value"), lo: 13, hi: 16 });
        fields.insert("PORT_VID", Field { brief: Some("VID field in the TCI."), details: Some("n: Port VID"), lo: 0, hi: 12 });
        regs.insert("PORT_VLAN_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Configures per port custom values for TAGs"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PTP_EDLY_VAL", Field { brief: Some("Signed value to add to CF when frame is transmitted on this port. Field is used if requested through the analyzer match rule. This value can be used as the egress asymmetry delay for the particular PTP flow."), details: None, lo: 0, hi: 32 });
        regs.insert("PTP_EDLY_CFG", Register { addr: Address { base: 38, count: 1, width: 1 }, brief: Some("1588 configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PTP_IDLY1_VAL", Field { brief: Some("Signed value to add to CF when frame is received on this port. Field is used if requested through the analyzer match rule. This value can be used as the ingress asymmetry or ingress asymmetry+path delay for the particular PTP flow."), details: None, lo: 0, hi: 32 });
        regs.insert("PTP_IDLY1_CFG", Register { addr: Address { base: 39, count: 1, width: 1 }, brief: Some("1588 configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PTP_IDLY2_VAL", Field { brief: Some("Signed value to add to CF when frame is received on this port. Field is used if requested through the analyzer match rule. This value can be used as the ingress asymmetry or ingress asymmetry+path delay for the particular PTP flow."), details: None, lo: 0, hi: 32 });
        regs.insert("PTP_IDLY2_CFG", Register { addr: Address { base: 40, count: 1, width: 1 }, brief: Some("1588 configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PTP_UDP4_CSUM_DIS", Field { brief: Some("Set to disable clearing of checksum field in IPv4 frames"), details: None, lo: 0, hi: 1 });
        fields.insert("PTP_UDP6_CSUM_DIS", Field { brief: Some("Set to skip update of udp checksums for IPv6 frames"), details: None, lo: 1, hi: 2 });
        regs.insert("PTP_MISC_CFG", Register { addr: Address { base: 37, count: 1, width: 1 }, brief: Some("1588 configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PTP_DOM_VAL", Field { brief: Some("Sets the time domain this port belongs to."), details: None, lo: 0, hi: 2 });
        fields.insert("PTP_MODE_VAL", Field { brief: Some("PTP operation mode for frames."), details: Some("0: Front port 1: Backplane port using RSRV field 30 bit TS transfer 2: Backplane port using RSRV field 32 bit TS transfer 3: Backplane port using CF field for 44 bit TS transfer 4: Backplane port using CF field for 48 bit TS transfer 5: Monitor port. Frame updated to arrival stamper. 6: PTP Disabled port"), lo: 2, hi: 5 });
        regs.insert("PTP_MODE_CFG", Register { addr: Address { base: 35, count: 2, width: 1 }, brief: Some("1588 configuration"), details: Some("Selects mode of port when transmitting (index 0), or receiving (index 1)"), fields });
        let mut fields = HashMap::new();
        fields.insert("PTP_SMAC_HIGH", Field { brief: Some("If requested by the PTP action out of the analyzer, this MAC address can be pasted into the SMAC."), details: None, lo: 0, hi: 16 });
        regs.insert("PTP_SMAC_HIGH", Register { addr: Address { base: 42, count: 1, width: 1 }, brief: Some("High 16 bits of PTP Mac Address"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PTP_SMAC_LOW", Field { brief: Some("If requested by the PTP action out of the analyzer, this MAC address can be pasted into the SMAC."), details: None, lo: 0, hi: 32 });
        regs.insert("PTP_SMAC_LOW", Register { addr: Address { base: 41, count: 1, width: 1 }, brief: Some("Low 32 bits of PTP Mac Address"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TAG_CFG", Field { brief: Some("Control port tagging. See TAG_CTRL.TAG_CFG_OBEY_WAS_TAGGED."), details: Some("0: Port tagging disabled 1: Tag all frames, except when VID=PORT_VLAN_CFG.PORT_VID or VID=0 2: Tag all frames, except when VID=0 3: Tag all frames"), lo: 10, hi: 12 });
        fields.insert("TAG_CFG_OBEY_WAS_TAGGED", Field { brief: Some("Control how port tags are added. If this bit is set, the IFH field VSTAX.TAG.WAS_TAGGED must be '1' before a port tag is added to a frame. See TAG_CTRL.TAG_CFG"), details: Some("0: Normal port tagging mode 1: Frames are not port tagged, if VSTAX.TAG.WAS_TAGGED = '0' regardless of TAG_CTRL.TAG_CFG configuration"), lo: 12, hi: 13 });
        fields.insert("TAG_DEI_CFG", Field { brief: Some("Select DEI fields in port tag"), details: Some("Select DEI in port tag. 0: Classified DEI 1: PORT_DEI 2: DE and QoS mapped to DEI (DEI_MAP_DEx) 3: DE level (Color) 4: DE and COSID mapped to DEI (DEI_MAP_DEx) 5: DE and classified PCP mapped to DEI (DEI_MAP_DEx) 6-7: Reserved"), lo: 0, hi: 3 });
        fields.insert("TAG_PCP_CFG", Field { brief: Some("Select PCP fields in port tag"), details: Some("Select PCP in port tag. 0: Classified PCP 1: PORT_PCP 2: DE and QoS mapped to PCP (PCP_MAP_DEx) 3: QoS class 4: DE and COSID mapped to PCP (PCP_MAP_DEx) 5: COSID 6: DE and classified PCP mapped to PCP (PCP_MAP_DEx) 7: Reserved"), lo: 3, hi: 6 });
        fields.insert("TAG_TPID_CFG", Field { brief: Some("Select Tag Protocol Identifier (TPID) for port tagging"), details: Some("0: 0x8100 1: 0x88A8 2: Custom1. REW::TPID_CFG[0].TPID_VAL 3: Custom2. REW::TPID_CFG[1].TPID_VAL 4: Custom3. REW::TPID_CFG[2].TPID_VAL 5: Select via ifh.vstax.tag_type and ifh.encap.tag_tpid If ifh.encap.tag_tipd = STD_TPID: If ifh.vstax.tag_type = 0 then 0x8100 else 0x88A8 If ifh.encap.tag_tipd = CUSTOM<n>: Custom<n> TPID 6-7: Reserved"), lo: 7, hi: 10 });
        fields.insert("TAG_VID_CFG", Field { brief: Some("Select VID in port tag"), details: Some("Select VID in port tag. 0: Use classified VID. 1: Use PORT_VLAN_CFG.PORT_VID"), lo: 6, hi: 7 });
        regs.insert("TAG_CTRL", Register { addr: Address { base: 33, count: 1, width: 1 }, brief: Some("Configure PORT tagging"), details: None, fields });
        groups.insert("PORT", RegisterGroup { addr: Address { base: 81920, count: 53, width: 64 }, desc: "Port based configuration and status for rewriter", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("COS_NXT", Field { brief: Some("The auto updated COSID value is determined according to the following algorithm: mask = IFH.TS.INJ_LBK.COS_MASK[7:0] isdx = IFH.VSTAX.MISC.ISDX cos_nxt_sel = IFH.TS.INJ_LBK.COS_NXT_SEL if (cos_nxt_sel > 0 and isdx > 0 and mask > 0) { cos_nxt = REW:ISDX_TBL:COS_CTRL[IFH.VSTAX.MISC.ISDX].COS_NXT[cos_nxt_sel-1] # Use cos_nxt to find next bit in cos_mask for idx in 0:7 { if (mask[(idx+cos_nxt) mod 8] = '1') { cosid_new = idx break } } # Update next pointer REW:ISDX_TBL:COS_CTRL[IFH.VSTAX.MISC.ISDX].COS_NXT[cos_nxt_sel-1] = ((cosid_new+1) mod 8) }"), details: Some("0-7: Next COS value to use"), lo: 0, hi: 3 });
        regs.insert("COS_CTRL", Register { addr: Address { base: 0, count: 3, width: 1 }, brief: Some("COSID value selection"), details: Some("The multi COSID auto update function is active if the following IFH fields are set by the AFI in the injected frames: IFH.FWD.TS_MODE = INJ_LBK IFH.TS.INJ_LBK.COS_NXT_SEL: Selects one of three multi COSID injections per ISDX (0: disable) IFH.TS.INJ_LBK.COS_MASK[7:0] : Specifies the COSIDs to be used. IFH.TS.INJ_LBK.CHG_COSID_ENA: Controls updating of IFH.VSTAX.MISC.COSID IFH.TS.INJ_LBK.CHG_OUTER_PCP_ENA: Controls updating of outermost PCP value IFH.TS.INJ_LBK.CHG_IFH_TC_ENA: Controls updating of IFH.DST.ENCAP.MPLS_TC IFH.TS.INJ_LBK.CHG_IFH_PCP_ENA: Controls updating of IFH.VSTAX.TAG.UPRIO The multi COSID function operates differently for injected Up-MEP or Down-MEP frames. Up-MEP frames are injected by the AFI on the VD1 port and looped back to the ANA. Injected Up-MEP frames are modified when they pass through the REW the first time on the VD1 port. The IFH of the looped frames will be modified if enabled by the CHG-fields. The PCP of the outer most VLAN tag in the ETH link layer is changed if this is enabled. The IFH.TS.INJ_LBK.COS_NXT_SEL field is set to 0 to in the frame. This disables further COSID updates when the frame reaches the REW again after the loop back. Down-MEP frames are injected by the AFI on a physical port. If enabled by the INJ_LBK.CHG bits the the REW will use the new COSID value for the selected fields. The INJ_LBK.CHG_OUTER_PCP_ENA field has no functionality in Down-MEP mode. The outer PCP value will be controlled by the normal tagging configuration."), fields });
        let mut fields = HashMap::new();
        fields.insert("PTP_DOM_VAL", Field { brief: Some("Sets the time domain this port belongs to."), details: None, lo: 0, hi: 2 });
        fields.insert("PTP_MODE_VAL", Field { brief: Some("PTP operation mode for frames."), details: Some("0: Front port 1: Backplane port using RSRV field 30 bit TS transfer 2: Backplane port using RSRV field 32 bit TS transfer 3: Backplane port using CF field for 44 bit TS transfer 4: Backplane port using CF field for 48 bit TS transfer 5: Monitor port. Frame updated to arrival stamper. 6: PTP Disabled port"), lo: 2, hi: 5 });
        regs.insert("PTP_CPUVD_MODE_CFG", Register { addr: Address { base: 2, count: 4, width: 1 }, brief: Some("1588 configuration"), details: Some("Selects ingress PTP mode of the CPU and virtual device ports. Replication n configures port 53+n."), fields });
        let mut fields = HashMap::new();
        fields.insert("PTP_RSRV_NOT_ZERO", Field { brief: Some("Register contains one bit per port being set when the port has received a frame with non-zero reserved bytes field This register covers ports 0-31"), details: None, lo: 0, hi: 32 });
        regs.insert("PTP_RSRV_NOT_ZERO", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("PTP reserved field check"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PTP_NXT", Field { brief: Some("Write one to advance the stamp queue to the next available."), details: None, lo: 11, hi: 12 });
        fields.insert("PTP_OVFL", Field { brief: Some("The stamp is overflown, and some stamps are lost."), details: None, lo: 0, hi: 1 });
        fields.insert("PTP_OVWR_ENA", Field { brief: Some("If the fifo is overflown, additional stamps will overwrite older."), details: None, lo: 12, hi: 13 });
        fields.insert("PTP_VLD", Field { brief: Some("The stamp queue is non empty"), details: None, lo: 10, hi: 11 });
        fields.insert("STAMP_PORT", Field { brief: Some("Field contains the port number the stamp was made on"), details: None, lo: 1, hi: 9 });
        fields.insert("STAMP_TX", Field { brief: Some("Current stamp is an egress stamp"), details: None, lo: 9, hi: 10 });
        regs.insert("PTP_TWOSTEP_CTRL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Configuration register for PTP stamping"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("STAMP_NSEC", Field { brief: Some("Contains the 32 bit timestamp."), details: None, lo: 0, hi: 32 });
        regs.insert("PTP_TWOSTEP_STAMP", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Ingress time stamp"), details: None, fields });
        groups.insert("PTP_CTRL", RegisterGroup { addr: Address { base: 85314, count: 1, width: 8 }, desc: "PTP Control", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("RLEG_EVID", Field { brief: Some("VID for egress router leg. This must be configured consistently in ANA_L3:VMID:RLEG_CTRL.RLEG_EVID."), details: Some("n: VID"), lo: 0, hi: 12 });
        fields.insert("RLEG_VSTAX2_WAS_TAGGED", Field { brief: Some("Control the value of VSTAX.TAG.WAS_TAGGED field in the stack header for frames that are L3 forwarded to a stack port."), details: Some("0: VSTAX.TAG.WAS_TAGGED = 0 1: VSTAX.TAG.WAS_TAGGED = 1"), lo: 12, hi: 13 });
        regs.insert("RLEG_CTRL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Rewriter router leg configuration"), details: None, fields });
        groups.insert("PTP_SEQ_NO", RegisterGroup { addr: Address { base: 85504, count: 1, width: 256 }, desc: "Sequence numbers for PTP frames", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("RD_LAST_PORT_BYTE_CNT_LSB", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("RD_LAST_PORT_BYTE_CNT_LSB", Register { addr: Address { base: 56, count: 1, width: 1 }, brief: Some("PORT_BYTE_CNT_LSB sample register."), details: Some("Whenever either of the bit fields the following RAM are read: * ANA_AC_OAM_MOD:VOE_SRV_LM_CNT (ANA) * REW:VOE_SRV_LM_CNT (REW) this register will sample the value of the following bit field: * ANA_AC_OAM_MOD:VOE_PORT_LM_CNT:PORT_BYTE_CNT_LSB.PORT_BYTE_CNT_LSB (ANA) * REW:VOE_PORT_LM_CNT:PORT_BYTE_CNT_LSB.PORT_BYTE_CNT_LSB (REW)"), fields });
        groups.insert("RAM_CTRL", RegisterGroup { addr: Address { base: 85322, count: 1, width: 1 }, desc: "Access core memory", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("TAG_DEI_SEL", Field { brief: Some("Selects DEI for MPLS encapsulation tag Idx0:  TAG_A, Idx1:\tTAG_B"), details: Some("0: Classified DEI 1: Encapsulation TAG_DEI_VAL:n 2: DP: REW::DP_MAP.DP 3: Reserved 4: Mapped using mapping table 0, otherwise use LL_TAG_VAL[N].TAG_DEI_VAL 5: Mapped using mapping table 1, otherwise use mapping table 0 6: Mapped using mapping table 2, otherwise use LL_TAG_VAL[N].TAG_DEI_VAL 7: Mapped using mapping table 3, otherwise use mapping table 2"), lo: 1, hi: 4 });
        fields.insert("TAG_PCP_SEL", Field { brief: Some("Selects PCP for MPLS encapsulation tag Idx0:  TAG_A, Idx1:\tTAG_B"), details: Some("0: Classified PCP 1: Encapsulation TAG_PCP_VAL:n 2-3: Reserved 4: Mapped using mapping table 0, otherwise use LL_TAG_VAL[N].TAG_PCP_VAL 5: Mapped using mapping table 1, otherwise use mapping table 0 6: Mapped using mapping table 2, otherwise use LL_TAG_VAL[N].TAG_PCP_VAL 7: Mapped using mapping table 3, otherwise use mapping table 2"), lo: 4, hi: 7 });
        fields.insert("TAG_TPID_SEL", Field { brief: Some("Selects TPID for MPLS encapsulation tag Idx0:  TAG_A, Idx1:\tTAG_B"), details: Some("0: Encapsulation LL_TAG_VAL[N].TAG_TPID 1: Classified.  ANA controls via IFH: If ifh.encap.tag_tipd = STD_TPID: If ifh.vstax.tag_type = 0 then 0x8100 else LL_TAG_VAL[N].TAG_TPID if ifh.encap.tag_tipd > 0: Custom TPID 1 to 3 configured by  REW::TPID_CFG[N].TPID_VAL"), lo: 0, hi: 1 });
        fields.insert("TAG_VID_SEL", Field { brief: Some("Selects VID for MPLS encapsulation tag Idx0:  TAG_A, Idx1:\tTAG_B"), details: Some("0: Classified VID + TAG_VID_VAL:n 1: TAG_VID_VAL:n"), lo: 7, hi: 8 });
        regs.insert("LL_TAG_REMARK_CFG", Register { addr: Address { base: 18, count: 2, width: 1 }, brief: Some("Configure remarking of VLAN tags in MPLS link layer"), details: None, fields });
        groups.insert("VMID", RegisterGroup { addr: Address { base: 85376, count: 128, width: 1 }, desc: "Egress Mapped VLAN (EVMID) configuration", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("PORT_BYTE_CNT_MSB", Field { brief: Some("See Register Description."), details: None, lo: 0, hi: 8 });
        regs.insert("PORT_BYTE_CNT_MSB", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Byte count of all frames passing through the Port VOE (MSB)"), details: Some("Byte count of all frames passing through the Port VOE. Whenever this RAM is read, the value of this register will be sampled into the following register: * ANA_AC_OAM_MOD::RD_LAST_PORT_BYTE_CNT_MSB.RD_LAST_PORT_BYTE_CNT_MSB (ANA) * REW::RD_LAST_PORT_BYTE_CNT_MSB.RD_LAST_PORT_BYTE_CNT_MSB (REW)"), fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_FRM_CNT_LSB", Field { brief: Some("See Register Description."), details: None, lo: 0, hi: 32 });
        regs.insert("PORT_FRM_CNT_LSB", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Count all the frames which pass through the Port VOE"), details: Some("This counter counts all the frames which pass though the Port VOE. Whenever this RAM is read, the value of this register will be sampled into the following register: * ANA_AC_OAM_MOD::RD_LAST_PORT_FRM_CNT_LSB.RD_LAST_PORT_FRM_CNT_LSB (ANA) * REW::RD_LAST_PORT_FRM_CNT_LSB.RD_LAST_PORT_FRM_CNT_LSB (REW)"), fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_LM_CNT_LSB", Field { brief: Some("See Register Description."), details: None, lo: 0, hi: 32 });
        regs.insert("PORT_LM_CNT_LSB", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Count selected OAM PDU received by MEP Counter"), details: Some("Implements the OAM VOE LM port counters. Depending on whether the OAM_PDU_MOD block is instantiated in the REW or the ANA these counters will be either egress (REW) or ingress (ANA) counters. Y.1731 LM counters count frames and are 32 bit wide. Whenever this RAM is read, the value of this register will be sampled into the following register: * ANA_AC_OAM_MOD::RD_LAST_PORT_LM_CNT_LSB.RD_LAST_PORT_LM_CNT_LSB (ANA) * REW::RD_LAST_PORT_LM_CNT_LSB.RD_LAST_PORT_LM_CNT_LSB (REW)"), fields });
        let mut fields = HashMap::new();
        fields.insert("SRV_LM_CNT_LSB", Field { brief: None, details: None, lo: 0, hi: 32 });
        regs.insert("SRV_LM_CNT_LSB", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Service LM counters pr. priority"), details: Some("Implements the OAM VOE LM counters. Depending on whether the OAM_PDU_MOD block is instantiated in the REW or the ANA these counters will be either egress (REW) or ingress (ANA) counters. Y.1731 LM counters count frames and are 32 bit wide."), fields });
        groups.insert("VOE_PORT_LM_CNT", RegisterGroup { addr: Address { base: 86016, count: 424, width: 4 }, desc: "OAM LM port counters pr. priority", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("PTP_SEQ_NO", Field { brief: Some("Sequence number for the flow given by the timestamp field in IFH. Sequence number will automatically increase at each transmission referring to the sequence entry."), details: None, lo: 0, hi: 16 });
        regs.insert("PTP_SEQ_NO", Register { addr: Address { base: 0, count: 256, width: 1 }, brief: Some("Sequence number configuration"), details: None, fields });
        groups.insert("VOE_SRV_LM_CNT", RegisterGroup { addr: Address { base: 73728, count: 8192, width: 1 }, desc: "OAM Service LM counters pr. priority", regs });
        out.insert("REW", Target { desc: "Rewriter", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("DFT_MST", Field { brief: Some("Use this field to configure default master."), details: Some("0: No default master 1: Master 1 2: Master 2 3: Master 3"), lo: 0, hi: 4 });
        regs.insert("DFT_MST", Register { addr: Address { base: 18, count: 1, width: 1 }, brief: Some("Default master"), details: Some("The default master is selected by the bus when no master has requested ownership. The default master is able to start bus accesses slightly faster than other masters."), fields });
        let mut fields = HashMap::new();
        fields.insert("EBT", Field { brief: Some("Set when an Early Burst Termination takes place. The register is cleared when read."), details: None, lo: 0, hi: 1 });
        regs.insert("EBT", Register { addr: Address { base: 17, count: 1, width: 1 }, brief: Some("Early burst termination"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("EBT_COUNT", Field { brief: Some("Maximum number of cycles a transfer can take before being subject to an early burst termination."), details: None, lo: 0, hi: 10 });
        regs.insert("EBT_COUNT", Register { addr: Address { base: 15, count: 1, width: 1 }, brief: Some("Early burst termination count"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("EBT_EN", Field { brief: Some("Use this field to enable early burst termination."), details: Some("0: Disabled 1: Enabled"), lo: 0, hi: 1 });
        regs.insert("EBT_EN", Register { addr: Address { base: 16, count: 1, width: 1 }, brief: Some("Early burst termination enable"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PL1", Field { brief: Some("Arbitration priority for the master. When multiple masters request the bus at the same time, the one with the highest priority is ganted bus access."), details: Some("Values 0x1 through 0xF, higher values are prioritized over lower values."), lo: 0, hi: 4 });
        regs.insert("PL_CPU", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Master 1 arbitration priority"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PL3", Field { brief: Some("See SBA::PL1 for description."), details: None, lo: 0, hi: 4 });
        regs.insert("PL_CSR", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Master 3 arbitration priority"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PL2", Field { brief: Some("See SBA::PL1 for description."), details: None, lo: 0, hi: 4 });
        regs.insert("PL_PCIE", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Master 2 arbitration priority"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RESERVED1", Field { brief: None, details: None, lo: 0, hi: 32 });
        regs.insert("RESERVED1", Register { addr: Address { base: 3, count: 12, width: 1 }, brief: Some("Reserved"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("WT_CL1", Field { brief: Some("Number of tokens to grant the master at the start of each refresh period for weighted-token arbitration scheme. If configured with a value of zero, the master is considered to have infinite tokens."), details: None, lo: 0, hi: 16 });
        regs.insert("WT_CPU", Register { addr: Address { base: 21, count: 1, width: 1 }, brief: Some("Master 1 clock tokens"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("WT_CL3", Field { brief: Some("See SBA::WT_CL1 for description."), details: None, lo: 0, hi: 16 });
        regs.insert("WT_CSR", Register { addr: Address { base: 23, count: 1, width: 1 }, brief: Some("Master 3 clock tokens"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("WT_EN", Field { brief: Some("Set this field to enable weighted-token arbitration scheme."), details: None, lo: 0, hi: 1 });
        regs.insert("WT_EN", Register { addr: Address { base: 19, count: 1, width: 1 }, brief: Some("Weighted-token arbitration scheme enable"), details: Some("When weighted token arbitration is enabled, each master on the shared bus is granted a configurable number of tokens at the start of each refresh period. The length of each refresh period is configurable. In each clock-cycle that a master uses the bus, the token counter for that master decreases. Once all tokens are spent, the master is forced to a low priority. A master with tokens remaining, always takes priority over masters with no tokens remaining."), fields });
        let mut fields = HashMap::new();
        fields.insert("WT_CL2", Field { brief: Some("See SBA::WT_CL1 for description."), details: None, lo: 0, hi: 16 });
        regs.insert("WT_PCIE", Register { addr: Address { base: 22, count: 1, width: 1 }, brief: Some("Master 2 clock tokens"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("WT_TCL", Field { brief: Some("Refresh period length for the weighted-token arbitration scheme."), details: None, lo: 0, hi: 16 });
        regs.insert("WT_TCL", Register { addr: Address { base: 20, count: 1, width: 1 }, brief: Some("Clock tokens refresh period"), details: None, fields });
        groups.insert("SBA", RegisterGroup { addr: Address { base: 0, count: 1, width: 24 }, desc: "Shared bus arbiter registers", regs });
        out.insert("SBA", Target { desc: "Shared Bus Arbiter", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("DES_DIS", Field { brief: Some("Deserializer disable."), details: None, lo: 0, hi: 1 });
        fields.insert("DES_IF_MODE_SEL", Field { brief: Some("Interface width"), details: Some("0: 8 1: 10 2: 16 (energy efficient) 3: 20 (energy efficient) 4: 32 5: 40 6: 16 bit (fast) 7: 20 bit (fast)"), lo: 2, hi: 5 });
        fields.insert("DES_INV_H", Field { brief: Some("Invert output of high auxillary deserializer"), details: None, lo: 7, hi: 8 });
        fields.insert("DES_INV_L", Field { brief: Some("Invert output of low auxillary deserializer"), details: None, lo: 6, hi: 7 });
        fields.insert("DES_INV_M", Field { brief: Some("Invert output of main deserializer"), details: None, lo: 5, hi: 6 });
        fields.insert("DES_VSC_DIS", Field { brief: Some("Auxillary deserializer channels disable."), details: None, lo: 1, hi: 2 });
        regs.insert("SD10G65_DES_CFG0", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("SD10G65 DES Configuration register 0"), details: Some("Configuration register 0 for SD10G65 DES."), fields });
        groups.insert("SD10G65_DES", RegisterGroup { addr: Address { base: 0, count: 1, width: 2 }, desc: "SD10G65 DES Configuration and Status Register set", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("IB_1V_ENA", Field { brief: Some("Enable for 1V mode"), details: Some("0: VDDI=1.2V 1: VDDI=1.0V"), lo: 6, hi: 7 });
        fields.insert("IB_CLKDIV_ENA", Field { brief: Some("Enable clock dividers in sampling stag"), details: Some("0: Disable (use in double rate mode) 1: Enable (use in full rate mode)"), lo: 5, hi: 6 });
        fields.insert("IB_DFE_ENA", Field { brief: Some("Enable DFE stage (gates IB_ISEL_DFE)"), details: Some("0: Disable 1: Enable"), lo: 14, hi: 15 });
        fields.insert("IB_DIRECT_ENA", Field { brief: Some("Is or'ed to the prim. input of the macro: sx_direct_data_ena_rx_i and is used to enable the direct data path."), details: None, lo: 15, hi: 16 });
        fields.insert("IB_EQZ_ENA", Field { brief: Some("Enable EQualiZation stage"), details: Some("0: Disable 1: Enable (mission mode)"), lo: 1, hi: 2 });
        fields.insert("IB_IA_ENA", Field { brief: Some("Enable for IA including ACJtag"), details: Some("0: Disable 1: Enable"), lo: 10, hi: 11 });
        fields.insert("IB_IA_SDET_ENA", Field { brief: Some("Enable for IA signal detect circuit (IB_SDET_SEL = 0 required)"), details: Some("0: Disable 1: Enable"), lo: 9, hi: 10 });
        fields.insert("IB_IE_SDET_ENA", Field { brief: Some("Enable for IA signal detect circuit (IB_SDET_SEL = 1 required)"), details: Some("0: Disable 1: Enable"), lo: 8, hi: 9 });
        fields.insert("IB_LD_ENA", Field { brief: Some("Enable for level detect circuit"), details: Some("0: Disable 1: Enable"), lo: 7, hi: 8 });
        fields.insert("IB_RCML_ADJ", Field { brief: Some("Offset resistance adjustment for CML cells (two-complement)"), details: Some("1000: -8 1111: -1 0000: 0 0111: 7"), lo: 27, hi: 31 });
        fields.insert("IB_RIB_ADJ", Field { brief: Some("Offset resistance adjustment for termination (two-complement)"), details: Some("1000: -8 1111: -1 0000: 0 0111: 7"), lo: 17, hi: 21 });
        fields.insert("IB_RIB_SHIFT", Field { brief: Some("Shifts resistance adjustment value ib_rib_adj by +1"), details: None, lo: 21, hi: 22 });
        fields.insert("IB_SAM_ENA", Field { brief: Some("Enable SAMpling stage"), details: Some("0: Disable 1: Enable (mission mode)"), lo: 2, hi: 3 });
        fields.insert("IB_SIG_SEL", Field { brief: Some("Select input buffer input signal"), details: Some("0: normal operation 1: -6dB input 2: OB->IB data loop or test signal 3: RESERVED"), lo: 12, hi: 14 });
        fields.insert("IB_SPARE_POOL2", Field { brief: Some("Routed to analog macro but not used inside! Vscope clock source is selected via ib_sel_vclk."), details: None, lo: 4, hi: 5 });
        fields.insert("IB_TERM_VDD_ENA", Field { brief: Some("Enable common mode termination"), details: Some("0: no common mode termination (only AC-common mode termination) 1: termination to VDDI"), lo: 22, hi: 23 });
        fields.insert("IB_TERM_V_SEL", Field { brief: Some("Select termination voltage"), details: None, lo: 23, hi: 27 });
        fields.insert("IB_VBULK_SEL", Field { brief: Some("Controls Bulk Voltage of High Speed Cells"), details: Some("0: High 1: Low (mission mode)"), lo: 11, hi: 12 });
        fields.insert("IB_VSCOPE_ENA", Field { brief: Some("Enable VScope Path of Sampling-Stage"), details: Some("0: Disable 1: Enable"), lo: 3, hi: 4 });
        regs.insert("SD10G65_IB_CFG0", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("SD10G65 IB Configuration register 0"), details: Some("Configuration register 0 for SD10G65 IB. Note: Configuration bit-grp IB_CLKDIV_ENA was named IB_VSCOPE_CLK_ENA in an early revision of the input buffer."), fields });
        let mut fields = HashMap::new();
        fields.insert("IB_AGC_L", Field { brief: Some("Inductor peaking of EQ-Buffer3 (over all 5. stage)"), details: Some("0: no peaking 15: max. peaking max. peaking >3dB at 8GHz"), lo: 12, hi: 16 });
        fields.insert("IB_AMP_C", Field { brief: Some("C-gain peaking for IB-stage"), details: Some("0: no peaking 7: max. peaking corner frequency adjustment with ib_eqz_c_adj_ib"), lo: 9, hi: 12 });
        fields.insert("IB_AMP_L", Field { brief: Some("Inductor peaking of 1. stage Input buffer"), details: Some("0: no peaking 15: max. peaking max. peaking > 3db at 8GHz"), lo: 28, hi: 32 });
        fields.insert("IB_EQZ_C0", Field { brief: Some("C-gain peaking for EQ-stage0"), details: Some("0: no peaking 7: max. peaking corner frequency adjustment with ib_eqz_c_adj_es0"), lo: 6, hi: 9 });
        fields.insert("IB_EQZ_C1", Field { brief: Some("C-gain peaking for EQ-stage1"), details: Some("0: no peaking 7: max. peaking corner frequency adjustment with ib_eqz_c_adj_es1"), lo: 3, hi: 6 });
        fields.insert("IB_EQZ_C2", Field { brief: Some("C-gain peaking for EQ-stage2"), details: Some("0: no peaking 7: max. peaking corner frequency adjustment with ib_eqz_c_adj_es2"), lo: 0, hi: 3 });
        fields.insert("IB_EQZ_L0", Field { brief: Some("Inductor peaking of EQ-Buffer0 (over all 2. stage)"), details: Some("0: no peaking 15: max. peaking max. peaking > 3db at 8GHz"), lo: 24, hi: 28 });
        fields.insert("IB_EQZ_L1", Field { brief: Some("Inductor peaking of EQ-Buffer1 (over all 3. stage)"), details: Some("0: no peaking 15: max. peaking max. peaking > 3dB at 8GHz"), lo: 20, hi: 24 });
        fields.insert("IB_EQZ_L2", Field { brief: Some("Inductor peaking of EQ-Buffer2 (over all 4. stage)"), details: Some("0: no peaking 15: max. peaking max. peaking > 3dB at 8GHz"), lo: 16, hi: 20 });
        regs.insert("SD10G65_IB_CFG1", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("SD10G65 IB Configuration register 1"), details: Some("Configuration register 1 for SD10G65 IB."), fields });
        let mut fields = HashMap::new();
        fields.insert("IB_EQZ_LD0_NEDGE", Field { brief: Some("Result of Level-Detect0 (after IB-stage of EQZ) circuitry"), details: Some("1: Input level above threshold defined by IB_EQ_LD_LEV"), lo: 22, hi: 23 });
        fields.insert("IB_EQZ_LD0_PEDGE", Field { brief: Some("Result of Level-Detect0 (after IB-stage of EQZ) circuitry"), details: Some("1: Input level above threshold defined by IB_EQ_LD_LEV"), lo: 23, hi: 24 });
        fields.insert("IB_EQZ_LD1_NEDGE", Field { brief: Some("Result of Level-Detect1 (after ES2-stage of EQZ) circuitry"), details: Some("1: Input level above threshold defined by IB_EQ_LD_LEV"), lo: 24, hi: 25 });
        fields.insert("IB_EQZ_LD1_PEDGE", Field { brief: Some("Result of Level-Detect1 (after ES2-stage of EQZ) circuitry"), details: Some("1: Input level above threshold defined by IB_EQ_LD_LEV"), lo: 25, hi: 26 });
        fields.insert("IB_IA_DIRECT_DATA", Field { brief: Some("Direct Data output from IA block"), details: None, lo: 20, hi: 21 });
        fields.insert("IB_IA_DOFFS_CAL", Field { brief: Some("Data offset calibration result IA stage"), details: None, lo: 31, hi: 32 });
        fields.insert("IB_IA_SDET", Field { brief: Some("Result signal detect of IA stage"), details: None, lo: 26, hi: 27 });
        fields.insert("IB_IE_DIRECT_DATA", Field { brief: Some("Direct Data output from IE block"), details: None, lo: 21, hi: 22 });
        fields.insert("IB_IE_SDET", Field { brief: Some("Result signal detect of IE stage"), details: None, lo: 27, hi: 28 });
        fields.insert("IB_IE_SDET_NEDGE", Field { brief: Some("Detection of toggling signal at PADP and PADN"), details: None, lo: 28, hi: 29 });
        fields.insert("IB_IE_SDET_PEDGE", Field { brief: Some("Detection of toggling signal at PADP and PADN"), details: None, lo: 29, hi: 30 });
        fields.insert("IB_IS_DOFFS_CAL", Field { brief: Some("Data offset calibration result IS stage"), details: None, lo: 30, hi: 31 });
        fields.insert("IB_JTAG_CLK", Field { brief: Some("JTAG debug clk"), details: None, lo: 1, hi: 2 });
        fields.insert("IB_JTAG_ENA", Field { brief: Some("JTAG debug enable"), details: None, lo: 0, hi: 1 });
        fields.insert("IB_JTAG_IN_N", Field { brief: Some("JTAG debug n-input"), details: None, lo: 2, hi: 3 });
        fields.insert("IB_JTAG_IN_P", Field { brief: Some("JTAG debug p-input"), details: None, lo: 3, hi: 4 });
        fields.insert("IB_JTAG_OUT_N", Field { brief: Some("JTAG debug n-output"), details: None, lo: 9, hi: 10 });
        fields.insert("IB_JTAG_OUT_P", Field { brief: Some("JTAG debug p-output"), details: None, lo: 10, hi: 11 });
        fields.insert("IB_JTAG_THRES", Field { brief: Some("JTAG debug threshold"), details: Some("0: 0mV 1: 10mV 31: 310mV"), lo: 4, hi: 9 });
        fields.insert("IB_LOOP_DRV", Field { brief: Some("Drive enable for BiDi loop (a.k.a. Input loop o. RX->TX loop). Is or'ed with primary input: ib_inp_loop_ena_i. Is overruled by PAD loop."), details: None, lo: 16, hi: 17 });
        fields.insert("IB_LOOP_REC", Field { brief: Some("Receive enable for BiDi loop (a.k.a. PAD loop o. TX->RX loop). Is or'ed with primary input: ib_pad_loop_ena_i. Disable testgenerator 'ib_tstgen_ena' if input loop is used"), details: None, lo: 17, hi: 18 });
        regs.insert("SD10G65_IB_CFG10", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("SD10G65 IB Configuration register 10 JTAG related setting"), details: Some("Configuration register 10 for SD10G65 IB."), fields });
        let mut fields = HashMap::new();
        fields.insert("IB_DFE_ISEL", Field { brief: Some("DFE Bias current settings (bit-group is gated with IB_DFE_ENA)"), details: Some("0: DFE disabled 1: Minimum current 15: Maximum current"), lo: 12, hi: 16 });
        fields.insert("IB_ENA_400_INP", Field { brief: Some("Increase current in first stage (only available in 1.2 Volt mode)"), details: None, lo: 11, hi: 12 });
        fields.insert("IB_SPARE_POOL", Field { brief: Some("Reserved"), details: None, lo: 16, hi: 17 });
        fields.insert("IB_TC_DFE", Field { brief: Some("Gain temperature coefficient for DFE stage"), details: None, lo: 6, hi: 11 });
        fields.insert("IB_TC_EQ", Field { brief: Some("Gain temperature coefficient for AGC stage"), details: None, lo: 1, hi: 6 });
        regs.insert("SD10G65_IB_CFG11", Register { addr: Address { base: 11, count: 1, width: 1 }, brief: Some("SD10G65 IB Configuration register 11 JTAG related setting"), details: Some("Configuration register 11 for SD10G65 IB."), fields });
        let mut fields = HashMap::new();
        fields.insert("IB_EQZ_AGC", Field { brief: Some("Amplification (gain) of AGC in Input Buffer (normal operation)"), details: Some("after gain calibration 0: gain = 0.3 255: gain = 1.5 if disp/disn is active dac function for dfe gain calibration"), lo: 10, hi: 18 });
        fields.insert("IB_EQZ_GAIN", Field { brief: Some("Gain of Input Buffer"), details: Some("0-511 gain adjustment only in first stage > 511 gain in first stage at max. 512-639 gain in 2.stage increased from 1 to 2 > 639 gain = 2 640-767 gain in 3.stage increased from 1 to 2 >767 gain = 2 768-895 gain in 4.stage increased from 1 to 2 >895 gain at max."), lo: 18, hi: 28 });
        fields.insert("IB_EQZ_OFFSET", Field { brief: Some("Offset value for IB-stage of Input Buffer"), details: Some("512: neutral > 512: positive < 512: negative range +/- 600mV (low gain) to +/-30mV (high gain) gain dependent offset sensitivity requiered for Base line wander compensation not supported in test chip"), lo: 0, hi: 10 });
        regs.insert("SD10G65_IB_CFG2", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("SD10G65 IB Configuration register 2"), details: Some("Configuration register 2 for SD10G65 IB."), fields });
        let mut fields = HashMap::new();
        fields.insert("IB_DIRECT_SEL", Field { brief: Some("Selects source of direct data path to core"), details: Some("0: IE 1: IA"), lo: 23, hi: 24 });
        fields.insert("IB_EQ_LD0_LEVEL", Field { brief: Some("Level for Level-Detect circuitry 0."), details: Some("0: 20mV 1: 25mV ... 40: 220mV ... 63: 340mV"), lo: 11, hi: 17 });
        fields.insert("IB_EQ_LD1_OFFSET", Field { brief: Some("With APC enabled level offset (6bit-signed) compared to IB_EQ_LD0_LEVEL for Level-Detect circuitry 1. Saturating between 20mV and 340mV. See also note in register description."), details: Some("0: no offset 1: +5mV 31: +155mV 63(= -1): -5mV 32(= -32): -160mV."), lo: 17, hi: 23 });
        fields.insert("IB_IA_SDET_LEVEL", Field { brief: Some("Threshold value for IA Signal-Detect."), details: Some("0: 0mV ... 8: 80mV ... 31: 310mV"), lo: 0, hi: 5 });
        fields.insert("IB_IE_SDET_LEVEL", Field { brief: Some("Threshold value for IE Signal-Detect."), details: Some("0: 20mV 1: 25mV 2: 30mV ... 63: 340mV"), lo: 5, hi: 11 });
        fields.insert("IB_LDSD_DIVSEL", Field { brief: Some("Dividing factor for SDET and LD circuits of IE."), details: Some("0: 128 1: 32 2: 8 3: 4"), lo: 30, hi: 32 });
        fields.insert("IB_SDET_CLK_DIV", Field { brief: Some("Clock dividing factor for Signal Detect circuit of IA"), details: Some("0: 2 ... 7: 256"), lo: 27, hi: 30 });
        fields.insert("IB_SDET_SEL", Field { brief: Some("Selects source of signal detect (ib_X_sdet_ena must be enabled accordingly)"), details: Some("0: IA 1: IE"), lo: 24, hi: 25 });
        fields.insert("IB_SET_SDET", Field { brief: Some("Force Signal-Detect output to high level"), details: Some("0: Normal operation 1: Force sigdet high"), lo: 26, hi: 27 });
        regs.insert("SD10G65_IB_CFG3", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("SD10G65 IB Configuration register 3"), details: Some("Configuration register 1 for SD10G65 IB. Note: the behavior of IB_EQ_LD1_OFFSET changes when APC is disabled. In this case IB_EQ_LD1_OFFSET directly controls the level for Level-Detect circuitry 1. Coding: 0: 20mV, 1: 25mV, ... 63: 340mV."), fields });
        let mut fields = HashMap::new();
        fields.insert("IB_EQZ_C_ADJ_ES0", Field { brief: Some("corner frequency selection for c-gain peaking 4.stage"), details: Some("0: lowest corner frequency 3: highest corner frequency"), lo: 24, hi: 26 });
        fields.insert("IB_EQZ_C_ADJ_ES1", Field { brief: Some("corner frequency selection for c-gain peaking 3.stage"), details: Some("0: lowest corner frequency 3: highest corner frequency"), lo: 26, hi: 28 });
        fields.insert("IB_EQZ_C_ADJ_ES2", Field { brief: Some("corner frequency selection for c-gain peaking 2.stage"), details: Some("0: lowest corner frequency 3: highest corner frequency"), lo: 28, hi: 30 });
        fields.insert("IB_EQZ_C_ADJ_IB", Field { brief: Some("corner frequency selection for c-gain peaking 1.stage"), details: Some("0: lowest corner frequency 3: highest corner frequency"), lo: 30, hi: 32 });
        fields.insert("IB_EQZ_C_MODE", Field { brief: Some("Coder mode: APC C value to IE capacitance"), details: Some("0: equ. distributed 2: 1st buffer max - 2nd buffer max - ..."), lo: 18, hi: 21 });
        fields.insert("IB_EQZ_L_MODE", Field { brief: Some("Coder mode: APC L value to IE inductance"), details: Some("0: equ. distributed (double step 3->4) 1: equ. distributed (no change 6+7) 2: 1st buffer max - 2nd buffer max - ..."), lo: 21, hi: 24 });
        fields.insert("IB_MAIN_THRES", Field { brief: Some("Threshold value (offset) for main sampling path"), details: Some("0: -max 31: -0 32: +0 63: +max (depending on calibration)"), lo: 0, hi: 6 });
        fields.insert("IB_VSCOPE_H_THRES", Field { brief: Some("Threshold value (offset) for vscope-high sampling path"), details: Some("0: -max 31: -0 32: +0 63: +max (depending on calibration)"), lo: 12, hi: 18 });
        fields.insert("IB_VSCOPE_L_THRES", Field { brief: Some("Threshold value (offset) for vscope-low sampling path"), details: Some("0: -max 31: -0 32: +0 63: +max (depending on calibration)"), lo: 6, hi: 12 });
        regs.insert("SD10G65_IB_CFG4", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("SD10G65 IB Configuration register 4"), details: Some("Configuration register 4 for SD10G65 IB."), fields });
        let mut fields = HashMap::new();
        fields.insert("IB_AGC_DIS", Field { brief: Some("AGC output disable required to calibrate DFE-gain"), details: Some("0: mission mode 3: Vout = 0V 1: Vout= xx*ampldfe/64 2: Vout=-xx*ampldfe/64 ampldfe=270mV if ena1V = '1' (1V mode) ampldfe=360mV if ena1V = '0' (1.2V mode) xx="), lo: 17, hi: 19 });
        fields.insert("IB_CALMUX_ENA", Field { brief: Some("Enables IS MUX in detblk1"), details: None, lo: 10, hi: 11 });
        fields.insert("IB_DFE_DIS", Field { brief: Some("DFE output disable required to calibrate IS"), details: Some("0: mission mode 3: Vout = 0V 1: Vout= xx*ampldfe/64 2: Vout=-xx*ampldfe/64 ampldfe=196mV if ena1V = '1' (1V mode) ampldfe=260mV if ena1V = '0' (1.2V mode) xx= TBD"), lo: 19, hi: 21 });
        fields.insert("IB_EQ_LD_CAL_ENA", Field { brief: Some("Selects EQ Level Detect for calibration"), details: None, lo: 16, hi: 17 });
        fields.insert("IB_HYS_CAL_ENA", Field { brief: Some("Enable calibration in order to eliminate hysteresis"), details: Some("1: Enable 0: Disable"), lo: 11, hi: 12 });
        fields.insert("IB_IA_OFFS_CAL_ENA", Field { brief: Some("Selects IA offset circuit for calibration"), details: None, lo: 13, hi: 14 });
        fields.insert("IB_IE_SDET_CAL_ENA", Field { brief: Some("Selects IE Signal Detect for calibration"), details: None, lo: 12, hi: 13 });
        fields.insert("IB_IS_OFFS_CAL_ENA", Field { brief: Some("Selects IS offset circuit for calibration"), details: None, lo: 14, hi: 15 });
        fields.insert("IB_JUMPH_ENA", Field { brief: Some("Enable jump to opposite half of h-channel"), details: Some("0: Post main sampler 1: Pre main sampler"), lo: 22, hi: 23 });
        fields.insert("IB_JUMPL_ENA", Field { brief: Some("Enable jump to opposite half of l-channel"), details: Some("0: Post main sampler 1: Pre main sampler"), lo: 21, hi: 22 });
        fields.insert("IB_OFFS_BLKSEL", Field { brief: Some("Selects calibration target (sample stage threshold, sample stage offset, aux.-stage offset), dependend on calibration group, see encoding."), details: Some("When ib_thres_cal_ena = 1 0: MD0 threshold 1: MD1 threshold 2: CP0 threshold 3: CP1 threshold 4: VH0 threshold 5: VH1 threshold 6: VL0 threshold 7: VL1 threshold When ib_is_offs_cal_ena = 1 0: MD0 offset 1: MD1 offset 2: CP0 offset 3: CP1 offset 4: VH0 offset 5: VH1 offset 6: VL0 offset 7: VL1 offset When ib_ia_offs_cal_ena = 1 0: Observe0 offset 1: Observe1 offset 2: Observe0 threshold 3: Observe1 threshold (MSB not used)"), lo: 6, hi: 10 });
        fields.insert("IB_OFFS_VALUE", Field { brief: Some("Calibration value for IA/IS. Values for threshold calibration get inverted for negative threshold voltages (ib_vscope_h_thres, ib_vscope_l_thres or ib_main_thres)."), details: Some("For offset calibration 0: -max_offset * 32/32 31: -max_offset * 1/32 32: +max_offset * 1/32 63: +max_offset * 32/32 For threshold calibration 0: min_threshold 63: max_threshold"), lo: 0, hi: 6 });
        fields.insert("IB_THRES_CAL_ENA", Field { brief: Some("Selects IS threshold circuit for calibration"), details: None, lo: 15, hi: 16 });
        fields.insert("IB_TSTGEN_AMPL", Field { brief: Some("Test generator amplitude setting"), details: Some("0: 0mV ... 15: 150mV"), lo: 28, hi: 32 });
        fields.insert("IB_TSTGEN_DATA", Field { brief: Some("Test generator data"), details: Some("0: low 1: high"), lo: 26, hi: 27 });
        fields.insert("IB_TSTGEN_ENA", Field { brief: Some("Test generator enable but data path selected with 'ib_sig_sel' (disable input loop if testgenerator is used)"), details: Some("0: inactive 1: active"), lo: 27, hi: 28 });
        fields.insert("IB_TSTGEN_TOGGLE_ENA", Field { brief: Some("Test generator data toggle enable"), details: Some("0: inactive 1: active"), lo: 25, hi: 26 });
        regs.insert("SD10G65_IB_CFG5", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("SD10G65 IB Configuration register 5"), details: Some("Configuration register 5 for SD10G65 IB."), fields });
        let mut fields = HashMap::new();
        fields.insert("IB_AUTO_AGC_ADJ", Field { brief: Some("Enable automatic AGC adjustment"), details: Some("1: AGC is adjusted automatically (IB_EQZ_AGC_ADJ value is not used) 0: AGC is adjusted with value stored in IB_EQZ_AGC_ADJ"), lo: 12, hi: 13 });
        fields.insert("IB_EQZ_AGC_ADJ", Field { brief: Some("Gain adjustment of AGC-amplifier"), details: Some("Bitgroup should be set to 2*IB_DFE_GAIN_ADJ"), lo: 5, hi: 12 });
        fields.insert("IB_EQZ_GAIN_ADJ", Field { brief: Some("0dB Gain adjustment for EQZ-stages of Input Buffer"), details: Some("level at LD0 = LD1 -> 0dB level range 160mV-220mV"), lo: 16, hi: 23 });
        fields.insert("IB_SAM_OFFS_ADJ", Field { brief: Some("Range for offset calibration of all sampling pathes"), details: Some("0: 0mV 32: 80mV"), lo: 0, hi: 5 });
        regs.insert("SD10G65_IB_CFG6", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("SD10G65 IB Configuration register 6"), details: Some("Configuration register 6 for SD10G65 IB."), fields });
        let mut fields = HashMap::new();
        fields.insert("IB_DFE_GAIN_ADJ", Field { brief: Some("Gain adjustment of DFEamplifier"), details: Some("DFE Gain 1 Volt mode = 0dB 1.2 Volt mode 1dB measurement with int. DAC and Vscope Channels"), lo: 16, hi: 22 });
        fields.insert("IB_DFE_GAIN_ADJ_S", Field { brief: Some("Select configuration of DFEamplifier gain adjustment"), details: Some("0: Normal operation (APC can take over control) 1: Enforce configuration via IB_DFE_GAIN_ADJ"), lo: 15, hi: 16 });
        fields.insert("IB_DFE_OFFSET_H", Field { brief: Some("Higher threshold offset of DFE buffer for IS calibration"), details: Some("0: 0mv 63: 200mV"), lo: 6, hi: 12 });
        fields.insert("IB_DFE_OFFSET_H_L", Field { brief: Some("Selects higher or lower DFE offset for IS calibration"), details: Some("0: ib_dfe_offset_l 1: ib_dfe_offset_h"), lo: 22, hi: 23 });
        fields.insert("IB_DFE_OFFSET_L", Field { brief: Some("Lower sample offset of DFE buffer for IS calibration"), details: Some("0: 0mv 63: 200mV"), lo: 0, hi: 6 });
        fields.insert("IB_MAIN_THRES_CAL", Field { brief: Some("Initial value for calibration of main sampling path"), details: None, lo: 23, hi: 29 });
        regs.insert("SD10G65_IB_CFG7", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("SD10G65 IB Configuration register 7"), details: Some("Configuration register 7 for SD10G65 IB."), fields });
        let mut fields = HashMap::new();
        fields.insert("IB_AOUT_ENA", Field { brief: Some("Enable analog output decoder in IE"), details: Some("1: Enable 0: Disable"), lo: 30, hi: 31 });
        fields.insert("IB_AOUT_MUX", Field { brief: Some("not used"), details: None, lo: 31, hi: 32 });
        fields.insert("IB_AOUT_POOL", Field { brief: Some("Select analog signal routed to analog test output from either IB sampling stage or equalizer. See also SD10G65_IB_CFG8.IB_AOUT_ENA and SD10G65_SBUS_RX_CFG.SBUS_ANAOUT_SEL."), details: Some("Encoding for sampling stage: 0: VCMT 1: VCMR 2: CMLCI 3: RESIDL 4: RESCML 5: CMLSU 6: CMLBI 7: CMLRA 8: VCN 9: VCP 10: DIFSRC 11: VREGN 12: VREGP 13: TSTSRC 14: TSTDRN 15: TSTRES 16: CMLBF1P 17: CMLBF1N 18: CMLBF2P 19: CMLBF2P 20: CMLBF3P 21: CMLBF3P 22: CMLBF4P 23: CMLBF4P 24 to 31: same coding as for 16 to 23 Encoding for equalizer: 0: n.a. 1: vddi_int 2: eq1_vreg 3: eq2_vreg 4: eq3_vreg 5: agc_vreg 6: dfe_vreg 7: dfe_p 8: n.a. 9: ib_cmv 10: eq1_cmv 11: eq2_cmv 12: eq3_cmv 13: agc_cmv 14: dfe_cmv 15: dfe_n"), lo: 25, hi: 30 });
        fields.insert("IB_BIAS_ADJ", Field { brief: Some("Gain of cml stages inside IS"), details: Some("0: 3dB 31: 6dB 63: 9dB"), lo: 4, hi: 10 });
        fields.insert("IB_BIAS_MODE", Field { brief: Some("Bias regulation mode"), details: Some("0: constant resistor 1: constant current"), lo: 19, hi: 20 });
        fields.insert("IB_CML_AMPL", Field { brief: Some("Amplitude of cml stages inside IS"), details: Some("0: 200mVppd 7: 240mVppd"), lo: 10, hi: 13 });
        fields.insert("IB_CML_CURR", Field { brief: Some("Current through CML Cells"), details: Some("0: 150% 5: 100% 15: 50%"), lo: 0, hi: 4 });
        fields.insert("IB_EQ_CURR", Field { brief: Some("EQZ current control"), details: Some("0: mission mode 1: 1.5% current increase"), lo: 21, hi: 22 });
        fields.insert("IB_INV_IA_CAL_VAL", Field { brief: Some("Invert calibration value coming from the calibration FSM for IA calibration."), details: None, lo: 15, hi: 16 });
        fields.insert("IB_INV_IA_DOFS", Field { brief: Some("Invert observe signal from auxilary stage that goes to calibration FSM"), details: None, lo: 17, hi: 18 });
        fields.insert("IB_INV_IS_DOFS", Field { brief: Some("Invert observe signal from sample stage that goes to calibration FSM"), details: None, lo: 16, hi: 17 });
        fields.insert("IB_INV_OFFS_CAL_VAL", Field { brief: Some("Invert calibration value coming from the calibration FSM for IS offset calibration."), details: None, lo: 13, hi: 14 });
        fields.insert("IB_INV_THR_CAL_VAL", Field { brief: Some("Invert calibration value coming from the calibration FSM for IS threshold calibration."), details: None, lo: 14, hi: 15 });
        fields.insert("IB_LAT_NEUTRAL", Field { brief: Some("Enables neutral setting of latches"), details: Some("1: Reset to mid values 0: Normal operation"), lo: 18, hi: 19 });
        fields.insert("IB_SEL_VCLK", Field { brief: Some("Use separate vscope clock for vscope-channels"), details: None, lo: 20, hi: 21 });
        regs.insert("SD10G65_IB_CFG8", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("SD10G65 IB Configuration register 8"), details: Some("Configuration register 8 for SD10G65 IB."), fields });
        let mut fields = HashMap::new();
        fields.insert("IB_DFE_COEF1", Field { brief: Some("Weighting for first DFE coefficient"), details: None, lo: 0, hi: 7 });
        fields.insert("IB_DFE_COEF2", Field { brief: Some("Weighting for second DFE coefficient"), details: None, lo: 8, hi: 14 });
        fields.insert("IB_DFE_COEF3", Field { brief: Some("Weighting for third DFE coefficient"), details: None, lo: 16, hi: 21 });
        fields.insert("IB_DFE_COEF4", Field { brief: Some("Weighting for fourth DFE coefficient"), details: None, lo: 24, hi: 29 });
        regs.insert("SD10G65_IB_CFG9", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("SD10G65 IB Configuration register 9  automatically adapted DFE coefficients"), details: Some("Configuration register 9 for SD10G65 IB."), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_SVN_ID", Field { brief: Some("SVN revision number of RTL sources"), details: None, lo: 0, hi: 32 });
        regs.insert("SD10G65_RX_SVN_ID", Register { addr: Address { base: 13, count: 1, width: 1 }, brief: Some("SD10G65_RX subversion revision number"), details: Some("Subversion revision number for the RTL used in SD10G65_RX"), fields });
        let mut fields = HashMap::new();
        fields.insert("SBUS_ANAOUT_EN", Field { brief: Some("Enable analog test output multiplexer"), details: None, lo: 7, hi: 8 });
        fields.insert("SBUS_ANAOUT_SEL", Field { brief: Some("Analog test output"), details: Some("0: l0_ctrlspeed[0] 1: vbulk 2: nref 3: vref820m 4: vddfilt 5: vddfilt 6: ie_aout 7: ib_aout 8: ob_aout2 9: pll_frange 10: pll_srange 11: pll_vreg820m_tx 12: pll_vreg820m_rx 13: ob_aout_n 14: ob_aout_p 15: vddfilt"), lo: 8, hi: 12 });
        fields.insert("SBUS_BIAS_EN", Field { brief: Some("Bias enable"), details: Some("1: Enable 0: Disable"), lo: 0, hi: 1 });
        fields.insert("SBUS_BIAS_SPEED_SEL", Field { brief: Some("Bias speed selection"), details: Some("0: Below 4Gbps 1: 4Gbps to 6Gbps 2: 6Gbps to 9Gbps 3: Above 9Gbps"), lo: 1, hi: 3 });
        fields.insert("SBUS_LOOPDRV_ENA", Field { brief: Some("Enable BiDi loop driver for F2DF testing"), details: None, lo: 12, hi: 13 });
        fields.insert("SBUS_RCOMP", Field { brief: Some("Offset value for BIAS resistor calibration (2-complement)"), details: Some("1000: -8 1111: -1 0000: 0 0111: 7"), lo: 3, hi: 7 });
        fields.insert("SBUS_SPARE_POOL", Field { brief: Some("Pool of spare bits for use in late design changes."), details: None, lo: 16, hi: 20 });
        regs.insert("SD10G65_SBUS_RX_CFG", Register { addr: Address { base: 12, count: 1, width: 1 }, brief: Some("SD10G65 SBUS RX CFG Service-Bus related setting"), details: Some("Configuration register for Service-Bus related setting. Note: SBUS configuration applies for RX/TX aggregates only, any configuration applied to SBUS_TX_CFG (output buffer cfg space) will be ignored."), fields });
        let mut fields = HashMap::new();
        fields.insert("OB_REV_ID", Field { brief: Some("Feature set number of output buffer (ob10g_N)"), details: None, lo: 20, hi: 26 });
        fields.insert("RCPLL_REV_ID", Field { brief: Some("Feature set number of RC-PLL (pll10g_N)"), details: None, lo: 8, hi: 14 });
        fields.insert("SYNTH_REV_ID", Field { brief: Some("Feature set number of synthesizer (syn_N)"), details: None, lo: 14, hi: 20 });
        fields.insert("TOP_REV_ID", Field { brief: Some("Feature set number of Toplevel (sd10g65_N)"), details: None, lo: 0, hi: 8 });
        regs.insert("SD10G65_TX_REV_ID", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("SD10G65_TX Revision ID"), details: Some("Revision numbers of the analog sub IPs used in the SD10G65_TX"), fields });
        groups.insert("SD10G65_IB", RegisterGroup { addr: Address { base: 32, count: 1, width: 15 }, desc: "SD10G65 IB Configuration and Status Register set", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("MOEBDIV_BW_CDR_SEL_A", Field { brief: Some("Bandwidth selection for cp/md of cdr loop when core NOT flags valid data detected"), details: None, lo: 9, hi: 12 });
        fields.insert("MOEBDIV_BW_CDR_SEL_B", Field { brief: Some("Bandwidth selection for cp/md of cdr loop when core flags valid data detected"), details: None, lo: 6, hi: 9 });
        fields.insert("MOEBDIV_BW_CORE_SEL", Field { brief: Some("Bandwidth selection for cp/md signals towards core"), details: None, lo: 3, hi: 6 });
        fields.insert("MOEBDIV_CPMD_SWAP", Field { brief: Some("CP/MD swapping"), details: None, lo: 2, hi: 3 });
        fields.insert("MOEBDIV_DIS", Field { brief: Some("Divider disable"), details: None, lo: 0, hi: 1 });
        fields.insert("MOEBDIV_DIV32_ENA", Field { brief: Some("MD divider enable"), details: None, lo: 1, hi: 2 });
        regs.insert("SD10G65_MOEBDIV_CFG0", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("SD10G65 MOEBDIV Configuration register 0"), details: Some("Configuration register 0 for SD10G65 MoebiusDivider"), fields });
        let mut fields = HashMap::new();
        fields.insert("BYP_D", Field { brief: Some("Bypass data path (e.g. for JTAG), allows to drive output when EN_DIRECT=1 and EN_OB=1"), details: None, lo: 18, hi: 19 });
        fields.insert("CLK_BUF_CMV", Field { brief: Some("Control of common mode voltage of clock buffer between synthesizer and OB."), details: None, lo: 21, hi: 23 });
        fields.insert("EN_DIRECT", Field { brief: Some("Enable direct path"), details: None, lo: 14, hi: 15 });
        fields.insert("EN_INP_LOOP", Field { brief: Some("Enable input loop"), details: None, lo: 15, hi: 16 });
        fields.insert("EN_OB", Field { brief: Some("Enable output buffer and serializer"), details: None, lo: 13, hi: 14 });
        fields.insert("EN_PAD_LOOP", Field { brief: Some("Enable pad loop"), details: None, lo: 16, hi: 17 });
        fields.insert("INCR_LEVN", Field { brief: Some("Selects amplitude range controled via levn. See description of levn."), details: None, lo: 8, hi: 9 });
        fields.insert("LEVN", Field { brief: Some("Amplitude control value. Step size is 25 mVpp, decreasing amplitude with increasing control value. Range depends on incr_levn. Coding for incr_levn=0: 31: 500mVpp, 30: 525mVpp, 29: 550mVpp, ..., 0: 1275mVpp. Coding for incr_levn=1: 31: 300mVpp, 30: 325mVpp, 29: 350mVpp, .., 0: 1075mVpp. (Note: maximum achievable amplitude depends on the supply voltage)"), details: None, lo: 0, hi: 5 });
        fields.insert("OB_SPARE_POOL", Field { brief: Some("Pool of spare bits for use in late design changes."), details: None, lo: 19, hi: 21 });
        fields.insert("RST", Field { brief: Some("Set digital part into pseudo reset"), details: None, lo: 17, hi: 18 });
        fields.insert("SEL_IFW", Field { brief: Some("Interface width"), details: Some("0: 8 1: 10 2: 16 3: 20 4: 32 5: 40 6-7: Reserved"), lo: 5, hi: 8 });
        fields.insert("SER_INV", Field { brief: Some("Invert input to serializer"), details: None, lo: 23, hi: 24 });
        regs.insert("SD10G65_OB_CFG0", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("SD10G65 OB Configuration register 0"), details: Some("Configuration register 0 for SD10G65 OB."), fields });
        let mut fields = HashMap::new();
        fields.insert("AB_COMP_EN", Field { brief: Some("Enable amplitude compensation of AB bleed current"), details: None, lo: 26, hi: 27 });
        fields.insert("DIODE_CUR", Field { brief: Some("Bleed current for class AB operation of driver"), details: Some("0: 1% 1: 0.5% 2: 2% 3: reserved"), lo: 23, hi: 26 });
        fields.insert("LEV_SHFT", Field { brief: Some("Level shift ctrl of class AB bias generator"), details: Some("0: 50mV 1: 100mV 2:150mV 3: 200mV"), lo: 21, hi: 23 });
        fields.insert("PREDRV_C_CTRL", Field { brief: Some("Slew rate ctrl of OB (C)"), details: Some("C=3 R=3: 25ps C=3 R=0: 35ps C=0 R=3: 55ps C=1 R=0: 70ps C=0 R=0: 120 ps"), lo: 16, hi: 18 });
        fields.insert("PREDRV_R_CTRL", Field { brief: Some("Slew rate ctrl of OB (R), encoding see PREDRV_C_CTRL"), details: None, lo: 18, hi: 20 });
        fields.insert("R_COR", Field { brief: Some("Additional resistor calibration trim"), details: None, lo: 4, hi: 5 });
        fields.insert("R_I", Field { brief: Some("Offset resistance adjustment for CML cells (two-complement)"), details: Some("1000: -8 1111: -1 0000: 0 0111: 7"), lo: 0, hi: 4 });
        fields.insert("VCAS", Field { brief: Some("Ctrl of cascade volt in drv stage"), details: Some("0: reserved 1: 0 2: 1/12 4: 2/12 8: 3/12 16: 4/12 Intermediate values possible when setting two bits"), lo: 5, hi: 10 });
        fields.insert("VTAIL", Field { brief: Some("Tail voltage driver settings"), details: Some("0: reserved 1: 75mV 2: 100mV 4: 125mV 8: 150mV 16: 175mV 32: 200mV Intermediate values possible when setting two bits"), lo: 10, hi: 16 });
        regs.insert("SD10G65_OB_CFG1", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("SD10G65 OB Configuration register 1"), details: Some("Configuration register 1 for SD10G65 OB."), fields });
        let mut fields = HashMap::new();
        fields.insert("D_FILTER", Field { brief: Some("Transmit filter coefficients for FIR taps. Suggested start value (no emphasis, max amplitude)"), details: Some("0x820820: for I/F width 8/10 bits 0x7DF820: for I/F width 16/20/32/40 bits"), lo: 0, hi: 24 });
        regs.insert("SD10G65_OB_CFG2", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("SD10G65 OB Configuration register 2"), details: Some("Configuration register 2 for SD10G65 OB. D_filter contains four 6-bit precalculated DA input values. Please note the differences in programming for various interface (IF) bit widths. For calculation details see documentation of OB10G."), fields });
        let mut fields = HashMap::new();
        fields.insert("REC_DET_DONE", Field { brief: Some("Indicates a completed receiver detect measurement. Should be one few us after rec_det_start is set."), details: None, lo: 18, hi: 19 });
        fields.insert("REC_DET_ENABLE", Field { brief: Some("Enable reciver detect function. MUST be disabled for normal operation !!!"), details: None, lo: 16, hi: 17 });
        fields.insert("REC_DET_START", Field { brief: Some("Rising edge starts receiver detect measurement. Has to be keept set until rec_det_value has been read."), details: None, lo: 17, hi: 18 });
        fields.insert("REC_DET_THRS", Field { brief: Some("Reciver detect threshold (suggested start value: 2)"), details: Some("0: reserved 1: 0mV 2: 8.3mV 4: 16.7mV 8: 25mV Intermediate values possible when setting two bits"), lo: 12, hi: 16 });
        fields.insert("REC_DET_VALUE", Field { brief: Some("Holds the time between the start and the flag of the receiver detect measuremnet. Time [ns +/- 4 ns] = 8 * value - 12"), details: None, lo: 0, hi: 12 });
        regs.insert("SD10G65_OB_CFG3", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("SD10G65 OB Configuration register 3  access to receiver detect functionality"), details: Some("Configuration register 3 for SD10G65 OB."), fields });
        let mut fields = HashMap::new();
        fields.insert("SBUS_ANAOUT_EN", Field { brief: Some("Enable analog test output"), details: None, lo: 7, hi: 8 });
        fields.insert("SBUS_ANAOUT_SEL", Field { brief: Some("Analog test output"), details: Some("0: l0_ctrlspeed[0] 1: vbulk 2: nref 3: vref820m 4: vddfilt 5: vddfilt 6: ie_aout 7: ib_aout 8: ob_aout2 9: pll_frange 10: pll_srange 11: pll_vreg820m_tx 12: pll_vreg820m_rx 13: ob_aout_n 14: ob_aout_p 15: vddfilt"), lo: 8, hi: 12 });
        fields.insert("SBUS_BIAS_EN", Field { brief: Some("Bias enable"), details: Some("1: Enable 0: Disable"), lo: 0, hi: 1 });
        fields.insert("SBUS_BIAS_SPEED_SEL", Field { brief: Some("Bias speed selection"), details: Some("0: Below 4Gbps 1: 4Gbps to 6Gbps 2: 6Gbps to 9Gbps 3: Above 9Gbps"), lo: 1, hi: 3 });
        fields.insert("SBUS_LOOPDRV_ENA", Field { brief: Some("Enable BiDi loop driver for F2DF testing"), details: None, lo: 12, hi: 13 });
        fields.insert("SBUS_RCOMP", Field { brief: Some("Offset value for BIAS resistor calibration (2-complement)"), details: Some("1000: -8 1111: -1 0000: 0 0111: 7"), lo: 3, hi: 7 });
        fields.insert("SBUS_SPARE_POOL", Field { brief: Some("Pool of spare bits for use in late design changes."), details: None, lo: 16, hi: 20 });
        regs.insert("SD10G65_SBUS_TX_CFG", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("SD10G65 SBUS TX CFG Service-Bus related setting"), details: Some("Configuration register for Service-Bus related setting. Note: this register is only used for configuration if Tx is used stand alone, otherwise SD10G65_SBUS_RX_CFG (Rx macro) is used for configuration!"), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_SVN_ID", Field { brief: Some("SVN revision number of RTL sources"), details: None, lo: 0, hi: 32 });
        regs.insert("SD10G65_TX_SVN_ID", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("SD10G65_TX subversion revision number"), details: Some("Subversion revision number for the RTL used in SD10G65_TX"), fields });
        groups.insert("SD10G65_OB", RegisterGroup { addr: Address { base: 16, count: 1, width: 7 }, desc: "SD10G65 OB Configuration and Status Register set", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("PLLF_ENA", Field { brief: Some("Enable RCPLL FSM"), details: None, lo: 0, hi: 1 });
        fields.insert("PLLF_FBDIV_PRE", Field { brief: Some("Enable predivider for feedback clock to allow for faster clocks,"), details: Some("0: disable 1: enable"), lo: 14, hi: 15 });
        fields.insert("PLLF_LOOP_CTRL_ENA", Field { brief: Some("Enable PLL loop ctrl by pllf_loop_ena,"), details: Some("0: enable loop ctrl by FSM 1: enable loop ctrl by pllf_loop_ena"), lo: 11, hi: 12 });
        fields.insert("PLLF_LOOP_ENA", Field { brief: Some("Enable closed loop, selected with pllf_loop_ctrl_ena=1"), details: None, lo: 10, hi: 11 });
        fields.insert("PLLF_OOR_RECAL_ENA", Field { brief: Some("Enable VCO control signal out of range recalibration"), details: None, lo: 6, hi: 7 });
        fields.insert("PLLF_RAMP_MODE_SEL", Field { brief: Some("Sets the ramp characteristic of the FSM, higher values give faster ramp up but less accuracy,"), details: Some("0: normal (default) ramping 1: faster ramping 2: fastest ramping 3: slow ramping uses all possible values of r_ctrl"), lo: 7, hi: 10 });
        fields.insert("PLLF_REF_CNT_SEL", Field { brief: Some("Select output on pllf_ref_cnt_stat,"), details: Some("0: ref_cnt 1: pll_cnt_diff 2: syn_cnt 3: pll_cnt"), lo: 12, hi: 14 });
        fields.insert("PLLF_RST_FRQDET_ENA", Field { brief: Some("Enable restart of FSM from frequency deviation/unlock condition"), details: None, lo: 5, hi: 6 });
        fields.insert("PLLF_RST_OVERRUN_ENA", Field { brief: Some("Enable restart of FSM from overrun"), details: None, lo: 4, hi: 5 });
        fields.insert("PLLF_START_CNT", Field { brief: Some("Preload value of the ramp up counter, reduces ramp up time for higher frequencies"), details: None, lo: 16, hi: 26 });
        fields.insert("PLLF_SYN_CLK_ENA", Field { brief: Some("Enable feedback clock usage instead of DES/SER par. clock,"), details: Some("0: disable 1: enable"), lo: 15, hi: 16 });
        fields.insert("PLLF_VCO_FAST_ENA", Field { brief: Some("Enable vco load by pllf_vco_fast,"), details: Some("0: enable vco fast by FSM 1: enable vco load by pllf_vco_fast"), lo: 2, hi: 3 });
        fields.insert("PLLF_VCO_LOAD_ENA", Field { brief: Some("Enable vco load by pllf_vco_load,"), details: Some("0: enable vco load by FSM 1: enable vco load by pllf_vco_load"), lo: 3, hi: 4 });
        fields.insert("PLLF_VCO_SLOW_ENA", Field { brief: Some("Enable vco load by pllf_vco_slow,"), details: Some("0: enable vco slow by FSM 1: enable vco load by pllf_vco_slow"), lo: 1, hi: 2 });
        regs.insert("SD10G65_RX_RCPLL_CFG0", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("SD10G65 RX RCPLL Configuration register 0"), details: Some("Configuration register 0 for SD10G65 RX RCPLL."), fields });
        let mut fields = HashMap::new();
        fields.insert("PLLF_BIST_ENA", Field { brief: Some("enable special BIST settings"), details: None, lo: 14, hi: 15 });
        fields.insert("PLLF_REF_CNT_END", Field { brief: Some("Target value: 1/vco_frq * par.bit.width * 512 * ref_clk_frq"), details: None, lo: 16, hi: 32 });
        fields.insert("PLLF_VCO_FAST", Field { brief: Some("Select vco static frequency by feedforward (higher freq.),"), details: Some("0: min. freq 3: max. freq."), lo: 2, hi: 4 });
        fields.insert("PLLF_VCO_LOAD", Field { brief: Some("Select vco static frequency by load,"), details: Some("0: VCO off"), lo: 4, hi: 14 });
        fields.insert("PLLF_VCO_SLOW", Field { brief: Some("Select vco static frequency by feedback (lower freq.),"), details: Some("0: max. freq 3: min. freq."), lo: 0, hi: 2 });
        regs.insert("SD10G65_RX_RCPLL_CFG1", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("SD10G65 RX RCPLL Configuration register 1"), details: Some("Configuration register 1 for SD10G65 RX RCPLL."), fields });
        let mut fields = HashMap::new();
        fields.insert("PLL_CAL_ENA", Field { brief: Some("Not used"), details: None, lo: 1, hi: 2 });
        fields.insert("PLL_ENA", Field { brief: Some("Enable analog RCPLL part"), details: None, lo: 0, hi: 1 });
        fields.insert("PLL_FBSEL820", Field { brief: Some("Select VCO regulated supply (820mV),"), details: Some("0: 820mv 4: 860mV 6: 950mV 7: short to VDDA all others reserved"), lo: 24, hi: 27 });
        fields.insert("PLL_LPF_CUR", Field { brief: Some("Select chargepump current,"), details: Some("0: 50uA 1: 100uA 2: 150uA 3: 200uA"), lo: 11, hi: 13 });
        fields.insert("PLL_LPF_RES", Field { brief: Some("Select loop filter resistor value,"), details: Some("0: not allowed 1: 2400 2: 1600 3: 960 4: 1200 5: 800 6: 685 7: 533 8: 800 9: 600 10: 533 11: 436 12: 480 13: 400 14: 369 15: 320"), lo: 7, hi: 11 });
        fields.insert("PLL_SHORT_BULKHN_ENA", Field { brief: Some("Debug, short N bulk voltage of OpAmps,"), details: Some("0: N bulk unequal 0 1: short to VSSA"), lo: 15, hi: 16 });
        fields.insert("PLL_SHORT_BULKHP_ENA", Field { brief: Some("Debug, short P bulk voltage of OpAmps,"), details: Some("0: P bulk unequal supply 1: short to supply"), lo: 16, hi: 17 });
        fields.insert("PLL_SHORT_BULKN_ENA", Field { brief: Some("Debug, short N bulk voltage of VCO,"), details: Some("0: N bulk unequal 0 1: short to VSSA"), lo: 13, hi: 14 });
        fields.insert("PLL_SHORT_BULKP_ENA", Field { brief: Some("Debug, short P bulk voltage of VCO,"), details: Some("0: P bulk unequal supply 1: short to supply"), lo: 14, hi: 15 });
        fields.insert("PLL_VCO_CUR", Field { brief: Some("Select vco current,"), details: Some("0: lowest current 31: highest current"), lo: 2, hi: 7 });
        fields.insert("PLL_VREG18", Field { brief: Some("Select VCO load switch gate voltage,"), details: Some("0: 1.4V 1: 1.5V 2: 1.6V 3: 1.7V 15: max."), lo: 20, hi: 24 });
        regs.insert("SD10G65_RX_RCPLL_CFG2", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("SD10G65 RX RCPLL Configuration register 2"), details: Some("Configuration register 2 for SD10G65 RX RCPLL."), fields });
        let mut fields = HashMap::new();
        fields.insert("PLLF_LOCK_STAT", Field { brief: Some("PLL lock status,"), details: Some("0: not locked 1: locked"), lo: 31, hi: 32 });
        fields.insert("PLLF_VCO_FAST_STAT", Field { brief: Some("Actual value of VCO fast portion, set by FSM"), details: None, lo: 2, hi: 4 });
        fields.insert("PLLF_VCO_LOAD_STAT", Field { brief: Some("Actual value of VCO load, set by FSM"), details: None, lo: 4, hi: 14 });
        fields.insert("PLLF_VCO_SLOW_STAT", Field { brief: Some("Actual value of VCO slow portion, set by FSM"), details: None, lo: 0, hi: 2 });
        fields.insert("PLL_RANGE_LIMIT", Field { brief: Some("Out of range status bit,"), details: Some("0: within range 1: out of range"), lo: 16, hi: 17 });
        fields.insert("PLL_RANGE_LIMIT_STY", Field { brief: Some("Out of range status bit, sticky bit,"), details: Some("0: within range 1: out of range"), lo: 17, hi: 18 });
        regs.insert("SD10G65_RX_RCPLL_STAT0", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("SD10G65 RX RCPLL Status register 0"), details: Some("Status register 0 for SD10G65 RX RCPLL."), fields });
        let mut fields = HashMap::new();
        fields.insert("DES_REV_ID", Field { brief: Some("Feature set number of deserializer (des10g_N)"), details: None, lo: 26, hi: 32 });
        fields.insert("IB_REV_ID", Field { brief: Some("Feature set number of input buffer (ib10g_N)"), details: None, lo: 20, hi: 26 });
        fields.insert("RCPLL_REV_ID", Field { brief: Some("Feature set number of RC-PLL (pll10g_N)"), details: None, lo: 8, hi: 14 });
        fields.insert("SYNTH_REV_ID", Field { brief: Some("Feature set number of synthesizer (syn_N)"), details: None, lo: 14, hi: 20 });
        fields.insert("TOP_REV_ID", Field { brief: Some("Feature set number of Toplevel (sd10g65_N)"), details: None, lo: 0, hi: 8 });
        regs.insert("SD10G65_RX_REV_ID", Register { addr: Address { base: 14, count: 1, width: 1 }, brief: Some("SD10G65_RX Revision ID"), details: Some("Revision numbers of the analog sub IPs used in the SD10G65_RX"), fields });
        groups.insert("SD10G65_RX_RCPLL", RegisterGroup { addr: Address { base: 48, count: 1, width: 5 }, desc: "SD10G65 RX RCPLL Configuration and Status Register set", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("PLLF_FSM_CNT_STAT", Field { brief: Some("Actual value of step up counter"), details: None, lo: 4, hi: 15 });
        fields.insert("PLLF_FSM_STAT", Field { brief: Some("Actual value of the FSM stage,"), details: Some("0: reset state 1: init state after reset 3: ramp up state checks for the counters and ramps up the frequency 6: additional wait state for internal BIAS settling 8: additional wait state 1 9: additional wait state 2 10; additional wait state 3 11: additional wait state 4 12: 1st locking state enables dynamic locking 13: final locking state checks for out of lock and overrun condition 14: error state low frequency 15: error state high frequency"), lo: 0, hi: 4 });
        fields.insert("PLLF_REF_CNT_STAT", Field { brief: Some("Internal FSM values selected by pllf_ref_cnt_sel"), details: None, lo: 16, hi: 32 });
        regs.insert("SD10G65_RX_RCPLL_STAT1", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("SD10G65 RX RCPLL Status register 1"), details: Some("Status register 1 for SD10G65 RX RCPLL."), fields });
        let mut fields = HashMap::new();
        fields.insert("SYNTH_INTEG1_FSEL", Field { brief: Some("frequency select of integrator 1"), details: None, lo: 6, hi: 11 });
        fields.insert("SYNTH_INTEG1_LIM", Field { brief: Some("limit of integrator 1"), details: None, lo: 11, hi: 16 });
        fields.insert("SYNTH_INTEG1_MAX0", Field { brief: Some("max value of integrator 1 during init phase"), details: None, lo: 16, hi: 21 });
        fields.insert("SYNTH_INTEG1_MAX1", Field { brief: Some("max value of integrator 1 during normal operation"), details: None, lo: 21, hi: 26 });
        fields.insert("SYNTH_INTEG2_FSEL", Field { brief: Some("frequency select of integrator 2"), details: None, lo: 0, hi: 6 });
        regs.insert("SD10G65_RX_SYNTH_CDRLF", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("SD10G65 RX Synthesizer Register CDR loopfilter control"), details: Some("Register for CDR loopfilter control for SD10G65 RX SYNTH."), fields });
        let mut fields = HashMap::new();
        fields.insert("SYNTH_CONV_ENA", Field { brief: Some("enables CML2CMOS converter (low speed part of synthesizer)"), details: None, lo: 1, hi: 2 });
        fields.insert("SYNTH_ENA", Field { brief: Some("synthesizer enable"), details: None, lo: 0, hi: 1 });
        fields.insert("SYNTH_FBDIV_SEL", Field { brief: Some("selects feedback divider setting."), details: Some("0: divide by 1 1: divide by 2 2: divide by 4 3: reserved"), lo: 16, hi: 18 });
        fields.insert("SYNTH_FB_DIR", Field { brief: Some("inverts direction of sync out part"), details: None, lo: 13, hi: 14 });
        fields.insert("SYNTH_FB_STEP", Field { brief: Some("selects step width for sync output"), details: None, lo: 14, hi: 16 });
        fields.insert("SYNTH_HRATE_ENA", Field { brief: Some("enables half rate mode"), details: None, lo: 3, hi: 4 });
        fields.insert("SYNTH_I1_DIR", Field { brief: Some("inverts direction of integral1 part"), details: None, lo: 7, hi: 8 });
        fields.insert("SYNTH_I1_STEP", Field { brief: Some("selects step width for integrator1"), details: None, lo: 8, hi: 9 });
        fields.insert("SYNTH_I2_DIR", Field { brief: Some("inverts direction of integral2 part"), details: None, lo: 10, hi: 11 });
        fields.insert("SYNTH_I2_ENA", Field { brief: Some("enable contribution of integral2 part"), details: None, lo: 9, hi: 10 });
        fields.insert("SYNTH_I2_STEP", Field { brief: Some("selects step width for integrator2"), details: None, lo: 11, hi: 13 });
        fields.insert("SYNTH_OFF_COMP_ENA", Field { brief: Some("Enable for different offset compensation stages"), details: Some("bit 0: Synthesizer main rotator bit 1: Feedback buffer bit 2: CDR rotator bit 3: VCO buffer"), lo: 18, hi: 22 });
        fields.insert("SYNTH_P_DIR", Field { brief: Some("inverts direction of propotional part"), details: None, lo: 5, hi: 6 });
        fields.insert("SYNTH_P_STEP", Field { brief: Some("selects step width for propotional"), details: None, lo: 6, hi: 7 });
        fields.insert("SYNTH_SPARE_POOL", Field { brief: Some("reg. pool for late changes/fixes. Used bits: Bit3-1: Synthesizer BIAS adjust in steps of ~3%."), details: Some("0: 100% 7: 121%"), lo: 22, hi: 30 });
        fields.insert("SYNTH_SPEED_SEL", Field { brief: Some("Selects circuit speed."), details: Some("0: for settings with synth_fbdiv_sel = 2 1: for setting with synth_fbdiv_sel less than 2"), lo: 4, hi: 5 });
        regs.insert("SD10G65_RX_SYNTH_CFG0", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("SD10G65 RX Synthesizer Configuration register 0"), details: Some("Configuration register 0 for SD10G65 RX SYNTH."), fields });
        let mut fields = HashMap::new();
        fields.insert("SYNTH_FREQM_1", Field { brief: Some("frequency m setting bits 35:32"), details: None, lo: 4, hi: 8 });
        fields.insert("SYNTH_FREQN_1", Field { brief: Some("frequency n setting bits 35:32"), details: None, lo: 0, hi: 4 });
        fields.insert("SYNTH_FREQ_MULT", Field { brief: Some("frequency multiplier"), details: None, lo: 8, hi: 22 });
        fields.insert("SYNTH_FREQ_MULT_BYP", Field { brief: Some("frequency multiplier decoder bypass"), details: None, lo: 26, hi: 27 });
        fields.insert("SYNTH_FREQ_MULT_HI", Field { brief: Some("frequency multiplier MSBits in bypass mode"), details: None, lo: 22, hi: 26 });
        regs.insert("SD10G65_RX_SYNTH_CFG1", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("SD10G65 RX Synthesizer Configuration register 1"), details: Some("Configuration register 1 for SD10G65 RX SYNTH."), fields });
        let mut fields = HashMap::new();
        fields.insert("SYNTH_AUX_ENA", Field { brief: Some("enables clock for VScope / APC auxillary data chanels"), details: None, lo: 16, hi: 17 });
        fields.insert("SYNTH_CPMD_DIG_ENA", Field { brief: Some("uses cp/md selected via synth_cpmd_dig_sel instead of cp/md from sample stage"), details: None, lo: 17, hi: 18 });
        fields.insert("SYNTH_CPMD_DIG_SEL", Field { brief: Some("Cp/md dig select. Coding 0: select Bit 0/5 as cp/md (FX100 mode); 1: use cp/md from core"), details: None, lo: 18, hi: 19 });
        fields.insert("SYNTH_DV_CTRL_I1E", Field { brief: Some("Controls the data valid behavior for the CDRLF I1 enable function: b0 = 0 => external signal controls, 1 => b1 controls"), details: None, lo: 22, hi: 24 });
        fields.insert("SYNTH_DV_CTRL_I1M", Field { brief: Some("Controls the data valid behavior for the CDRLF I1 max function: b0 = 0 => external signal controls, 1 => b1 controls"), details: None, lo: 24, hi: 26 });
        fields.insert("SYNTH_DV_CTRL_I2E", Field { brief: Some("Controls the data valid behavior for the CDRLF I2 enable function: b0 = 0 => external signal controls, 1 => b1 controls"), details: None, lo: 26, hi: 28 });
        fields.insert("SYNTH_DV_CTRL_MD", Field { brief: Some("Controls the data valid behavior for the moebdiv select function: b0 = 0 => external signal controls, 1 => b1 controls"), details: None, lo: 20, hi: 22 });
        fields.insert("SYNTH_ETSD_MODE_ENA", Field { brief: Some("Enable ET-Serdes test mode. In this test mode the data_valid input port of SD10G65_RX switches between lock2data mode (data_valid = 0) and lock2ref mode (data_valid = 1). Do not use in mission mode."), details: None, lo: 28, hi: 29 });
        fields.insert("SYNTH_PHASE_AUX", Field { brief: Some("relationship phase center/aux"), details: None, lo: 0, hi: 7 });
        fields.insert("SYNTH_PHASE_DATA", Field { brief: Some("relationship phase center/edge"), details: None, lo: 8, hi: 15 });
        regs.insert("SD10G65_RX_SYNTH_CFG2", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("SD10G65 RX Synthesizer Configuration register 2"), details: Some("Configuration register 2 for SD10G65 RX SYNTH."), fields });
        let mut fields = HashMap::new();
        fields.insert("SYNTH_FREQM_0", Field { brief: Some("frequency m setting bits 31:0"), details: None, lo: 0, hi: 32 });
        regs.insert("SD10G65_RX_SYNTH_CFG3", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("SD10G65 RX Synthesizer Configuration register 3"), details: Some("Configuration register 3 for SD10G65 RX SYNTH."), fields });
        let mut fields = HashMap::new();
        fields.insert("SYNTH_FREQN_0", Field { brief: Some("frequency n setting bits 31:0"), details: None, lo: 0, hi: 32 });
        regs.insert("SD10G65_RX_SYNTH_CFG4", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("SD10G65 RX Synthesizer Configuration register 4"), details: Some("Configuration register 4 for SD10G65 RX SYNTH."), fields });
        let mut fields = HashMap::new();
        fields.insert("SYNTH_CAPTURE_QUAL", Field { brief: Some("Rising edge captures qualifier for readback"), details: None, lo: 20, hi: 21 });
        fields.insert("SYNTH_I1_SAT_DET", Field { brief: Some("Sticky flag to indicate saturating of Integrator1"), details: None, lo: 24, hi: 25 });
        fields.insert("SYNTH_I1_SAT_DET_CLR", Field { brief: Some("Clear for sticky flag \"synth_i1_sat_det\""), details: None, lo: 25, hi: 26 });
        fields.insert("SYNTH_I2_WRAP_DET", Field { brief: Some("Sticky flag to indicate a wrap/saturating of Integrator2"), details: None, lo: 21, hi: 22 });
        fields.insert("SYNTH_I2_WRAP_DET_CLR", Field { brief: Some("Clear for sticky flag \"synth_I2_wrap_det\""), details: None, lo: 22, hi: 23 });
        fields.insert("SYNTH_I2_WRAP_INHIBIT", Field { brief: Some("Controls Integrator2 behavior: '0': wrapping; '1': saturating."), details: None, lo: 23, hi: 24 });
        fields.insert("SYNTH_QUAL_I1", Field { brief: Some("Captured integrator 1 value"), details: None, lo: 0, hi: 16 });
        fields.insert("SYNTH_QUAL_I2_MSB", Field { brief: Some("MS Bits of captured integrator 2"), details: None, lo: 16, hi: 20 });
        regs.insert("SD10G65_RX_SYNTH_QUALIFIER0", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("SD10G65 RX Synthesizer Register 0 for qualifier access"), details: Some("Register 0 for qualifier access for SD10G65 RX SYNTH."), fields });
        let mut fields = HashMap::new();
        fields.insert("SYNTH_QUAL_I2_LSB", Field { brief: Some("LS Bits of captured integrator 2"), details: None, lo: 0, hi: 32 });
        regs.insert("SD10G65_RX_SYNTH_QUALIFIER1", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("SD10G65 RX Synthesizer Register 1 for qualifier access"), details: Some("Register 1 for qualifier access for SD10G65 RX SYNTH."), fields });
        let mut fields = HashMap::new();
        fields.insert("SYNTH_SC_PROTOCOL_ERR", Field { brief: Some("Sticky bit that indicates a sync control protocol error."), details: None, lo: 19, hi: 20 });
        fields.insert("SYNTH_SC_PROTOCOL_ERR_CLR", Field { brief: Some("Clear for synth_sc_protocol_err sticky bit. Rising edge causes the clearing and a concurrent error event has higher priority."), details: None, lo: 18, hi: 19 });
        fields.insert("SYNTH_SC_SYNC_TIMER_SEL", Field { brief: Some("Selects the synchronization period for the I2 value via sync control bus. Must be disabled (0) when sync control test generator is used. Coding in 312.5MHz clock cycles: 0: disabled, 1: 2^6, 2: 2^7, .., 15: 2^20."), details: None, lo: 0, hi: 4 });
        fields.insert("SYNTH_SC_TEST_COUNT", Field { brief: Some("Selects sync control test generator period. Test generator period, i.e. number of INC resp. DEC steps, equal programmed value + 1."), details: None, lo: 4, hi: 14 });
        fields.insert("SYNTH_SC_TEST_ENABLE", Field { brief: Some("Enables sync control test generator. Before enabling the test generator the sync timer must be disabled (synth_sc_sync_timer_sel = 0) and the integrator 2 has to be cleared (synth_dv_ctrl_i2e = 1)."), details: None, lo: 17, hi: 18 });
        fields.insert("SYNTH_SC_TEST_MODE", Field { brief: Some("Selects sync control test generator mode: 0: INC, 1: DEC, 2: WOBBLE"), details: None, lo: 14, hi: 16 });
        fields.insert("SYNTH_SC_TEST_TRIGGER", Field { brief: Some("Triggers sync control test generator. In INC resp. DEC mode both edges act as trigger event. In WOBBLE mode a 1 enables wobbling. Disabling in WOBBEL mode lets current wobble cycle finish before stopping. I.e. the I2 values reaches its value prior wobbling again."), details: None, lo: 16, hi: 17 });
        regs.insert("SD10G65_RX_SYNTH_SYNC_CTRL", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("SD10G65 RX Synthesizer Register for sync control data"), details: Some("Register 0 for sync control data for SD10G65 RX SYNTH."), fields });
        groups.insert("SD10G65_RX_SYNTH", RegisterGroup { addr: Address { base: 64, count: 1, width: 10 }, desc: "SD10G65 RX SYNTH Configuration and Status Register set", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("MLD_SYNC_CLK_SEL", Field { brief: Some("Select the MLD clock source for the internal MLD phase detector"), details: None, lo: 23, hi: 25 });
        fields.insert("MLD_SYNC_CTRL", Field { brief: Some("Control of the internal MLD phase detector: b0: enable; b1: enable hyst. b2: enable window function; b3: select window size"), details: None, lo: 25, hi: 29 });
        fields.insert("MLD_SYNC_SRC_SEL", Field { brief: Some("Select between the internal and external MLD phase detector: 0: internal; 1: external"), details: None, lo: 29, hi: 30 });
        fields.insert("SMOOTH_ENA", Field { brief: Some("Enables Smooth generator"), details: None, lo: 10, hi: 11 });
        fields.insert("SSC_MOD_MUL", Field { brief: Some("SSC modulation period multiplier encoded 2**n: 0 => 1; 1 => 2; 2 => 4, 3 => 8 ..."), details: None, lo: 0, hi: 3 });
        fields.insert("SSC_SD_GAIN", Field { brief: Some("SSC sigma delta gain."), details: None, lo: 5, hi: 10 });
        fields.insert("SSC_SYNC_POS", Field { brief: Some("SSC modulation start position on synchronization trigger"), details: None, lo: 3, hi: 5 });
        fields.insert("SYNC_CTRL_FSEL", Field { brief: Some("Frequency select of integrator 2 replica used for lane sync."), details: None, lo: 16, hi: 22 });
        fields.insert("SYNC_CTRL_PROTOCOL_ERR", Field { brief: Some("Sticky bit that indicates a sync control protocol error."), details: None, lo: 31, hi: 32 });
        fields.insert("SYNC_CTRL_PROTOCOL_ERR_CLR", Field { brief: Some("Clear for synth_sc_protocol_err sticky bit. Rising edge causes the clearing and a concurrent error event has higher priority."), details: None, lo: 30, hi: 31 });
        fields.insert("SYNC_CTRL_WRAP_INHIBIT", Field { brief: Some("Controls integrator 2 replica behavior: '0': wrapping; '1': saturating."), details: None, lo: 22, hi: 23 });
        regs.insert("SD10G65_SSC_CFG1", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("SD10G65 SSC generator Configuration register 1"), details: Some("Configuration register 1 for SD10G65 SSC generator."), fields });
        let mut fields = HashMap::new();
        fields.insert("PLLF_ENA", Field { brief: Some("Enable RCPLL FSM"), details: None, lo: 0, hi: 1 });
        fields.insert("PLLF_FBDIV_PRE", Field { brief: Some("Enable predivider for feedback clock to allow for faster clocks,"), details: Some("0: disable 1: enable"), lo: 14, hi: 15 });
        fields.insert("PLLF_LOOP_CTRL_ENA", Field { brief: Some("Enable PLL loop ctrl by pllf_loop_ena,"), details: Some("0: enable loop ctrl by FSM 1: enable loop ctrl by pllf_loop_ena"), lo: 11, hi: 12 });
        fields.insert("PLLF_LOOP_ENA", Field { brief: Some("Enable closed loop, selected with pllf_loop_ctrl_ena=1"), details: None, lo: 10, hi: 11 });
        fields.insert("PLLF_OOR_RECAL_ENA", Field { brief: Some("Enable VCO control signal out of range recalibration"), details: None, lo: 6, hi: 7 });
        fields.insert("PLLF_RAMP_MODE_SEL", Field { brief: Some("Sets the ramp characteristic of the FSM, higher values give faster ramp up but less accuracy,"), details: Some("0: normal (default) ramping 1: faster ramping 2: fastest ramping 3: slow ramping uses all possible values of r_ctrl"), lo: 7, hi: 10 });
        fields.insert("PLLF_REF_CNT_SEL", Field { brief: Some("Select output on pllf_ref_cnt_stat,"), details: Some("0: ref_cnt 1: pll_cnt_diff 2: syn_cnt 3: pll_cnt"), lo: 12, hi: 14 });
        fields.insert("PLLF_RST_FRQDET_ENA", Field { brief: Some("Enable restart of FSM from frequency deviation/unlock condition"), details: None, lo: 5, hi: 6 });
        fields.insert("PLLF_RST_OVERRUN_ENA", Field { brief: Some("Enable restart of FSM from overrun"), details: None, lo: 4, hi: 5 });
        fields.insert("PLLF_START_CNT", Field { brief: Some("Preload value of the ramp up counter, reduces ramp up time for higher frequencies"), details: None, lo: 16, hi: 26 });
        fields.insert("PLLF_SYN_CLK_ENA", Field { brief: Some("Enable feedback clock usage instead of DES/SER par. clock,"), details: Some("0: disable 1: enable"), lo: 15, hi: 16 });
        fields.insert("PLLF_VCO_FAST_ENA", Field { brief: Some("Enable vco load by pllf_vco_fast,"), details: Some("0: enable vco fast by FSM 1: enable vco load by pllf_vco_fast"), lo: 2, hi: 3 });
        fields.insert("PLLF_VCO_LOAD_ENA", Field { brief: Some("Enable vco load by pllf_vco_load,"), details: Some("0: enable vco load by FSM 1: enable vco load by pllf_vco_load"), lo: 3, hi: 4 });
        fields.insert("PLLF_VCO_SLOW_ENA", Field { brief: Some("Enable vco load by pllf_vco_slow,"), details: Some("0: enable vco slow by FSM 1: enable vco load by pllf_vco_slow"), lo: 1, hi: 2 });
        regs.insert("SD10G65_TX_RCPLL_CFG0", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("SD10G65 TX RCPLL Configuration register 0"), details: Some("Configuration register 0 for SD10G65 TX RCPLL."), fields });
        let mut fields = HashMap::new();
        fields.insert("PLLF_BIST_ENA", Field { brief: Some("enable special BIST settings"), details: None, lo: 14, hi: 15 });
        fields.insert("PLLF_REF_CNT_END", Field { brief: Some("Target value: 1/vco_frq * par.bit.width * 512 * ref_clk_frq"), details: None, lo: 16, hi: 32 });
        fields.insert("PLLF_VCO_FAST", Field { brief: Some("Select vco static frequency by feedforward (higher freq.),"), details: Some("0: min. freq 3: max. freq."), lo: 2, hi: 4 });
        fields.insert("PLLF_VCO_LOAD", Field { brief: Some("Select vco static frequency by load,"), details: Some("0: VCO off"), lo: 4, hi: 14 });
        fields.insert("PLLF_VCO_SLOW", Field { brief: Some("Select vco static frequency by feedback (lower freq.),"), details: Some("0: max. freq 3: min. freq."), lo: 0, hi: 2 });
        regs.insert("SD10G65_TX_RCPLL_CFG1", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("SD10G65 TX RCPLL Configuration register 1"), details: Some("Configuration register 1 for SD10G65 TX RCPLL."), fields });
        let mut fields = HashMap::new();
        fields.insert("PLL_CAL_ENA", Field { brief: Some("Not used"), details: None, lo: 1, hi: 2 });
        fields.insert("PLL_ENA", Field { brief: Some("Enable analog RCPLL part"), details: None, lo: 0, hi: 1 });
        fields.insert("PLL_FBSEL820", Field { brief: Some("Select VCO regulated supply (820mV),"), details: Some("0: 820mv 4: 860mV 6: 950mV 7: short to VDDA all others reserved"), lo: 24, hi: 27 });
        fields.insert("PLL_LPF_CUR", Field { brief: Some("Select chargepump current,"), details: Some("0: 50uA 1: 100uA 2: 150uA 3: 200uA"), lo: 11, hi: 13 });
        fields.insert("PLL_LPF_RES", Field { brief: Some("Select loop filter resistor value,"), details: Some("0: not allowed 1: 2400 2: 1600 3: 960 4: 1200 5: 800 6: 685 7: 533 8: 800 9: 600 10: 533 11: 436 12: 480 13: 400 14: 369 15: 320"), lo: 7, hi: 11 });
        fields.insert("PLL_SHORT_BULKHN_ENA", Field { brief: Some("Debug, short N bulk voltage of OpAmps,"), details: Some("0: N bulk unequal 0 1: short to VSSA"), lo: 15, hi: 16 });
        fields.insert("PLL_SHORT_BULKHP_ENA", Field { brief: Some("Debug, short P bulk voltage of OpAmps,"), details: Some("0: P bulk unequal supply 1: short to supply"), lo: 16, hi: 17 });
        fields.insert("PLL_SHORT_BULKN_ENA", Field { brief: Some("Debug, short N bulk voltage of VCO,"), details: Some("0: N bulk unequal 0 1: short to VSSA"), lo: 13, hi: 14 });
        fields.insert("PLL_SHORT_BULKP_ENA", Field { brief: Some("Debug, short P bulk voltage of VCO,"), details: Some("0: P bulk unequal supply 1: short to supply"), lo: 14, hi: 15 });
        fields.insert("PLL_VCO_CUR", Field { brief: Some("Select vco current,"), details: Some("0: lowest current 31: highest current"), lo: 2, hi: 7 });
        fields.insert("PLL_VREG18", Field { brief: Some("Select VCO load switch gate voltage,"), details: Some("0: 1.4V 1: 1.5V 2: 1.6V 3: 1.7V 15: max."), lo: 20, hi: 24 });
        regs.insert("SD10G65_TX_RCPLL_CFG2", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("SD10G65 TX RCPLL Configuration register 2"), details: Some("Configuration register 2 for SD10G65 TX RCPLL."), fields });
        let mut fields = HashMap::new();
        fields.insert("PLLF_LOCK_STAT", Field { brief: Some("PLL lock status,"), details: Some("0: not locked 1: locked"), lo: 31, hi: 32 });
        fields.insert("PLLF_VCO_FAST_STAT", Field { brief: Some("Actual value of VCO fast portion, set by FSM"), details: None, lo: 2, hi: 4 });
        fields.insert("PLLF_VCO_LOAD_STAT", Field { brief: Some("Actual value of VCO load, set by FSM"), details: None, lo: 4, hi: 14 });
        fields.insert("PLLF_VCO_SLOW_STAT", Field { brief: Some("Actual value of VCO slow portion, set by FSM"), details: None, lo: 0, hi: 2 });
        fields.insert("PLL_RANGE_LIMIT", Field { brief: Some("Out of range status bit,"), details: Some("0: within range 1: out of range"), lo: 16, hi: 17 });
        fields.insert("PLL_RANGE_LIMIT_STY", Field { brief: Some("Out of range status bit, sticky bit,"), details: Some("0: within range 1: out of range"), lo: 17, hi: 18 });
        regs.insert("SD10G65_TX_RCPLL_STAT0", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("SD10G65 TX RCPLL Status register 0"), details: Some("Status register 0 for SD10G65 TX RCPLL."), fields });
        let mut fields = HashMap::new();
        fields.insert("PLLF_FSM_CNT_STAT", Field { brief: Some("Actual value of step up counter"), details: None, lo: 4, hi: 15 });
        fields.insert("PLLF_FSM_STAT", Field { brief: Some("Actual value of the FSM stage,"), details: Some("0: reset state 1: init state after reset 3: ramp up state checks for the counters and ramps up the frequency 6: additional wait state for internal BIAS settling 8: additional wait state 1 9: additional wait state 2 10; additional wait state 3 11: additional wait state 4 12: 1st locking state enables dynamic locking 13: final locking state checks for out of lock and overrun condition 14: error state low frequency 15: error state high frequency"), lo: 0, hi: 4 });
        fields.insert("PLLF_REF_CNT_STAT", Field { brief: Some("Internal FSM values selected by pllf_ref_cnt_sel"), details: None, lo: 16, hi: 32 });
        regs.insert("SD10G65_TX_RCPLL_STAT1", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("SD10G65 TX RCPLL Status register 1"), details: Some("Status register 1 for SD10G65 TX RCPLL."), fields });
        groups.insert("SD10G65_TX_RCPLL", RegisterGroup { addr: Address { base: 96, count: 1, width: 5 }, desc: "SD10G65 TX RCPLL Configuration and Status Register set", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("F2DF_DATA_VALID_PROPPER_SIDE", Field { brief: Some("Data valid value in \"PropperSide\" state. '0': data valid flaged only in \"Lock\" state; '1' data valid also flaged in \"PropperSide\" state."), details: None, lo: 3, hi: 4 });
        fields.insert("F2DF_ENABLE", Field { brief: Some("F2df enable. Enabling the f2df circuit automatically switches the input of the CDR-loop to the f2df control block (overrules synth_cpmd_dig_sel and synth_cpmd_dig_ena) and replaces the data valid signal from the core logic by the data valid signal generated by the f2df control logic."), details: None, lo: 0, hi: 1 });
        fields.insert("F2DF_FSM_STATE", Field { brief: Some("Actual FSM state: '0': Iffy; '1': WrongSide; '2': PropperSide; '3': Lock."), details: None, lo: 23, hi: 25 });
        fields.insert("F2DF_SAMPLE_MODE", Field { brief: Some("Sampling mode: '0' one parallel data word per sampled clock cycle; '1' clock pattern sampled in two parallel data words."), details: None, lo: 1, hi: 2 });
        fields.insert("F2DF_SIDE_DET_BIT_SEL", Field { brief: Some("Select bit from input data used for side detection. Debug feature: '31' select constant zero, '30' select constant one."), details: None, lo: 17, hi: 22 });
        fields.insert("F2DF_SIDE_DET_ONES_WEIGHT", Field { brief: Some("Sample '1' => increment 8bit filter saturating counter by 2**n. Cnt >= 0xC0 => PropperSide detected."), details: None, lo: 14, hi: 17 });
        fields.insert("F2DF_SIDE_DET_STICKY", Field { brief: Some("Sticky bit: indicate loosing propper side detection in lock state."), details: None, lo: 22, hi: 23 });
        fields.insert("F2DF_SIDE_DET_ZEROS_WEIGHT", Field { brief: Some("Sample '0' => decrement 8bit filter saturating counter by 2**n. Cnt <"), details: Some("0x40 => WrongSide detected."), lo: 11, hi: 14 });
        fields.insert("F2DF_STICKY_CLR", Field { brief: Some("Clear all sticky bits."), details: None, lo: 2, hi: 3 });
        fields.insert("F2DF_TOG_DET_CNT", Field { brief: Some("Determines the number of samples that have to show at least one toggle."), details: None, lo: 4, hi: 10 });
        fields.insert("F2DF_TOG_DET_STICKY", Field { brief: Some("Sticky bit: indicate missing toggle of MD sampler in lock state."), details: None, lo: 10, hi: 11 });
        regs.insert("F2DF_CFG_STAT", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("F2DF Configuration / status register"), details: Some("Configuration / status register for the F2DF control logic."), fields });
        let mut fields = HashMap::new();
        fields.insert("SSC_ENA", Field { brief: Some("SSC generator enable."), details: None, lo: 0, hi: 1 });
        fields.insert("SSC_MOD_FREQ", Field { brief: Some("SSC modulation frequency fine tuning control"), details: None, lo: 1, hi: 7 });
        fields.insert("SSC_MOD_LIM", Field { brief: Some("SSC modulation amplitude limiter"), details: None, lo: 19, hi: 32 });
        fields.insert("SSC_MOD_PERIOD", Field { brief: Some("SSC modulation period / amplitude."), details: None, lo: 7, hi: 19 });
        regs.insert("SD10G65_SSC_CFG0", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("SD10G65 SSC generator Configuration register 0"), details: Some("Configuration register 0 for SD10G65 SSC generator."), fields });
        let mut fields = HashMap::new();
        fields.insert("SYNTH_BIAS_ADJUST", Field { brief: Some("Synthesizer BIAS adjust in steps of ~3%, 0: 100%, 7: 121%"), details: None, lo: 23, hi: 26 });
        fields.insert("SYNTH_CONV_ENA", Field { brief: Some("enables CML2CMOS converter"), details: None, lo: 1, hi: 2 });
        fields.insert("SYNTH_CS_SPEED", Field { brief: Some("comon sync speed"), details: None, lo: 11, hi: 14 });
        fields.insert("SYNTH_DS_DIR", Field { brief: Some("dig. sync direction"), details: None, lo: 6, hi: 7 });
        fields.insert("SYNTH_DS_ENA", Field { brief: Some("dig. sync enable"), details: None, lo: 5, hi: 6 });
        fields.insert("SYNTH_DS_SPEED", Field { brief: Some("dig. sync speed"), details: None, lo: 7, hi: 8 });
        fields.insert("SYNTH_ENA", Field { brief: Some("synthesizer enable"), details: None, lo: 0, hi: 1 });
        fields.insert("SYNTH_ENA_SYNC_UNIT", Field { brief: Some("enable sync unit"), details: None, lo: 2, hi: 3 });
        fields.insert("SYNTH_FBDIV_SEL", Field { brief: Some("selects feedback divider setting"), details: None, lo: 16, hi: 18 });
        fields.insert("SYNTH_HRATE_ENA", Field { brief: Some("half rate enable"), details: None, lo: 3, hi: 4 });
        fields.insert("SYNTH_LS_DIR", Field { brief: Some("lane sync direction"), details: None, lo: 9, hi: 10 });
        fields.insert("SYNTH_LS_ENA", Field { brief: Some("lane sync enable"), details: None, lo: 8, hi: 9 });
        fields.insert("SYNTH_LS_SPEED", Field { brief: Some("lane sync speed"), details: None, lo: 10, hi: 11 });
        fields.insert("SYNTH_OFF_COMP_ENA", Field { brief: Some("Enable for different offset compensation stages"), details: None, lo: 18, hi: 23 });
        fields.insert("SYNTH_SPARE_POOL", Field { brief: Some("reg. pool for late changes/fixes."), details: None, lo: 26, hi: 30 });
        fields.insert("SYNTH_SPEED_SEL", Field { brief: Some("Selects circuit speed. Coding: 0 for settings with synth_fbdiv_sel = 2; 1 for setting with synth_fbdiv_sel smaller than 2."), details: None, lo: 4, hi: 5 });
        regs.insert("SD10G65_TX_SYNTH_CFG0", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("SD10G65 TX Synthesizer Configuration register 0"), details: Some("Configuration register 0 for SD10G65 TX SYNTH."), fields });
        let mut fields = HashMap::new();
        fields.insert("SYNTH_FREQM_1", Field { brief: Some("frequency m setting bits 35:32"), details: None, lo: 4, hi: 8 });
        fields.insert("SYNTH_FREQN_1", Field { brief: Some("frequency n setting bits 35:32"), details: None, lo: 0, hi: 4 });
        fields.insert("SYNTH_FREQ_MULT", Field { brief: Some("frequency multiplier"), details: None, lo: 8, hi: 22 });
        fields.insert("SYNTH_FREQ_MULT_BYP", Field { brief: Some("frequency multiplier decoder bypass"), details: None, lo: 26, hi: 27 });
        fields.insert("SYNTH_FREQ_MULT_HI", Field { brief: Some("frequency multiplier MSBits in bypass mode"), details: None, lo: 22, hi: 26 });
        regs.insert("SD10G65_TX_SYNTH_CFG1", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("SD10G65 TX Synthesizer Configuration register 1"), details: Some("Configuration register 1 for SD10G65 TX SYNTH."), fields });
        let mut fields = HashMap::new();
        fields.insert("SYNTH_FREQM_0", Field { brief: Some("frequency m setting bits 31:0"), details: None, lo: 0, hi: 32 });
        regs.insert("SD10G65_TX_SYNTH_CFG3", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("SD10G65 TX Synthesizer Configuration register 3"), details: Some("Configuration register 3 for SD10G65 TX SYNTH."), fields });
        let mut fields = HashMap::new();
        fields.insert("SYNTH_FREQN_0", Field { brief: Some("frequency n setting bits 31:0"), details: None, lo: 0, hi: 32 });
        regs.insert("SD10G65_TX_SYNTH_CFG4", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("SD10G65 TX Synthesizer Configuration register 4"), details: Some("Configuration register 4 for SD10G65 TX SYNTH."), fields });
        groups.insert("SD10G65_TX_SYNTH", RegisterGroup { addr: Address { base: 80, count: 1, width: 6 }, desc: "SD10G65 TX SYNTH Configuration and Status Register set", regs });
        out.insert("SD10G65", Target { desc: "\\see vtss_target_SD10G65_e Configuration and status for high speed macro.", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("APC_DIRECT_ENA", Field { brief: Some("Enable APC direct connections instead of local IB configuration registers."), details: None, lo: 3, hi: 4 });
        fields.insert("APC_FSM_RECOVER_MODE", Field { brief: Some("Top-ctrl FSM recovery behavior"), details: Some("0: No auto-recovery 1: Auto-restart on missing input signal after Restart-Delay-Timer has expired 2: Auto-restart on missing input signal"), lo: 26, hi: 28 });
        fields.insert("APC_MODE", Field { brief: Some("APC operation mode"), details: Some("0: Off 1: Manual mode 2: Perform calibrarion and run FSM1 3: Perform calibration and run FSM2 4: Perform calibration and run FSM1 and FSM2 in ping-pong operation 5: Perform calibration and then enter manual mode"), lo: 0, hi: 3 });
        fields.insert("BLOCK_READ_SEL", Field { brief: Some("Select flexctrl block in order to read internal counters. Counter values readable from APC_FLEXCTRL_CNT_STATUS."), details: Some("0: Offset-ctrl 1: L-ctrl 2: C-ctrl 3: AGC-ctrl 4: DFE1-ctrl 5: DFE2-ctrl 6: DFE3-ctrl 7: DFE4-ctrl 8: SAM_Offset-cal 9: Level-cal 10: HML sampling errors"), lo: 12, hi: 16 });
        fields.insert("CTRL_MODE", Field { brief: Some("Obsolete. Replaced by dedicated and independent ctrl_mode bits for each parameter control block."), details: None, lo: 5, hi: 6 });
        fields.insert("FREEZE_APC", Field { brief: Some("Freeze current state"), details: Some("0: Normal operation 1: Freeze APC"), lo: 10, hi: 11 });
        fields.insert("HML_CLR_CNT", Field { brief: Some("Clear HML sampling error counter"), details: Some("1: Clear counter"), lo: 31, hi: 32 });
        fields.insert("HML_ERRCORR_ENA", Field { brief: Some("HML sampling error correction enable. Invalid samples are not used for parameter control (smart sampling)."), details: Some("0: Disable smart sampling 1: Enable smart sampling"), lo: 29, hi: 30 });
        fields.insert("HML_ERRCORR_MODE", Field { brief: Some("HML sampling error correction mode. Correctable sampling errors can be automatically corrected."), details: Some("0: Disable auto-correctin 1: Enable auto-correction"), lo: 30, hi: 31 });
        fields.insert("HML_SWAP_HL", Field { brief: Some("H/L swapping in HML sampling error correction logic"), details: Some("0: No H/L swapping 1: H/L swapped"), lo: 28, hi: 29 });
        fields.insert("IF_WIDTH", Field { brief: Some("Interface bit-width"), details: Some("0: 8-bit 1: 10-bit 2: 16-bit 3: 20-bit 4: 32-bit 5: 40-bit"), lo: 6, hi: 9 });
        fields.insert("RESET_APC", Field { brief: Some("Reset APC core logic (configuration registers are not reset)"), details: Some("1: Reset APC 0: Normal operation (mission mode)"), lo: 11, hi: 12 });
        fields.insert("SIG_DET_VALID_CFG", Field { brief: Some("Signal detect valid configuration (Offs/AGC/L/C/DFE)"), details: Some("0: Signal_detect input directly used 1: Signal_detect input gated with gain_ctrl ramp-up done (EQZ_GAIN_CTRL_DONE)"), lo: 25, hi: 26 });
        fields.insert("SIG_LOST_DELAY_TIME", Field { brief: Some("Signal lost delay timer configuration used for APC recovery. The signal lost delay time specifies the time when a missing input signal is considered a lost input signal on sig_det = 0. The delay time is T = (2^sig_lost_delay_time) * T_rx_clk_per"), details: None, lo: 20, hi: 25 });
        fields.insert("SKIP_CAL", Field { brief: Some("Skip calibration process in top control state machine (applies for apc_modes 2, 3 and 4)"), details: None, lo: 9, hi: 10 });
        fields.insert("THROTTLE_MODE", Field { brief: Some("APC throttling mode"), details: Some("0: Disable no power reduction (continuous operation) 1: Enable power reduced operation (pulsed operation)"), lo: 4, hi: 5 });
        fields.insert("TOP_CTRL_STATE", Field { brief: Some("Current state of APC top control state machine"), details: Some("0: Off 1: Power-up 2: Power-down 3: Manual mode 4: Calibrate IS 5: Calibrate LD 6: Not used 7: Gain-control ramp-up 8: Mission mode (FSM1 controlled) 9: Mission mode (FSM2 controlled) 10-12: Debug states 13: Snooze 14-15: Not used"), lo: 16, hi: 20 });
        regs.insert("APC_COMMON_CFG0", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("APC common configuration register 0"), details: Some("Common configurations 0 for APC logic. Note: For HML error correction logic HML=000/001/011/111 are considered valid, 010 and 101 are considered correctable (010 correctable to 011; 101 correctable to 001) and 100 and 110 are considered incorrectable."), fields });
        let mut fields = HashMap::new();
        fields.insert("DFE1_ACTVAL", Field { brief: Some("Parameter value (controlled/computed value)"), details: None, lo: 16, hi: 26 });
        fields.insert("DFE1_CTRL_DONE", Field { brief: Some("Parameter control state in one-time mode"), details: Some("1: Finished"), lo: 26, hi: 27 });
        fields.insert("DFE1_CTRL_MODE", Field { brief: Some("Parameter control mode for DFE1 parameter"), details: Some("0: Discrete 1: Continuous"), lo: 10, hi: 11 });
        fields.insert("DFE1_CTRL_THRES", Field { brief: Some("Alternative threshold for DFE1 parameter (controller goal: err_cnt = 0.5*DFE1_THRES)"), details: None, lo: 4, hi: 10 });
        fields.insert("DFE1_CTRL_THRES_ENA", Field { brief: Some("Enable use of alternative threshold for DFE1 parameter"), details: Some("0: Use default threshold 1: Use alternative threshold"), lo: 3, hi: 4 });
        fields.insert("DFE1_OP_MODE", Field { brief: Some("Operation mode"), details: Some("0: Off 1: One-time 2: Non-stop 3: Paused"), lo: 0, hi: 2 });
        fields.insert("DFE1_READ_CNT_SEL", Field { brief: Some("Select counter to be read"), details: Some("0: dfe1_value 1: Hit counter 2: Error counter"), lo: 12, hi: 14 });
        fields.insert("DFE1_RECOVER_MODE", Field { brief: Some("DFE1 recovery behavior"), details: Some("0: No auto-recovery 1: Freeze DFE1 on weak (eqz_gain > eqz_gain_freeze_thres) or missing input signal 2: Freeze DFE1 on weak signal and restart on missing input signal 3: Freeze DFE1 on missing input signal 4: Freeze DFE1 on missing input signal and auto-restart after Restart-Delay-Timer has expired 5: Auto-restart DFE1 on missing input signal 6-7: Reserved"), lo: 27, hi: 30 });
        fields.insert("DFE1_START_CTRL", Field { brief: Some("Start operation (parameter update). Should be cleared afterwards in One-time mode and stay set in Non-stop and Paused mode"), details: None, lo: 2, hi: 3 });
        fields.insert("DFE1_SYNC_MODE", Field { brief: Some("Synchronization mode"), details: Some("0: Independent 1: Attached to parctrl FSM 1 2: Attached to parctrl FSM 2 3: Attached to both parctrl FSMs"), lo: 14, hi: 16 });
        regs.insert("APC_DFE1_CTRL", Register { addr: Address { base: 30, count: 1, width: 1 }, brief: Some("APC DFE1 Control registers"), details: Some("General behavior control for DFE1 parameter control."), fields });
        let mut fields = HashMap::new();
        fields.insert("DFE1_CHG_MODE", Field { brief: Some("Parameter change mode"), details: Some("0: Automatic update 1: Preset (use DFE1_INI as fix value internal processing continues) 2: Freeze (internal processing stops parameter stays at current value) 3: No update (internal processing continues but parameter is not updated)"), lo: 24, hi: 26 });
        fields.insert("DFE1_DIR_SEL", Field { brief: Some("Select parameter update direction"), details: Some("0: Normal 1: Inverted"), lo: 31, hi: 32 });
        fields.insert("DFE1_INI", Field { brief: Some("Parameter initial value"), details: None, lo: 0, hi: 8 });
        fields.insert("DFE1_MAX", Field { brief: Some("Maximum value of paramter"), details: None, lo: 16, hi: 24 });
        fields.insert("DFE1_MIN", Field { brief: Some("Minimum value of paramter"), details: None, lo: 8, hi: 16 });
        fields.insert("DFE1_RANGE_SEL", Field { brief: Some("Parameter range selection (only when CTRL_MODE = continuous). Value complies to number of left-shifts"), details: None, lo: 26, hi: 31 });
        regs.insert("APC_DFE1_PAR_CFG", Register { addr: Address { base: 32, count: 1, width: 1 }, brief: Some("APC DFE1 Parameter control register"), details: Some("Configuration register for controlled DFE1 parameter. Note, for parameters larger than 8 bits, ini/min/max values are shifted to the left. For parameters smaller than 8 bits only the lower bits of ini/min/max are used."), fields });
        let mut fields = HashMap::new();
        fields.insert("DFE1_OP_TIME", Field { brief: Some("Operation time (in number of rx_clk cycles)"), details: None, lo: 0, hi: 16 });
        fields.insert("DFE1_PS_TIME", Field { brief: Some("Pause time"), details: Some("(in number of rx_clk cycles)"), lo: 16, hi: 32 });
        regs.insert("APC_DFE1_TIMER_CFG", Register { addr: Address { base: 31, count: 1, width: 1 }, brief: Some("APC DFE1 Timer config"), details: Some("Configuration registers for DFE1 controller timing."), fields });
        let mut fields = HashMap::new();
        fields.insert("DFE2_ACTVAL", Field { brief: Some("Parameter value (controlled/computed value)"), details: None, lo: 16, hi: 26 });
        fields.insert("DFE2_CTRL_DONE", Field { brief: Some("Parameter control state in one-time mode"), details: Some("1: Finished"), lo: 26, hi: 27 });
        fields.insert("DFE2_CTRL_MODE", Field { brief: Some("Parameter control mode for DFE2 parameter"), details: Some("0: Discrete 1: Continuous"), lo: 10, hi: 11 });
        fields.insert("DFE2_CTRL_THRES", Field { brief: Some("Alternative threshold for DFE2 parameter (controller goal: err_cnt = 0.5*DFE2_THRES)"), details: None, lo: 4, hi: 10 });
        fields.insert("DFE2_CTRL_THRES_ENA", Field { brief: Some("Enable use of alternative threshold for DFE2 parameter"), details: Some("0: Use default threshold 1: Use alternative threshold"), lo: 3, hi: 4 });
        fields.insert("DFE2_OP_MODE", Field { brief: Some("Operation mode"), details: Some("0: Off 1: One-time 2: Non-stop 3: Paused"), lo: 0, hi: 2 });
        fields.insert("DFE2_READ_CNT_SEL", Field { brief: Some("Select counter to be read"), details: Some("0: dfe2_value 1: Hit counter 2: Error counter"), lo: 12, hi: 14 });
        fields.insert("DFE2_RECOVER_MODE", Field { brief: Some("DFE2 recovery behavior"), details: Some("0: No auto-recovery 1: Freeze DFE2 on weak (eqz_gain > eqz_gain_freeze_thres) or missing input signal 2: Freeze DFE2 on weak signal and restart on missing input signal 3: Freeze DFE2 on missing input signal 4: Freeze DFE2 on missing input signal and auto-restart after Restart-Delay-Timer has expired 5: Auto-restart DFE2 on missing input signal 6-7: Reserved"), lo: 27, hi: 30 });
        fields.insert("DFE2_START_CTRL", Field { brief: Some("Start operation (parameter update). Should be cleared afterwards in One-time mode and stay set in Non-stop and Paused mode"), details: None, lo: 2, hi: 3 });
        fields.insert("DFE2_SYNC_MODE", Field { brief: Some("Synchronization mode"), details: Some("0: Independent 1: Attached to parctrl FSM 1 2: Attached to parctrl FSM 2 3: Attached to both parctrl FSMs"), lo: 14, hi: 16 });
        regs.insert("APC_DFE2_CTRL", Register { addr: Address { base: 33, count: 1, width: 1 }, brief: Some("APC DFE2 Control registers"), details: Some("General behavior control for DFE2 parameter control."), fields });
        let mut fields = HashMap::new();
        fields.insert("DFE2_CHG_MODE", Field { brief: Some("Parameter change mode"), details: Some("0: Automatic update 1: Preset (use DFE2_INI as fix value internal processing continues) 2: Freeze (internal processing stops parameter stays at current value) 3: No update (internal processing continues but parameter is not updated)"), lo: 24, hi: 26 });
        fields.insert("DFE2_DIR_SEL", Field { brief: Some("Select parameter update direction"), details: Some("0: Normal 1: Inverted"), lo: 31, hi: 32 });
        fields.insert("DFE2_INI", Field { brief: Some("Parameter initial value"), details: None, lo: 0, hi: 8 });
        fields.insert("DFE2_MAX", Field { brief: Some("Maximum value of paramter"), details: None, lo: 16, hi: 24 });
        fields.insert("DFE2_MIN", Field { brief: Some("Minimum value of paramter"), details: None, lo: 8, hi: 16 });
        fields.insert("DFE2_RANGE_SEL", Field { brief: Some("Parameter range selection (only when CTRL_MODE = continuous). Value complies to number of left-shifts"), details: None, lo: 26, hi: 31 });
        regs.insert("APC_DFE2_PAR_CFG", Register { addr: Address { base: 35, count: 1, width: 1 }, brief: Some("APC DFE2 Parameter control register"), details: Some("Configuration register for controlled DFE2 parameter. Note, for parameters larger than 8 bits, ini/min/max values are shifted to the left. For parameters smaller than 8 bits only the lower bits of ini/min/max are used."), fields });
        let mut fields = HashMap::new();
        fields.insert("DFE2_OP_TIME", Field { brief: Some("Operation time (in number of rx_clk cycles)"), details: None, lo: 0, hi: 16 });
        fields.insert("DFE2_PS_TIME", Field { brief: Some("Pause time"), details: Some("(in number of rx_clk cycles)"), lo: 16, hi: 32 });
        regs.insert("APC_DFE2_TIMER_CFG", Register { addr: Address { base: 34, count: 1, width: 1 }, brief: Some("APC DFE2 Timer config"), details: Some("Configuration registers for DFE2 controller timing."), fields });
        let mut fields = HashMap::new();
        fields.insert("DFE3_ACTVAL", Field { brief: Some("Parameter value (controlled/computed value)"), details: None, lo: 16, hi: 26 });
        fields.insert("DFE3_CTRL_DONE", Field { brief: Some("Parameter control state in one-time mode"), details: Some("1: Finished"), lo: 26, hi: 27 });
        fields.insert("DFE3_CTRL_MODE", Field { brief: Some("Parameter control mode for DFE3 parameter"), details: Some("0: Discrete 1: Continuous"), lo: 10, hi: 11 });
        fields.insert("DFE3_CTRL_THRES", Field { brief: Some("Alternative threshold for DFE3 parameter (controller goal: err_cnt = 0.5*DFE3_THRES)"), details: None, lo: 4, hi: 10 });
        fields.insert("DFE3_CTRL_THRES_ENA", Field { brief: Some("Enable use of alternative threshold for DFE3 parameter"), details: Some("0: Use default threshold 1: Use alternative threshold"), lo: 3, hi: 4 });
        fields.insert("DFE3_OP_MODE", Field { brief: Some("Operation mode"), details: Some("0: Off 1: One-time 2: Non-stop 3: Paused"), lo: 0, hi: 2 });
        fields.insert("DFE3_READ_CNT_SEL", Field { brief: Some("Select counter to be read"), details: Some("0: dfe3_value 1: Hit counter 2: Error counter"), lo: 12, hi: 14 });
        fields.insert("DFE3_RECOVER_MODE", Field { brief: Some("DFE3 recovery behavior"), details: Some("0: No auto-recovery 1: Freeze DFE3 on weak (eqz_gain > eqz_gain_freeze_thres) or missing input signal 2: Freeze DFE3 on weak signal and restart on missing input signal 3: Freeze DFE3 on missing input signal 4: Freeze DFE3 on missing input signal and auto-restart after Restart-Delay-Timer has expired 5: Auto-restart DFE3 on missing input signal 6-7: Reserved"), lo: 27, hi: 30 });
        fields.insert("DFE3_START_CTRL", Field { brief: Some("Start operation (parameter update). Should be cleared afterwards in One-time mode and stay set in Non-stop and Paused mode"), details: None, lo: 2, hi: 3 });
        fields.insert("DFE3_SYNC_MODE", Field { brief: Some("Synchronization mode"), details: Some("0: Independent 1: Attached to parctrl FSM 1 2: Attached to parctrl FSM 2 3: Attached to both parctrl FSMs"), lo: 14, hi: 16 });
        regs.insert("APC_DFE3_CTRL", Register { addr: Address { base: 36, count: 1, width: 1 }, brief: Some("APC DFE3 Control registers"), details: Some("General behavior control for DFE3 parameter control."), fields });
        let mut fields = HashMap::new();
        fields.insert("DFE3_CHG_MODE", Field { brief: Some("Parameter change mode"), details: Some("0: Automatic update 1: Preset (use DFE3_INI as fix value internal processing continues) 2: Freeze (internal processing stops parameter stays at current value) 3: No update (internal processing continues but parameter is not updated)"), lo: 24, hi: 26 });
        fields.insert("DFE3_DIR_SEL", Field { brief: Some("Select parameter update direction"), details: Some("0: Normal 1: Inverted"), lo: 31, hi: 32 });
        fields.insert("DFE3_INI", Field { brief: Some("Parameter initial value"), details: None, lo: 0, hi: 8 });
        fields.insert("DFE3_MAX", Field { brief: Some("Maximum value of paramter"), details: None, lo: 16, hi: 24 });
        fields.insert("DFE3_MIN", Field { brief: Some("Minimum value of paramter"), details: None, lo: 8, hi: 16 });
        fields.insert("DFE3_RANGE_SEL", Field { brief: Some("Parameter range selection (only when CTRL_MODE = continuous). Value complies to number of left-shifts"), details: None, lo: 26, hi: 31 });
        regs.insert("APC_DFE3_PAR_CFG", Register { addr: Address { base: 38, count: 1, width: 1 }, brief: Some("APC DFE3 Parameter control register"), details: Some("Configuration register for controlled DFE3 parameter. Note, for parameters larger than 8 bits, ini/min/max values are shifted to the left. For parameters smaller than 8 bits only the lower bits of ini/min/max are used."), fields });
        let mut fields = HashMap::new();
        fields.insert("DFE3_OP_TIME", Field { brief: Some("Operation time (in number of rx_clk cycles)"), details: None, lo: 0, hi: 16 });
        fields.insert("DFE3_PS_TIME", Field { brief: Some("Pause time"), details: Some("(in number of rx_clk cycles)"), lo: 16, hi: 32 });
        regs.insert("APC_DFE3_TIMER_CFG", Register { addr: Address { base: 37, count: 1, width: 1 }, brief: Some("APC DFE3 Timer config"), details: Some("Configuration registers for DFE3 controller timing."), fields });
        let mut fields = HashMap::new();
        fields.insert("DFE4_ACTVAL", Field { brief: Some("Parameter value (controlled/computed value)"), details: None, lo: 16, hi: 26 });
        fields.insert("DFE4_CTRL_DONE", Field { brief: Some("Parameter control state in one-time mode"), details: Some("1: Finished"), lo: 26, hi: 27 });
        fields.insert("DFE4_CTRL_MODE", Field { brief: Some("Parameter control mode for DFE4 parameter"), details: Some("0: Discrete 1: Continuous"), lo: 10, hi: 11 });
        fields.insert("DFE4_CTRL_THRES", Field { brief: Some("Alternative threshold for DFE4 parameter (controller goal: err_cnt = 0.5*DFE4_THRES)"), details: None, lo: 4, hi: 10 });
        fields.insert("DFE4_CTRL_THRES_ENA", Field { brief: Some("Enable use of alternative threshold for DFE4 parameter"), details: Some("0: Use default threshold 1: Use alternative threshold"), lo: 3, hi: 4 });
        fields.insert("DFE4_OP_MODE", Field { brief: Some("Operation mode"), details: Some("0: Off 1: One-time 2: Non-stop 3: Paused"), lo: 0, hi: 2 });
        fields.insert("DFE4_READ_CNT_SEL", Field { brief: Some("Select counter to be read"), details: Some("0: dfe4_value 1: Hit counter 2: Error counter"), lo: 12, hi: 14 });
        fields.insert("DFE4_RECOVER_MODE", Field { brief: Some("DFE4 recovery behavior"), details: Some("0: No auto-recovery 1: Freeze DFE4 on weak (eqz_gain > eqz_gain_freeze_thres) or missing input signal 2: Freeze DFE4 on weak signal and restart on missing input signal 3: Freeze DFE4 on missing input signal 4: Freeze DFE4 on missing input signal and auto-restart after Restart-Delay-Timer has expired 5: Auto-restart DFE4 on missing input signal 6-7: Reserved"), lo: 27, hi: 30 });
        fields.insert("DFE4_START_CTRL", Field { brief: Some("Start operation (parameter update). Should be cleared afterwards in One-time mode and stay set in Non-stop and Paused mode"), details: None, lo: 2, hi: 3 });
        fields.insert("DFE4_SYNC_MODE", Field { brief: Some("Synchronization mode"), details: Some("0: Independent 1: Attached to parctrl FSM 1 2: Attached to parctrl FSM 2 3: Attached to both parctrl FSMs"), lo: 14, hi: 16 });
        regs.insert("APC_DFE4_CTRL", Register { addr: Address { base: 39, count: 1, width: 1 }, brief: Some("APC DFE4 Control registers"), details: Some("General behavior control for DFE4 parameter control."), fields });
        let mut fields = HashMap::new();
        fields.insert("DFE4_CHG_MODE", Field { brief: Some("Parameter change mode"), details: Some("0: Automatic update 1: Preset (use DFE4_INI as fix value internal processing continues) 2: Freeze (internal processing stops parameter stays at current value) 3: No update (internal processing continues but parameter is not updated)"), lo: 24, hi: 26 });
        fields.insert("DFE4_DIR_SEL", Field { brief: Some("Select parameter update direction"), details: Some("0: Normal 1: Inverted"), lo: 31, hi: 32 });
        fields.insert("DFE4_INI", Field { brief: Some("Parameter initial value"), details: None, lo: 0, hi: 8 });
        fields.insert("DFE4_MAX", Field { brief: Some("Maximum value of paramter"), details: None, lo: 16, hi: 24 });
        fields.insert("DFE4_MIN", Field { brief: Some("Minimum value of paramter"), details: None, lo: 8, hi: 16 });
        fields.insert("DFE4_RANGE_SEL", Field { brief: Some("Parameter range selection (only when CTRL_MODE = continuous). Value complies to number of left-shifts"), details: None, lo: 26, hi: 31 });
        regs.insert("APC_DFE4_PAR_CFG", Register { addr: Address { base: 41, count: 1, width: 1 }, brief: Some("APC DFE4 Parameter control register"), details: Some("Configuration register for controlled DFE4 parameter. Note, for parameters larger than 8 bits, ini/min/max values are shifted to the left. For parameters smaller than 8 bits only the lower bits of ini/min/max are used."), fields });
        let mut fields = HashMap::new();
        fields.insert("DFE4_OP_TIME", Field { brief: Some("Operation time (in number of rx_clk cycles)"), details: None, lo: 0, hi: 16 });
        fields.insert("DFE4_PS_TIME", Field { brief: Some("Pause time"), details: Some("(in number of rx_clk cycles)"), lo: 16, hi: 32 });
        regs.insert("APC_DFE4_TIMER_CFG", Register { addr: Address { base: 40, count: 1, width: 1 }, brief: Some("APC DFE4 Timer config"), details: Some("Configuration registers for DFE4 controller timing."), fields });
        let mut fields = HashMap::new();
        fields.insert("EQZ_AGC_ACTVAL", Field { brief: Some("Parameter value (controlled/computed value)"), details: None, lo: 16, hi: 26 });
        fields.insert("EQZ_AGC_CTRL_DONE", Field { brief: Some("Parameter control state in one-time mode"), details: Some("1: Finished"), lo: 26, hi: 27 });
        fields.insert("EQZ_AGC_CTRL_MODE", Field { brief: Some("Parameter control mode for EQZ_AGC parameter"), details: Some("0: Discrete 1: Continuous"), lo: 10, hi: 11 });
        fields.insert("EQZ_AGC_CTRL_THRES", Field { brief: Some("Alternative threshold for EQZ_AGC parameter (controller goal: err_cnt = 0.5*EQZ_AGC_THRES)"), details: None, lo: 4, hi: 10 });
        fields.insert("EQZ_AGC_CTRL_THRES_ENA", Field { brief: Some("Enable use of alternative threshold for EQZ_AGC parameter"), details: Some("0: Use default threshold 1: Use alternative threshold"), lo: 3, hi: 4 });
        fields.insert("EQZ_AGC_OP_MODE", Field { brief: Some("Operation mode"), details: Some("0: Off 1: One-time 2: Non-stop 3: Paused"), lo: 0, hi: 2 });
        fields.insert("EQZ_AGC_READ_CNT_SEL", Field { brief: Some("Select counter to be read"), details: Some("0: eqz_agc_value 1: Hit counter 2: Error counter"), lo: 12, hi: 14 });
        fields.insert("EQZ_AGC_RECOVER_MODE", Field { brief: Some("EQZ_AGC recovery behavior"), details: Some("0: No auto-recovery 1: Freeze EQZ_AGC on weak (eqz_gain > eqz_gain_freeze_thres) or missing input signal 2: Freeze EQZ_AGC on weak signal and restart on missing input signal 3: Freeze EQZ_AGC on missing input signal 4: Freeze EQZ_AGC on missing input signal and auto-restart after Restart-Delay-Timer has expired 5: Auto-restart EQZ_AGC on missing input signal 6-7: Reserved"), lo: 27, hi: 30 });
        fields.insert("EQZ_AGC_START_CTRL", Field { brief: Some("Start operation (parameter update). Should be cleared afterwards in One-time mode and stay set in Non-stop and Paused mode"), details: None, lo: 2, hi: 3 });
        fields.insert("EQZ_AGC_SYNC_MODE", Field { brief: Some("Synchronization mode"), details: Some("0: Independent 1: Attached to parctrl FSM 1 2: Attached to parctrl FSM 2 3: Attached to both parctrl FSMs"), lo: 14, hi: 16 });
        regs.insert("APC_EQZ_AGC_CTRL", Register { addr: Address { base: 27, count: 1, width: 1 }, brief: Some("APC EQZ_AGC Control registers"), details: Some("General behavior control for EQZ_AGC parameter control."), fields });
        let mut fields = HashMap::new();
        fields.insert("EQZ_AGC_CHG_MODE", Field { brief: Some("Parameter change mode"), details: Some("0: Automatic update 1: Preset (use EQZ_AGC_INI as fix value internal processing continues) 2: Freeze (internal processing stops parameter stays at current value) 3: No update (internal processing continues but parameter is not updated)"), lo: 24, hi: 26 });
        fields.insert("EQZ_AGC_DIR_SEL", Field { brief: Some("Select parameter update direction"), details: Some("0: Normal 1: Inverted"), lo: 31, hi: 32 });
        fields.insert("EQZ_AGC_INI", Field { brief: Some("Parameter initial value"), details: None, lo: 0, hi: 8 });
        fields.insert("EQZ_AGC_MAX", Field { brief: Some("Maximum value of paramter"), details: None, lo: 16, hi: 24 });
        fields.insert("EQZ_AGC_MIN", Field { brief: Some("Minimum value of paramter"), details: None, lo: 8, hi: 16 });
        fields.insert("EQZ_AGC_RANGE_SEL", Field { brief: Some("Parameter range selection (only when CTRL_MODE = continuous). Value complies to number of left-shifts"), details: None, lo: 26, hi: 31 });
        regs.insert("APC_EQZ_AGC_PAR_CFG", Register { addr: Address { base: 29, count: 1, width: 1 }, brief: Some("APC EQZ_AGC Parameter control register"), details: Some("Configuration register for controlled EQZ_AGC parameter. Note, for parameters larger than 8 bits, ini/min/max values are shifted to the left. For parameters smaller than 8 bits only the lower bits of ini/min/max are used."), fields });
        let mut fields = HashMap::new();
        fields.insert("EQZ_AGC_OP_TIME", Field { brief: Some("Operation time (in number of rx_clk cycles)"), details: None, lo: 0, hi: 16 });
        fields.insert("EQZ_AGC_PS_TIME", Field { brief: Some("Pause time"), details: Some("(in number of rx_clk cycles)"), lo: 16, hi: 32 });
        regs.insert("APC_EQZ_AGC_TIMER_CFG", Register { addr: Address { base: 28, count: 1, width: 1 }, brief: Some("APC EQZ_AGC Timer config"), details: Some("Configuration registers for EQZ_AGC controller timing."), fields });
        let mut fields = HashMap::new();
        fields.insert("EQZ_GAIN_ADJ_HALT", Field { brief: Some("Stop update of gain_adj"), details: None, lo: 10, hi: 11 });
        fields.insert("EQZ_GAIN_ADJ_START_UPDATE", Field { brief: Some("Start (initiate) gain_adj update process (on rising edge of cfg bit)"), details: None, lo: 8, hi: 9 });
        fields.insert("EQZ_GAIN_AUTO_RESTART", Field { brief: Some("Restart gain/gain_adj calibration automatically on rising edge of signal_detect"), details: None, lo: 2, hi: 3 });
        fields.insert("EQZ_GAIN_CAL_MODE", Field { brief: Some("Gain calibration mode"), details: Some("0: Use successive approximation to find required gain 1: use max gain and reduce linearly to find required gain"), lo: 9, hi: 10 });
        fields.insert("EQZ_GAIN_CHG_MODE", Field { brief: Some("Parameter change mode"), details: Some("0: Automatic update 1: Preset (use PAR_INI as fix value internal processing continues) 2: Freeze (internal processing stops parameter stays at current value) 3: No update (internal processing continues but parameter is not updated)"), lo: 0, hi: 2 });
        fields.insert("EQZ_GAIN_FREEZE_THRES", Field { brief: Some("Gain freeze threshold, used in APC recovery mode for low input signals"), details: None, lo: 13, hi: 23 });
        fields.insert("EQZ_GAIN_OP_MODE", Field { brief: Some("Operation mode (only when EQZ_GAIN_STOP_CTRL = 1)"), details: Some("0: Idle 1: Calibrate and work 2: Work"), lo: 4, hi: 6 });
        fields.insert("EQZ_GAIN_RECOVER_MODE", Field { brief: Some("Gain recovery behavior"), details: Some("0: No auto-recovery 1: Freeze gain on missing input signal and auto-restart after Restart-Delay-Timer has expired 2: Auto-restart Gain control on missing input signal 3: Reserved"), lo: 11, hi: 13 });
        fields.insert("EQZ_GAIN_START_CTRL", Field { brief: Some("(Re-)start (initiate) main gain/gain_adj calibration process (on rising edge of cfg bit)"), details: None, lo: 6, hi: 7 });
        fields.insert("EQZ_GAIN_START_UPDATE", Field { brief: Some("Start (initiate) gain update process (on rising edge of cfg bit)"), details: None, lo: 7, hi: 8 });
        fields.insert("EQZ_GAIN_STOP_CTRL", Field { brief: Some("Stop main gain control machine immediately"), details: None, lo: 3, hi: 4 });
        regs.insert("APC_EQZ_COMMON_CFG", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("APC EQZ CTRL config"), details: Some("Configuration register for gain control logic"), fields });
        let mut fields = HashMap::new();
        fields.insert("EQZ_GAIN_ACTVAL", Field { brief: Some("Parameter value (controlled/computed gain value)"), details: None, lo: 6, hi: 16 });
        fields.insert("EQZ_GAIN_ADJ_ACTVAL", Field { brief: Some("Parameter value (controlled/computed gain adjustment value)"), details: None, lo: 16, hi: 23 });
        fields.insert("EQZ_GAIN_CTRL_DONE", Field { brief: Some("Status flag indicating main gain/gain_adj ramp-up process has finished"), details: None, lo: 23, hi: 24 });
        fields.insert("LD_LEV_ACTVAL", Field { brief: Some("Parameter value (controlled/computed level for level-detect logic)"), details: None, lo: 0, hi: 6 });
        regs.insert("APC_EQZ_CTRL_STATUS", Register { addr: Address { base: 12, count: 1, width: 1 }, brief: Some("APC EQZ CTRL status register"), details: Some("Observation register for controlled settings"), fields });
        let mut fields = HashMap::new();
        fields.insert("EQZ_C_ACTVAL", Field { brief: Some("Parameter value (controlled/computed value)"), details: None, lo: 16, hi: 26 });
        fields.insert("EQZ_C_CTRL_DONE", Field { brief: Some("Parameter control state in one-time mode"), details: Some("1: Finished"), lo: 26, hi: 27 });
        fields.insert("EQZ_C_CTRL_MODE", Field { brief: Some("Parameter control mode for EQZ_C parameter"), details: Some("0: Discrete 1: Continuous"), lo: 10, hi: 11 });
        fields.insert("EQZ_C_CTRL_THRES", Field { brief: Some("Alternative threshold for EQZ_C parameter (controller goal: err_cnt = 0.5*EQZ_C_THRES)"), details: None, lo: 4, hi: 10 });
        fields.insert("EQZ_C_CTRL_THRES_ENA", Field { brief: Some("Enable use of alternative threshold for EQZ_C parameter"), details: Some("0: Use default threshold 1: Use alternative threshold"), lo: 3, hi: 4 });
        fields.insert("EQZ_C_OP_MODE", Field { brief: Some("Operation mode"), details: Some("0: Off 1: One-time 2: Non-stop 3: Paused"), lo: 0, hi: 2 });
        fields.insert("EQZ_C_READ_CNT_SEL", Field { brief: Some("Select counter to be read"), details: Some("0: eqz_c_value 1: Hit counter 2: Error counter"), lo: 12, hi: 14 });
        fields.insert("EQZ_C_RECOVER_MODE", Field { brief: Some("EQZ_C recovery behavior"), details: Some("0: No auto-recovery 1: Freeze EQZ_C on weak (eqz_gain > eqz_gain_freeze_thres) or missing input signal 2: Freeze EQZ_C on weak signal and restart on missing input signal 3: Freeze EQZ_C on missing input signal 4: Freeze EQZ_C on missing input signal and auto-restart after Restart-Delay-Timer has expired 5: Auto-restart EQZ_C on missing input signal 6-7: Reserved"), lo: 27, hi: 30 });
        fields.insert("EQZ_C_START_CTRL", Field { brief: Some("Start operation (parameter update). Should be cleared afterwards in One-time mode and stay set in Non-stop and Paused mode"), details: None, lo: 2, hi: 3 });
        fields.insert("EQZ_C_SYNC_MODE", Field { brief: Some("Synchronization mode"), details: Some("0: Independent 1: Attached to parctrl FSM 1 2: Attached to parctrl FSM 2 3: Attached to both parctrl FSMs"), lo: 14, hi: 16 });
        regs.insert("APC_EQZ_C_CTRL", Register { addr: Address { base: 21, count: 1, width: 1 }, brief: Some("APC EQZ_C Control registers"), details: Some("General behavior control for EQZ_C parameter control."), fields });
        let mut fields = HashMap::new();
        fields.insert("EQZ_C_CHG_MODE", Field { brief: Some("Parameter change mode"), details: Some("0: Automatic update 1: Preset (use EQZ_C_INI as fix value internal processing continues) 2: Freeze (internal processing stops parameter stays at current value) 3: No update (internal processing continues but parameter is not updated)"), lo: 24, hi: 26 });
        fields.insert("EQZ_C_DIR_SEL", Field { brief: Some("Select parameter update direction"), details: Some("0: Normal 1: Inverted"), lo: 31, hi: 32 });
        fields.insert("EQZ_C_INI", Field { brief: Some("Parameter initial value"), details: None, lo: 0, hi: 8 });
        fields.insert("EQZ_C_MAX", Field { brief: Some("Maximum value of paramter"), details: None, lo: 16, hi: 24 });
        fields.insert("EQZ_C_MIN", Field { brief: Some("Minimum value of paramter"), details: None, lo: 8, hi: 16 });
        fields.insert("EQZ_C_RANGE_SEL", Field { brief: Some("Parameter range selection (only when CTRL_MODE = continuous). Value complies to number of left-shifts"), details: None, lo: 26, hi: 31 });
        regs.insert("APC_EQZ_C_PAR_CFG", Register { addr: Address { base: 23, count: 1, width: 1 }, brief: Some("APC EQZ_C Parameter control register"), details: Some("Configuration register for controlled EQZ_C parameter. Note, for parameters larger than 8 bits, ini/min/max values are shifted to the left. For parameters smaller than 8 bits only the lower bits of ini/min/max are used."), fields });
        let mut fields = HashMap::new();
        fields.insert("EQZ_C_OP_TIME", Field { brief: Some("Operation time (in number of rx_clk cycles)"), details: None, lo: 0, hi: 16 });
        fields.insert("EQZ_C_PS_TIME", Field { brief: Some("Pause time"), details: Some("(in number of rx_clk cycles)"), lo: 16, hi: 32 });
        regs.insert("APC_EQZ_C_TIMER_CFG", Register { addr: Address { base: 22, count: 1, width: 1 }, brief: Some("APC EQZ_C Timer config"), details: Some("Configuration registers for EQZ_C controller timing."), fields });
        let mut fields = HashMap::new();
        fields.insert("EQZ_GAIN_ADJ_INI", Field { brief: Some("Gain_adj initial value (used if EQZ_GAIN_CHG_MODE = 1)"), details: None, lo: 0, hi: 7 });
        fields.insert("EQZ_GAIN_ADJ_MAX", Field { brief: Some("Maximum gain_adj in normal operation"), details: None, lo: 20, hi: 27 });
        fields.insert("EQZ_GAIN_ADJ_MIN", Field { brief: Some("Minimum gain_adj in normal operation"), details: None, lo: 10, hi: 17 });
        regs.insert("APC_EQZ_GAIN_ADJ_CTRL_CFG", Register { addr: Address { base: 11, count: 1, width: 1 }, brief: Some("APC EQZ ADJ CTRL configuration register"), details: Some("Configuration register for gain_adj"), fields });
        let mut fields = HashMap::new();
        fields.insert("EQZ_GAIN_INI", Field { brief: Some("Gain initial value (used if EQZ_GAIN_CHG_MODE = 1)"), details: None, lo: 0, hi: 10 });
        fields.insert("EQZ_GAIN_MAX", Field { brief: Some("Maximum gain in normal operation (should be not greater then 895 (512+3*128-1)"), details: None, lo: 20, hi: 30 });
        fields.insert("EQZ_GAIN_MIN", Field { brief: Some("Minimum gain in normal operation"), details: None, lo: 10, hi: 20 });
        regs.insert("APC_EQZ_GAIN_CTRL_CFG", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("APC EQZ CTRL configuration register"), details: Some("Configuration register for gain"), fields });
        let mut fields = HashMap::new();
        fields.insert("LD_CATCH_BYPASS", Field { brief: Some("Bypass LD catch circuitry (allows capturing pulses shorter then one rx_clk cycle)"), details: None, lo: 29, hi: 30 });
        fields.insert("LD_EQ_START_TOG_CHK", Field { brief: Some("Start (initiate) a LD-EQ toggle check (for present LD-level)"), details: None, lo: 7, hi: 8 });
        fields.insert("LD_EQ_TOGGLE", Field { brief: Some("Captured toggling of LD-EQ"), details: None, lo: 31, hi: 32 });
        fields.insert("LD_IB_START_TOG_CHK", Field { brief: Some("Start (initiate) a LD-IB toggle check (for present LD-level)"), details: None, lo: 6, hi: 7 });
        fields.insert("LD_IB_TOGGLE", Field { brief: Some("Captured toggling of LD-IB"), details: None, lo: 30, hi: 31 });
        fields.insert("LD_LEV_INI", Field { brief: Some("LD_lev initial value (used as preset value if EQZ_GAIN_CHG_MODE = 1)"), details: None, lo: 0, hi: 6 });
        fields.insert("LD_LEV_UPDATE", Field { brief: Some("Update internal LD_lev value with LD_LEV_INI"), details: None, lo: 8, hi: 9 });
        fields.insert("LD_TOG_THRESHOLD", Field { brief: Some("Number of required toggles before toggling is considered valid"), details: None, lo: 22, hi: 26 });
        fields.insert("LD_T_TOGGLE_DEADTIME", Field { brief: Some("Sensitivity deadtime between two toggles (value is multiplied by 2)"), details: None, lo: 14, hi: 22 });
        fields.insert("LD_WD_CNT_MAX", Field { brief: Some("Max value for LD updates in gain_adjust (watch-dog; prevent endless loop of LD adjustment; max is 2^value - 1)"), details: None, lo: 26, hi: 29 });
        regs.insert("APC_EQZ_LD_CTRL", Register { addr: Address { base: 13, count: 1, width: 1 }, brief: Some("APC EQZ LD control"), details: Some("Configuration register for level-detect (LD) control, timing and behavior (timing: number of rx_clk cycles, used for LD toggling)"), fields });
        let mut fields = HashMap::new();
        fields.insert("LD_T_DEADTIME_WRK", Field { brief: Some("Minimum activity for LD in work mode (value is multiplied by 8)"), details: None, lo: 16, hi: 32 });
        fields.insert("LD_T_TIMEOUT_WRK", Field { brief: Some("Activity timeout threshold for LD in work mode (value is multiplied by 8)"), details: None, lo: 0, hi: 16 });
        regs.insert("APC_EQZ_LD_CTRL_CFG0", Register { addr: Address { base: 14, count: 1, width: 1 }, brief: Some("APC EQZ LD CTRL config0"), details: Some("Configuration register 0 for level-detect (LD) controller timing (number of rx_clk cycles, used for operation timing). Important note: For small ld_t_* values it might be necessary to change IB configuration bit-group IB_LDSD_DIVSEL to higher values!"), fields });
        let mut fields = HashMap::new();
        fields.insert("LD_T_DEADTIME_CAL", Field { brief: Some("Minimum activity for LD in calibration mode (value is multiplied by 8)"), details: None, lo: 16, hi: 32 });
        fields.insert("LD_T_TIMEOUT_CAL", Field { brief: Some("Activity timeout threshold for LD in calibration mode (value is multiplied by 8)"), details: None, lo: 0, hi: 16 });
        regs.insert("APC_EQZ_LD_CTRL_CFG1", Register { addr: Address { base: 15, count: 1, width: 1 }, brief: Some("APC EQZ LD CTRL config1"), details: Some("Configuration register 1 for level-detect (LD) controller timing (number of rx_clk cycles, used for calibration timing). Important note: For small ld_t_* values it might be necessary to change IB configuration bit-group IB_LDSD_DIVSEL to higher values!"), fields });
        let mut fields = HashMap::new();
        fields.insert("EQZ_L_ACTVAL", Field { brief: Some("Parameter value (controlled/computed value)"), details: None, lo: 16, hi: 26 });
        fields.insert("EQZ_L_CTRL_DONE", Field { brief: Some("Parameter control state in one-time mode"), details: Some("1: Finished"), lo: 26, hi: 27 });
        fields.insert("EQZ_L_CTRL_MODE", Field { brief: Some("Parameter control mode for EQZ_L parameter"), details: Some("0: Discrete 1: Continuous"), lo: 10, hi: 11 });
        fields.insert("EQZ_L_CTRL_THRES", Field { brief: Some("Alternative threshold for EQZ_L parameter (controller goal: err_cnt = 0.5*EQZ_L_THRES)"), details: None, lo: 4, hi: 10 });
        fields.insert("EQZ_L_CTRL_THRES_ENA", Field { brief: Some("Enable use of alternative threshold for EQZ_L parameter"), details: Some("0: Use default threshold 1: Use alternative threshold"), lo: 3, hi: 4 });
        fields.insert("EQZ_L_OP_MODE", Field { brief: Some("Operation mode"), details: Some("0: Off 1: One-time 2: Non-stop 3: Paused"), lo: 0, hi: 2 });
        fields.insert("EQZ_L_READ_CNT_SEL", Field { brief: Some("Select counter to be read"), details: Some("0: eqz_l_value 1: Hit counter 2: Error counter"), lo: 12, hi: 14 });
        fields.insert("EQZ_L_RECOVER_MODE", Field { brief: Some("EQZ_L recovery behavior"), details: Some("0: No auto-recovery 1: Freeze EQZ_L on weak (eqz_gain > eqz_gain_freeze_thres) or missing input signal 2: Freeze EQZ_L on weak signal and restart on missing input signal 3: Freeze EQZ_L on missing input signal 4: Freeze EQZ_L on missing input signal and auto-restart after Restart-Delay-Timer has expired 5: Auto-restart EQZ_L on missing input signal 6-7: Reserved"), lo: 27, hi: 30 });
        fields.insert("EQZ_L_START_CTRL", Field { brief: Some("Start operation (parameter update). Should be cleared afterwards in One-time mode and stay set in Non-stop and Paused mode"), details: None, lo: 2, hi: 3 });
        fields.insert("EQZ_L_SYNC_MODE", Field { brief: Some("Synchronization mode"), details: Some("0: Independent 1: Attached to parctrl FSM 1 2: Attached to parctrl FSM 2 3: Attached to both parctrl FSMs"), lo: 14, hi: 16 });
        regs.insert("APC_EQZ_L_CTRL", Register { addr: Address { base: 24, count: 1, width: 1 }, brief: Some("APC EQZ_L Control registers"), details: Some("General behavior control for EQZ_L parameter control."), fields });
        let mut fields = HashMap::new();
        fields.insert("EQZ_L_CHG_MODE", Field { brief: Some("Parameter change mode"), details: Some("0: Automatic update 1: Preset (use EQZ_L_INI as fix value internal processing continues) 2: Freeze (internal processing stops parameter stays at current value) 3: No update (internal processing continues but parameter is not updated)"), lo: 24, hi: 26 });
        fields.insert("EQZ_L_DIR_SEL", Field { brief: Some("Select parameter update direction"), details: Some("0: Normal 1: Inverted"), lo: 31, hi: 32 });
        fields.insert("EQZ_L_INI", Field { brief: Some("Parameter initial value"), details: None, lo: 0, hi: 8 });
        fields.insert("EQZ_L_MAX", Field { brief: Some("Maximum value of paramter"), details: None, lo: 16, hi: 24 });
        fields.insert("EQZ_L_MIN", Field { brief: Some("Minimum value of paramter"), details: None, lo: 8, hi: 16 });
        fields.insert("EQZ_L_RANGE_SEL", Field { brief: Some("Parameter range selection (only when CTRL_MODE = continuous). Value complies to number of left-shifts"), details: None, lo: 26, hi: 31 });
        regs.insert("APC_EQZ_L_PAR_CFG", Register { addr: Address { base: 26, count: 1, width: 1 }, brief: Some("APC EQZ_L Parameter control register"), details: Some("Configuration register for controlled EQZ_L parameter. Note, for parameters larger than 8 bits, ini/min/max values are shifted to the left. For parameters smaller than 8 bits only the lower bits of ini/min/max are used."), fields });
        let mut fields = HashMap::new();
        fields.insert("EQZ_L_OP_TIME", Field { brief: Some("Operation time (in number of rx_clk cycles)"), details: None, lo: 0, hi: 16 });
        fields.insert("EQZ_L_PS_TIME", Field { brief: Some("Pause time"), details: Some("(in number of rx_clk cycles)"), lo: 16, hi: 32 });
        regs.insert("APC_EQZ_L_TIMER_CFG", Register { addr: Address { base: 25, count: 1, width: 1 }, brief: Some("APC EQZ_L Timer config"), details: Some("Configuration registers for EQZ_L controller timing."), fields });
        let mut fields = HashMap::new();
        fields.insert("EQZ_OFFS_ACTVAL", Field { brief: Some("Parameter value (controlled/computed value)"), details: None, lo: 16, hi: 26 });
        fields.insert("EQZ_OFFS_CTRL_DONE", Field { brief: Some("Parameter control state in one-time mode"), details: Some("1: Finished"), lo: 26, hi: 27 });
        fields.insert("EQZ_OFFS_CTRL_MODE", Field { brief: Some("Parameter control mode for EQZ_OFFS parameter"), details: Some("0: Discrete 1: Continuous"), lo: 10, hi: 11 });
        fields.insert("EQZ_OFFS_CTRL_THRES", Field { brief: Some("Alternative threshold for EQZ_OFFS parameter (controller goal: err_cnt = 0.5*EQZ_OFFS_THRES)"), details: None, lo: 4, hi: 10 });
        fields.insert("EQZ_OFFS_CTRL_THRES_ENA", Field { brief: Some("Enable use of alternative threshold for EQZ_OFFS parameter"), details: Some("0: Use default threshold 1: Use alternative threshold"), lo: 3, hi: 4 });
        fields.insert("EQZ_OFFS_OP_MODE", Field { brief: Some("Operation mode"), details: Some("0: Off 1: One-time 2: Non-stop 3: Paused"), lo: 0, hi: 2 });
        fields.insert("EQZ_OFFS_READ_CNT_SEL", Field { brief: Some("Select counter to be read"), details: Some("0: eqz_offs_value 1: Hit counter 2: Error counter"), lo: 12, hi: 14 });
        fields.insert("EQZ_OFFS_RECOVER_MODE", Field { brief: Some("EQZ_OFFS recovery behavior"), details: Some("0: No auto-recovery 1: Freeze EQZ_OFFS on weak (eqz_gain > eqz_gain_freeze_thres) or missing input signal 2: Freeze EQZ_OFFS on weak signal and restart on missing input signal 3: Freeze EQZ_OFFS on missing input signal 4: Freeze EQZ_OFFS on missing input signal and auto-restart after Restart-Delay-Timer has expired 5: Auto-restart EQZ_OFFS on missing input signal 6-7: Reserved"), lo: 27, hi: 30 });
        fields.insert("EQZ_OFFS_START_CTRL", Field { brief: Some("Start operation (parameter update). Should be cleared afterwards in One-time mode and stay set in Non-stop and Paused mode"), details: None, lo: 2, hi: 3 });
        fields.insert("EQZ_OFFS_SYNC_MODE", Field { brief: Some("Synchronization mode"), details: Some("0: Independent 1: Attached to parctrl FSM 1 2: Attached to parctrl FSM 2 3: Attached to both parctrl FSMs"), lo: 14, hi: 16 });
        regs.insert("APC_EQZ_OFFS_CTRL", Register { addr: Address { base: 18, count: 1, width: 1 }, brief: Some("APC EQZ_OFFS Control registers"), details: Some("General behavior control for EQZ_OFFS parameter control."), fields });
        let mut fields = HashMap::new();
        fields.insert("EQZ_OFFS_CHG_MODE", Field { brief: Some("Parameter change mode"), details: Some("0: Automatic update 1: Preset (use EQZ_OFFS_INI as fix value internal processing continues) 2: Freeze (internal processing stops parameter stays at current value) 3: No update (internal processing continues but parameter is not updated)"), lo: 24, hi: 26 });
        fields.insert("EQZ_OFFS_DIR_SEL", Field { brief: Some("Select parameter update direction"), details: Some("0: Normal 1: Inverted"), lo: 31, hi: 32 });
        fields.insert("EQZ_OFFS_INI", Field { brief: Some("Parameter initial value"), details: None, lo: 0, hi: 8 });
        fields.insert("EQZ_OFFS_MAX", Field { brief: Some("Maximum value of paramter"), details: None, lo: 16, hi: 24 });
        fields.insert("EQZ_OFFS_MIN", Field { brief: Some("Minimum value of paramter"), details: None, lo: 8, hi: 16 });
        fields.insert("EQZ_OFFS_RANGE_SEL", Field { brief: Some("Parameter range selection (only when CTRL_MODE = continuous). Value complies to number of left-shifts"), details: None, lo: 26, hi: 31 });
        regs.insert("APC_EQZ_OFFS_PAR_CFG", Register { addr: Address { base: 20, count: 1, width: 1 }, brief: Some("APC EQZ_OFFS Parameter control register"), details: Some("Configuration register for controlled EQZ_OFFS parameter. Note, for parameters larger than 8 bits, ini/min/max values are shifted to the left. For parameters smaller than 8 bits only the lower bits of ini/min/max are used."), fields });
        let mut fields = HashMap::new();
        fields.insert("EQZ_OFFS_OP_TIME", Field { brief: Some("Operation time (in number of rx_clk cycles)"), details: None, lo: 0, hi: 16 });
        fields.insert("EQZ_OFFS_PS_TIME", Field { brief: Some("Pause time"), details: Some("(in number of rx_clk cycles)"), lo: 16, hi: 32 });
        regs.insert("APC_EQZ_OFFS_TIMER_CFG", Register { addr: Address { base: 19, count: 1, width: 1 }, brief: Some("APC EQZ_OFFS Timer config"), details: Some("Configuration registers for EQZ_OFFS controller timing."), fields });
        let mut fields = HashMap::new();
        fields.insert("EQZ_C_PAT_MASK", Field { brief: Some("EQZ-C-control pattern mask (only those bits are used for pattern matching whose mask bit is set)"), details: None, lo: 24, hi: 32 });
        fields.insert("EQZ_C_PAT_MATCH", Field { brief: Some("EQZ-C-control pattern used for pattern matching (corresponding mask bits must be set)"), details: None, lo: 16, hi: 24 });
        fields.insert("EQZ_L_PAT_MASK", Field { brief: Some("EQZ-L-control pattern mask (only those bits are used for pattern matching whose mask bit is set)"), details: None, lo: 8, hi: 16 });
        fields.insert("EQZ_L_PAT_MATCH", Field { brief: Some("EQZ-L-control pattern used for pattern matching (corresponding mask bits must be set)"), details: None, lo: 0, hi: 8 });
        regs.insert("APC_EQZ_PAT_MATCH_CFG0", Register { addr: Address { base: 16, count: 1, width: 1 }, brief: Some("APC EQZ Pattern matching cfg register0"), details: Some("Pattern matching configuration register for eqz_c and eqz_l control"), fields });
        let mut fields = HashMap::new();
        fields.insert("EQZ_AGC_PAT_MASK", Field { brief: Some("EQZ-AGC-control pattern mask (only those bits are used for pattern matching whose mask bit is set)"), details: None, lo: 8, hi: 16 });
        fields.insert("EQZ_AGC_PAT_MATCH", Field { brief: Some("EQZ-AGC-control pattern used for pattern matching (corresponding mask bits must be set)"), details: None, lo: 0, hi: 8 });
        fields.insert("EQZ_OFFS_PAT_MASK", Field { brief: Some("EQZ-Offset-control pattern mask (only those bits are used for pattern matching whose mask bit is set)"), details: None, lo: 24, hi: 32 });
        fields.insert("EQZ_OFFS_PAT_MATCH", Field { brief: Some("EQZ-Offset-control pattern used for pattern matching (corresponding mask bits must be set)"), details: None, lo: 16, hi: 24 });
        regs.insert("APC_EQZ_PAT_MATCH_CFG1", Register { addr: Address { base: 17, count: 1, width: 1 }, brief: Some("APC EQZ Pattern matching cfg register1"), details: Some("Pattern matching configuration register for eqz_offs and eqz_agc control Note, if mask is set to 0, all bits are \"matching\" and taken into account for parameter contol."), fields });
        let mut fields = HashMap::new();
        fields.insert("APC_CTRL_CNTVAL", Field { brief: Some("Current counter value"), details: None, lo: 0, hi: 32 });
        regs.insert("APC_FLEXCTRL_CNT_STATUS", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("APC FLEXCTRL read counter register"), details: Some("Observation register for multiple counters. The selection is done via APC_COMMON_CFG0.BLOCK_READ_SEL (select flexctrl block to be read) and APC_XXX_CTRL.XXX_READ_CNT_SEL (counter within flexctrl block XXX) or APC_COMMON_CFG0.OFFSCAL_READ_CNT_SEL. Notice that for EQZ and DFE counters hit_cnt and err_cnt make only sense in DISCRETE control mode."), fields });
        let mut fields = HashMap::new();
        fields.insert("CPMD_THRES_INIT", Field { brief: Some("Initial value for CP/MD FF threshold calibration."), details: None, lo: 14, hi: 20 });
        fields.insert("IB_DFE_GAIN_ADJ", Field { brief: Some("Gain adjustent for DFE amplifier"), details: None, lo: 20, hi: 26 });
        fields.insert("SKIP_DFE_BUFFER_CAL", Field { brief: Some("Skip DFE buffer 0db calibration"), details: None, lo: 0, hi: 1 });
        fields.insert("SKIP_DFE_BUFFER_INIT", Field { brief: Some("Skip DFE buffer 0db initialization"), details: None, lo: 4, hi: 5 });
        fields.insert("SKIP_OBSERVE_CAL", Field { brief: Some("Skip observe block calibration"), details: None, lo: 3, hi: 4 });
        fields.insert("SKIP_OBSERVE_INIT", Field { brief: Some("Skip observe block initialization"), details: None, lo: 7, hi: 8 });
        fields.insert("SKIP_OFFSET_CAL", Field { brief: Some("Skip sample FF offset calibration"), details: None, lo: 2, hi: 3 });
        fields.insert("SKIP_OFFSET_INIT", Field { brief: Some("Skip sample FF offset initialization"), details: None, lo: 6, hi: 7 });
        fields.insert("SKIP_THRESHOLD_CAL", Field { brief: Some("Skip sample FF threshold calibration"), details: None, lo: 1, hi: 2 });
        fields.insert("SKIP_THRESHOLD_INIT", Field { brief: Some("Skip sample FF threshold initialization"), details: None, lo: 5, hi: 6 });
        fields.insert("VSC_THRES_INIT", Field { brief: Some("Initial value for VScope FF threshold calibration."), details: None, lo: 8, hi: 14 });
        regs.insert("APC_IS_CAL_CFG0", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("APC sampling stage calibration configuration register 0"), details: Some("Configuration register 0 for APC sampling stage calibrations logic"), fields });
        let mut fields = HashMap::new();
        fields.insert("CAL_NUM_ITERATIONS", Field { brief: Some("Controls number of calibrations iterations to settle values that depend on each other (offset vs threshold). Coding number of iterations = cal_num_iterations + 1."), details: None, lo: 16, hi: 20 });
        fields.insert("CAL_RAMP_SEL", Field { brief: Some("Selects ramp used to calculate calibration value. Coding: 0: both, 1: rising, 2: falling, 3: reserved."), details: None, lo: 20, hi: 22 });
        fields.insert("CAL_VSC_OFFSET_TGT", Field { brief: Some("Controls the offset calibration target of the VScope FFs. Coding: 0: calibration target is zero, 1: calibration target is the programmed VScope threshold."), details: None, lo: 15, hi: 16 });
        fields.insert("EQZ_AGC_DAC_VAL", Field { brief: Some("AGC-DAC value used for DFE 0dB calibration during IB-calibration process"), details: None, lo: 24, hi: 32 });
        fields.insert("OFFSCAL_DIS_SWAP", Field { brief: Some("Swaps disp with disn used during calibration"), details: None, lo: 2, hi: 3 });
        fields.insert("OFFSCAL_DONE", Field { brief: Some("Offset calibration state"), details: Some("1: finished"), lo: 1, hi: 2 });
        fields.insert("OFFSCAL_READ_CNT_SEL", Field { brief: Some("Select offset calibration result to be read (BLOCK_READ_SEL = 8 required)"), details: None, lo: 3, hi: 8 });
        fields.insert("PAR_DATA_NUM_ONES_THRES", Field { brief: Some("Selects the number of ones threshold when using parallel data. Value for rising ramp from zero to one. The value for the falling ramp (one -> zero) is half the interface width minus par_data_num_ones_thres."), details: None, lo: 9, hi: 14 });
        fields.insert("PAR_DATA_SEL", Field { brief: Some("Controls whether the parallel data from the deserializer or the signal from the observe multiplexer in the sample stage is used. Coding: 0: observe multiplexer, 1: parallel data."), details: None, lo: 8, hi: 9 });
        fields.insert("PAR_DATA_SWAP_EVEN_ODD", Field { brief: Some("Swaps the mapping of even resp. odd bits of parallel data to the every two sample FFs of the DDR sampling stage."), details: None, lo: 14, hi: 15 });
        fields.insert("START_OFFSCAL", Field { brief: Some("Start offset calibration process (sampling stage; only in manual mode, see apc_mode)"), details: None, lo: 0, hi: 1 });
        fields.insert("USE_AGC_DAC_VAL", Field { brief: Some("Enable use of EQZ_AGC_DAC_VAL instead of EQZ_AGC_INI during DFE 0dB IB calibration"), details: None, lo: 23, hi: 24 });
        regs.insert("APC_IS_CAL_CFG1", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("APC sampling stage calibration configuration register 1"), details: Some("Configuration register 1 for APC sampling stage calibrations logic"), fields });
        let mut fields = HashMap::new();
        fields.insert("LC_SC_AGC_THRESHOLD", Field { brief: Some("EQZ_AGC threshold for mandatory increase of L and C. If EQZ_AGC > (128+LC_SC_AGC_THRESHOLD) then L and C control values are increased."), details: Some("0: 128 1: 129 ... 127: 255"), lo: 9, hi: 16 });
        fields.insert("LC_SC_AVGSHFT", Field { brief: Some("DFE1/2 and EQZ_AGC averaging behavior. DFE/AGC parameters are averaged over 2^(8+LC_SC_AVGSHFT) input values."), details: Some("0: Average over 256 values 1: Average over 512 values ..."), lo: 24, hi: 28 });
        fields.insert("LC_SC_DFE1_THRESHOLD", Field { brief: Some("DFE1 comparison threshold for L-control used in mode 2. EQZ_L is increased/decreased if DFE1 differs from neutral value by more than LC_SC_DFE1_THRESHOLD."), details: None, lo: 20, hi: 24 });
        fields.insert("LC_SC_DFE2_THRESHOLD", Field { brief: Some("DFE2 comparison threshold for C-control used in mode 2. EQZ_C is increased/decreased if DFE1 differs from neutral value by more than LC_SC_DFE2_THRESHOLD."), details: None, lo: 16, hi: 20 });
        fields.insert("LC_SC_DIV_C", Field { brief: Some("Select divider for C-control used in mode 1 (Divider = 4+LC_SC_DIV_C)"), details: Some("0: Divide by 4 1: Devide by 5 ... 7: Devide by 11"), lo: 2, hi: 5 });
        fields.insert("LC_SC_DIV_C_SEL", Field { brief: Some("Define DFE2 comparison parameter for EQZ_C control in mode 1"), details: Some("0: EQZ_L 1: EQZ_C"), lo: 8, hi: 9 });
        fields.insert("LC_SC_DIV_L", Field { brief: Some("Select divider for L-control used in mode 1 (Divider = 4+LC_SC_DIV_L)"), details: Some("0: Divide by 4 1: Devide by 5 ... 7: Devide by 11"), lo: 5, hi: 8 });
        fields.insert("LC_SC_MODE", Field { brief: Some("Select LC soft-control mode. LC soft-control modes must be enabled first after INI/MIN/MAX values of all parameters have been programmed."), details: Some("0: Disabled 1: Mode 1 2: Mode 2 3: Reserved"), lo: 0, hi: 2 });
        fields.insert("LC_SC_TIMER", Field { brief: Some("Operation timer configuration: L/C-control operates in every 2^(2*LC_SC_TIMER)-th clock cycle."), details: Some("0: Operate every clock cycle 1: Operate every 4th clock cycle 2: Operate every 16th clock cycle ..."), lo: 28, hi: 32 });
        regs.insert("APC_LC_SOFTCTRL_CFG", Register { addr: Address { base: 42, count: 1, width: 1 }, brief: Some("APC LC softcontrol configuration register"), details: Some("Configuration register 0 for the LC-Softcontrol logic block. The L and C paramters can be controlled depending on DFE1 and DFE2 and EQZ_AGC parameters instead of pattern matching."), fields });
        let mut fields = HashMap::new();
        fields.insert("CAL_CLK_DIV", Field { brief: Some("Calibration clock divider. Clock used in calibration blocks is divided by 2^(2*CAL_CLK_DIV)"), details: Some("0: No clock division 1: Clock is divided by 4 2: Clock is divided by 16 ... 7: Clock is divided by 16384"), lo: 28, hi: 31 });
        fields.insert("DETLEV_CAL_DONE", Field { brief: Some("Detect level calibration state"), details: Some("1: finished"), lo: 19, hi: 20 });
        fields.insert("DETLVL_TIMER", Field { brief: Some("Timer for calibration process"), details: Some("14: Use for 400MHz rx_clk"), lo: 1, hi: 5 });
        fields.insert("IE_SDET_LEVEL", Field { brief: Some("Level for IE signal detect (when controlled by APC)"), details: Some("0: 20mV"), lo: 5, hi: 11 });
        fields.insert("SKIP_LD_CAL", Field { brief: Some("Skip level detect calibration"), details: None, lo: 11, hi: 12 });
        fields.insert("SKIP_SDET_CAL", Field { brief: Some("Skip signal detect calibration"), details: None, lo: 12, hi: 13 });
        fields.insert("START_DETLVL_CAL", Field { brief: Some("Start signal and level detect calibration process (sampling stage; only in manual mode, see apc_mode)"), details: None, lo: 0, hi: 1 });
        regs.insert("APC_LD_CAL_CFG", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("APC level detect calibration configuration register"), details: Some("Configuration register for APC level detect calibrations logic"), fields });
        let mut fields = HashMap::new();
        fields.insert("FSM1_OP_TIME", Field { brief: Some("FSM1 Operation time (in number of rx_clk cycles)"), details: None, lo: 0, hi: 16 });
        fields.insert("FSM1_PS_TIME", Field { brief: Some("FSM1 Pause time"), details: Some("(in number of rx_clk cycles)"), lo: 16, hi: 32 });
        regs.insert("APC_PARCTRL_FSM1_TIMER_CFG", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("APC parctrl FSM1 Timer config"), details: Some("Timing configuration register for common flexible parameter control FSM1"), fields });
        let mut fields = HashMap::new();
        fields.insert("FSM2_OP_TIME", Field { brief: Some("FSM2 Operation time (in number of rx_clk cycles)"), details: None, lo: 0, hi: 16 });
        fields.insert("FSM2_PS_TIME", Field { brief: Some("FSM2 Pause time"), details: Some("(in number of rx_clk cycles)"), lo: 16, hi: 32 });
        regs.insert("APC_PARCTRL_FSM2_TIMER_CFG", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("APC parctrl FSM2 Timer config"), details: Some("Timing configuration register for common flexible parameter control FSM2"), fields });
        let mut fields = HashMap::new();
        fields.insert("APC_SPARE_POOL", Field { brief: Some("APC spare register pool"), details: None, lo: 28, hi: 32 });
        fields.insert("FSM1_CTRL_DONE", Field { brief: Some("Parameter control state of FSM1 in one-time mode"), details: Some("1: finished"), lo: 3, hi: 4 });
        fields.insert("FSM1_CTRL_MODE", Field { brief: Some("Parameter control mode for FSM1"), details: Some("0: Discrete 1: Continuous"), lo: 14, hi: 15 });
        fields.insert("FSM1_OP_MODE", Field { brief: Some("Operation mode of FSM1"), details: Some("0: Off 1: One-time 2: Non-stop 3: Paused"), lo: 0, hi: 2 });
        fields.insert("FSM1_RECOVER_MODE", Field { brief: Some("FSM1 recovery behavior"), details: Some("0: No auto-recovery 1: Freeze FSM1 on weak (eqz_gain > eqz_gain_freeze_thres) or missing input signal 2: Freeze FSM1 on weak signal and restart on missing input signal 3: Freeze FSM1 on missing input signal 4: Freeze FSM1 on missing input signal and auto-restart after Restart-Delay-Timer has expired 5: Auto-restart FSM1 on missing input signal 6-7: Reserved"), lo: 8, hi: 11 });
        fields.insert("FSM1_START_CTRL", Field { brief: Some("Start operation of FSM1 (parameter update). Should be cleared afterwards in One-time mode and stay set in Non-stop and Paused mode"), details: None, lo: 2, hi: 3 });
        fields.insert("FSM2_CTRL_DONE", Field { brief: Some("Parameter control state of FSM2 in one-time mode"), details: Some("1: finished"), lo: 7, hi: 8 });
        fields.insert("FSM2_CTRL_MODE", Field { brief: Some("Parameter control mode for FSM2"), details: Some("0: Discrete 1: Continuous"), lo: 15, hi: 16 });
        fields.insert("FSM2_OP_MODE", Field { brief: Some("Operation mode of FSM2"), details: Some("0: Off 1: One-time 2: Non-stop 3: Paused"), lo: 4, hi: 6 });
        fields.insert("FSM2_RECOVER_MODE", Field { brief: Some("FSM2 recovery behavior"), details: Some("0: No auto-recovery 1: Freeze FSM2 on weak (eqz_gain > eqz_gain_freeze_thres) or missing input signal 2: Freeze FSM2 on weak signal and restart on missing input signal 3: Freeze FSM2 on missing input signal 4: Freeze FSM2 on missing input signal and auto-restart after Restart-Delay-Timer has expired 5: Auto-restart FSM2 on missing input signal 6-7: Reserved"), lo: 11, hi: 14 });
        fields.insert("FSM2_START_CTRL", Field { brief: Some("Start operation of FSM2 (parameter update). Should be cleared afterwards in One-time mode and stay set in Non-stop and Paused mode"), details: None, lo: 6, hi: 7 });
        regs.insert("APC_PARCTRL_SYNC_CFG", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("APC parameter control synchronization register"), details: Some("Configuration register for common flexible parameter control FSMs"), fields });
        let mut fields = HashMap::new();
        fields.insert("PWR_DN_TIME", Field { brief: Some("Delay time required to power down auxilliary channels"), details: None, lo: 16, hi: 24 });
        fields.insert("PWR_UP_TIME", Field { brief: Some("Delay time required to power up auxilliary channels"), details: None, lo: 24, hi: 32 });
        fields.insert("SLEEP_TIME", Field { brief: Some("APC top-control sleep-time (power-down). Given in number of clock cycles (typically 2.5 ... 5 ns)"), details: None, lo: 0, hi: 16 });
        regs.insert("APC_TOP_CTRL_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("APC top control configuration register"), details: Some("Configuration register for top control logic"), fields });
        groups.insert("SD10G65_APC", RegisterGroup { addr: Address { base: 0, count: 1, width: 44 }, desc: "SD10G65 APC Configuration and Status Register set", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("MAX_BIST_FRAMES_CFG", Field { brief: Some("BIST FSM: threshold to enter FINISHED state (refer to cfg field frame_len_cfg)"), details: Some("N: time = (N+1) * (frame_len_cfg+1) 40-bit clock cycles"), lo: 0, hi: 16 });
        fields.insert("WAKEUP_DLY_CFG", Field { brief: Some("BIST FSM: threshold to leave DOZE state"), details: Some("N: time = (N+1) 40-bit clock cycles"), lo: 16, hi: 32 });
        regs.insert("DFT_BIST_CFG0", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("DFT BIST configuration register 0"), details: Some("BIST configuration register for SD10G65 DFT controlling 'check and wait-stable' mode. The length of a '40-bit clock cycle' is defined by 40 divided by the chosen bit rate per second."), fields });
        let mut fields = HashMap::new();
        fields.insert("MAX_UNSTABLE_CYC_CFG", Field { brief: Some("BIST FSM: threshold to iterate counter for max_stable_attempts"), details: Some("N: attempts = (N+1)"), lo: 16, hi: 32 });
        fields.insert("STABLE_THRES_CFG", Field { brief: Some("BIST FSM: threshold to enter CHECK state"), details: Some("N: time = (N+1) 40-bit clock cycles"), lo: 0, hi: 16 });
        regs.insert("DFT_BIST_CFG1", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("DFT BIST configuration register 1"), details: Some("BIST configuration register for SD10G65 DFT\tcontrolling 'stable' mode. The length of a '40-bit clock cycle' is defined by 40 divided by the chosen bit rate per second."), fields });
        let mut fields = HashMap::new();
        fields.insert("FRAME_LEN_CFG", Field { brief: Some("BIST FSM: threshold to iterate counter for max_bist_frames (refer to cfg field max_bist_frames_cfg)"), details: Some("N: multiplier = (N+1)"), lo: 0, hi: 32 });
        regs.insert("DFT_BIST_CFG2", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("DFT BIST configuration register 2"), details: Some("BIST configuration register for SD10G65 DFT controlling frame length in 'check' mode."), fields });
        let mut fields = HashMap::new();
        fields.insert("MAX_STABLE_ATTEMPTS_CFG", Field { brief: Some("BIST FSM: threshold to enter SYNC_ERR state"), details: Some("N: attempts = (N+1)"), lo: 0, hi: 32 });
        regs.insert("DFT_BIST_CFG3", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("DFT BIST configuration register 3"), details: Some("BIST configuration register for SD10G65 DFT controlling stable attempts in ' wait-stable' mode."), fields });
        let mut fields = HashMap::new();
        fields.insert("CLK_CMP_DIV_RX", Field { brief: Some("Clock compare divider for RX clock"), details: Some("0: rx clk 1: rx_clk/2 2: rx_clk/4 3: rx_clk/8"), lo: 4, hi: 6 });
        fields.insert("CLK_CMP_DIV_TX", Field { brief: Some("Clock compare divider for TX clock"), details: Some("0: tx clk 1: tx_clk/2 2: tx_clk/4 3: tx_clk/8"), lo: 6, hi: 8 });
        fields.insert("CLK_CMP_ENA", Field { brief: Some("Enable clock comparison (enabling automatically clears comparison counter)"), details: None, lo: 0, hi: 1 });
        fields.insert("CLK_CMP_MODE", Field { brief: Some("Clock comparison mode"), details: Some("0: single shot 1: continuous"), lo: 1, hi: 2 });
        fields.insert("CLK_CMP_SEL", Field { brief: Some("Clock compare selection"), details: Some("0: rx_clk vs. tx_clk 1: rx_clk 2: tx_clk 3: Reserved"), lo: 2, hi: 4 });
        fields.insert("CLK_CMP_UPDTOG", Field { brief: Some("Clock compare value updated toggle bit. Toggles on each update of CLK_CMP_VALUE"), details: None, lo: 16, hi: 17 });
        fields.insert("CLK_CMP_WRAP_ENA", Field { brief: Some("Enable clock comparison counter wrap"), details: Some("0: counter saturates 1: counter wraps"), lo: 8, hi: 9 });
        regs.insert("DFT_CLK_CMP_CFG", Register { addr: Address { base: 13, count: 1, width: 1 }, brief: Some("DFT clock compare config"), details: Some("Configuration register for Clock Compare logic. Compared clocks are always divided by 4 before any further processing. A clock edge on tx_clk increments the counter, a clock edge on rx_clk decrements the counter. If only one clock is selected for clock comparison, the number of clock cycles within a given time can be measured."), fields });
        let mut fields = HashMap::new();
        fields.insert("CLK_CMP_MAXVAL", Field { brief: Some("Clock comparison max value (maximum measured difference between clk0 and clk1)"), details: None, lo: 0, hi: 32 });
        regs.insert("DFT_CLK_CMP_MAXVAL", Register { addr: Address { base: 16, count: 1, width: 1 }, brief: Some("DFT clock comparison maximum value"), details: Some("Clock comparison max result. Can be used to judge e.g. SSC clock deviation. This register is updated after clock comparison timer has expired. In continuous mode this register is periodically updated."), fields });
        let mut fields = HashMap::new();
        fields.insert("CLK_CMP_TIMER", Field { brief: Some("Clock comparison timer. Counter interval is N + 1 core clock cycles."), details: None, lo: 0, hi: 32 });
        regs.insert("DFT_CLK_CMP_TIMER", Register { addr: Address { base: 14, count: 1, width: 1 }, brief: Some("DFT clock compare timer"), details: Some("Clock comparison timer. After timer has expired, current clock comparison value is stored. The timer is clocked with core_clk (typically f=250MHz or 4ns period)"), fields });
        let mut fields = HashMap::new();
        fields.insert("CLK_CMP_VALUE", Field { brief: Some("Clock comparison value (difference between clk0 and clk1)"), details: None, lo: 0, hi: 32 });
        regs.insert("DFT_CLK_CMP_VALUE", Register { addr: Address { base: 15, count: 1, width: 1 }, brief: Some("DFT clock comparison value"), details: Some("Clock comparison result. This register is updated after clock comparison timer has expired. In continuous mode this register is periodically updated."), fields });
        let mut fields = HashMap::new();
        fields.insert("ERR_CNT", Field { brief: Some("Counter output depending on cnt_cfg"), details: None, lo: 0, hi: 32 });
        regs.insert("DFT_ERR_STAT", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("DFT error status register"), details: Some("Status register for SD10G65 DFT containing the error counter value"), fields });
        let mut fields = HashMap::new();
        fields.insert("ACTIVE", Field { brief: Some("BIST is active (i.e. left DOZE but did not enter a final state)"), details: None, lo: 0, hi: 1 });
        fields.insert("CMP_DATA_STAT", Field { brief: Some("10 bits data word at address 'read_addr_cfg' used for further observation by SW"), details: None, lo: 8, hi: 18 });
        fields.insert("INCOMPLETE", Field { brief: Some("BIST not complete (i.e. not reached stable state or following)"), details: None, lo: 1, hi: 2 });
        fields.insert("INSTABLE", Field { brief: Some("BIST: input data not stable"), details: None, lo: 2, hi: 3 });
        fields.insert("NO_SYNC", Field { brief: Some("BIST: no sync found since BIST enabled"), details: None, lo: 3, hi: 4 });
        fields.insert("STUCK_AT_01", Field { brief: Some("Data input is constantly 0 or constantly 1 for all 40 parallel bits for at least 7 clock cycles (defined by c_STCK_CNT_THRES)"), details: None, lo: 4, hi: 5 });
        fields.insert("STUCK_AT_PAR", Field { brief: Some("Data input is unchanged for all 40 parallel bits for at least 7 clock cycles (defined by c_STCK_CNT_THRES)"), details: None, lo: 5, hi: 6 });
        regs.insert("DFT_MAIN_STAT", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("DFT miscellaneous status register"), details: Some("Status register for SD10G65 DFT"), fields });
        let mut fields = HashMap::new();
        fields.insert("PRBS_DATA_STAT", Field { brief: Some("PRBS data after first sync lost"), details: None, lo: 0, hi: 32 });
        regs.insert("DFT_PRBS_STAT", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("DFT PRBS status register"), details: Some("Status register for SD10G65 DFT containing the PRBS data related to 1st sync lost event"), fields });
        let mut fields = HashMap::new();
        fields.insert("BIST_CNT_CFG", Field { brief: Some("States in which error counting is enabled"), details: Some("3:all but IDLE; 2:check 1:stable+check 0:wait_stable+stable+check"), lo: 20, hi: 22 });
        fields.insert("BIST_MODE_CFG", Field { brief: Some("BIST mode"), details: Some("0: off 1: BIST 2: BER 3:CONT (infinite mode)"), lo: 1, hi: 3 });
        fields.insert("CHK_MODE_CFG", Field { brief: Some("Selects pattern to check"), details: Some("0: PRBS pattern 1: constant pattern"), lo: 18, hi: 19 });
        fields.insert("CMP_MODE_CFG", Field { brief: Some("Selects compare mode"), details: Some("0: compare mode possible 1 learn mode is forced"), lo: 9, hi: 10 });
        fields.insert("CNT_CFG", Field { brief: Some("Selects modes in which error counter is active"), details: Some("0:learn and compare mode 1:transition between modes 2:learn mode 3:compare mode"), lo: 3, hi: 5 });
        fields.insert("CNT_RST", Field { brief: Some("SW reset of error counter; rising edge activates reset"), details: None, lo: 5, hi: 6 });
        fields.insert("DFT_RX_ENA", Field { brief: Some("Enable RX DFT capability"), details: Some("0: Disable DFT 1: Enable DFT"), lo: 0, hi: 1 });
        fields.insert("DIRECT_THROUGH_ENA_CFG", Field { brief: Some("Enables data through from gearbox to gearbox"), details: None, lo: 25, hi: 26 });
        fields.insert("ERR_CNT_CAPT_CFG", Field { brief: Some("Captures data from error counter to allow reading of stable data"), details: None, lo: 24, hi: 25 });
        fields.insert("FREEZE_PATTERN_CFG", Field { brief: Some("Disable change of stored patterns (e.g. to avoid changes during read-out)"), details: None, lo: 19, hi: 20 });
        fields.insert("INV_ENA_CFG", Field { brief: Some("Enables PRBS checker input inversion"), details: None, lo: 10, hi: 11 });
        fields.insert("LRN_CNT_CFG", Field { brief: Some("Number of consecutive errors/non-errors before transitioning to respective state"), details: Some("value = num-40-bits-words + 1"), lo: 6, hi: 9 });
        fields.insert("RX_DATA_SRC_SEL", Field { brief: Some("Data source selection"), details: Some("0: main path 1: vscope high path 2: vscope low path"), lo: 22, hi: 24 });
        fields.insert("RX_PRBS_SEL_CFG", Field { brief: Some("Selects PRBS check"), details: Some("0: prbs7 1: prbs15 2: prbs23 3: prbs11 4: prbs31 (default) 5: prbs9"), lo: 11, hi: 14 });
        fields.insert("RX_WID_SEL_CFG", Field { brief: Some("Selects DES interface width"), details: Some("0:8 1:10 2:16 3:20 4:32 5:40 (default)"), lo: 15, hi: 18 });
        fields.insert("RX_WORD_MODE_CFG", Field { brief: Some("Pattern generator: 0:bytes mode; 1:10-bits word mode"), details: None, lo: 14, hi: 15 });
        fields.insert("STUCK_AT_01_MASK_CFG", Field { brief: Some("Disables error generation based on stuck_at_01 errors,"), details: Some("0: stuck_at_01 error generates 63 errors per clock cycle (in PRBS mode only) 1: stuck_at_01 error does not generate errors"), lo: 26, hi: 27 });
        fields.insert("STUCK_AT_PAR_MASK_CFG", Field { brief: Some("Disables error generation based on stuck_at_par errors,"), details: Some("0: stuck_at_par error generates 63 errors per clock cycle (in PRBS mode only) 1: stuck_at_par error does not generate errors"), lo: 27, hi: 28 });
        regs.insert("DFT_RX_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("DFT Main configuration register"), details: Some("Main configuration register for SD10G65 DFT."), fields });
        let mut fields = HashMap::new();
        fields.insert("LSB_MASK_CFG", Field { brief: Some("Mask out (active high) errors in 32 LSB data bits"), details: None, lo: 0, hi: 32 });
        regs.insert("DFT_RX_MASK_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("DFT pattern mask configuration register"), details: Some("Configuration register for SD10G65 DFT to mask data bits preventing error counting for these bits."), fields });
        let mut fields = HashMap::new();
        fields.insert("MAX_ADDR_CHK_CFG", Field { brief: Some("Maximum address in Checker (before continuing with address 0)"), details: None, lo: 8, hi: 12 });
        fields.insert("MSB_MASK_CFG", Field { brief: Some("Mask out (active high) errors in 8 MSB data bits"), details: None, lo: 24, hi: 32 });
        fields.insert("PAT_READ_CFG", Field { brief: Some("Pattern read enable"), details: None, lo: 16, hi: 17 });
        fields.insert("READ_ADDR_CFG", Field { brief: Some("Address to read patterns from used by SW"), details: None, lo: 0, hi: 4 });
        regs.insert("DFT_RX_PAT_CFG", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("DFT Pattern checker configuration register"), details: Some("Pattern checker configuration register for SD10G65 DFT."), fields });
        let mut fields = HashMap::new();
        fields.insert("DFT_TX_ENA", Field { brief: Some("Enable TX DFT capability"), details: Some("0: Disable DFT 1: Enable DFT"), lo: 0, hi: 1 });
        fields.insert("IPATH_CFG", Field { brief: Some("Selects PRBS generator input"), details: Some("0:pat-gen 1:core"), lo: 4, hi: 5 });
        fields.insert("OPATH_CFG", Field { brief: Some("Selects DFT-TX output"), details: Some("0:PRBS/scrambler (default) 1:bypass 2:clock pattern generator"), lo: 2, hi: 4 });
        fields.insert("RST_ON_STUCK_AT_CFG", Field { brief: Some("Enables (1) reset of PRBS generator in case of unchanged data ('stuck-at') for at least 511 clock cycles. Can be disabled (0) e.g. in scrambler mode to avoid the very rare case that input patterns allow to keep the generator's shift register filled with a constant value."), details: None, lo: 12, hi: 13 });
        fields.insert("SCRAM_INV_CFG", Field { brief: Some("Inverts the scrambler output"), details: None, lo: 5, hi: 6 });
        fields.insert("TX_PRBS_SEL_CFG", Field { brief: Some("Selects PRBS generator"), details: Some("0: prbs7 1: prbs15 2: prbs23 3: prbs11 4: prbs31 (default) 5: prbs9"), lo: 6, hi: 9 });
        fields.insert("TX_WID_SEL_CFG", Field { brief: Some("Selects SER interface width"), details: Some("0:8 1:10 2:16 3:20 4:32 5:40 (default)"), lo: 9, hi: 12 });
        fields.insert("TX_WORD_MODE_CFG", Field { brief: Some("Word width of constant pattern generator"), details: Some("0:bytes mode; 1:10-bits word mode"), lo: 1, hi: 2 });
        regs.insert("DFT_TX_CFG", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("DFT Main configuration register"), details: Some("Main configuration register for SD10G65 DFT."), fields });
        let mut fields = HashMap::new();
        fields.insert("PAT_STAT", Field { brief: Some("10 bits data word at address 'store_addr_cfg' used for further observation by SW"), details: None, lo: 0, hi: 10 });
        fields.insert("TX_STUCK_AT_STICKY", Field { brief: Some("Scrambler/PRBS generator output unchanged for at least 511 clock cycles"), details: None, lo: 12, hi: 13 });
        regs.insert("DFT_TX_CMP_DAT_STAT", Register { addr: Address { base: 12, count: 1, width: 1 }, brief: Some("DFT TX constant pattern status register"), details: Some("Status register for SD10G65 DFT containing the constant patterns used for comparison (last in LEARN mode)"), fields });
        let mut fields = HashMap::new();
        fields.insert("CG_TIMER_CFG", Field { brief: Some("Preload value for clock generator timer (refer also to configuration field cg_mode_cfg)."), details: None, lo: 22, hi: 32 });
        fields.insert("ERR_FREQ_CFG", Field { brief: Some("Frequency of continous/limited error insertion in steps of 40 bits (refer also to err_posit_offs_cfg)"), details: Some("0: disable continous insertion 1-15: step between 2 errors = 2^(err_freq_cfg + 5) 40 bit words"), lo: 16, hi: 20 });
        fields.insert("ERR_POSIT_CFG", Field { brief: Some("Position within 40 bit word where an error is inserted by inverting the bit value"), details: Some("0: LSB 39: MSB 40-63: reserved"), lo: 10, hi: 16 });
        fields.insert("ERR_POSIT_OFFS_CFG", Field { brief: Some("Offset of bit position increased per inserted error; allows 'walking' error. Offset is reset when continous/limited error insertion is disabled or burst mode is enabled and burst insertion is finished or err_posit_offs_cfg = 0"), details: Some("0: disabled 1: move 1 bit (from LSB to MSB) ... 39: move 39 bit (from LSB to MSB) 40-63: reserved"), lo: 4, hi: 10 });
        fields.insert("ERR_TRIG_ONESHOT_CFG", Field { brief: Some("Trigger a single error or a burst of errors (refer to num_err_cfg)"), details: Some("0 to 1 (edge) activates this function"), lo: 20, hi: 21 });
        fields.insert("NUM_ERR_CFG", Field { brief: Some("Limited error insertion: burst mode (err_freq_cfg must be > 0; each burst is triggered by a 0 to 1 transition of configuration field err_trig_oneshot_cfg)"), details: Some("0: burst mode is disabled 1-15: number of errors per burst = 2^(num_err_cfg + 5)"), lo: 0, hi: 4 });
        regs.insert("DFT_TX_ERR_INSERT_CFG", Register { addr: Address { base: 17, count: 1, width: 1 }, brief: Some("DFT TX Error insertion configuration register"), details: Some("Configuration register for explicit error insertion into DFT driven data stream. Allows to insert expected errors to check e.g. TX/RX connectivity"), fields });
        let mut fields = HashMap::new();
        fields.insert("MAX_ADDR_GEN_CFG", Field { brief: Some("Maximum address in generator (before continuing with address 0)"), details: None, lo: 18, hi: 22 });
        fields.insert("PATTERN_CFG", Field { brief: Some("10 bits word of constant patterns for transmission"), details: None, lo: 0, hi: 10 });
        fields.insert("PAT_VLD_CFG", Field { brief: Some("Constant patterns are valid to store"), details: None, lo: 26, hi: 27 });
        fields.insert("STORE_ADDR_CFG", Field { brief: Some("Current storage address for patterns in generator"), details: None, lo: 10, hi: 14 });
        regs.insert("DFT_TX_PAT_CFG", Register { addr: Address { base: 11, count: 1, width: 1 }, brief: Some("DFT TX Constant pattern configuration register"), details: Some("TX Constant MSB pattern configuration register for SD10G65 DFT."), fields });
        let mut fields = HashMap::new();
        fields.insert("GP_REG_LSB", Field { brief: Some("32 LSBs of general purpose register"), details: None, lo: 0, hi: 32 });
        regs.insert("VSCOPE_DBG_LSB", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Vscope general purpose register"), details: Some("Vscope general purpose  register"), fields });
        groups.insert("SD10G65_DFT", RegisterGroup { addr: Address { base: 51, count: 1, width: 19 }, desc: "SD10G65 DFT Configuration and Status Register set", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("RX_LANE_SYNC_FIFO_OF_STICKY", Field { brief: Some("RX Lane synchronization fifo overflow"), details: None, lo: 0, hi: 1 });
        regs.insert("RX_SYNC_CTRL_STAT", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("RX_SYNC_CTRL status register"), details: Some("RX Sync control status register"), fields });
        let mut fields = HashMap::new();
        fields.insert("PLLB_COMP_UNCERT", Field { brief: Some("BIST compare uncertainty"), details: None, lo: 4, hi: 12 });
        fields.insert("PLLB_FREQ_DEVI", Field { brief: Some("BIST frequency deviation limit, correlates to compare dividers"), details: None, lo: 16, hi: 32 });
        fields.insert("PLLB_INC_DEC_MODE", Field { brief: Some("BIST ramp-up/down mode, 0: ramp up and down, 1: ramp-up only, 2: ramp-down only, 3: reserved"), details: None, lo: 2, hi: 4 });
        fields.insert("PLLB_START_BIST", Field { brief: Some("BIST start, 0: reset BIST, 1: start/enable BIST"), details: None, lo: 0, hi: 1 });
        regs.insert("SD10G65_RCPLL_BIST_CFG0", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("SD10G65 RX RCPLL BIST Configuration register 0"), details: Some("Configuration register 0 for SD10G65 RX RCPLL BIST."), fields });
        let mut fields = HashMap::new();
        fields.insert("PLLB_DIV_FACTOR_PRE", Field { brief: Some("BIST compare pre divider M"), details: None, lo: 0, hi: 16 });
        fields.insert("PLLB_LOCK_REPEAT", Field { brief: Some("BIST compare divider repeat count"), details: None, lo: 20, hi: 24 });
        fields.insert("PLLB_LOCK_UNCERT", Field { brief: Some("BIST compare divider phase uncertainty"), details: None, lo: 16, hi: 20 });
        regs.insert("SD10G65_RCPLL_BIST_CFG1", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("SD10G65 RX RCPLL BIST Configuration register 1"), details: Some("Configuration register 1 for SD10G65 RX RCPLL BIST."), fields });
        let mut fields = HashMap::new();
        fields.insert("PLLB_DIV_FACTOR_M", Field { brief: Some("BIST compare divider M"), details: None, lo: 0, hi: 16 });
        regs.insert("SD10G65_RCPLL_BIST_CFG2", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("SD10G65 RX RCPLL BIST Configuration register 2"), details: Some("Configuration register 2 for SD10G65 RX RCPLL BIST."), fields });
        let mut fields = HashMap::new();
        fields.insert("PLLB_DIV_FACTOR_N", Field { brief: Some("BIST compare divider N"), details: None, lo: 0, hi: 16 });
        regs.insert("SD10G65_RCPLL_BIST_CFG3", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("SD10G65 RX RCPLL BIST Configuration register 3"), details: Some("Configuration register 3 for SD10G65 RX RCPLL BIST."), fields });
        let mut fields = HashMap::new();
        fields.insert("PLLB_BUSY", Field { brief: Some("BIST busy, 0: not busy, 1: busy"), details: None, lo: 2, hi: 3 });
        fields.insert("PLLB_DONE_N", Field { brief: Some("BIST done (inverted), 0: done, 1: not done"), details: None, lo: 1, hi: 2 });
        fields.insert("PLLB_FAIL", Field { brief: Some("BIST pass/fail, 0: passed, 1: failed"), details: None, lo: 0, hi: 1 });
        fields.insert("PLLB_PHASE_LOCK", Field { brief: Some("BIST compare divider phase lock"), details: None, lo: 3, hi: 4 });
        fields.insert("PLLB_PLL_CNT_HIGH", Field { brief: Some("BIST pll_cnt upper limit at max. frequency"), details: None, lo: 16, hi: 27 });
        fields.insert("PLLB_PLL_CNT_LOW", Field { brief: Some("BIST pll_cnt lower limit at min. frequency"), details: None, lo: 5, hi: 16 });
        regs.insert("SD10G65_RCPLL_BIST_STAT0", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("SD10G65 RX RCPLL BIST Status register 0"), details: Some("Status register 0 for SD10G65 RX RCPLL BIST."), fields });
        let mut fields = HashMap::new();
        fields.insert("PLLB_PHASE_DIFF", Field { brief: Some("BIST compare divider phase difference"), details: None, lo: 0, hi: 16 });
        regs.insert("SD10G65_RCPLL_BIST_STAT1", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("SD10G65 RX RCPLL BIST Status register 1"), details: Some("Status register 1 for SD10G65 RX RCPLL BIST."), fields });
        let mut fields = HashMap::new();
        fields.insert("PLLB_CLOCK_SEL", Field { brief: Some("BIST macro clock (parallel) clock selection, 0: RX, 1: TX"), details: None, lo: 0, hi: 1 });
        fields.insert("PLLB_MEAS_MODE", Field { brief: Some("BIST measure mode, 0: frequency, 1: phase"), details: None, lo: 1, hi: 2 });
        fields.insert("PLLB_SEL125CLK", Field { brief: Some("BIST select 125MHz feedback clock from synthesizer"), details: None, lo: 3, hi: 4 });
        fields.insert("PLLB_SPI_BASE_ADDR", Field { brief: Some("BIST SPI base address for rcpll10g FSM inside the macro (e.g. RX or TX)"), details: None, lo: 8, hi: 16 });
        fields.insert("PLLB_START_MEAS", Field { brief: Some("BIST start measure, 1: start"), details: None, lo: 2, hi: 3 });
        regs.insert("SD10G65_RX_RCPLL_BIST_CFG4", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("SD10G65 RX RCPLL BIST Configuration register 4"), details: Some("Configuration register 4 for SD10G65 RX RCPLL BIST."), fields });
        groups.insert("SD10G65_RCPLL_BIST", RegisterGroup { addr: Address { base: 74, count: 1, width: 7 }, desc: "SD10G65 RX and TX RCPLL BIST Configuration and Status Register set", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CG_DCD_CFG", Field { brief: Some("Duty cycle distortion: Refer to configuration fields 'cg_per_cfg' and 'cg_per_jump_cfg' for encoding description"), details: None, lo: 2, hi: 12 });
        fields.insert("CG_MODE_CFG", Field { brief: Some("clock generator mode"), details: Some("0: normal operation; cg_per_cfg controls period 0->1 transition: after current period has finished (only) the next period is controlled by cg_per_jump_cfg afterwards normal operation 2: every N'th period the high value is replaced by a low value N is defined by cg_timer_cfg 3: every N'th period the low value is replaced by a high value N is defined by cg_timer_cfg"), lo: 0, hi: 2 });
        fields.insert("CG_PER_CFG", Field { brief: Some("(Half) clock period configuration in normal mode (refer also to configuration field cg_mode_cfg):"), details: Some("high period = cg_per_cfg + cg_dcd_cfg low period = cg_per_cfg - cg_dcd_cfg"), lo: 22, hi: 32 });
        fields.insert("CG_PER_JUMP_CFG", Field { brief: Some("(Half) clock period configuration in jump mode (refer also to configuration field cg_mode_cfg):"), details: Some("high period = cg_per_jump_cfg + cg_dcd_cfg low period = cg_per_jump_cfg - cg_dcd_cfg"), lo: 12, hi: 22 });
        regs.insert("DFT_CLK_GEN_CFG", Register { addr: Address { base: 18, count: 1, width: 1 }, brief: Some("DFT clock generator configuration register"), details: Some("Configuration register for clock generator to build a low speed clock signal of variable length and variable duty cycle provided on all data bits simultaniously"), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_I2_CLR", Field { brief: Some("Clear RX I2 value"), details: None, lo: 8, hi: 9 });
        fields.insert("RX_I2_HOLD", Field { brief: Some("Keep current RX I2 value constant"), details: None, lo: 9, hi: 10 });
        fields.insert("RX_LANE_SYNC_SRC", Field { brief: Some("Source selection for RX lane synchronization"), details: Some("0: Do not use external sync_ctrl info 1: Select sync_ctrl info from external DES"), lo: 0, hi: 1 });
        regs.insert("RX_SYNC_CTRL_CFG", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("RX_SYNC_CTRL config register"), details: Some("RX Sync control configuration register, synchronize I2 of one RX to the I2 of another RX"), fields });
        let mut fields = HashMap::new();
        fields.insert("LANE_SYNC_SRC", Field { brief: Some("Source selection for lane synchronization"), details: Some("0: Select external DES 1: Select F2DF 2: Select local DES 3: Disable sync_ctrl"), lo: 0, hi: 2 });
        regs.insert("SYNC_CTRL_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("SYNC_CTRL config register"), details: Some("Sync control configuration register"), fields });
        let mut fields = HashMap::new();
        fields.insert("LANE_SYNC_FIFO_OF_STICKY", Field { brief: Some("Lane synchronization fifo overflow"), details: None, lo: 0, hi: 1 });
        regs.insert("SYNC_CTRL_STAT", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("SYNC_CTRL status register"), details: Some("Sync control status register"), fields });
        groups.insert("SD10G65_SYNC_CTRL", RegisterGroup { addr: Address { base: 70, count: 1, width: 4 }, desc: "SYNC_CTRL Configuration and Status Register set", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("LC_SC_DFE1_TARGET", Field { brief: Some("Target value for DFE1 during L/C-control operation"), details: None, lo: 0, hi: 7 });
        fields.insert("LC_SC_DFE2_TARGET", Field { brief: Some("Target value for DFE2 during L/C-control operation"), details: None, lo: 8, hi: 14 });
        regs.insert("APC_LC_SOFTCTRL_CFG1", Register { addr: Address { base: 43, count: 1, width: 1 }, brief: Some("APC LC softcontrol configuration register 1"), details: Some("Configuration register 1 for the LC-Softcontrol logic block."), fields });
        let mut fields = HashMap::new();
        fields.insert("COUNTER", Field { brief: Some("Counter value"), details: None, lo: 0, hi: 32 });
        regs.insert("VSCOPE_CNT", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Vscope counter register"), details: Some("Vscope counter register"), fields });
        let mut fields = HashMap::new();
        fields.insert("AMPL_INCR", Field { brief: Some("Amplitude increment per scan step"), details: Some("Increment = ampl_incr + 1"), lo: 4, hi: 7 });
        fields.insert("AMPL_OFFS_VAL", Field { brief: Some("Offset between AuxL amplitude (reference) and AuxH amplitude, signed (2s-complement), +- 1/4 amplitude max."), details: None, lo: 25, hi: 30 });
        fields.insert("HW_SCAN_ENA", Field { brief: Some("Enables HW scan with N results per scan or fast-scan"), details: Some("0: off 1: N-point scan 2: fast-scan (sq) 3: fast-scan (diag)"), lo: 0, hi: 2 });
        fields.insert("MAX_AMPL_INCR_VAL", Field { brief: Some("Maximum amplitude increment value before wrapping"), details: None, lo: 10, hi: 16 });
        fields.insert("MAX_PHASE_INCR_VAL", Field { brief: Some("Maximum phase increment value before wrapping"), details: None, lo: 17, hi: 25 });
        fields.insert("NUM_SCANS_PER_ITR", Field { brief: Some("Number of scans per iteration in N-point-scan mode"), details: Some("0: 1 1: 2 2: 4 3: 8"), lo: 2, hi: 4 });
        fields.insert("PHASE_INCR", Field { brief: Some("Phase increment per scan step"), details: Some("Increment = phase_incr + 1"), lo: 7, hi: 10 });
        fields.insert("PHASE_JUMP_INV", Field { brief: Some("Invert the jumph_ena and jumpl_ena bit in HW scan mode"), details: None, lo: 31, hi: 32 });
        regs.insert("VSCOPE_HW_SCAN_CFG1", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Vscope hw scan config register 1"), details: Some("Vscope HW scan configuration register 1"), fields });
        let mut fields = HashMap::new();
        fields.insert("AMPL_START_VAL", Field { brief: Some("Start value for VScope amplitude in N-point-scan mode and fast-scan mode (before IB amplitude symmetry compensation)"), details: None, lo: 8, hi: 14 });
        fields.insert("AUX_AMPL_SYM_DIS", Field { brief: Some("Disable IB amplitude symmetry compensation for AuxH and AuxL"), details: None, lo: 15, hi: 16 });
        fields.insert("FAST_SCAN_THRES", Field { brief: Some("Threshold for error_counter in fast-scan mode"), details: Some("N+1"), lo: 29, hi: 32 });
        fields.insert("FS_THRES_SHIFT", Field { brief: Some("Left shift for threshold of error_counter in fast-scan mode"), details: Some("threshold = (fast_scan_thres+1) shift_left fs_thres_shift"), lo: 24, hi: 29 });
        fields.insert("PHASE_JUMP_VAL", Field { brief: Some("Value at which jumpl_ena and jumph_ena in IB must be toggled"), details: None, lo: 16, hi: 24 });
        fields.insert("PHASE_START_VAL", Field { brief: Some("Start value for VScope phase in N-point-scan mode and fast-scan mode"), details: None, lo: 0, hi: 8 });
        regs.insert("VSCOPE_HW_SCAN_CFG2", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Vscope hw config register 2"), details: Some("Vscope HW scan configuration register 2"), fields });
        let mut fields = HashMap::new();
        fields.insert("CNT_ENA", Field { brief: Some("Enable Counting"), details: Some("0: disable counting and assign counter output; internal counters get their preload value 1: enable counting"), lo: 4, hi: 5 });
        fields.insert("CNT_OUT_SEL", Field { brief: Some("Counter output selection"), details: Some("0-3: error counter 0-3 4: hit counter 5: clock counter 6: 8 LSBs of error counter 3-1 and hit counter 7: 8 LSBs of error counter 3-0"), lo: 26, hi: 29 });
        fields.insert("COMP_SEL", Field { brief: Some("Comparator input selection"), details: Some("[REF] 0 or 1: auxL 4 or 5: auxH 2 or 7: main [SUB] 5 or 7: auxL 0 or 2: auxH 1 or 4: main (3 or 6: reserved)"), lo: 23, hi: 26 });
        fields.insert("COUNT_PER", Field { brief: Some("Counter period: preload value for clock counter"), details: Some("After preload clock counter = 2**32 - 2**(count_per + 1)"), lo: 5, hi: 10 });
        fields.insert("GP_REG_FREEZE", Field { brief: Some("Allows to freeze the GP register value to assure valid reading"), details: None, lo: 20, hi: 21 });
        fields.insert("GP_SELECT", Field { brief: Some("Select GP reg input"), details: Some("0: rx (main) 1: low aux 2: high aux 3: counter"), lo: 21, hi: 23 });
        fields.insert("IB_AUX_OFFS_WR_DIS", Field { brief: Some("Disables writing of ib_auxl_offset and ib_auxh_offset in IB"), details: None, lo: 30, hi: 31 });
        fields.insert("IB_JUMP_ENA_WR_DIS", Field { brief: Some("Disables writing of ib_jumpl_ena and ib_jumph_ena in IB"), details: None, lo: 29, hi: 30 });
        fields.insert("IF_MODE", Field { brief: Some("Interface Width"), details: Some("0: 8 bit 1: 10 bit 2: 16 bit 3: 20 bit 4: 32 bit 5: 40 bit others: reserved"), lo: 1, hi: 4 });
        fields.insert("INTR_DIS", Field { brief: Some("Disable interrupt output"), details: None, lo: 12, hi: 13 });
        fields.insert("PRELOAD_VAL", Field { brief: Some("Preload value for error counter"), details: Some("After preload error counter = 2**32 - 2**(preload_val + 1)"), lo: 13, hi: 18 });
        fields.insert("QUICK_SCAN", Field { brief: Some("Counter output assignment and internal counter reset implicitly done by reading the counter; unused in hw-scan mode where this function is permanently enabled"), details: None, lo: 10, hi: 11 });
        fields.insert("SCAN_LIM", Field { brief: Some("Scan limit, selects which counter saturation limits the other counters"), details: Some("0: clock counter 1: hit counter 2: error counters 3: no limit"), lo: 18, hi: 20 });
        fields.insert("SYN_PHASE_WR_DIS", Field { brief: Some("Disables writing of synth_phase_aux in synthesizer"), details: None, lo: 31, hi: 32 });
        fields.insert("TRIG_ENA", Field { brief: Some("Enable trigger"), details: None, lo: 11, hi: 12 });
        fields.insert("VSCOPE_ENA", Field { brief: Some("Enable Vscope"), details: None, lo: 0, hi: 1 });
        regs.insert("VSCOPE_MAIN_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Vscope main config register"), details: Some("Vscope main configuration register"), fields });
        let mut fields = HashMap::new();
        fields.insert("DC_MASK", Field { brief: Some("Don't Care mask: Enable history mask usage."), details: Some("0: enable history mask bit 1: history mask bit is \"don't care\""), lo: 10, hi: 20 });
        fields.insert("HIST_MASK", Field { brief: Some("History mask: Respective sequence is expected in reference input (comp_sel); if enabled (dc_mask) before hit and error counting is enabled"), details: None, lo: 0, hi: 10 });
        fields.insert("PRELOAD_HIT_CNT", Field { brief: Some("Preload value for hit counter"), details: Some("After preload hit counter = 2**32 - 2**(preload_hit_cnt + 1)"), lo: 20, hi: 25 });
        regs.insert("VSCOPE_PAT_LOCK_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Vscope pattern lock config register"), details: Some("Vscope pattern lock configuration register"), fields });
        let mut fields = HashMap::new();
        fields.insert("DONE_STICKY", Field { brief: Some("Done sticky"), details: None, lo: 0, hi: 1 });
        fields.insert("FAST_SCAN_HIT", Field { brief: Some("Fast scan mode: Indicator per cursor position whether threshold was reached"), details: None, lo: 4, hi: 8 });
        fields.insert("GP_REG_MSB", Field { brief: Some("8 MSBs of general purpose register"), details: None, lo: 8, hi: 16 });
        regs.insert("VSCOPE_STAT", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Vscope status register"), details: Some("Vscope status register"), fields });
        groups.insert("SD10G65_VSCOPE2", RegisterGroup { addr: Address { base: 44, count: 1, width: 7 }, desc: "SD10G65 VSCOPE Configuration and Status Register set", regs });
        out.insert("SD10G65_DIG", Target { desc: "\\see vtss_target_SD10G65_DIG_e Configuration and status of digital peripherals for high speed macro.", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("SCKDV", Field { brief: Some("The LSB for this field is always set to 0 and is unaffected by a write operation, which ensures an even value is held in this register. If the value is 0, the serial output clock (si_clk) is disabled. The frequency of the si_clk is derived from the following equation: Fsclk_out = Fsystem_clk/SCKDV where SCKDV is any even value between 2 and 65534 and Fsystem_clk is 250MHz."), details: None, lo: 0, hi: 16 });
        regs.insert("BAUDR", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Baud Rate Select"), details: Some("The register derives the frequency of the serial clock that regulates the data transfer. The 16-bit field in this register defines the SI divider value. This register can only be written when master is disabled (SIMC::SIMCEN.SIMCEN = 0)."), fields });
        let mut fields = HashMap::new();
        fields.insert("CFS", Field { brief: Some("Control Frame Size. Selects the length of the control word for the Microwire frame format."), details: Some("n: n+1 bit control word."), lo: 12, hi: 16 });
        fields.insert("DFS", Field { brief: Some("Selects the data frame length. See SIMC::DR register description for how to read/write words of less than 16 bit."), details: Some("0-2: Reserved. n: n+1 bit serial data transfer."), lo: 0, hi: 4 });
        fields.insert("FRF", Field { brief: Some("Selects which serial protocol transfers the data. Note: In addition to this field, software must also configure ICPU_CFG::GENERAL_CTRL.SIMC_SSP_ENA."), details: Some("0: Motorola SPI 1: Texas Instruments SSP 2-3: Reserved"), lo: 4, hi: 6 });
        fields.insert("SCPH", Field { brief: Some("Valid when the frame format (FRF) is set to Motorola SPI. The serial clock phase selects the relationship of the serial clock with the slave select signal. When SCPH = 0, data are captured on the first edge of the serial clock. When SCPH = 1, the serial clock starts toggling one cycle after the slave select line is activated, and data are captured on the second edge of the serial clock."), details: Some("0: Serial clock toggles in middle of first data bit. 1: Serial clock toggles at start of first data bit."), lo: 6, hi: 7 });
        fields.insert("SCPOL", Field { brief: Some("Valid when the frame format (FRF) is set to Motorola SPI. Used to select the polarity of the inactive serial clock, which is held inactive when the master is not actively transferring data on the serial bus."), details: Some("0: Inactive state of serial clock is low. 1: Inactive state of serial clock is high."), lo: 7, hi: 8 });
        fields.insert("SRL", Field { brief: Some("Shift Register Loop. Used for testing purposes only. Set to connect the transmit shift register output to the receive shift register input."), details: Some("0: Normal Mode Operation 1: Test Mode Operation"), lo: 11, hi: 12 });
        fields.insert("TMOD", Field { brief: Some("Selects the mode of transfer for serial communication. In transmit-only mode, data received from the external device is not valid and is not stored in the receive FIFO memory; it is overwritten on the next transfer. In receive-only mode, transmitted data are not valid. After the first write to the transmit FIFO, the same word is retransmitted for the duration of the transfer. In transmit-and-receive mode, both transmit and receive data are valid. The transfer continues until the transmit FIFO is empty. Data received from the external device are stored into the receive FIFO memory, where it can be accessed by the host processor."), details: Some("0: Transmit and Receive. 1: Transmit Only. 2: Receive Only. 3: Reserved."), lo: 8, hi: 10 });
        regs.insert("CTRLR0", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Control Register 0"), details: Some("This register controls the serial data transfer. This register can only be written when master is disabled (SIMC::SIMCEN.SIMCEN = 0)."), fields });
        let mut fields = HashMap::new();
        fields.insert("NDF", Field { brief: Some("When SIMC::CTRLR0.TMOD = 2, this register field sets the number of data frames to be continuously received by the master. The master continues to receive serial data until the number of data frames received is equal to this register value plus 1, which enables receiveing up to 64 KB of data in a continuous transfer."), details: None, lo: 0, hi: 16 });
        regs.insert("CTRLR1", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Control Register 1"), details: Some("Control register 1 controls the end of serial transfers when in receive-only mode. This register can only be written when master is disabled (SIMC::SIMCEN.SIMCEN = 0)."), fields });
        let mut fields = HashMap::new();
        fields.insert("DR", Field { brief: Some("Data is aligned to bit 0 (right-justified) when accessing less than 16 bit data-words. Read = Receive FIFO buffer. Write = Transmit FIFO buffer."), details: None, lo: 0, hi: 16 });
        regs.insert("DR", Register { addr: Address { base: 24, count: 36, width: 1 }, brief: Some("Transmit/Receive FIFO"), details: Some("16-bit read/write buffer for the transmit/receive FIFOs. When the register is read, data in the receive FIFO buffer is accessed. When it is written to, data are moved into the transmit FIFO buffer; a write can occur only when SIMC::SIMCEN.SIMCEN = 1. FIFOs are reset when SIMC::SIMCEN.SIMCEN = 0. This register is replicated to allow burst access to fifo's; the replication index is not used when accessing the FIFO."), fields });
        let mut fields = HashMap::new();
        fields.insert("ICR", Field { brief: Some("This field is set when any of the master's TXO, RXO, RXU, or MST interrupts are active. Reading from this register clears all interrupts, as reading from SIMC::TXOICR, SIMC::RXOICR, SIMC::RXUICR, and SIMC::MSTICR registers."), details: None, lo: 0, hi: 1 });
        regs.insert("ICR", Register { addr: Address { base: 18, count: 1, width: 1 }, brief: Some("SIMC Combined Interrupt Clear"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MSTIM", Field { brief: Some("Set to enable Multi-Master Contention Interrupt"), details: None, lo: 5, hi: 6 });
        fields.insert("RXFIM", Field { brief: Some("Set to enable Receive FIFO Full Interrupt"), details: None, lo: 4, hi: 5 });
        fields.insert("RXOIM", Field { brief: Some("Set to enable Receive FIFO Overflow Interrupt"), details: None, lo: 3, hi: 4 });
        fields.insert("RXUIM", Field { brief: Some("Set to enable Receive FIFO Underflow Interrupt"), details: None, lo: 2, hi: 3 });
        fields.insert("TXEIM", Field { brief: Some("Set to enable Transmit FIFO Empty Interrupt"), details: None, lo: 0, hi: 1 });
        fields.insert("TXOIM", Field { brief: Some("Set to enable Transmit FIFO Overflow Interrupt"), details: None, lo: 1, hi: 2 });
        regs.insert("IMR", Register { addr: Address { base: 11, count: 1, width: 1 }, brief: Some("Interrupt Mask"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MSTIS", Field { brief: Some("Multi-Master Contention Interrupt Status, this field is masked by SIMC::IMR.MSTIM."), details: None, lo: 5, hi: 6 });
        fields.insert("RXFIS", Field { brief: Some("Receive FIFO Full Interrupt Status, this field is masked by SIMC::IMR.RXFIM. This interrupt is based on programmable fill level, see SIMC::RXFTLR for more information."), details: None, lo: 4, hi: 5 });
        fields.insert("RXOIS", Field { brief: Some("Receive FIFO Overflow Interrupt Status, this field is masked by SIMC::IMR.RXOIM."), details: None, lo: 3, hi: 4 });
        fields.insert("RXUIS", Field { brief: Some("Receive FIFO Underflow Interrupt Status, this field is masked by SIMC::IMR.RXUIM."), details: None, lo: 2, hi: 3 });
        fields.insert("TXEIS", Field { brief: Some("Transmit FIFO Empty Interrupt Status, this field is masked by SIMC::IMR.TXEIM. This interrupt is based on programmable fill level, see SIMC::TXFTLR for more information."), details: None, lo: 0, hi: 1 });
        fields.insert("TXOIS", Field { brief: Some("Transmit FIFO Overflow Interrupt Status, this field is masked by SIMC::IMR.TXOIM."), details: None, lo: 1, hi: 2 });
        regs.insert("ISR", Register { addr: Address { base: 12, count: 1, width: 1 }, brief: Some("Interrupt Status"), details: Some("If any bit is set in this register, then the SI Master Controller is indicating interrupt towards the VCore Interrupt Controller."), fields });
        let mut fields = HashMap::new();
        fields.insert("MSTICR", Field { brief: Some("This field is set when Multi-Master Contention Interrupt is active, interrupt is cleared by reading this register."), details: None, lo: 0, hi: 1 });
        regs.insert("MSTICR", Register { addr: Address { base: 17, count: 1, width: 1 }, brief: Some("Multi-Master Contention Interrupt Clear"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MDD", Field { brief: Some("Defines the direction of the data word when the Microwire serial protocol is used. When this bit is set to 0, the data word is received by the master from the external serial device. When this bit is set to 1, the data word is transmitted from the master to the external serial device."), details: None, lo: 1, hi: 2 });
        fields.insert("MHS", Field { brief: Some("Set to enable the busy/ready handshaking interface for the Microwire protocol. When enabled, the master checks for a ready status from the target slave, after the transfer of the last data/control bit, before clearing the BUSY status in the SR register."), details: Some("0: handshaking interface is disabled 1: handshaking interface is enabled"), lo: 2, hi: 3 });
        fields.insert("MWMOD", Field { brief: Some("Defines whether the Microwire transfer is sequential or non-sequential. When sequential mode is used, only one control word is needed to transmit or receive a block of data words. When non-sequential mode is used, there must be a control word for each data word that is transmitted or received."), details: Some("0: non-sequential transfer 1: sequential transfer"), lo: 0, hi: 1 });
        regs.insert("MWCR", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Microwire Control Register"), details: Some("This register controls the direction of the data word for the half-duplex Microwire serial protocol. This register can only be written when master is disabled (SIMC::SIMCEN.SIMCEN = 0)."), fields });
        let mut fields = HashMap::new();
        fields.insert("MSTIR", Field { brief: Some("Current status of Multi-Master Contention Interrupt before masking."), details: None, lo: 5, hi: 6 });
        fields.insert("RXFIR", Field { brief: Some("Current status of Receive FIFO Full Interrupt before masking"), details: None, lo: 4, hi: 5 });
        fields.insert("RXOIR", Field { brief: Some("Current status of Receive FIFO Overflow Interrupt before masking"), details: None, lo: 3, hi: 4 });
        fields.insert("RXUIR", Field { brief: Some("Current status of Receive FIFO Underflow Interrupt before masking"), details: None, lo: 2, hi: 3 });
        fields.insert("TXEIR", Field { brief: Some("Current status of Transmit FIFO Empty Interrupt before masking"), details: None, lo: 0, hi: 1 });
        fields.insert("TXOIR", Field { brief: Some("Current status of Transmit FIFO Overflow Interrupt before masking"), details: None, lo: 1, hi: 2 });
        regs.insert("RISR", Register { addr: Address { base: 13, count: 1, width: 1 }, brief: Some("Raw Interrupt Status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RXTFL", Field { brief: Some("Contains the number of valid data entries in the receive FIFO."), details: None, lo: 0, hi: 6 });
        regs.insert("RXFLR", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("Receive FIFO Level"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RFT", Field { brief: Some("When the number of receive FIFO entries is greater than or equal to this value + 1, the receive FIFO full interrupt is triggered. The receive FIFO depth is 40, do not program value exceeding 39."), details: None, lo: 0, hi: 6 });
        regs.insert("RXFTLR", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Receive FIFO Threshold level"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RXOICR", Field { brief: Some("This field is set when Receive FIFO Overflow Interrupt is active, interrupt is cleared by reading this register."), details: None, lo: 0, hi: 1 });
        regs.insert("RXOICR", Register { addr: Address { base: 15, count: 1, width: 1 }, brief: Some("Receive FIFO Overflow Interrupt Clear"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RXUICR", Field { brief: Some("This field is set when Receive FIFO Underflow Interrupt is active, interrupt is cleared by reading this register."), details: None, lo: 0, hi: 1 });
        regs.insert("RXUICR", Register { addr: Address { base: 16, count: 1, width: 1 }, brief: Some("Receive FIFO Underflow Interrupt Clear"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SER", Field { brief: Some("Each bit in this register corresponds to a slave select line from the master. When a bit in this register is set, the corresponding slave select line from the master is activated when a serial transfer begins. Setting or clearing bits in this register have no effect on the corresponding slave select outputs until a transfer is started. Before beginning a transfer, enable the bit in this register that corresponds to the slave device with which the master wants to communicate. When not operating in broadcast mode, only one bit in this field should be set."), details: Some("1: Selected 0: Not Selected"), lo: 0, hi: 16 });
        regs.insert("SER", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Slave Enable"), details: Some("The register enables the individual slave select output lines from the master. 16 slave-select output pins are available on the master. This register can only be written when master is disabled and not busy."), fields });
        let mut fields = HashMap::new();
        fields.insert("SIMCEN", Field { brief: Some("Set to enable master operations. When disabled, all serial transfers are halted immediately. Transmit and receive FIFO buffers are cleared when disabled. It is impossible to program some of the master control registers when enabled. Note: The SI Master Controller must own the SI interface before it is enabled, see ICPU_CFG::GENERAL_CTRL.IF_SI_OWNER for more information."), details: None, lo: 0, hi: 1 });
        regs.insert("SIMCEN", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("SIMC Enable"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BUSY", Field { brief: Some("Set when serial transfer is in progress. Cleared when master is idle or disabled."), details: None, lo: 0, hi: 1 });
        fields.insert("RFF", Field { brief: Some("Set when receive FIFO is full."), details: None, lo: 4, hi: 5 });
        fields.insert("RFNE", Field { brief: Some("Set when receive FIFO has one or more data-word."), details: None, lo: 3, hi: 4 });
        fields.insert("TFE", Field { brief: Some("Set when transmit FIFO is empty."), details: None, lo: 2, hi: 3 });
        fields.insert("TFNF", Field { brief: Some("Set when transmit FIFO has room for one or more data-word."), details: None, lo: 1, hi: 2 });
        regs.insert("SR", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("Status Register"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TXTFL", Field { brief: Some("Contains the number of valid data entries in the transmit FIFO."), details: None, lo: 0, hi: 3 });
        regs.insert("TXFLR", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("Transmit FIFO Level"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TFT", Field { brief: Some("When the number of transmit FIFO entries is less than or equal to this value, the transmit FIFO empty interrupt is triggered. The transmit FIFO depth is 8, do not program value exceeding 7."), details: None, lo: 0, hi: 3 });
        regs.insert("TXFTLR", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Transmit FIFO Threshold Level"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TXOICR", Field { brief: Some("This field is set when Transmit FIFO Overflow Interrupt is active, interrupt is cleared by reading this register."), details: None, lo: 0, hi: 1 });
        regs.insert("TXOICR", Register { addr: Address { base: 14, count: 1, width: 1 }, brief: Some("Transmit FIFO Overflow Interrupt Clear"), details: None, fields });
        groups.insert("SIMC", RegisterGroup { addr: Address { base: 0, count: 1, width: 3 }, desc: "SI Master Controller", regs });
        out.insert("SIMC", Target { desc: "SI Master Controller", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ACK_GEN_CALL", Field { brief: Some("ACK General Call. When set to 1, the TWI controller responds with a ACK when it receives a General Call. Otherwise, the controller responds with a NACK."), details: None, lo: 0, hi: 1 });
        regs.insert("ACK_GEN_CALL", Register { addr: Address { base: 38, count: 1, width: 1 }, brief: Some("Acknowledge general call"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MASTER_10BITADDR", Field { brief: Some("Controls whether transfers starts in 7- or 10-bit addressing mode when acting as a master."), details: Some("'0': 7-bit addressing '1': 10-bit addressing"), lo: 4, hi: 5 });
        fields.insert("MASTER_ENA", Field { brief: Some("This bit controls whether the TWI master is enabled."), details: Some("'0': master disabled '1': master enabled"), lo: 0, hi: 1 });
        fields.insert("RESTART_ENA", Field { brief: Some("Determines whether RESTART conditions may be sent when acting as a master. Some older slaves do not support handling RESTART conditions; however, RESTART conditions are used in several operations. When RESTART is disabled, the master is prohibited from performing the following functions: * Change direction within a transfer (split) * Send a START BYTE * Combined format transfers in 7-bit addressing modes * Read operation with a 10-bit address * Send multiple bytes per transfer By replacing RESTART condition followed by a STOP and a subsequent START condition, split operations are  broken down into multiple transfers. If the above operations are performed, it will result in setting RAW_INTR_STAT.R_TX_ABRT."), details: Some("'0': disable '1': enable"), lo: 5, hi: 6 });
        fields.insert("SLAVE_10BITADDR", Field { brief: Some("Controls whether the the TWI controller responds to 7- or 10-bit addresses in slave mode. In 7-bit mode; transactions that involve 10-bit addressing are ignored and only the lower 7 bits of the SAR register are compared."), details: Some("'0': 7-bit addressing. '1': 10-bit addressing."), lo: 3, hi: 4 });
        fields.insert("SLAVE_DIS", Field { brief: Some("This bit controls whether the TWI controller has its slave disabled. If this bit is set (slave is disabled), the controller functions only as a master and does not perform any action that requires a slave."), details: Some("'0': slave is enabled '1': slave is disabled"), lo: 6, hi: 7 });
        fields.insert("SPEED", Field { brief: Some("These bits control at which speed the TWI controller operates; its setting is relevant only in master mode. Hardware protects against illegal values being programmed by software."), details: Some("'1': standard mode (100 kbit/s) '2': fast mode (400 kbit/s)"), lo: 1, hi: 3 });
        regs.insert("CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("TWI configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CLR_ACTIVITY", Field { brief: Some("Reading this register clears the ACTIVITY interrupt if the TWI controller is not active anymore. If the TWI  controller is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this register to get status of the R_ACTIVITY interrupt (bit 8) of the RAW_INTR_STAT register."), details: None, lo: 0, hi: 1 });
        regs.insert("CLR_ACTIVITY", Register { addr: Address { base: 23, count: 1, width: 1 }, brief: Some("Clear ACTIVITY interrupt"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CLR_GEN_CALL", Field { brief: Some("Read this register to clear the R_GEN_CALL interrupt (bit 11) of RAW_INTR_STAT register."), details: None, lo: 0, hi: 1 });
        regs.insert("CLR_GEN_CALL", Register { addr: Address { base: 26, count: 1, width: 1 }, brief: Some("Clear GEN_CALL interrupt"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CLR_INTR", Field { brief: Some("Read this register to clear the combined interrupt, all individual interrupts, and the TX_ABRT_SOURCE register. This bit does not clear hardware clearable interrupts but software clearable interrupts. Refer to Bit 9 of the TX_ABRT_SOURCE register for an exception to clearing TX_ABRT_SOURCE."), details: None, lo: 0, hi: 1 });
        regs.insert("CLR_INTR", Register { addr: Address { base: 16, count: 1, width: 1 }, brief: Some("Clear combined and individual interrupt"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CLR_RD_REQ", Field { brief: Some("Read this register to clear the R_RD_REQ interrupt (bit 5) of the RAW_INTR_STAT register."), details: None, lo: 0, hi: 1 });
        regs.insert("CLR_RD_REQ", Register { addr: Address { base: 20, count: 1, width: 1 }, brief: Some("Clear RD_REQ interrupt"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CLR_RX_DONE", Field { brief: Some("Read this register to clear the R_RX_DONE interrupt (bit 7) of the RAW_INTR_STAT register."), details: None, lo: 0, hi: 1 });
        regs.insert("CLR_RX_DONE", Register { addr: Address { base: 22, count: 1, width: 1 }, brief: Some("Clear RX_DONE interrupt"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CLR_RX_OVER", Field { brief: Some("Read this register to clear the R_RX_OVER interrupt (bit 1) of the RAW_INTR_STAT register."), details: None, lo: 0, hi: 1 });
        regs.insert("CLR_RX_OVER", Register { addr: Address { base: 18, count: 1, width: 1 }, brief: Some("Clear RX_OVER interrupt"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CLR_RX_UNDER", Field { brief: Some("Read this register to clear the R_RX_UNDER interrupt (bit 0) of the RAW_INTR_STAT register."), details: None, lo: 0, hi: 1 });
        regs.insert("CLR_RX_UNDER", Register { addr: Address { base: 17, count: 1, width: 1 }, brief: Some("Clear RX_UNDER interrupt"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CLR_START_DET", Field { brief: Some("Read this register to clear the R_START_DET interrupt (bit 10) of the RAW_INTR_STAT register."), details: None, lo: 0, hi: 1 });
        regs.insert("CLR_START_DET", Register { addr: Address { base: 25, count: 1, width: 1 }, brief: Some("Clear START_DET interrupt"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CLR_STOP_DET", Field { brief: Some("Read this register to clear the R_STOP_DET interrupt (bit 9) of the RAW_INTR_STAT register."), details: None, lo: 0, hi: 1 });
        regs.insert("CLR_STOP_DET", Register { addr: Address { base: 24, count: 1, width: 1 }, brief: Some("Clear STOP_DET interrupt"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CLR_TX_ABRT", Field { brief: Some("Read this register to clear the R_TX_ABRT interrupt (bit 6) of the RAW_INTR_STAT register, and the TX_ABRT_SOURCE register. Refer to Bit 9 of the TX_ABRT_SOURCE register for an exception to clearing TX_ABRT_SOURCE."), details: None, lo: 0, hi: 1 });
        regs.insert("CLR_TX_ABRT", Register { addr: Address { base: 21, count: 1, width: 1 }, brief: Some("Clear TX_ABRT interrupt"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CLR_TX_OVER", Field { brief: Some("Read this register to clear the R_TX_OVER interrupt (bit 3) of the RAW_INTR_STAT register."), details: None, lo: 0, hi: 1 });
        regs.insert("CLR_TX_OVER", Register { addr: Address { base: 19, count: 1, width: 1 }, brief: Some("Clear TX_OVER interrupt"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ADD_ENCODED_PARAMS", Field { brief: Some("This value indicates if this register is valid or not."), details: Some("'0': Dones not have encoded parameters. '1': Has encoded parameters."), lo: 7, hi: 8 });
        fields.insert("APB_DATA_WIDTH", Field { brief: Some("The value of this register is derived from the APB_DATA_WIDTH coreConsultant parameter."), details: Some("0: 8 bits 1: 16 bits 2: 32 bits"), lo: 0, hi: 2 });
        fields.insert("HAS_DMA", Field { brief: None, details: Some("'0': Does not have DMA interface. '1': Has DMA interface."), lo: 6, hi: 7 });
        fields.insert("HC_COUNT_VALUES", Field { brief: Some("The value of this register is derived from the HC_COUNT_VALUES coreConsultant parameter."), details: None, lo: 4, hi: 5 });
        fields.insert("INTR_IO", Field { brief: Some("The value of this register is derived from the IC_INTR_IO coreConsultant parameter."), details: None, lo: 5, hi: 6 });
        fields.insert("MAX_SPEED_MODE", Field { brief: Some("The maximum TWI speed of the controller."), details: Some("1: Standard 2: Fast 3: High"), lo: 2, hi: 4 });
        fields.insert("RX_BUFFER_DEPTH", Field { brief: Some("The depth of the RX buffer."), details: None, lo: 8, hi: 16 });
        fields.insert("TX_BUFFER_DEPTH", Field { brief: Some("The depth of the TX buffer."), details: None, lo: 16, hi: 24 });
        regs.insert("COMP_PARAM_1", Register { addr: Address { base: 61, count: 1, width: 1 }, brief: Some("Component parameter"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("COMP_TYPE", Field { brief: Some("Component Type number = 0x44_57_01_40, this assigned unique hex value is constant."), details: None, lo: 0, hi: 32 });
        regs.insert("COMP_TYPE", Register { addr: Address { base: 63, count: 1, width: 1 }, brief: Some("Component type"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("COMP_VERSION", Field { brief: Some("Specific values for this register are described in the Releases Table in the Release Notes."), details: None, lo: 0, hi: 32 });
        regs.insert("COMP_VERSION", Register { addr: Address { base: 62, count: 1, width: 1 }, brief: Some("Component version"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ENABLE", Field { brief: Some("Controls whether the TWI controller is enabled. Software can disable the controller while it is active. However, it is important that care be taken to ensure that the controller is disabled properly. When TWI controller is disabled, the following occurs: The TX FIFO and RX FIFO get flushed. The interrupt bits in the RAW_INTR_STAT register are cleared. Status bits in the INTR_STAT register are still active until the TWI controller goes into IDLE state. If the module is transmitting, it stops as well as deletes the contents of the transmit buffer after the current transfer is complete. If the module is receiving, the controller stops the current transfer at the end of the current byte and does not acknowledge the transfer."), details: Some("'0': Disables TWI controller '1': Enables TWI controller"), lo: 0, hi: 1 });
        regs.insert("CTRL", Register { addr: Address { base: 27, count: 1, width: 1 }, brief: Some("TWI control"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CMD", Field { brief: Some("This bit controls whether a read or a write is performed. This bit does not control the direction when the TWI acts as a slave. It controls only the direction when it acts as a master. When a command is entered in the TX FIFO, this bit distinguishes the write and read commands. In slave-receiver mode, this bit is a \"don't care\" because writes to this register are not required. In slave-transmitter mode, a \"0\" indicates that CPU data is to be transmitted and as DATA. When programming this bit, remember the following: attempting to perform a read operation after a General Call command has been sent results in a TX_ABRT interrupt (RAW_INTR_STAT.R_TX_ABRT), unless TAR.GC_OR_START_ENA has been cleared. If a \"1\" is written to this bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs. NOTE: It is possible that while attempting a master TWI read transfer, a RD_REQ interrupt may have occurred simultaneously due to a remote TWI master addressing this controller. In this type of scenario, the TWI controller ignores the DATA_CMD write, generates a TX_ABRT interrupt, and waits to service the RD_REQ interrupt."), details: Some("'1' = Read '0' = Write"), lo: 8, hi: 9 });
        fields.insert("DATA", Field { brief: Some("This register contains the data to be transmitted or received on the TWI bus. If you are writing to this register and want to perform a read, this field is ignored by the controller. However, when you read this register, these bits return the value of data received on the TWI interface."), details: None, lo: 0, hi: 8 });
        regs.insert("DATA_CMD", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Rx/Tx data buffer and command"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BUSY", Field { brief: Some("When read as 1, the TWI controller is deemed to be actively involved in an TWI transfer, irrespective of whether being in an address or data phase for all master or slave modes. When read as 0, the TWI controller is deemed completely inactive."), details: None, lo: 0, hi: 1 });
        fields.insert("SLV_FIFO_FILLED_AND_FLUSHED", Field { brief: Some("Slave FIFO Filled and Flushed. This bit indicates if a Slave-Receiver operation has been aborted with at least 1 data byte received from a TWI transfer due to the setting of ENABLE from 1 to 0. When read as 1, the TWI controller is deemed to have been actively engaged in an aborted TWI transfer (with matching address) and the data phase of the TWI transfer has been entered, even though the data byte has been responded with a NACK. When read as 0, the TWI controller is deemed to have been disabled when the TWI bus is idle."), details: None, lo: 2, hi: 3 });
        fields.insert("SLV_RX_ABORTED", Field { brief: Some("Slave-Receiver Operation Aborted. This bit indicates if a Slave-Receiver operation has been aborted due to the setting of the ENABLE register from 1 to 0. When read as 1, the TWI controller is deemed to have forced a NACK during any part of a TWI transfer, irrespective of whether the TWI address matches the slave address set in the TWI controller (SAR register). When read as 0, the TWI controller is deemed to have been disabled when the TWI bus is idle."), details: None, lo: 1, hi: 2 });
        regs.insert("ENABLE_STATUS", Register { addr: Address { base: 39, count: 1, width: 1 }, brief: Some("Enable status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FS_SCL_HCNT", Field { brief: Some("This register sets the SCL clock divider for the high-period in fast speed. This value must result in a value no less than 0.6us."), details: None, lo: 0, hi: 16 });
        regs.insert("FS_SCL_HCNT", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Fast speed TWI clock SCL high count"), details: Some("The clock for the TWI controller is the VCore system clock. This field must be set accordingly to the VCore system frequency; value = (0.6us / VCore clock period) - 8. Example: a 178.6MHz clock correspond to a period of 5.6ns, for this frequency this field must not be set lower than (round up): 100 = (0.6us / 5.6ns) - 8."), fields });
        let mut fields = HashMap::new();
        fields.insert("FS_SCL_LCNT", Field { brief: Some("This register sets the SCL clock divider for the low-period in fast speed. This value must result in a value no less than 1.3us."), details: None, lo: 0, hi: 16 });
        regs.insert("FS_SCL_LCNT", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("Fast speed TWI clock SCL low count"), details: Some("The clock for the TWI controller is the VCore system clock. This field must be set accordingly to the VCore system frequency; value = (1.3us / VCore clock period) - 1. Example: a 178.6MHz clock correspond to a period of 5.6ns, for this frequency this field must not be set lower than (round up): 232 = (1.3us / 5.6ns) - 1."), fields });
        let mut fields = HashMap::new();
        fields.insert("M_ACTIVITY", Field { brief: None, details: None, lo: 8, hi: 9 });
        fields.insert("M_GEN_CALL", Field { brief: None, details: None, lo: 11, hi: 12 });
        fields.insert("M_RD_REQ", Field { brief: None, details: None, lo: 5, hi: 6 });
        fields.insert("M_RX_DONE", Field { brief: None, details: None, lo: 7, hi: 8 });
        fields.insert("M_RX_FULL", Field { brief: None, details: None, lo: 2, hi: 3 });
        fields.insert("M_RX_OVER", Field { brief: None, details: None, lo: 1, hi: 2 });
        fields.insert("M_RX_UNDER", Field { brief: None, details: None, lo: 0, hi: 1 });
        fields.insert("M_START_DET", Field { brief: None, details: None, lo: 10, hi: 11 });
        fields.insert("M_STOP_DET", Field { brief: None, details: None, lo: 9, hi: 10 });
        fields.insert("M_TX_ABRT", Field { brief: None, details: None, lo: 6, hi: 7 });
        fields.insert("M_TX_EMPTY", Field { brief: None, details: None, lo: 4, hi: 5 });
        fields.insert("M_TX_OVER", Field { brief: None, details: None, lo: 3, hi: 4 });
        regs.insert("INTR_MASK", Register { addr: Address { base: 12, count: 1, width: 1 }, brief: Some("Interrupt mask"), details: Some("These fields mask the corresponding interrupt status fields (RAW_INTR_STAT). They are active high; a value of 0 prevents the corresponding field in RAW_INTR_STAT from generating an interrupt."), fields });
        let mut fields = HashMap::new();
        fields.insert("ACTIVITY", Field { brief: None, details: None, lo: 8, hi: 9 });
        fields.insert("GEN_CALL", Field { brief: None, details: None, lo: 11, hi: 12 });
        fields.insert("RD_REQ", Field { brief: None, details: None, lo: 5, hi: 6 });
        fields.insert("RX_DONE", Field { brief: None, details: None, lo: 7, hi: 8 });
        fields.insert("RX_FULL", Field { brief: None, details: None, lo: 2, hi: 3 });
        fields.insert("RX_OVER", Field { brief: None, details: None, lo: 1, hi: 2 });
        fields.insert("RX_UNDER", Field { brief: None, details: None, lo: 0, hi: 1 });
        fields.insert("START_DET", Field { brief: None, details: None, lo: 10, hi: 11 });
        fields.insert("STOP_DET", Field { brief: None, details: None, lo: 9, hi: 10 });
        fields.insert("TX_ABRT", Field { brief: None, details: None, lo: 6, hi: 7 });
        fields.insert("TX_EMPTY", Field { brief: None, details: None, lo: 4, hi: 5 });
        fields.insert("TX_OVER", Field { brief: None, details: None, lo: 3, hi: 4 });
        regs.insert("INTR_STAT", Register { addr: Address { base: 11, count: 1, width: 1 }, brief: Some("Interrupt status"), details: Some("Each field in this register has a corresponding mask field in the INTR_MASK register. These fields are cleared by reading the matching interrupt clear register. The unmasked raw versions of these fields are available in the RAW_INTR_STAT register. See RAW_INTR_STAT for a description of these fields"), fields });
        let mut fields = HashMap::new();
        fields.insert("R_ACTIVITY", Field { brief: Some("This bit captures TWI activity and stays set until it is cleared. There are four ways to clear it: Disabling the TWI controller Reading the CLR_ACTIVITY register Reading the CLR_INTR register VCore system reset Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the TWI controller module is idle, this bit remains set until cleared, indicating that there was activity on the bus."), details: None, lo: 8, hi: 9 });
        fields.insert("R_GEN_CALL", Field { brief: Some("Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling TWI controller or when the CPU reads bit 0 of the CLR_GEN_CALL register. The TWI controller stores the received data in the Rx buffer."), details: None, lo: 11, hi: 12 });
        fields.insert("R_RD_REQ", Field { brief: Some("This bit is set to 1 when the TWI controller acts as a slave and another TWI master is attempting to read data from this controller. The TWI controller holds the TWI bus in a wait state (SCL=0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the DATA_CMD register. This bit is set to 0 just after the required data is written to the DATA_CMD register."), details: None, lo: 5, hi: 6 });
        fields.insert("R_RX_DONE", Field { brief: Some("When the TWI controller is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done."), details: None, lo: 7, hi: 8 });
        fields.insert("R_RX_FULL", Field { brief: Some("Set when the receive buffer reaches or goes above the RX_TL threshold in the RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (ENABLE=0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the ENABLE field is programmed with a 0, regardless of the activity that continues."), details: None, lo: 2, hi: 3 });
        fields.insert("R_RX_OVER", Field { brief: Some("Set if the receive buffer is completely filled to RX_BUFFER_DEPTH and an additional byte is received from an external TWI device. The TWI controller acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (ENABLE=0), this bit keeps its level until the master or slave state machines go into idle, and when ENABLE_STATUS.BUSY goes to 0, this interrupt is cleared."), details: None, lo: 1, hi: 2 });
        fields.insert("R_RX_UNDER", Field { brief: Some("Set if the processor attempts to read the receive buffer when it is empty by reading from the DATA_CMD register. If the module is disabled (ENABLE=0), this bit keeps its level until the master or slave state machines go into idle, and when ENABLE_STATUS.BUSY goes to 0, this interrupt is cleared."), details: None, lo: 0, hi: 1 });
        fields.insert("R_START_DET", Field { brief: Some("Indicates whether a START or RESTART condition has occurred on the TWI regardless of whether the TWI controller is operating in slave or master mode."), details: None, lo: 10, hi: 11 });
        fields.insert("R_STOP_DET", Field { brief: Some("Indicates whether a STOP condition has occurred on the TWI controller regardless of whether the TWI controller is operating in slave or master mode."), details: None, lo: 9, hi: 10 });
        fields.insert("R_TX_ABRT", Field { brief: Some("This bit is set to 1 when the TWI controller is acting as a master is unable to complete a command that the processor has sent. The conditions that set this field are: No slave acknowledges the address byte. The addressed slave receiver does not acknowledge a byte of data. Attempting to send a master command when configured only to be a slave. When CFG.RESTART_ENA is set to 0 (RESTART condition disabled), and the processor attempts to issue a TWI function that is impossible to perform without using RESTART conditions. High-speed master code is acknowledged (this controller does not support high-speed). START BYTE is acknowledged. General Call address is not acknowledged. When a read request interrupt occurs and the processor has previously placed data in the Tx buffer that has not been transmitted yet. This data could have been intended to service a multi-byte RD_REQ that ended up having fewer numbers of bytes requested. The TWI controller loses arbitration of the bus between transfers and is then accessed as a slave-transmitter. If a read command is issued after a General Call command has been issued. Disabling the TWI reverts it back to normal operation. If the CPU attempts to issue read command before a RD_REQ is serviced. Anytime this bit is set, the contents of the transmit and receive buffers are flushed."), details: None, lo: 6, hi: 7 });
        fields.insert("R_TX_EMPTY", Field { brief: Some("This bit is set to 1 when the transmit buffer is at or below the threshold value set in the TX_TL register. It is automatically cleared by hardware when the buffer level goes above the threshold. When ENABLE is 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer activity, then with ENABLE_STATUS.BUSY=0, this bit is set to 0."), details: None, lo: 4, hi: 5 });
        fields.insert("R_TX_OVER", Field { brief: Some("Set during transmit if the transmit buffer is filled to TX_BUFFER_DEPTH and the processor attempts to issue another TWI command by writing to the DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ENABLE_STATUS.BUSY goes to 0, this interrupt is cleared."), details: None, lo: 3, hi: 4 });
        regs.insert("RAW_INTR_STAT", Register { addr: Address { base: 13, count: 1, width: 1 }, brief: Some("Raw interrupt status"), details: Some("Unlike the INTR_STAT register, these fields are not masked so they always show the true status of the TWI controller."), fields });
        let mut fields = HashMap::new();
        fields.insert("RESERVED1", Field { brief: None, details: None, lo: 0, hi: 32 });
        regs.insert("RESERVED1", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Reserved"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RESERVED2", Field { brief: None, details: None, lo: 0, hi: 32 });
        regs.insert("RESERVED2", Register { addr: Address { base: 9, count: 2, width: 1 }, brief: Some("Reserved"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RESERVED3", Field { brief: None, details: None, lo: 0, hi: 32 });
        regs.insert("RESERVED3", Register { addr: Address { base: 31, count: 1, width: 1 }, brief: Some("Reserved"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RESERVED4", Field { brief: None, details: None, lo: 0, hi: 32 });
        regs.insert("RESERVED4", Register { addr: Address { base: 34, count: 1, width: 1 }, brief: Some("Reserved"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RESERVED5", Field { brief: None, details: None, lo: 0, hi: 32 });
        regs.insert("RESERVED5", Register { addr: Address { base: 35, count: 1, width: 1 }, brief: Some("Reserved"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RESERVED6", Field { brief: None, details: None, lo: 0, hi: 32 });
        regs.insert("RESERVED6", Register { addr: Address { base: 36, count: 1, width: 1 }, brief: Some("Reserved"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RESERVED7", Field { brief: None, details: None, lo: 0, hi: 32 });
        regs.insert("RESERVED7", Register { addr: Address { base: 40, count: 21, width: 1 }, brief: Some("Reserved"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RESERVED8", Field { brief: None, details: None, lo: 0, hi: 32 });
        regs.insert("RESERVED8", Register { addr: Address { base: 33, count: 1, width: 1 }, brief: Some("Reserved"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RXFLR", Field { brief: Some("Receive FIFO Level. Contains the number of valid data entries in the receive FIFO."), details: None, lo: 0, hi: 3 });
        regs.insert("RXFLR", Register { addr: Address { base: 30, count: 1, width: 1 }, brief: Some("Receive FIFO level"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_TL", Field { brief: Some("Controls the level of entries (or above) that triggers the RX_FULL interrupt (bit 2 in RAW_INTR_STAT register). The valid range is 0-7. A value of 0 sets the threshold for 1 entry, and a value of 7 sets the threshold for 8 entries."), details: None, lo: 0, hi: 3 });
        regs.insert("RX_TL", Register { addr: Address { base: 14, count: 1, width: 1 }, brief: Some("Receive FIFO threshold"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SAR", Field { brief: Some("The SAR holds the slave address when the TWI is operating as a slave. For 7-bit addressing, only SAR[6:0] is used. This register can be written only when the TWI interface is disabled (ENABLE = 0)."), details: None, lo: 0, hi: 10 });
        regs.insert("SAR", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Slave address"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SDA_SETUP", Field { brief: Some("This register controls the amount of time delay (in terms of number of VCore clock periods) introduced in the rising edge of SCL, relative to SDA changing, when the TWI controller services a read request in a slave-receiver operation. The minimum for fast mode is 100ns, for nomal mode the minimum is 250ns."), details: None, lo: 0, hi: 8 });
        regs.insert("SDA_SETUP", Register { addr: Address { base: 37, count: 1, width: 1 }, brief: Some("SDA setup"), details: Some("This field must be set accordingly to the VCore system frequency; value = 100ns / VCore clock period. Example: a 178.6MHz clock correspond to a period of 5.6ns, for this frequency and fast TWI speed this field must not be set lower than (round up): 18 = 100ns / 5.6ns. For normal TWI speed this field must not be set lower than (round up): 45 = 250ns / 5.6ns."), fields });
        let mut fields = HashMap::new();
        fields.insert("SS_SCL_HCNT", Field { brief: Some("This register sets the SCL clock divider for the high-period in standard speed. This value must result in a high period of no less than 4us."), details: None, lo: 0, hi: 16 });
        regs.insert("SS_SCL_HCNT", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Standard speed TWI clock SCL high count"), details: Some("The clock for the TWI controller is the VCore system clock. This field must be set accordingly to the VCore system frequency; value = (4us / VCore clock period) - 8. Example: a 178.6MHz clock correspond to a period of 5.6ns, for this frequency this field must not be set lower than (round up): 707 = (4us / 5.6ns) - 8."), fields });
        let mut fields = HashMap::new();
        fields.insert("SS_SCL_LCNT", Field { brief: Some("This register sets the SCL clock divider for the low-period in standard speed. This value must result in a value no less than 4.7us."), details: None, lo: 0, hi: 16 });
        regs.insert("SS_SCL_LCNT", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Standard speed TWI clock SCL low count"), details: Some("The clock for the TWI controller is the VCore system clock. This field must be set accordingly to the VCore system frequency; value = (4.7us / VCore clock period) - 1. Example: a 178.6MHz clock correspond to a period of 5.6ns, for this frequency this field must not be set lower than (round up): 839 = (4.7us / 5.6ns) - 1."), fields });
        let mut fields = HashMap::new();
        fields.insert("BUS_ACTIVITY", Field { brief: Some("TWI Activity Status."), details: None, lo: 0, hi: 1 });
        fields.insert("MST_ACTIVITY", Field { brief: Some("Master FSM Activity Status. When the Master Finite State Machine (FSM) is not in the IDLE state, this bit is set."), details: Some("'0': Master FSM is in IDLE state so the Master part of the controller is not Active '1': Master FSM is not in IDLE state so the Master part of the controller is Active"), lo: 5, hi: 6 });
        fields.insert("RFF", Field { brief: Some("Receive FIFO Completely Full. When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared."), details: Some("'0': Receive FIFO is not full '1': Receive FIFO is full"), lo: 4, hi: 5 });
        fields.insert("RFNE", Field { brief: Some("Receive FIFO Not Empty. Set when the receive FIFO contains one or more entries and is cleared when the receive FIFO is empty. This bit can be polled by software to completely empty the receive FIFO."), details: Some("'0': Receive FIFO is empty '1': Receive FIFO is not empty"), lo: 3, hi: 4 });
        fields.insert("SLV_ACTIVITY", Field { brief: Some("Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is not in the IDLE state, this bit is set."), details: Some("'0': Slave FSM is in IDLE state so the Slave part of the controller is not Active '1': Slave FSM is not in IDLE state so the Slave part of the controller is Active"), lo: 6, hi: 7 });
        fields.insert("TFE", Field { brief: Some("Transmit FIFO Completely Empty. When the transmit FIFO is completely empty, this bit is set. When it contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt."), details: Some("'0': Transmit FIFO is not empty '1': Transmit FIFO is empty"), lo: 2, hi: 3 });
        fields.insert("TFNF", Field { brief: Some("Transmit FIFO Not Full. Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full."), details: Some("'0': Transmit FIFO is full '1': Transmit FIFO is not full"), lo: 1, hi: 2 });
        regs.insert("STAT", Register { addr: Address { base: 28, count: 1, width: 1 }, brief: Some("TWI status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("GC_OR_START", Field { brief: Some("If TAR.GC_OR_START_ENA is set to 1, then this bit indicates whether a General Call or START byte command is to be performed."), details: Some("'0': General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting RAW_INTR_STAT.R_TX_ABRT. The TWI controller remains in General Call mode until the TAR.GC_OR_START_ENA field is cleared. '1': START BYTE"), lo: 10, hi: 11 });
        fields.insert("GC_OR_START_ENA", Field { brief: Some("This bit indicates whether software performs a General Call or START BYTE command."), details: Some("'0': ignore bit 10 GC_OR_START and use TAR normally '1': perform special TWI command as specified in GC_OR_START bit"), lo: 11, hi: 12 });
        fields.insert("TAR", Field { brief: Some("This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE, the CPU needs to write only once into these bits. If the TAR and SAR are the same, loopback exists but the FIFOs are shared between master and slave, so full loopback is not feasible. Only one direction loopback mode is supported (simplex), not duplex. A master cannot transmit to itself; it can transmit to only a slave."), details: None, lo: 0, hi: 10 });
        regs.insert("TAR", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Target address"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TXFLR", Field { brief: Some("Transmit FIFO Level. Contains the number of valid data entries in the transmit FIFO."), details: None, lo: 0, hi: 3 });
        regs.insert("TXFLR", Register { addr: Address { base: 29, count: 1, width: 1 }, brief: Some("Transmit FIFO level"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ABRT_10ADDR1_NOACK", Field { brief: Some("Master is in 10-bit address mode and the first 10-bit address byte was not acknowledged by any slave."), details: None, lo: 1, hi: 2 });
        fields.insert("ABRT_10ADDR2_NOACK", Field { brief: Some("Master is in 10-bit address mode and the second address byte of the 10-bit address was not acknowledged by any slave."), details: None, lo: 2, hi: 3 });
        fields.insert("ABRT_10B_RD_NORSTRT", Field { brief: Some("The restart is disabled (RESTART_ENA bit (CFG[5]) = 0) and the master sends a read command in 10-bit addressing mode."), details: None, lo: 10, hi: 11 });
        fields.insert("ABRT_7B_ADDR_NOACK", Field { brief: Some("Master is in 7-bit addressing mode and the address sent was not acknowledged by any slave."), details: None, lo: 0, hi: 1 });
        fields.insert("ABRT_GCALL_NOACK", Field { brief: Some("TWI controller in master mode sent a General Call and no slave on the bus acknowledged the General Call."), details: None, lo: 4, hi: 5 });
        fields.insert("ABRT_GCALL_READ", Field { brief: Some("TWI controller in master mode sent a General Call but the user programmed the byte following the General Call to be a read from the bus (DATA_CMD[9] is set to 1)."), details: None, lo: 5, hi: 6 });
        fields.insert("ABRT_HS_ACKDET", Field { brief: Some("Master is in High Speed mode and the High Speed Master code was acknowledged (wrong behavior)."), details: None, lo: 6, hi: 7 });
        fields.insert("ABRT_HS_NORSTRT", Field { brief: Some("The restart is disabled (RESTART_ENA bit (CFG[5]) = 0) and the user is trying to use the master to transfer data in High Speed mode."), details: None, lo: 8, hi: 9 });
        fields.insert("ABRT_MASTER_DIS", Field { brief: Some("User tries to initiate a Master operation with the Master mode disabled."), details: None, lo: 11, hi: 12 });
        fields.insert("ABRT_SBYTE_ACKDET", Field { brief: Some("Master has sent a START Byte and the START Byte was acknowledged (wrong behavior)."), details: None, lo: 7, hi: 8 });
        fields.insert("ABRT_SBYTE_NORSTRT", Field { brief: Some("To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; restart must be enabled (CFG[5]=1), the SPECIAL bit must be cleared (TAR[11]), or the GC_OR_START bit must be cleared (TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, bit 9 clears for one cycle and then gets re-asserted."), details: Some("'1': The restart is disabled (RESTART_ENA bit (CFG[5]) = 0) and the user is trying to send a START Byte."), lo: 9, hi: 10 });
        fields.insert("ABRT_SLVFLUSH_TXFIFO", Field { brief: Some("Slave has received a read command and some data exists in the TX FIFO so the slave issues a TX_ABRT interrupt to flush old data in TX FIFO."), details: None, lo: 13, hi: 14 });
        fields.insert("ABRT_SLVRD_INTX", Field { brief: Some("When the processor side responds to a slave mode request for data to be transmitted to a remote master and user writes a 1 to DATA_CMD.CMD."), details: None, lo: 15, hi: 16 });
        fields.insert("ABRT_SLV_ARBLOST", Field { brief: Some("Slave lost the bus while transmitting data to a remote master. TX_ABRT_SOURCE[12] is set at the same time. Note: Even though the slave never \"owns\" the bus, something could go wrong on the bus. This is a fail safe check. For instance, during a data transmission at the low-to-high transition of SCL, if what is on the data bus is not what is supposed to be transmitted, then the TWI controller no longer own the bus."), details: None, lo: 14, hi: 15 });
        fields.insert("ABRT_TXDATA_NOACK", Field { brief: Some("This is a master-mode only bit. Master has received an acknowledgement for the address, but when it sent data byte(s) following the address, it did not receive an acknowledge from the remote slave(s)."), details: None, lo: 3, hi: 4 });
        fields.insert("ARB_LOST", Field { brief: Some("Master has lost arbitration, or if TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost arbitration. Note: the TWI controller can be both master and slave at the same time."), details: None, lo: 12, hi: 13 });
        regs.insert("TX_ABRT_SOURCE", Register { addr: Address { base: 32, count: 1, width: 1 }, brief: Some("Transmit abort source"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TX_TL", Field { brief: Some("Controls the level of entries (or below) that trigger the TX_EMPTY interrupt (bit 4 in RAW_INTR_STAT register). The valid range is 0-7. A value of 0 sets the threshold for 0 entries, and a value of 7 sets the threshold for 7 entries."), details: None, lo: 0, hi: 3 });
        regs.insert("TX_TL", Register { addr: Address { base: 15, count: 1, width: 1 }, brief: Some("Transmit FIFO threshold"), details: None, fields });
        groups.insert("TWI", RegisterGroup { addr: Address { base: 0, count: 1, width: 64 }, desc: "Two-Wire Interface controller", regs });
        out.insert("TWI", Target { desc: "\\see vtss_target_TWI_e Two-Wire Interface Controller", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("HTX", Field { brief: Some("This register is use to halt transmissions for testing, so that the transmit FIFO can be filled by the master when FIFOs are enabled."), details: Some("0: Halt tx disabled 1: Halt tx enabled"), lo: 0, hi: 1 });
        regs.insert("HTX", Register { addr: Address { base: 41, count: 1, width: 1 }, brief: Some("Halt tx"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("EDSSI", Field { brief: Some("Enable modem status interrupt. This is used to enable or disable the generation of Modem Status interrupt. This is the fourth highest priority interrupt."), details: Some("0: Disabled 1: Enabled"), lo: 3, hi: 4 });
        fields.insert("ELSI", Field { brief: Some("Enable receiver line status interrupt. This is used to enable or disable the generation of Receiver Line Status interrupt. This is the highest priority interrupt."), details: Some("0: Disabled 1: Enabled"), lo: 2, hi: 3 });
        fields.insert("ERBFI", Field { brief: Some("Enable received data available interrupt. This is used to enable or disable the generation of Received Data Available interrupt and the Character Timeout interrupt (if FIFOs are enabled). These are the second highest priority interrupts."), details: Some("0: Disabled 1: Enabled"), lo: 0, hi: 1 });
        fields.insert("ETBEI", Field { brief: Some("Enable transmit holding register empty interrupt. This is used to enable or disable the generation of Transmitter Holding Register Empty interrupt. This is the third highest priority interrupt."), details: Some("0: Disabled 1: Enabled"), lo: 1, hi: 2 });
        fields.insert("PTIME", Field { brief: Some("Programmable THRE interrupt mode enable. This is used to enable or disable the generation of THRE interrupt."), details: Some("0: Disabled 1: Enabled"), lo: 7, hi: 8 });
        regs.insert("IER", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Interrupt enable / divisor (high)"), details: Some("When the LCR.DLAB is set, this register is the upper 8 bits of the 16-bit Divisor register that contains the baud rate divisor for the UART. For more information and a description of how to calculate the baud rate, see RBR_THR."), fields });
        let mut fields = HashMap::new();
        fields.insert("FIFOE", Field { brief: Some("This description is valid for writes only. Reading this field has special meaning; for more information, see the general register description. FIFO Enable. This enables or disables the transmit (XMIT) and receive (RCVR) FIFOs. Whenever the value of this bit is changed, both the XMIT and RCVR controller portion of FIFOs are reset."), details: None, lo: 0, hi: 1 });
        fields.insert("FIFOSE_RT", Field { brief: Some("When reading this field, the current status of the FIFO is returned; 00 for disabled or 11 for enabled. Writing this field selects the trigger level in the receive FIFO at which the Received Data Available interrupt is generated (see encoding.) In auto flow control mode, it is used to determine when to generate back-pressure using the RTS signal."), details: Some("00: 1 character in the Rx FIFO 01: Rx FIFO 1/4 full 10: Rx FIFO 1/2 full 11: Rx FIFO 2 less than full"), lo: 6, hi: 8 });
        fields.insert("RFIFOR", Field { brief: Some("This description is valid for writes only. Reading this field has special meaning; for more information, see the general register description. Rx FIFO Reset. This resets the control portion of the receive FIFO and treats the FIFO as empty. Note that this bit is self-clearing. It is not necessary to clear this bit."), details: None, lo: 1, hi: 2 });
        fields.insert("TET", Field { brief: Some("Tx empty trigger. When the THRE mode is enabled (IER.PTIME), this field selects the empty threshold level at which the THRE Interrupts are generated."), details: Some("00: Tx FIFO empty 01: 2 characters in the Tx FIFO 10: Tx FIFO 1/4 full 11: Tx FIFO 1/2 full"), lo: 4, hi: 6 });
        fields.insert("XFIFOR", Field { brief: Some("This description is valid for writes only. Reading this field has special meaning; for more information, see the general register description. Tx FIFO Reset. This resets the control portion of the transmit FIFO and treats the FIFO as empty. Note that this bit is self-clearing. It is not necessary to clear this bit."), details: None, lo: 2, hi: 3 });
        regs.insert("IIR_FCR", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Interrupt identification / FIFO control register"), details: Some("This register has special meaning when reading, here the lowest 4 bits indicate interrupting sources. The encoding is as follows: 0110; type: Receiver line status, priority: Highest. Overrun/parity/ framing errors or break interrupt. Cleared by reading LSR. 0100; type: Received data available, priority: Second. RCVR FIFO trigger level reached. Cleared when FIFO drops below the trigger level. 1100; type: Character timeout indication, priority: Second. No characters in or out of the RCVR FIFO during the last four character times and there is at least 1 character in it during this time. Cleared by reading the receiver buffer register. 0010; type: Transmit holding register empty, priority: Third. Transmitter holding register empty (Prog. THRE Mode disabled) or XMIT FIFO at or below threshold (Prog. THRE Mode enabled). Cleared by reading the IIR register (if source of interrupt); or, writing into THR (THRE Mode disabled) or XMIT FIFO above threshold (THRE Mode enabled). 0000; type: Modem status, priority: Fourth. Clear to send. Note that if auto flow control mode is enabled, a change in CTS (that is, DCTS set) does not cause an interrupt. Cleared by reading the Modem status register. 0111; type: Busy detect indication, priortiy: Fifth. Master has tried to write to the Line Control register while the UART is busy (USR[0] is set to one). Cleared by reading the UART status register. 0001: No interrupting sources."), fields });
        let mut fields = HashMap::new();
        fields.insert("BC", Field { brief: Some("Break control bit.This bit is used to cause a break condition to be transmitted to the receiving device. If set to one, the serial output is forced to the spacing (logic 0) state. When not in Loopback Mode, as determined by MCR[4], the sout line is forced low until the Break bit is cleared."), details: None, lo: 6, hi: 7 });
        fields.insert("DLAB", Field { brief: Some("Divisor latch access bit. This bit is used to enable reading and writing of the Divisor registers (RBR_THR and IER) to set the baud rate of the UART. To access other registers, this bit must be cleared after initial baud rate setup."), details: None, lo: 7, hi: 8 });
        fields.insert("DLS", Field { brief: Some("Data length select. This is used to select the number of data bits per character that the peripheral transmits and receives. The following settings specify the number of bits that may be selected."), details: Some("00: 5 bits 01: 6 bits 10: 7 bits 11: 8 bits"), lo: 0, hi: 2 });
        fields.insert("EPS", Field { brief: Some("Even parity select. This bit is used to select between even and odd parity, when parity is enabled (PEN set to one). If set to one, an even number of logic 1s is transmitted or checked. If set to zero, an odd number of logic 1s is transmitted or checked."), details: None, lo: 4, hi: 5 });
        fields.insert("PEN", Field { brief: Some("Parity enable. This bit is used to enable or disable parity generation and detection in both transmitted and received serial characters."), details: Some("0: Parity disabled 1: Parity enabled"), lo: 3, hi: 4 });
        fields.insert("STOP", Field { brief: Some("Number of stop bits. This is used to select the number of stop bits per character that the peripheral transmits and receives. If set to zero, one stop bit is transmitted in the serial data. If set to one and the data bits are set to 5 (LCR.DLS), one and a half stop bits are transmitted. Otherwise, two stop bits are transmitted. Note that regardless of the number of stop bits selected, the receiver checks only the first stop bit."), details: Some("0: 1 stop bit 1: 1.5 stop bits when LCR.DLS is zero, otherwise, 2 stop bits"), lo: 2, hi: 3 });
        regs.insert("LCR", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Line control"), details: Some("Writes can be made to this register, with the exception of the BC field, only when UART is not busy, that is, when USR.BUSY is zero. This register can always be read."), fields });
        let mut fields = HashMap::new();
        fields.insert("BI", Field { brief: Some("Break interrupt bit. This is used to indicate the detection of a break sequence on the serial input data. It is set whenever the serial input is held in a logic 0 state for longer than the sum of start time + data bits + parity + stop bits. A break condition on serial input causes one and only one character, consisting of all-zeros, to be received by the UART. In the FIFO mode, the character associated with the break condition is carried through the FIFO and is revealed when the character is at the top of the FIFO. Reading the LSR clears the BI bit. In the non-FIFO mode, the BI indication occurs immediately and persists until the LSR is read."), details: None, lo: 4, hi: 5 });
        fields.insert("DR", Field { brief: Some("Data ready. This is used to indicate that the receiver contains at least one character in the receiver FIFO. This bit is cleared when the RX FIFO is empty."), details: Some("0: No data ready 1: Data ready"), lo: 0, hi: 1 });
        fields.insert("FE", Field { brief: Some("Framing error bit. This is used to indicate the a framing error in the receiver. A framing error occurs when the receiver does not detect a valid STOP bit in the received data. A framing error is associated with a received character. Therefore, in FIFO mode, an error is revealed when the character with the framing error is at the top of the FIFO. When a framing error occurs, the UART tries to resynchronize. It does this by assuming that the error was due to the start bit of the next character and then continues to receive the other bit, that is, data and/or parity, and then stops. Note that this field is set if a break interrupt has occurred, as indicated by Break Interrupt (LSR.BI). This field is cleared on read."), details: Some("0: No framing error 1: Framing error"), lo: 3, hi: 4 });
        fields.insert("OE", Field { brief: Some("Overrun error bit. This is used to indicate the occurrence of an overrun error. This occurs if a new data character was received before the previous data was read. In non-FIFO mode, the OE bit is set when a new character arrives before the previous character was read. When this happens, the data in the RBR is overwritten. In FIFO mode, an overrun error occurs when the FIFO is full and a new character arrives at the receiver. The data in the FIFO is retained and the data in the receive shift register is lost. This field is cleared on read."), details: Some("0: No overrun error 1: Overrun error"), lo: 1, hi: 2 });
        fields.insert("PE", Field { brief: Some("Parity error bit. This is used to indicate the occurrence of a parity error in the receiver if the Parity Enable bit (LCR.PEN) is set. A parity error is associated with a received character. Therefore, in FIFO mode, an error is revealed when the character with the parity error arrives at the top of the FIFO. Note that this field is set if a break interrupt has occurred, as indicated by Break Interrupt (LSR.BI). This field is cleared on read."), details: Some("0: No parity error 1: Parity error"), lo: 2, hi: 3 });
        fields.insert("RFE", Field { brief: Some("Receiver FIFO error bit. This bit is only valid when FIFOs are enabled. This is used to indicate whether there is at least one parity error, framing error, or break indication in the FIFO. This bit is cleared when the LSR is read, the character with the error is at the top of the receiver FIFO, and there are no subsequent errors in the FIFO."), details: Some("0: No error in Rx FIFO 1: Error in Rx FIFO"), lo: 7, hi: 8 });
        fields.insert("TEMT", Field { brief: Some("Transmitter empty bit. If FIFOs are enabled, this bit is set whenever the Transmitter Shift Register and the FIFO are both empty."), details: None, lo: 6, hi: 7 });
        fields.insert("THRE", Field { brief: Some("If FIFO (IIR_FCR.FIFOE) and THRE mode are enabled (IER.PTIME), this bit indicates that the Tx FIFO is full. Otherwise, this bit indicates that the Tx FIFO is empty."), details: None, lo: 5, hi: 6 });
        regs.insert("LSR", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Line status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("AFCE", Field { brief: Some("Auto flow control enable. This mode requires that FIFOs are enabled and that MCR.RTS is set."), details: Some("0: Auto flow control mode disabled 1: Auto flow control mode enabled"), lo: 5, hi: 6 });
        fields.insert("LB", Field { brief: Some("Loopback Bit. This is used to put the UART into a diagnostic mode for test purposes. The transmit line is held high, while serial transmit data is looped back to the receive line internally. In this mode, all the interrupts are fully functional. In addition, in loopback mode, the modem control input CTS is disconnected, and the modem control output RTS is looped back to the input internally."), details: None, lo: 4, hi: 5 });
        fields.insert("RTS", Field { brief: Some("Request to send. This is used to directly control the Request to Send (RTS) output. The RTS output is used to inform the partner that the UART is ready to exchange data. The RTS is still controlled from this field when Auto RTS Flow Control is enabled (MCR.AFCE), but the output can be forced high by the flow control mechanism. If this field is cleared, the UART permanently indicates backpressure to the partner."), details: Some("0: RTS is set high 1: RTS is set low"), lo: 1, hi: 2 });
        regs.insert("MCR", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Modem control"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CTS", Field { brief: Some("Clear to send. This field indicates the current state of the modem control line, CTS. When the Clear to Send input (CTS) is asserted, it is an indication that the partner is ready to exchange data with the UART."), details: Some("0: CTS input is deasserted (logic 0) 1: CTS input is asserted (logic 1)"), lo: 4, hi: 5 });
        fields.insert("DCTS", Field { brief: Some("Delta clear to send. This is used to indicate that the modem control line, CTS, has changed since the last time the MSR was read. Reading the MSR clears the DCTS bit. Note: If the DCTS bit is not set, the CTS signal is asserted, and a reset occurs (software or otherwise), then the DCTS bit is set when the reset is removed, if the CTS signal remains asserted. A read of the MSR after reset can be performed to prevent unwanted interrupts."), details: Some("0: No change on CTS since the last read of the MSR 1: Change on CTS since the last read of the MSR"), lo: 0, hi: 1 });
        regs.insert("MSR", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Modem status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RBR_THR", Field { brief: Some("Use this register to access the Rx and Tx FIFOs. When reading: The data in this register is valid only if LSR.DR is set. If FIFOs are disabled (IIR_FCR.FIFOE), the data in this register must be read before the next data arrives, otherwise it is overwritten, resulting in an overrun error. When FIFOs are enabled (IIR_FCR.FIFOE), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO is preserved, but any incoming data is lost and an overrun error occurs. When writing: Data should only be written to this register when the LSR.THRE indicates that there is room in the FIFO. If FIFOs are disabled (IIR_FCR.FIFOE), writes to this register while LSR.THRE is zero, causes the register to be overwritten. When FIFOs are enabled (IIR_FCR.FIFOE) and LSR.THRE is set, 16 characters may be written to this register before the FIFO is full. Any attempt to write data when the FIFO is full results in the write data being lost."), details: None, lo: 0, hi: 8 });
        regs.insert("RBR_THR", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Receive buffer / transmit holding / divisor (low)"), details: Some("When the LCR.DLAB is set, this register is the lower 8 bits of the 16-bit Divisor register that contains the baud rate divisor for the UART. The output baud rate is equal to the VCore system clock frequency divided by sixteen times the value of the baud rate divisor, as follows: baud rate = (VCore clock freq) / (16 * divisor). Note that with the Divisor set to zero, the baud clock is disabled and no serial communications occur. In addition, once this register is set, wait at least 0.1us before transmitting or receiving data."), fields });
        let mut fields = HashMap::new();
        fields.insert("RESERVED1", Field { brief: None, details: None, lo: 0, hi: 32 });
        regs.insert("RESERVED1", Register { addr: Address { base: 8, count: 23, width: 1 }, brief: Some("Reserved"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RESERVED2", Field { brief: None, details: None, lo: 0, hi: 32 });
        regs.insert("RESERVED2", Register { addr: Address { base: 32, count: 9, width: 1 }, brief: Some("Reserved"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SCR", Field { brief: Some("This register is for programmers to use as a temporary storage space. It has no functional purpose for the UART."), details: None, lo: 0, hi: 8 });
        regs.insert("SCR", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Scratchpad"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BUSY", Field { brief: Some("UART busy."), details: Some("0: UART is idle or inactive 1: UART is busy (actively transferring data)"), lo: 0, hi: 1 });
        regs.insert("USR", Register { addr: Address { base: 31, count: 1, width: 1 }, brief: Some("UART status"), details: None, fields });
        groups.insert("UART", RegisterGroup { addr: Address { base: 0, count: 1, width: 42 }, desc: "UART", regs });
        out.insert("UART", Target { desc: "\\see vtss_target_UART_e UART Controller", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ACKN", Field { brief: Some("Acknowledge bit (this bit is automatically overwritten by ANEG)"), details: None, lo: 14, hi: 15 });
        fields.insert("ADV_ABIL_LSB", Field { brief: Some("Reserved for future technology as defined in IEEE 802.3ap clause 73."), details: None, lo: 24, hi: 32 });
        fields.insert("CAP_10GKR", Field { brief: Some("Technology Ability to be advertised (here: 10GBase-KR)"), details: Some("0: Do not advertise 10GB-KR capability 1: Advertise 10GB-KR capability"), lo: 23, hi: 24 });
        fields.insert("CAP_10GKX4", Field { brief: Some("Technology Ability to be advertised (here: 10GBase-KX4)"), details: Some("0: Do not advertise 10GB-KX4 capability 1: Advertise 10GB-KX4 capability"), lo: 22, hi: 23 });
        fields.insert("CAP_1GKX", Field { brief: Some("Technology Ability to be advertised (here: 1000Base-KX)"), details: Some("0: Do not advertise 1GB-KX capability 1: Advertise 1GB-KX capability"), lo: 21, hi: 22 });
        fields.insert("ECHOED_NONCE", Field { brief: Some("Reserved for echoed nonce field (must be cleared)"), details: None, lo: 5, hi: 10 });
        fields.insert("NP", Field { brief: Some("Next page exchange desired"), details: Some("0: Disable NP exchange 1: Enable NP exchange"), lo: 15, hi: 16 });
        fields.insert("PAUSE", Field { brief: Some("Pause field"), details: None, lo: 10, hi: 13 });
        fields.insert("RF", Field { brief: Some("RF bit (initial value)"), details: None, lo: 13, hi: 14 });
        fields.insert("SEL_FIELD", Field { brief: Some("Selector field (must be 0x1)"), details: None, lo: 0, hi: 5 });
        fields.insert("TX_NONCE", Field { brief: Some("Initial value for Transmit-Nonce field"), details: None, lo: 16, hi: 21 });
        regs.insert("ANEG_ADV_ABILITY_0", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("ANEG Advertised Ability 0"), details: Some("48 bits that contain the advertised abilities link code word for auto-negotiation (here: lower 32 bit)."), fields });
        let mut fields = HashMap::new();
        fields.insert("ADV_ABIL_MSB", Field { brief: Some("Reserved for future technology as defined in IEEE 802.3ap clause 73."), details: None, lo: 0, hi: 14 });
        fields.insert("FEC", Field { brief: Some("FEC capability (bit 14: FEC ability, bit 15: FEC requested) - Only used with 10GBase-KR"), details: None, lo: 14, hi: 16 });
        regs.insert("ANEG_ADV_ABILITY_1", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("ANEG Advertised Ability 1"), details: Some("48 bits that contain the advertised abilities link code word for auto-negotiation (here: upper 16 bit)."), fields });
        let mut fields = HashMap::new();
        fields.insert("ANEG_ENA", Field { brief: Some("Auto-negotiation enable"), details: Some("1: Enable 0: Disable"), lo: 0, hi: 1 });
        fields.insert("ANEG_FREQSEL_DIS", Field { brief: Some("Disable automatic ANEG speed setting"), details: Some("0: Allow ANEG to select frequency 1: Frequency is programmed using mode2g5_ena and hr_mode_ena"), lo: 15, hi: 16 });
        fields.insert("ANEG_OB_CTRL_DIS", Field { brief: Some("Disable automatic ANEG OB configuration"), details: Some("0: Allow ANEG block to control OB during auto-negotiation 1: OB settings are not touched by ANEG block"), lo: 16, hi: 17 });
        fields.insert("ANEG_PWDN_DIS", Field { brief: Some("Disable automatic power down of lane controlled by ANEG"), details: Some("0: Allow ANEG to power down unused lane 1: Power down is not controlled by ANEG"), lo: 14, hi: 15 });
        fields.insert("ANEG_RESET_ONE_SHOT", Field { brief: Some("Asynchronous reset reseting all auto-negotiation logic"), details: Some("1: Reset"), lo: 31, hi: 32 });
        fields.insert("ARB_TESTMODE", Field { brief: Some("Reserved for test purposes. ANEG wait timer values are divided by 2^15 and the parallel detect timers are divided by 2^10"), details: Some("1: Enable division 0: Normal operation"), lo: 20, hi: 21 });
        fields.insert("ATE_TESTMODE", Field { brief: Some("Reserved for test purposes. Disable nonce/link_status checks"), details: Some("1: Disable checks 0: Normal operation"), lo: 22, hi: 23 });
        fields.insert("BLTD_ENA", Field { brief: Some("Reserved"), details: None, lo: 7, hi: 8 });
        fields.insert("PD_TIMER_10GKX4", Field { brief: Some("Parallel detect wait time for 10G using four lanes"), details: Some("0: 0 ms 1: 10 ms 2: 20 ms 3: 40 ms"), lo: 12, hi: 14 });
        fields.insert("PD_TIMER_1GKX", Field { brief: Some("Parallel detect wait time for 1G using single lane"), details: Some("0: 0 ms 1: 10 ms 2: 20 ms 3: 40 ms"), lo: 10, hi: 12 });
        fields.insert("PD_TIMER_2G5", Field { brief: Some("Parallel detect wait time for 2.5G using single lane"), details: Some("0: 0 ms 1: 10 ms 2: 20 ms 3: 40 ms"), lo: 8, hi: 10 });
        fields.insert("RESTART_ANEG_ONE_SHOT", Field { brief: Some("Restart negotiation process"), details: Some("1: Restart"), lo: 1, hi: 2 });
        fields.insert("RX_TESTMODE", Field { brief: Some("Reserved for test purposes. Control of page_test_max_timer_done check"), details: Some("1: Disable check 0: Normal operation"), lo: 21, hi: 22 });
        fields.insert("TXBYP_TESTMODE", Field { brief: Some("Reserved for test purposes. Transmit data 0 on all bit positions if ANEG is active"), details: Some("1: Bypass ANEG data 0: Normal operation"), lo: 23, hi: 24 });
        regs.insert("ANEG_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("ANEG Configuration"), details: Some("Auto-negotiation configuration register. Note: Setting one of the parallel detect wait times to 0 disables parallel detect function for that specific mode."), fields });
        let mut fields = HashMap::new();
        fields.insert("NP_TX_LSB", Field { brief: Some("Lower 32 bits of next page link code word"), details: None, lo: 0, hi: 32 });
        regs.insert("ANEG_NEXT_PAGE_0", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("ANEG Next Page 0"), details: Some("48 bits that contain the new next page to transmit during auto-negotiation (here: lower 32 bits)."), fields });
        let mut fields = HashMap::new();
        fields.insert("LANE_SYNC_ENA", Field { brief: Some("Enable alignment of lane to a common clock (e.g. XAUI mode) and dock lane with ANEG of lane 0 (Master-ANEG)"), details: Some("0: Off 1: On"), lo: 4, hi: 8 });
        fields.insert("SIGDET_MODE", Field { brief: Some("Combine signal_detect information for all 4 lanes."), details: Some("0: Each lane provides own signal_detect 1: Signal_detect of all four lanes are ANDed"), lo: 0, hi: 1 });
        fields.insert("SIGDET_MODE_R", Field { brief: Some("Combine signal_detect information for lanes 0 and 2."), details: Some("0: Lane 0 and 2 provides own signal_detect 1: Signal_detect of lanes 0 and 2 are ANDed"), lo: 1, hi: 2 });
        regs.insert("VAUI_CHANNEL_CFG", Register { addr: Address { base: 0, count: 2, width: 1 }, brief: Some("Configuration for VAUI channel"), details: Some("Configuration register for specific vaui channel settings"), fields });
        groups.insert("ANEG_CFG", RegisterGroup { addr: Address { base: 2, count: 8, width: 5 }, desc: "ANEG Configuration Registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ACKN", Field { brief: Some("Acknowledge bit (this bit is automatically overwritten by ANEG)"), details: None, lo: 14, hi: 15 });
        fields.insert("CAP_10GKR", Field { brief: Some("Technology Ability advertised by LP (here: 10GBase-KR)"), details: Some("0: LP is not 10GB-KR capable 1: LP is 10GB-KR capable"), lo: 23, hi: 24 });
        fields.insert("CAP_10GKX4", Field { brief: Some("Technology Ability advertised by LP (here: 10GBase-KX4)"), details: Some("0: LP is not 10GB-KX4 capable 1: LP is 10GB-KX4 capable"), lo: 22, hi: 23 });
        fields.insert("CAP_1GKX", Field { brief: Some("Technology Ability advertised by LP (here: 1000Base-KX)"), details: Some("0: LP is not 1GB-KX capable 1: LP is 1GB-KX capable"), lo: 21, hi: 22 });
        fields.insert("ECHOED_NONCE", Field { brief: Some("Echoed nonce field"), details: None, lo: 5, hi: 10 });
        fields.insert("LP_ADV_ABIL_LSB", Field { brief: Some("Bits 31 down to 24 of link code word received from link partner."), details: None, lo: 24, hi: 32 });
        fields.insert("NP", Field { brief: Some("Next page exchange desired by LP"), details: Some("0: No NP exchange desired 1: NP exchange desired"), lo: 15, hi: 16 });
        fields.insert("PAUSE", Field { brief: Some("Pause field"), details: None, lo: 10, hi: 13 });
        fields.insert("RF", Field { brief: Some("RF bit"), details: None, lo: 13, hi: 14 });
        fields.insert("SEL_FIELD", Field { brief: Some("Selector field"), details: None, lo: 0, hi: 5 });
        fields.insert("TX_NONCE", Field { brief: Some("Transmit-Nonce field (received from LinkPartner)"), details: None, lo: 16, hi: 21 });
        regs.insert("ANEG_LP_ADV_ABILITY_0", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("ANEG Link Partner Advertised Ability 0"), details: Some("48 bits that contain the link partner's advertised abilities / next page information (received link code word, lower 32 bits, received during auto-negotiation). The bit groups are only valid for base pages; for next page data exchange a different bit group coding has to be applied."), fields });
        let mut fields = HashMap::new();
        fields.insert("FEC", Field { brief: Some("FEC capability (bit 14: FEC ability, bit 15: FEC requested) - Only used with 10GBase-KR"), details: None, lo: 14, hi: 16 });
        fields.insert("LP_ADV_ABIL_MSB", Field { brief: Some("Bits 45 down to 32 of link code word received from link partner."), details: None, lo: 0, hi: 14 });
        regs.insert("ANEG_LP_ADV_ABILITY_1", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("ANEG Link Partner Advertised Ability 1"), details: Some("48 bits that contain the link partner's advertised abilities or next page information (received link code word, upper 16 bits, received during auto-negotiation). The bit groups are only valid for base pages; for next page data exchange a different bit group coding has to be applied."), fields });
        let mut fields = HashMap::new();
        fields.insert("NEXT_PAGE_LOADED_ONE_SHOT", Field { brief: Some("Must be set when a new next page is programmed (self-clearing)"), details: None, lo: 31, hi: 32 });
        fields.insert("NP_TX_MSB", Field { brief: Some("Upper 16 bits of next page link code word"), details: None, lo: 0, hi: 16 });
        regs.insert("ANEG_NEXT_PAGE_1", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("ANEG Next Page 1"), details: Some("48 bits that contain the new next page to transmit during auto-negotiation (here: upper 16 bits)."), fields });
        let mut fields = HashMap::new();
        fields.insert("ANEG_ARB_FSM_ERR_STICKY", Field { brief: Some("Error condition indicating an Arbitration state machine error."), details: Some("Bit is cleared by writing a 1 to this position."), lo: 20, hi: 21 });
        fields.insert("ANEG_COMPLETE", Field { brief: Some("Status indicating whether auto-negotiation has completed."), details: None, lo: 0, hi: 1 });
        fields.insert("ANEG_RX_FSM_ERR_STICKY", Field { brief: Some("Error condition indicating a Receive state machine error."), details: Some("Bit is cleared by writing a 1 to this position."), lo: 19, hi: 20 });
        fields.insert("ANEG_TX_FSM_ERR_STICKY", Field { brief: Some("Error condition indicating a Transmit state machine error."), details: Some("Bit is cleared by writing a 1 to this position."), lo: 18, hi: 19 });
        fields.insert("ARBITER_STATE", Field { brief: Some("Current state of Arbiter State Machine"), details: Some("0000: AUTO_NEG_ENA 0001: TX_DISABLE 0010: ABILITY_DETECT 0011: ACKN_DETECT 0100: COMPLETE_ACKN 0101: AN_GOOD_CHECK 0110: AN_GOOD 0111: NEXT_PAGE_WAIT 1000: LINK_STATUS_CHECK 1001: PARALLEL_DET_FAULT 1010: PD_CHECK10GKR 1011: PD_CHECK2G5 1100: PD_CHECK1GKX 1101: PD_CHECK10GKX4"), lo: 8, hi: 12 });
        fields.insert("INCOMPATIBLE_LINK", Field { brief: Some("Error condition indicating that no compatible link was found."), details: None, lo: 17, hi: 18 });
        fields.insert("LINK_CTRL_10GKX4", Field { brief: Some("Link control information for 10G quad lane mode"), details: Some("00: Disabled 01: Enabled 11: Scan for carrier"), lo: 28, hi: 30 });
        fields.insert("LINK_CTRL_1GKX", Field { brief: Some("Link control information for 1G single lane mode"), details: Some("00: Disabled 01: Enabled 11: Scan for carrier"), lo: 26, hi: 28 });
        fields.insert("LINK_CTRL_2G5", Field { brief: Some("Link control information for 2.5G single lane mode"), details: Some("00: Disabled 01: Enabled 11: Scan for carrier"), lo: 24, hi: 26 });
        fields.insert("LP_ANEG_ABLE", Field { brief: Some("Status indicating whether the link partner supports auto-negotiation."), details: None, lo: 1, hi: 2 });
        fields.insert("PAGE_RX", Field { brief: Some("Status indicating whether a new page has been received."), details: None, lo: 3, hi: 4 });
        fields.insert("PAR_DETECT_FAULT_STICKY", Field { brief: Some("Error condition indicating errors during parallel detection."), details: Some("Bit is cleared by writing a 1 to this position."), lo: 16, hi: 17 });
        regs.insert("ANEG_STATUS", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("ANEG Status"), details: Some("Auto negotiation status register"), fields });
        groups.insert("ANEG_STATUS", RegisterGroup { addr: Address { base: 42, count: 8, width: 3 }, desc: "ANEG Status Registers", regs });
        let regs = HashMap::new();
        groups.insert("VAUI_CHANNEL_CFG", RegisterGroup { addr: Address { base: 0, count: 1, width: 2 }, desc: "VAUI channel Configuration Registers", regs });
        out.insert("VAUI_CHANNEL", Target { desc: "\\see vtss_target_VAUI_CHANNEL_e Vaui channel configuration and status register set", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("IF_CNT", Field { brief: Some("The number of VCAP interfaces."), details: None, lo: 0, hi: 32 });
        regs.insert("IF_CNT", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("Number of VCAP interfaces"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TCAM_BIAS", Field { brief: Some("Bias setting for the TCAM keeper circuit, configure as described in datasheet."), details: None, lo: 0, hi: 6 });
        fields.insert("TCAM_BIST_SOE_ENA", Field { brief: Some("Configures the BIST engine to stop testing if an error is detected. This is a debug feature that leaves the contents of the TCAM at the point of the failure, thusly allowing debug of the failing pattern via normal R/W to the TCAM. Note that because the bist is pipelilned, the contents of the TCAM may have been modified a few times since the actual error."), details: None, lo: 8, hi: 9 });
        fields.insert("TCAM_CG_DIS", Field { brief: Some("Disable clock-gating in the TCAM, clock-gating is implemented for conserving power while the TCAMs are IDLE."), details: None, lo: 6, hi: 7 });
        fields.insert("TCAM_HCG_DIS", Field { brief: Some("Disable clock-gating on previous stage hit in the TCAM, clock-gating on previous stage hit is implemented for conserving power when a hit is found in an early pipeline stage."), details: None, lo: 7, hi: 8 });
        regs.insert("TCAM_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Configuration of the TCAM"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TCAM_BIST", Field { brief: Some("Set this field to start manual BIST of the TCAM. This field will be cleared once BIST is complete. The BIST procedure requires that the TCAM is initialized before start, setting TCAM_INIT at the same time as setting this field will first initalize the TCAM and then run BIST."), details: None, lo: 1, hi: 2 });
        fields.insert("TCAM_INIT", Field { brief: Some("Set this field to start manual initialization of the TCAM. This field is cleared once initialization is complete. The TCAM has random contents after reset and must be initialized prior to usage."), details: None, lo: 0, hi: 1 });
        regs.insert("TCAM_CTRL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Control of the TCAM"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("BIST_ADDR_ERR", Field { brief: Some("Set if BIST sub-procedure Address Decode failed."), details: None, lo: 12, hi: 13 });
        fields.insert("BIST_BL0E_ERR", Field { brief: Some("Set if BIST sub-procedure Bit-Line-0 (extended) failed."), details: None, lo: 9, hi: 10 });
        fields.insert("BIST_BL0_ERR", Field { brief: Some("Set if BIST sub-procedure Bit-Line-0 failed."), details: None, lo: 8, hi: 9 });
        fields.insert("BIST_BL1E_ERR", Field { brief: Some("Set if BIST sub-procedure Bit-Line-1 (extended) failed."), details: None, lo: 11, hi: 12 });
        fields.insert("BIST_BL1_ERR", Field { brief: Some("Set if BIST sub-procedure Bit-Line-1 failed."), details: None, lo: 10, hi: 11 });
        fields.insert("BIST_BUSY", Field { brief: Some("Set while BIST is running. When checking the BIST result this field must be cleared."), details: None, lo: 1, hi: 2 });
        fields.insert("BIST_COMP_ERR", Field { brief: Some("Set if BIST sub-procedure Compare failed."), details: None, lo: 13, hi: 14 });
        fields.insert("BIST_ERR", Field { brief: Some("Set if BIST failed."), details: None, lo: 2, hi: 3 });
        fields.insert("BIST_PENC_ERR", Field { brief: Some("Set if BIST sub-procedure Priority-Encode failed."), details: None, lo: 14, hi: 15 });
        fields.insert("BIST_PH0_ERR", Field { brief: Some("Set if BIST sub-procedure Pattern-Horizontal-0 failed."), details: None, lo: 6, hi: 7 });
        fields.insert("BIST_PH1_ERR", Field { brief: Some("Set if BIST sub-procedure Pattern-Horizontal-1 failed."), details: None, lo: 7, hi: 8 });
        fields.insert("BIST_PV0_ERR", Field { brief: Some("Set if BIST sub-procedure Pattern-Vertical-0 failed."), details: None, lo: 4, hi: 5 });
        fields.insert("BIST_PV1_ERR", Field { brief: Some("Set if BIST sub-procedure Pattern-Vertical-1 failed."), details: None, lo: 5, hi: 6 });
        fields.insert("BIST_RT_ERR", Field { brief: Some("Set if BIST sub-procedure Read-Tree failed."), details: None, lo: 15, hi: 16 });
        fields.insert("BIST_RUN", Field { brief: Some("Set when the BIST has been run. When checking the BIST result this field must be set."), details: None, lo: 3, hi: 4 });
        fields.insert("TCAM_RDY", Field { brief: Some("Indicates the current operational state of the TCAM."), details: Some("'0': Busy with initialization. '1': Ready to be used."), lo: 0, hi: 1 });
        regs.insert("TCAM_STAT", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Status for the TCAM"), details: None, fields });
        groups.insert("TCAM_BIST", RegisterGroup { addr: Address { base: 240, count: 1, width: 3 }, desc: "Build in test for TCAM", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ACTION_DEF_CNT", Field { brief: Some("The number of default actions. For VCAPs with more than one interface (see VCAP_SUPER::IF_CNT); this field returns the total number of defaults for all interfaces."), details: None, lo: 0, hi: 32 });
        regs.insert("ACTION_DEF_CNT", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Number of defaults"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ACTION_WIDTH", Field { brief: Some("Width of action. For version 1 VCAPs this is full word width. For version 2 VCAPs this is the width of one action suboword."), details: None, lo: 0, hi: 32 });
        regs.insert("ACTION_WIDTH", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Action width"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CNT_WIDTH", Field { brief: Some("The width of the counter memory, this is the complete width of all counter-fields associated with one full-word entry. There is one counter per entry sub-word (see VCAP_SUPER::ENTRY_SWCNT for number of subwords.)"), details: None, lo: 0, hi: 32 });
        regs.insert("CNT_WIDTH", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Counter width"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CORE_CNT", Field { brief: Some("The number of parallel entry/action cores."), details: None, lo: 0, hi: 32 });
        regs.insert("CORE_CNT", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("Number of cores"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ENTRY_CNT", Field { brief: Some("Number of full-word entries (and actions) per core, see VCAP_SUPER::CORE_CNT for number of cores."), details: None, lo: 0, hi: 32 });
        regs.insert("ENTRY_CNT", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Number of full-word entries"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ENTRY_SWCNT", Field { brief: Some("The number of supported subwords per full-word entry."), details: None, lo: 0, hi: 32 });
        regs.insert("ENTRY_SWCNT", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Number of subwords per full-word entry"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ENTRY_TG_WIDTH", Field { brief: Some("The width of a single TypeGroup id. For version 2 VCAPs this field return 0, the subword-encoding is configured directly via VCAP_SUPER::VCAP_ENTRY_DAT and VCAP_SUPER::VCAP_MASK_DAT."), details: None, lo: 0, hi: 32 });
        regs.insert("ENTRY_TG_WIDTH", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Entry type-group width"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ENTRY_WIDTH", Field { brief: Some("Width of entry. For version 1 VCAPs this is full word width including bits for the TypeGroup id(s). For version 2 VCAPs this is the width of one entry suboword."), details: None, lo: 0, hi: 32 });
        regs.insert("ENTRY_WIDTH", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Entry width"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("VCAP_ROW_DELETED_STICKY", Field { brief: Some("A move operation has resulted in deleting of one or more rules. This field applies only to version 1 VCAPs, for version 2 VCAPs it is not implemented and reading it will return zero."), details: None, lo: 0, hi: 1 });
        regs.insert("VCAP_STICKY", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Debug information"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("VCAP_VER", Field { brief: Some("Version of the VCAP control logic."), details: Some("0: Version 1 1: Version 2"), lo: 0, hi: 32 });
        regs.insert("VCAP_VER", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("VCAP version"), details: None, fields });
        groups.insert("VCAP_CONST", RegisterGroup { addr: Address { base: 230, count: 1, width: 10 }, desc: "VCAP constants", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("ACTION_DAT", Field { brief: Some("The cache register that holds action. The register is replicated; index 0 is the 32 LSBs of the action."), details: None, lo: 0, hi: 32 });
        regs.insert("VCAP_ACTION_DAT", Register { addr: Address { base: 128, count: 64, width: 1 }, brief: Some("Action cache"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CNT_DAT", Field { brief: Some("The cache register that holds counter. The register is replicated; index 0 is the 32 LSBs of the counter. When the counter is 1 bit wide the counter operates as a 1 bit saturating counter; it is set by VCAP when a rule is matched by a key."), details: None, lo: 0, hi: 32 });
        regs.insert("VCAP_CNT_DAT", Register { addr: Address { base: 192, count: 32, width: 1 }, brief: Some("Counter cache"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ENTRY_DAT", Field { brief: Some("The cache register that holds entry data. The register is replicated; index 0 is the 32 LSBs of the entry-data. Together with VCAP_MASK_DAT.MASK_DAT this field defines match parameters for TCAM entries. Version 2 VCAPs allows programming of never-match, this is needed when disabling entries. Version 1 VCAPs converts match-off to match-any when reading/writing entries."), details: Some("Match-0: Entry=0, Mask=0 Match-1: Entry=1, Mask=0 Match-any (don't care): Entry=0, Mask=1 Match-off (never-match): Entry=1, Mask=1"), lo: 0, hi: 32 });
        regs.insert("VCAP_ENTRY_DAT", Register { addr: Address { base: 0, count: 64, width: 1 }, brief: Some("Entry data cache"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MASK_DAT", Field { brief: Some("The cache register that holds entry mask. The register is replicated; index 0 is the 32 LSBs of the entry-mask. See VCAP_MASK_DAT.MASK_DAT for encoding information."), details: None, lo: 0, hi: 32 });
        regs.insert("VCAP_MASK_DAT", Register { addr: Address { base: 64, count: 64, width: 1 }, brief: Some("Entry mask cache"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MV_NUM_POS", Field { brief: Some("Specifies the distance during move operations. I.e. if this field is set to 4 for a move-down operation, then source address n is moved to destination address n+5."), details: Some("0: Distance is one position 1: Distance is two positions n: Distance is n+1 positions"), lo: 16, hi: 32 });
        fields.insert("MV_SIZE", Field { brief: Some("Specifies the number of addresses to move/initialize during\tmove/init operations."), details: Some("0: Address VCAP_UPDATE_CTRL.UPDATE_ADDR is moved/initialized n: Addresses VCAP_UPDATE_CTRL.UPDATE_ADDR through VCAP_UPDATE_CTRL.UPDATE_ADDR+n are moved/initialized"), lo: 0, hi: 16 });
        regs.insert("VCAP_MV_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Configuration for move/initialization"), details: None, fields });
        groups.insert("VCAP_CORE_CACHE", RegisterGroup { addr: Address { base: 2, count: 1, width: 225 }, desc: "VCAP cache", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CLEAR_CACHE", Field { brief: Some("Set to clear the cache. This field is cleared immediately by hardware (at the same time as clearing the cache). The contents of the cache will be set to disabled/empty."), details: None, lo: 1, hi: 2 });
        fields.insert("MV_TRAFFIC_IGN", Field { brief: Some("For version 1 VCAPs: Set to ignore interrupting traffic during move operations, this will increase speed of the move operations but counter-events may be lost for the VCAP addresses that are moved. When this field is cleared, then interrupting traffic will cause a restart of the move operation (to ensure consistent counter values) and becasue of this, move operations on a heavily loaded device may take a long time to finish. This field is not used for version 2 VCAPs, moving of counters are safe."), details: None, lo: 0, hi: 1 });
        fields.insert("UPDATE_ACTION_DIS", Field { brief: Some("Set to disable update of actions for VCAP operations: For read-operations action-cache will remain unchanged. For write/move/init operations the VCAP-action will remain unchanged."), details: None, lo: 20, hi: 21 });
        fields.insert("UPDATE_ADDR", Field { brief: Some("The address to access for VCAP operations."), details: Some("ES0 defaults at 0x1000-0x1034"), lo: 3, hi: 19 });
        fields.insert("UPDATE_CMD", Field { brief: Some("Write and read operations access VCAP memory at address specified by UPDATE_ADDR. Move up opeation moves one or more VCAP addresses from a high address to a lower address, this is equivalent to decreasing priority of a rule. The starting address is specified by UPDATE_ADDR, the number of addresses (the range) that is moved is defined by VCAP_MV_CFG.MV_SIZE, the distance to move is defined by VCAP_MV_CFG. MV_NUM_POS. Move down opeation moves one or more VCAP addresses from a low address to a higer address, this is equivalent to increasing priority of a rule. This operation is equivalent to \"Move up\" except for the direction that it moves addresses, see \"Move up\" for more details. Init operation writes the contents of the cache to one or more VCAP addresses. The starting address is specified by UPDATE_ADDR, the number of addresses (the range) that is written is defined by VCAP_MV_CFG.MV_SIZE. Setting CLEAR_CACHE at the same time as starting the operation will clear the cache and cause the init operation to initialize the range of addresses."), details: Some("000: Write from cache to VCAP 001: Read from VCAP to cache 010: Move entry and/or action up (decreasing addresses) 011: Move entry and/or action down (increasing addresses) 100: Initialize VCAP with the cache-value"), lo: 22, hi: 25 });
        fields.insert("UPDATE_CNT_DIS", Field { brief: Some("Set to disable update of counter for VCAP operations: For read-operations counter-cache will remain unchanged. For write/init operations the VCAP-counter will remain unchanged. For move operations the destination VCAP-counters will be set to zeros."), details: None, lo: 19, hi: 20 });
        fields.insert("UPDATE_ENTRY_DIS", Field { brief: Some("Set to disable update of entries for VCAP operations: For read-operations entry-cache will remain unchanged. For write/move/init operations the VCAP-entry will remain unchanged."), details: None, lo: 21, hi: 22 });
        fields.insert("UPDATE_SHOT", Field { brief: Some("Set to initiate the opeation specified in UPDATE_CMD. This bit is automatically cleared by hardware when the operation is finished. Software must not change write fields in the VCAP target while this field is set (while operation is active.)"), details: None, lo: 2, hi: 3 });
        regs.insert("VCAP_UPDATE_CTRL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Initiation of read/write/move/initialization operations"), details: Some("Operations on the VCAP cache is done via this register. The UPDATE_CMD field specifies the operation to perform when UPDATE_SHOT is set. For all of the operations it is possible to disable read/write of entries, actions, and/or counter by setting VCAP_UPDATE_CTRL.UPDATE_ENTRY_DIS, VCAP_UPDATE_CTRL.UPDATE_ACTION_DIS, and/or VCAP_UPDATE_CTRL.UPDATE_CNT_DIS respectively. Writing/moving to unimplemented addresses are ignored. Reading/moving from unimplemented addresses returns never-match for entries, and zeros from actions/counters. Active rules may only be written to empty (initialized) addresses. Software must not overwrite active rules (unless when initializing rules). To initialize a region of addresses use the init operation with CLEAR_CACHE bits set to '1'. Move operations automatically disable rules when moved; so it is OK when source and destination ranges overlap."), fields });
        groups.insert("VCAP_CORE_CFG", RegisterGroup { addr: Address { base: 0, count: 1, width: 2 }, desc: "VCAP operations", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CORE_IDX", Field { brief: Some("Set to index of specific core to access the mapping of that core via VCAP_SUPER::VCAP_CORE_MAP."), details: None, lo: 0, hi: 4 });
        regs.insert("VCAP_CORE_IDX", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Core index"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RULE_ENA", Field { brief: Some("Cache register. Set to enable ES0 rule. Applies only to the ES0 VCAP."), details: None, lo: 0, hi: 1 });
        regs.insert("VCAP_RULE_ENA", Register { addr: Address { base: 224, count: 1, width: 1 }, brief: Some("Cache rule enable"), details: None, fields });
        groups.insert("VCAP_CORE_MAP", RegisterGroup { addr: Address { base: 227, count: 1, width: 2 }, desc: "Mapping of cores to interfaces", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CORE_MAP", Field { brief: Some("Configure ownership of core n (defined by VCAP_SUPER::VCAP_CORE_IDX). When a core is mapped to a specific VCAP; lookups for that VCAP will be applied to the core. VCAP priority is still observed, a match in two cores will only cause the most significant rule to be \"hit\" (highest address.) After reset all cores are in power-save mode."), details: Some("Applies only to the Super VCAP."), lo: 0, hi: 3 });
        regs.insert("VCAP_CORE_MAP", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Mapping of core"), details: None, fields });
        groups.insert("VCAP_CORE_STICKY", RegisterGroup { addr: Address { base: 229, count: 1, width: 1 }, desc: "Sticky bits", regs });
        out.insert("VCAP_CORE", Target { desc: "\\see vtss_target_VCAP_CORE_e Vitesse Content Aware Processor", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("COSID_MAP_TABLE_ANA", Field { brief: Some("The table is used to map the choosen COSID in the ANA. bit(2:0) will be used to map COSID = 0 bit(5:3) will be used to map COSID = 1 ... bit(23:21) will be used to map COSID = 7 When mapping a COSID, the following procedure is followed: 1) Use COSID_SRC_SEL_ANA to select the source of the COSID mapping. I.e. if COSID_SRC_SEL_ANA = 1 (TC) the input to the mapping table is set to the IFH.TC. 2) Map the selected value. If IFH.TC = 3, the mapped COSID will be set to COSID_MAP_TABLE_ANA[11:9]"), details: None, lo: 0, hi: 24 });
        regs.insert("COSID_MAP_TABLE_ANA", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("COSID mapping table"), details: Some("COSID mapping table used for mapping the selected COSID values. A single mapping table is available for each of the Service/Path VOEs."), fields });
        let mut fields = HashMap::new();
        fields.insert("LBR_CRC_ERR_CNT", Field { brief: Some("See Register Description."), details: None, lo: 0, hi: 32 });
        regs.insert("LBR_CRC_ERR_CNT", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Count the number of LBR and TST CRC errors received."), details: Some("The VOE can verify the CRC-32 of Test TLVs in incoming LBR and TST PDUs. This functionality is enabled using one of the following bit fields: * VOP:VOE_CONF:OAM_HW_CTRL.LBR_TLV_CRC_VERIFY_ENA * VOP:VOE_CONF:OAM_HW_CTRL.TST_TLV_CRC_VERIFY_ENA When enabled the VOE examines the TLV field of valid LBR and TST PDUs in the Rx direction. If the first TLV following the LBR or TST PDU is a Test TLV including a CRC-32 across the Data Pattern, the VOE will calculate the CRC across the Data Pattern and verify the CRC-32. This register will count the number of CRC errors received by the VOE. The CRC counters are indexed as follows: * Service (/Path) VOEs are indexed: 0 - 255 * Port VOEs are indexed: 256 (Port 0) - 266 (Port 10)"), fields });
        groups.insert("ANA_COSID_MAP_CONF", RegisterGroup { addr: Address { base: 73728, count: 1024, width: 2 }, desc: "COSID / Color config in ANA - Service VOEs", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("MEP_MC_MAC_LSB", Field { brief: Some("See register description."), details: None, lo: 3, hi: 31 });
        regs.insert("COMMON_MEP_MC_MAC_LSB", Register { addr: Address { base: 74, count: 1, width: 1 }, brief: Some("VOP Multicast MAC address configuration (LSB)"), details: Some("Each VOE can be addressed using either a common Multicast MAC address or a VOE specific Unicast MAC address. This register configures the Multicast Address common to all the VOEs. The full MAC address is a concatenation of the following registers: 1) VOP::COMMON_MEP_MC_MAC_LSB 2) VOP::COMMON_MEP_MC_MAC_MSB The default value of this register is determined by 802.1ag. The DMAC check to be performed for each VOE is configured in the following bit field: VOP:VOE_CONF:VOE_CTRL.RX_DMAC_CHK_SEL Note that only the upper 44 bits are matched, since the lower 4 bits of the DMAC address contain the MEG level."), fields });
        let mut fields = HashMap::new();
        fields.insert("CPU_ERR_QU", Field { brief: Some("Configures the CPU queue port of the CPU error queue."), details: Some("0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7"), lo: 12, hi: 15 });
        fields.insert("DEF_COPY_QU", Field { brief: Some("Configures the destination for PDUs extracted to the Default CPU queue. The default CPU extraction queue is used for extraction of PDUs which do not have a dedicated extraction queue (UNKNOWN OPCODES)."), details: Some("0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7"), lo: 15, hi: 18 });
        fields.insert("DMM_CPU_QU", Field { brief: Some("Configures the CPU queue to which DMM frames are extracted."), details: Some("0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7"), lo: 3, hi: 6 });
        fields.insert("DMR_CPU_QU", Field { brief: Some("Configures the CPU queue to which DMR and 1DM frames are extracted."), details: Some("0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7"), lo: 0, hi: 3 });
        fields.insert("LMM_CPU_QU", Field { brief: Some("Configures the CPU queue to which LMM/SLM frames are extracted."), details: Some("0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7"), lo: 9, hi: 12 });
        fields.insert("LMR_CPU_QU", Field { brief: Some("Configures the CPU queue to which LMR / SLR / 1SL frames are extracted."), details: Some("0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7"), lo: 6, hi: 9 });
        regs.insert("CPU_EXTR_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Configuring destination for frames extracted to the CPU by Ethernet VOEs"), details: Some("This register configures the destination for OAM frames which are extracted to CPU by the VOE for various reasons. An OAM PDU may be extracted to the CPU for various reasons: * Based on PDU type (See register: VOP:VOE_CONF:OAM_CPU_COPY_CTRL.* * OAM error condition (e.g. DMAC error) * PDU specific extraction reasons. Most HW supported OAM PDUs have their own configuration, while some related PDUs share a single configuration. The configuration for each OAM PDU consists of one bit field which indicate which of the extraction queues the relevant PDUs are extracted: *_CPU_QU OAM PDU types which do not have a specific configuration will use the default configuration: DEF_COPY_CPU_QU The details are described for each bit field."), fields });
        let mut fields = HashMap::new();
        fields.insert("CCM_CPU_QU", Field { brief: Some("Configures the CPU queue to which CCM frames are extracted."), details: Some("0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7"), lo: 15, hi: 18 });
        fields.insert("CCM_LM_CPU_QU", Field { brief: Some("Configures the CPU queue to which CCM-LM frames are extracted. CCM-LM frames are CCM PDUs with non-zero content of the LM counters in the PDU"), details: Some("0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7"), lo: 12, hi: 15 });
        fields.insert("LBM_CPU_QU", Field { brief: Some("Configures the CPU queue to which LBM frames are extracted."), details: Some("0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7"), lo: 9, hi: 12 });
        fields.insert("LBR_CPU_QU", Field { brief: Some("Configures the CPU queue to which LBR and SAM_SEQ frames are extracted."), details: Some("0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7"), lo: 6, hi: 9 });
        fields.insert("LT_CPU_QU", Field { brief: Some("Configures the CPU queue to which LTM/LTR frames are extracted. (Configuration is shared for LTM and LTR PDUs)"), details: Some("0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7"), lo: 0, hi: 3 });
        fields.insert("TST_CPU_QU", Field { brief: Some("Configures the CPU queue to which TST frames are extracted."), details: Some("0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7"), lo: 3, hi: 6 });
        regs.insert("CPU_EXTR_CFG_1", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Configuring destination for frames extracted to the CPU."), details: Some("See description for CPU_EXTR_CFG"), fields });
        let mut fields = HashMap::new();
        fields.insert("BFD_CC_CPU_QU", Field { brief: Some("Configures the CPU queue to which BFD-CC PDUs are extracted."), details: Some("0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7"), lo: 3, hi: 6 });
        fields.insert("BFD_CV_CPU_QU", Field { brief: Some("Configures the CPU queue to which BFD-CV PDUs are extracted."), details: Some("0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7"), lo: 0, hi: 3 });
        regs.insert("CPU_EXTR_MPLS", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Configuring destination for frames extracted to the CPU by MPLS VOEs"), details: Some("See description for CPU_EXTR_CFG"), fields });
        let mut fields = HashMap::new();
        fields.insert("HMO_FORCE_SLOT", Field { brief: Some("See register description."), details: None, lo: 0, hi: 3 });
        regs.insert("HMO_FORCE_SLOT_CFG", Register { addr: Address { base: 33, count: 2, width: 1 }, brief: Some("HMO slots used for forced scanning."), details: Some("When a HMO scan is forced, the HMO slots used for the scan are used for the HMO scan is programmed in this register. A separate HMO slot can be programmed for each of the HMO timers. A HMO scan is forced using the following register: - VOP::LOC_CTRL.LOC_FORCE_HW_SCAN_ENA"), fields });
        let mut fields = HashMap::new();
        fields.insert("HMO_PERIOD_VAL", Field { brief: Some("Configures expiry period of the 2 HMO timers as the number of BASE_TICKs between every LOC timer expiry. The BASE_TICK is configured: VOP::LOC_CTRL.LOC_BASE_TICK_CNT Default HMO timer is set to 0, which causes the HMO timer to never expire."), details: Some("For the default value of the LOC_BASE_TICK_CNTthe HMO scan timer will expire with the following intervals. A value of 0 disables the timeout for this counter. 50: 10us 500: 100us 5000: 1 ms 16500: 3.3ms 50000: 10ms 500000: 100ms 5000000: 1s"), lo: 0, hi: 32 });
        regs.insert("HMO_PERIOD_CFG", Register { addr: Address { base: 31, count: 2, width: 1 }, brief: Some("Configures the 2 different HMO scan periods"), details: Some("2 independent HMO timers are implemented to be used with the auto Hit-Me-Once (HMO) scan. This register implements a separate timeout period for each of the 2 HMO timers. The timeout period is specified in the number of LOC base ticks between every HMO timer expiry. Each HMO scan timer has an associated HMO slot (0-7 i.e. 3 bit), which is increased every time the HMO scan timer expires. When a HMO scan timer expires and causes a HMO scan, the current HMO slot is part of the scan, so that only the VOEs assigned to that HMO slot are affected by the scan. This allows the distributing the VOEs assigned to a given HMO scan timer into 8 HMO slots. Hence each VOE is only affected by 1 of 8 HMO scans for a given HMO scan timer. I.e. to achieve auto HMO frame extraction every 1 second, the HMO timer must be set to expire every 125 us. For configuration of the LOC base tick, see bit field: * VOP::LOC_CTRL.LOC_BASE_TICK_CNT The default value for the LOC base tick is 200 ns. A HMO scan is initiated at half the configured HMO PERIOD, because this is the way the scans are implemented for LOC scanning. A VOE can be configured for HMO auto assertion based on one of the 2 HMO timers. The HMO timers are used only Ethernet VOEs. The HMO timers have no effect on MPLS-TP VOEs. Ethernet VOE: ----------------------- The HMO events are assigned to a specific HMO scan timer: * VOP::HMO_TIMER_CFG.* The VOE is assigned a HMO slot using the following register: * VOP:VOE_STAT:AUTO_HIT_ME_ONCE.HMO_SLOT When the HMO timer assigned to the VOE, causes a HMO scan with the HMO slot assigned to the VOE, the VOE will assert the extraction bits selected for auto HMO. The extraction bits are located in the following register: * VOP:VOE_STAT:PDU_EXTRACT The extraction bits are assigned for auto HMO in the following register: * VOP:VOE_STAT:AUTO_HIT_ME_ONCE MPLS-TP VOE: -------------------------- The HMO counters have no effect."), fields });
        let mut fields = HashMap::new();
        fields.insert("HMO_CCM_RX_BAD_NXT_TIMER", Field { brief: Some("Assign which HMO timer will trigger the following VOE Auto HMO bits: * VOP:VOE_STAT:PDU_EXTRACT.CCM_ZERO_PERIOD_RX_ERR_EXTR * VOP:VOE_STAT:PDU_EXTRACT.RX_MEL_LOW_ERR_EXTR * VOP:VOE_STAT:PDU_EXTRACT.CCM_MEGID_RX_ERR_EXTR * VOP:VOE_STAT:PDU_EXTRACT.CCM_MEPID_RX_ERR_EXTR * VOP:VOE_STAT:PDU_EXTRACT.CCM_PERIOD_RX_ERR_EXTR * VOP:VOE_STAT:PDU_EXTRACT.CCM_PRIO_RX_ERR_EXTR To trigger the Auto HMO bits, this must be enabled by the VOE: * VOP:VOE_STAT:AUTO_HIT_ME_ONCE.HMO_CCM_RX_BAD_NXT"), details: None, lo: 2, hi: 3 });
        fields.insert("HMO_CCM_RX_TLV_NON_ZERO_TIMER", Field { brief: Some("Assign which HMO timer will trigger the following VOE Auto HMO bits: * VOP:VOE_STAT:PDU_EXTRACT.CCM_RX_TLV_NON_ZERO_EXTR To trigger the Auto HMO bits, this must be enabled by the VOE: * VOP:VOE_STAT:AUTO_HIT_ME_ONCE.HMO_CCM_RX_TLV_NON_ZERO"), details: None, lo: 3, hi: 4 });
        fields.insert("HMO_EXTRACT_PEER_RX_TIMER", Field { brief: Some("Assign which HMO timer will trigger the following VOE Auto HMO bits: VOP:VOE_STAT:SYNLM_EXTRACT.EXTRACT_PEER_RX To trigger the Auto HMO bits, this must be enabled by the VOE: * VOP:VOE_STAT:AUTO_HIT_ME_ONCE.HMO_EXTRACT_PEER_RX"), details: None, lo: 0, hi: 1 });
        fields.insert("HMO_RX_CCM_NXT_TIMER", Field { brief: Some("Assign which HMO timer will trigger the following VOE Auto HMO bits: * VOP:VOE_STAT:PDU_EXTRACT.CCM_RX_CCM_NXT_EXTR To trigger the Auto HMO bits, this must be enabled by the VOE: * VOP:VOE_STAT:AUTO_HIT_ME_ONCE.HMO_CCM_RX_BAD_NXT"), details: None, lo: 4, hi: 5 });
        fields.insert("HMO_RX_TEST_FRM_NXT_TIMER", Field { brief: Some("Assign which HMO timer will trigger the following VOE Auto HMO bits: VOP:VOE_STAT:PDU_EXTRACT.RX_TEST_FRM_NXT_EXTR To trigger the Auto HMO bits, this must be enabled by the VOE: * VOP:VOE_STAT:AUTO_HIT_ME_ONCE.HMO_RX_TEST_FRM_NXT"), details: None, lo: 1, hi: 2 });
        regs.insert("HMO_TIMER_CFG", Register { addr: Address { base: 35, count: 1, width: 1 }, brief: Some("Configure HMO TIMER for HMO extraction events."), details: Some("There are 2 HMO timers, which allow for Auto HMO of selected frame types. Each of the events which support HMO are assigned to one of the 2 HMO timers using this register. This setting is hence global for all VOEs. For each of the bitfields, it is configured which of the HMO timers will trigger the HMO bits to be asserted. In addition to the correct HMO timer expiring, the VOE must be configured for the correct HMO SLOT and the Auto HMO must be enabled in the VOE before the HMO bits are asserted. The is used to space the extracted frames, so the CPU does not get flooded with frames from all active VOEs at once."), fields });
        let mut fields = HashMap::new();
        fields.insert("VOE_INTR", Field { brief: Some("Status of interrupts per VOE Ethernet: ---------------------- Interrupt is cleared by clearing the sticky causing interrupt in VOP:VOE_STAT:INTR_STICKY:* or by disabling the interrupt source in VOP:VOE_STAT:INTR_ENA.* MPLS-TP: ------------------------- Interrupt is cleared by clearing the sticky causing interrupt in VOP_MPLS:VOE_STAT_MPLS:INTR_STICKY_MPLS.* or by disabling the interrupt source in VOP_MPLS:VOE_STAT_MPLS:INTR_ENA_MPLS.*"), details: Some("Each bit in the field indicates the interrupt from a single VOE. 0: No interrupt from VOE 1: VOE has asserted the interrupt."), lo: 0, hi: 32 });
        regs.insert("INTR", Register { addr: Address { base: 40, count: 34, width: 1 }, brief: Some("VOE interrupts"), details: Some("This register contains the interrupt for each individual VOE, grouped in 32 bit registers. The interrupts are numbered according to the VOEs: 0 - 255 are the Service / Path VOEs 256 - 266 are the Port VOEs The VOE interrupts are enabled in the following registers: Ethernet: ------------------- * VOP:VOE_STAT:INTR_ENA MPLS-TP: ----------------- * VOP_MPLS:VOE_STAT_MPLS:INTR_ENA_MPLS The following register indicates with a single bit if there is an asserted interrupt in each of the registers in VOE_INTR * VOP::VOE32_INTR"), fields });
        let mut fields = HashMap::new();
        fields.insert("LOC_BASE_TICK_CNT", Field { brief: Some("Specifies the number of system clock cycles for each LOC base time tick. The system clock is: 4 ns (250 MHz). The default base tick is set to 50 = 200 ns The base tick, is the event used for incrementing the 7 LOC counters. The time at which each of the LOC timers will timeout is specified in: * VOP::LOC_PERIOD_CFG::LOC_PERIOD_VAL Ethernet VOEs: ------------------------ When a LOC timer expires it causes a LOC Scan event, which will increment the CCM miss counter (VOP:VOE_STAT:CCM_STAT.CCM_MISS_CNT) for each VOE assigned to that particular LOC timer. The CCM miss counter for each VOE (CCM_MISS_CNT) will be cleared each time the VOE receives a valid CCM or CCM-LM frame. If the CCM_MISS count reaches 7 it will optionally cause an interrupt. MPLS-TP VOEs: ------------------------ When a LOC timer expires it causes a LOC Scan event, which will increment the BFD miss counter (VOP_MPLS:VOE_STAT_MPLS:BFD_STAT.BFD_MISS_CNT) for each VOE assigned to that particular LOC timer. The LOC counter for each VOE (BFD_MISS_CNT) will be cleared each time the VOE receives a valid BFD-CC or BFD-CV PDU. If the BFD_MISS_CNT count reaches the configured Detect Multiplier it will optionally cause an interrupt."), details: Some("0: Illegal value 1: One clock between interval increment ... n: n clock between interval increment"), lo: 11, hi: 19 });
        fields.insert("LOC_FORCE_HW_SCAN_ENA", Field { brief: Some("When a LOC scan timer expires, the VOE will scan through all VOEs in the VOP and increment the LOC miss counter of all the VOEs assigned to that LOC timer. When a HMO scan timer expires, the VOE will scan through all VOEs in the VOP and assert the HMO extraction bits configured for the VOE. Another way to force a LOC scan / HMO is to write a mask to LOC_FORCE_HW_SCAN_ENA. Each of the bits in this register represents a LOC timer. Writing a mask to this register will force a LOC scan as if the LOC timers indicated in the mask had expired. A forced scan will start as soon as any currently active scan completes Active scan can be stopped by disabling the LOC scan controller. The width of the SCAN_MASK is 9 bits which are allocated as follows: bits 0-6: LOC scan timer 0 - 6 bits 7-8: HMO scan timer 0 - 1"), details: Some("0: No force bit 0 = 1: Force a scan of LOC scan timer 0 bit 1 = 1: Force a scan of LOC scan timer 1 bit 2 = 1: Force a scan of LOC scan timer 2 bit 3 = 1: Force a scan of LOC scan timer 3 bit 4 = 1: Force a scan of LOC scan timer 4 bit 5 = 1: Force a scan of LOC scan timer 5 bit 6 = 1: Force a scan of LOC scan timer 6 bit 7 = 1: Force a scan of HMO scan timer 0; (using HMO slot configured in VOP::HMO_FORCE_SLOT_CFG(0).HMO_FORCE_SLOT) bit 8 = 1: Force a scan of HMO scan timer 1; (using HMO slot configured in VOP::HMO_FORCE_SLOT_CFG(1).HMO_FORCE_SLOT)"), lo: 0, hi: 9 });
        fields.insert("LOC_SPACE_BETWEEN_ENTRY_SCAN", Field { brief: Some("Specifies the number of clk cycle before another scan entry can be attempted. This can be used to space the LOC miss scanning of the VOEs. If an active SCAN is ongoing, the VOE will scan through the VOE_STAT and update the LOC miss counter of VOEs which are enabled for LOC detection. The scan will be done in 'idle cycles'. 'Idle cycles' are defined as cycles where the is no frame access and no CSR access to the VOP."), details: Some("0-1: A scan is attempted at every idle cycle in the VOP 2: A scan is attempted no more often than every 2nd cycle. 3: A scan is attempted no more often than every 3rd cycle. .... 7: A scan is attempted no more often than every 7'th cycle."), lo: 9, hi: 11 });
        regs.insert("LOC_CTRL", Register { addr: Address { base: 23, count: 1, width: 1 }, brief: Some("Loss Of Continuity Controller configuration"), details: Some("Configures LOC Controller to increment the LOC miss counters in the VOEs."), fields });
        let mut fields = HashMap::new();
        fields.insert("LOC_PERIOD_VAL", Field { brief: Some("Configures Expiry Period of the 7 LOC timers as the number of BASE_TICKs between every LOC timer expiry. The BASE_TICK is configured: VOP::LOC_CTRL.LOC_BASE_TICK_CNT Default LOC timer expiry time: 3.3ms."), details: Some("A value of 0 disables the timeout for this counter. 50: 10us 500: 100us 5000: 1 ms 16500: 3.3ms 50000: 10ms 500000: 100ms 5000000: 1s"), lo: 0, hi: 32 });
        regs.insert("LOC_PERIOD_CFG", Register { addr: Address { base: 24, count: 7, width: 1 }, brief: Some("Configures the 7 different LOC scan periods"), details: Some("Independent timers are implemented to be used with the Loss Of Continuity (LOC) Scan. This register implements the timout period for every one of the 7 LOC timers. The timeout period is specified in the number of LOC base ticks between every LOC timer expiry. For configuration of the LOC base tick, see bit field: * VOP::LOC_CTRL.LOC_BASE_TICK_CNT The default value for the LOC base tick is 200 ns, which means that the LOC timer counters are incremented every 200 ns. A LOC miss count scan is initiated at half the configured LOC PERIOD. A VOE can be configured for LOC checking based on one of the 7 timeout counters. The LOC Controller is used both by Ethernet VOEs and MPLS-TP VOEs for LOC detection. Ethernet VOE: --------------- A LOC event is generated at the VOE when the CCM miss count count is 7. VOP:VOE_STAT:CCM_STAT.CCM_MISS_CNT This effectively implements a LOC event at 3,5 times the configured LOC period. MPLS-TP VOE: -------------------------- A LOC event is generated at the VOE when the BFD_MISS_CNT is equal to the valid Detect Multiplier in the VOE."), fields });
        let mut fields = HashMap::new();
        fields.insert("LOC_SCAN_COMPLETED_STICKY", Field { brief: Some("Asserted by VOP when LOC_SCAN completes."), details: Some("0: No event has occured 1: LOC scan completed Bit is cleared by writing a 1 to this position."), lo: 2, hi: 3 });
        fields.insert("LOC_SCAN_ONGOING_STATUS", Field { brief: Some("Reflects the current LOC scan mask. A bit is asserted for each of the LOC counters currently being increased. NOTE: This is not a sticky bit."), details: Some("0: No event has occured 1: LOC scan ongoing. A bit is asserted for each LOC counter which is updating the LOC MISS CNT."), lo: 3, hi: 12 });
        fields.insert("LOC_SCAN_STARTED_STICKY", Field { brief: Some("Asserted by VOP when LOC_SCAN starts."), details: Some("0: No event has occured 1: LOC scan started Bit is cleared by writing a 1 to this position."), lo: 1, hi: 2 });
        fields.insert("LOC_SCAN_START_DELAYED_STICKY", Field { brief: Some("Set when a LOC scan could not start because a scan is already ongoing. This is an indication that a LOC timer expired before the previous scan scheduled by the same LOC timer was initiated. This is an error condition. To fix it, the configured Period time of the LOC scan controller must be incremented."), details: Some("0: No event has occured 1: Scan could not start in time Bit is cleared by writing a 1 to this position."), lo: 0, hi: 1 });
        regs.insert("LOC_SCAN_STICKY", Register { addr: Address { base: 36, count: 1, width: 1 }, brief: Some("CCM SCAN Diagnostic"), details: Some("Bits in this register indicate the current status of the LOC scanning. Note that the following bit field is NOT sticky: * LOC_SCAN_ONGOING_STATUS"), fields });
        let mut fields = HashMap::new();
        fields.insert("OAM_MEP_INTR", Field { brief: Some("Status of the VOP interrupt. If asserted this can optionally generate an interrupt to the CPU. * VOP::MASTER_INTR_CTRL.OAM_MEP_INTR_ENA"), details: Some("0: VOP Interrupt is deasserted. 1: VOP Interrupt is asserted."), lo: 8, hi: 9 });
        fields.insert("OAM_MEP_INTR_ENA", Field { brief: Some("Configures if OAM_MEP_INTR causes CPU interrupts"), details: Some("0: Disable interrupt 1: Enable interrupt"), lo: 25, hi: 26 });
        regs.insert("MASTER_INTR_CTRL", Register { addr: Address { base: 37, count: 1, width: 1 }, brief: Some("VOP interrupt control."), details: Some("This is the combined interrupt output from the VOP. To determine the VOE source of the interrupt, read register: * VOP::INTR.VOE_INTR"), fields });
        let mut fields = HashMap::new();
        fields.insert("GENERIC_CODEPOINT_CPU_QU", Field { brief: Some("Configures CPU queue to which MPLS-TP OAM PDUs with a G-ACH Channel Type configured as generic codepoints are extracted."), details: None, lo: 8, hi: 11 });
        fields.insert("GENERIC_CODEPOINT_VAL", Field { brief: Some("This value configures the MPLS-TP G-ACH Channel Type to be processed as a Generic OpCode corresponding to this generic Index."), details: None, lo: 11, hi: 27 });
        regs.insert("MPLS_GENERIC_CODEPOINT", Register { addr: Address { base: 15, count: 8, width: 1 }, brief: Some("Generic OAM PDU Opcodes configuration"), details: Some("The VOE implements HW support for a number of dedicated MPLS-TP codepoints (BFD CC/CV) which all have dedicated control registers. In addition to the dedicated MPLS-TP Codepoints with dedicated control registers, the VOE further supports configuring 8 Generic Codepoints, which can be extracted to CPU or forwarded independently of other Codepoints. The Generic Codepoints are configured using this register. The value of each Codepoint is configured globally across all VOEs in the following bit field: * GENERIC_CODEPOINT_VAL A codepoint which is not explicitly supported and which not configured as a Generic Codepoint will be treated as an UNKNOWN Codepoint. The extraction and forwarding of Generic Codepoints can be configured individually pr. VOE using the following registers: * VOP_MPLS:VOE_CONF_MPLS:CPU_COPY_CTRL_MPLS.GENERIC_COPY_MASK * VOP_MPLS:VOE_CONF_MPLS:OAM_CNT_SEL_MPLS.GENERIC_CPT_CNT_SEL_MASK"), fields });
        let mut fields = HashMap::new();
        fields.insert("GENERIC_DMAC_CHK_DIS", Field { brief: Some("If this bit is asserted, the DMAC check will be disabled for this generic OpCode, regardless of the configuration of the bit field: VOP:VOE_CONF:VOE_CTRL.RX_DMAC_CHK_SEL This bit is required because some OpCodes (i.e. Ring PDU) will use a DMAC which is different from the configured Multicast and Unicast."), details: Some("0: Perform DMAC check according to the value configured in VOP:VOE_CONF:VOE_CTRL.RX_DMAC_CHK_SEL 1: No DMAC check for this Generic OpCode."), lo: 17, hi: 18 });
        fields.insert("GENERIC_OPCODE_CPU_QU", Field { brief: Some("Configures the CPU queue to which frames for this generic OpCode are extracted."), details: Some("0: CPU queue 0 1: CPU queue 1 ... 7: CPU queue 7"), lo: 8, hi: 11 });
        fields.insert("GENERIC_OPCODE_VAL", Field { brief: Some("This value configures the Y.1731 OpCode to be processed as a Generic OpCode corresponding to this generic Index."), details: None, lo: 0, hi: 8 });
        regs.insert("OAM_GENERIC_CFG", Register { addr: Address { base: 7, count: 8, width: 1 }, brief: Some("Generic OAM PDU Opcodes configuration"), details: Some("The VOE implements HW support for a number of selected OAM PDUs which all have dedicated control registers. In addition to the selected OAM PDUs with dedicated control registers, the VOE further supports configuring 8 Generic Opcodes, which can be extracted to CPU or forwarded independently of other OpCodes. The value of each OpCode is configured globally across all VOEs in the following bit field: * GENERIC_OPCODE_VAL An opcode which is not explicitly supported and which not configured as a Generic OpCode will be treated as an UNKNOWN opcode. The extraction and forwarding of Generic OpCodes can be configured individually pr. VOE using the following registers: * VOP:VOE_CONF:OAM_CPU_COPY_CTRL.GENERIC_COPY_MASK * VOP:VOE_CONF:OAM_CNT_OAM_CTRL.GENERIC_OAM_CNT_MASK * VOP:VOE_CONF:OAM_CNT_DATA_CTRL.GENERIC_DATA_CNT_MASK"), fields });
        let mut fields = HashMap::new();
        fields.insert("CCM_VERSION", Field { brief: Some("Configure which version of the CCM(-LM) PDU will be processed by the VOE."), details: Some("CCM_VERSION(x) = '0'; Version X of the CCM(-LM) PDU is invalid. CCM_VERSION(x) = '1'; Version X of the CCM(-LM) PDU is valid."), lo: 24, hi: 32 });
        fields.insert("DM_VERSION", Field { brief: Some("Configure which version of the DMM/DMR PDU will be processed by the VOE."), details: Some("DM_VERSION(x) = '0'; Version X of the DMM/DMR PDU is invalid. DM_VERSION(x) = '1'; Version X of the DMM/DMR PDU is valid."), lo: 8, hi: 16 });
        fields.insert("LM_VERSION", Field { brief: Some("Configure which version of the LMM/LMR PDU will be processed by the VOE."), details: Some("LM_VERSION(x) = '0'; Version X of the LMM/LMR PDU is invalid. LM_VERSION(x) = '1'; Version X of the LMM/LMR PDU is valid."), lo: 16, hi: 24 });
        fields.insert("SDM_VERSION", Field { brief: Some("Configure which version of the 1DM PDU will be processed by the VOE."), details: Some("SDM_VERSION(x) = '0'; Version X of the 1DM PDU is invalid. SDM_VERSION(x) = '1'; Version X of the 1DM PDU is valid."), lo: 0, hi: 8 });
        regs.insert("VERSION_CTRL", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Define valid y.1731 PDU version number."), details: Some("This register group allows configuration of which versions of the PDU is valid for each of the Y.1731 PDUs supported by HW processing. Only the PDUs which have dedicated HW support in the VOE can be verified by the VOE. For PDUs being forwarded to the CPU the version is assumed to be verified in SW. The version is configured commonly for Message and Response of the same PDU type. For each PDU (pair) there are 8 bits, each representing a version number: 0 - 7. Asserting the bit corresponding to a given version will configure the HW to accept PDUs of this version. E.g. the following will configure VERSION = 1 as being valid for CCM(-LM) frames. * CCM_VERSION(1) = 1"), fields });
        let mut fields = HashMap::new();
        fields.insert("LB_VERSION", Field { brief: Some("Configure which version of the LBM/LBR PDU will be processed by the VOE."), details: Some("LB_VERSION(x) = '0'; Version X of the LBM/LBR PDU is invalid. LB_VERSION(x) = '1'; Version X of the LBM/LBR PDU is valid."), lo: 16, hi: 24 });
        fields.insert("SL1_VERSION", Field { brief: Some("Configure which version of the 1SL PDU will be processed by the VOE."), details: Some("SL1_VERSION(x) = '0'; Version X of the LBM/LBR PDU is invalid. SL1_VERSION(x) = '1'; Version X of the LBM/LBR PDU is valid."), lo: 0, hi: 8 });
        fields.insert("SL_VERSION", Field { brief: Some("Configure which version of the SLM/SLR PDU will be processed by the VOE."), details: Some("SL_VERSION(x) = '0'; Version X of the LBM/LBR PDU is invalid. SL_VERSION(x) = '1'; Version X of the LBM/LBR PDU is valid."), lo: 8, hi: 16 });
        fields.insert("TST_VERSION", Field { brief: Some("Configure which version of the TST PDU will be processed by the VOE."), details: Some("TST_VERSION(x) = '0'; Version X of the TST PDU is invalid. TST_VERSION(x) = '1'; Version X of the TST PDU is valid."), lo: 24, hi: 32 });
        regs.insert("VERSION_CTRL_2", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Define valid y.1731 PDU version number."), details: Some("This register group allows configuration of which versions of the PDU is valid for each of the Y.1731 PDUs supported by HW processing. Only the PDUs which are being processed by VOE can be verified by the VOE. For PDUs being forwarded to the CPU the version is assumed to be verified in SW. The version is configured commonly for Message and Response of the same PDU type. For each PDU (pair) there are 8 bits, each representing a version number: 0 - 7. Asserting the bit corresponding to a given version will configure the VOE to accept PDUs of this version. E.g. the following will configure VERSION = 1 as being valid for CCM(-LM) frames. * CCM_VERSION(1) = 1"), fields });
        let mut fields = HashMap::new();
        fields.insert("BFD_VERSION", Field { brief: Some("The VOE will optionally validate the version of the incoming BFD frames against the value configured in this register. If the version in the incoming frame is not as configured, the frame will be discarded. The Rx validation is configured in the following bitfields: * VOP_MPLS:VOE_CONF_MPLS:BFD_CONFIG.BFD_RX_VERIFY_*"), details: None, lo: 0, hi: 3 });
        regs.insert("VERSION_CTRL_MPLS", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Version control configuration for MPLS"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("VOE32_INTR", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("VOE32_INTR", Register { addr: Address { base: 38, count: 2, width: 1 }, brief: Some("One bit per 32 VOE interrupts."), details: Some("The following register contains a bit for every VOE indicating whether VOE interrupt is asserted: * VOP::INTR.* To speed up the process of finding out which interrups are asserted, this register (INTR_VOE32) contains a single bit for every 32-bit register in the above register. Every bit in INTR_VOE32 indicates if an interrupt is asserted in the corresponding 32 bit register in VOP::INTR.* I.e. bit 0 = '1' indicates an active interrupt in VOP::INTR[0].VOE_INTR bit 1 = '1' indicates an active interrupt in VOP::INTR[1].VOE_INTR ..."), fields });
        let mut fields = HashMap::new();
        fields.insert("CCM_LM_UPD_RSV_ENA", Field { brief: Some("The CCM PDU does not have a dedicated register for the RxFCf counter. However there is a reserved field which can be used to hold this value. Asserting this field enables updating reserved field for Rx CCM LM PDU with RxFCf. This is the only way to relay the RxFCf counter to the CPU."), details: Some("0: Do not update CCM-LM frames with RxFC_f information 1: Update the CCM-LM Reserved field with RxFC_f information"), lo: 11, hi: 12 });
        fields.insert("CCM_RX_SRC_PORT_DETECT_CNT", Field { brief: Some("The VOE can optionally detect changes in the source port for CCM PDUs. The port on which the last valid PDU was received is saved: * VOP:VOE_STAT:CCM_RX_LAST.CCM_RX_SRC_PORT The VOE counts the number of valid CCM PDUs received on the same port as the previous in the following register: * VOP:VOE_STAT:CCM_STAT.CCM_RX_SRC_PORT_CNT If the this count reaches the value configured in this field, the following sticky bit is asserted: * VOP:VOE_STAT:INTR_STICKY.CCM_RX_SRC_PORT_DETECT_STICKY The sticky bit can optionally generate an interrupt. Note: that the VOE counts the number of frames matching the previous, hence if this bitfield is programmed to 'X', it will require 'X' + 1 consecutive frames on the same port to assert the sticky bit."), details: Some("0: illegal value (Will never generate a sticky bit) 1-7: Assert sticky bit when 1-7 CCM PDUs were received on the same port as the previous."), lo: 7, hi: 10 });
        fields.insert("G_8113_1_CNT_LBR_RX_ERROR_ENA", Field { brief: Some("If enabled the G.8113.1 LBR Rx errors at the 'Initiator MEP' are counted in the following counters: MEPID errors: * VOP:VOE_STAT:CCM_RX_ERR_1.CCM_RX_MEPID_ERR_CNT MEGID errors: * VOP:VOE_STAT:CCM_RX_ERR_1.CCM_RX_MEGID_ERR_CNT These counters are reused from Y.1731 CCM error counters. Note that only LBR Rx due to MEP ID and MEG ID mismatch are counted. LBR Rx errors due to 'illegal ID Sub-Type' and 'illlegal Loopback Indicator' are not counted. This bit only has effect for VOEs configured for G.8113.1 OAM."), details: Some("0: Do not count G.8113.1 LBR Rx errors. 1: Count G.8113.1 LBR Rx errors."), lo: 3, hi: 4 });
        fields.insert("G_8113_1_LBK_INDC_CHK_ENA", Field { brief: Some("When the VOE is configured for G.8113.1 OAM, the 'Initiator MEP' will determine if incoming Rx LBR PDUs carry the 'Requesting MEP ID' TLV. If so the 'Initiator MEP' will determine if the 'Loopback Indicator' has been set to '1' by the 'Responder MEP'. If the 'Loopback Indicator' is not equal to '1' the frame is marked as invalid. In the VOE the 'Loopback Indicator' check is optional and can be configured using this bitfield."), details: Some("0: Disable the 'Loopback Indicator' check in the 'Initiator MEP\" (G.8113.1 OAM) 1: Enable the 'Loopback Indicator' check in the 'Initiator MEP\" (G.8113.1 OAM)"), lo: 2, hi: 3 });
        fields.insert("G_8113_1_MEL_CHK_DIS", Field { brief: Some("Asserting this bit will disable the Y.1731 MEL checking (RX / TX) in the VOE when the VOE is configured for G.8113.1 OAM. This is intended for use with G.8113.1 OAM. Since the MEL has no meaning in MPLS OAM, it is possible to disable the MEL using this bit, even if the standard specifies to set the MEL values of all OAM PDUs to the correct value."), details: Some("0: MEL checking is done in the VOE as per Y.1731 1: MEL checking is disabled in the VOE. All frames are considered to have correct MEL."), lo: 6, hi: 7 });
        fields.insert("G_8113_1_MEP_SCENARIO", Field { brief: Some("The G.8113.1 standard (date: 11/2012) is not 100% clear on which MEP IDs are being exchanged and verified when two MEPs are exchanging 'LBM Target MEP ID' TLV <-> LBR 'Replying LBR MEP ID' TLV. It is therefore configurable which MEP IDs are carried in the TLVs, and from this follows which MEP IDs whill be used in the Initiator / Responder VOEs for MEP ID verification. The 4 possible scenarios are as follows: Scenario A: -------------------------------- Initiator MEP transmits 'Target MEP ID TLV' with the Initiator MEP ID (local MEP ID) Responder MEP replies with  'Replying MEP ID TLV' with the Initiator MEP ID (remote MEP ID) In this scenario the 'Responder MEP' must verify the Rx LBM Target MEP ID against the remote MEP ID (CCM_MEPID) In this scenario the 'Initiator MEP' must verify the Rx LBR Replying MEP ID against the local MEP ID (VOE_MEPID) Scenario B: -------------------------------- Initiator MEP transmits 'Target MEP ID TLV' with the Initiator MEP ID (local MEP ID) Responder MEP replies with  'Replying MEP ID TLV' with the Responder MEP ID (local MEP ID) In this scenario the 'Responder MEP' must verify the Rx LBM Target MEP ID against the remote MEP ID (CCM_MEPID) In this scenario the 'Initiator MEP' must verify the Rx LBR Replying MEP ID against the remote MEP ID (CCM_MEPID) Scenario C: -------------------------------- Initiator MEP transmits 'Target MEP ID TLV' with the Responder MEP ID (remote MEP ID) Responder MEP replies with  'Replying MEP ID TLV' with the Responder MEP ID (local MEP ID) In this scenario the 'Responder MEP' must verify the Rx LBM Target MEP ID against the local MEP ID (VOE_MEPID) In this scenario the 'Initiator MEP' must verify the Rx LBR Replying MEP ID against the remote MEP ID (CCM_MEPID) Scenario D: -------------------------------- Initiator MEP transmits 'Target MEP ID TLV' with the Responder MEP ID (remote MEP ID) Responder MEP replies with  'Replying MEP ID TLV' with the Initiator MEP ID (remote MEP ID) In this scenario the 'Responder MEP' must verify the Rx LBM Target MEP ID against the local MEP ID (VOE_MEPID) In this scenario the 'Initiator MEP' must verify the Rx LBR Replying MEP ID against the local MEP ID (VOE_MEPID)"), details: Some("00: Scenario A 01: Scenario B 10: Scenario C 11: Scenario D"), lo: 4, hi: 6 });
        fields.insert("LMR_UPD_RXFCL_ENA", Field { brief: Some("The LMR PDU does not have any fields reserved to hold the RxFCb counter upon reception of an LMR/SLR frame. For LMR: ---------------- The VOE supports adding the RxFCb counter following the other three counters in the LMR/SLR PDU. This requires extending the first TLV from 12 --> 16 bytes. Asserting this fields enables updating TLV OFFSET to 16 and setting inserting RxFCb after TxFCb. Further a new End TLV = 0 is written right after the LMR.RxFCb (at offset = 16) For SLR: -------------- The VOE supports adding the RxFCb counter following the other three counters in the SLR PDU. This requires extending the first TLV from 16 --> 20 bytes. Asserting this fields enables updating TLV OFFSET to 16 and setting inserting RxFCb after TxFCb. Further a new End TLV = 0 is written right after the SLR.RxFCb (at offset = 16) This solution is a proprietary solution, which allows forwarding the RxFCb value to an internal or external CPU. NOTE this will result in a non standards compliant frame. However, this is the only way to convey the RxFCb frame count to a CPU."), details: Some("0: No modifications to LMR upon reception 1: Update LMR frames as described above."), lo: 10, hi: 11 });
        fields.insert("LOC_SCAN_ENA", Field { brief: Some("Enables or disables automated Loss Of Continuity (LOC) Controller to be used for LOC detection by both Ethernet and MPLS-TP VOEs. When the LOC SCAN is disabled, the LOC timers will not expire so there is no increase of the LOC counters in the VOEs. When the LOC SCAN is enabled, the LOC timers will expire and increment the VOE LOC counters. LOC timers are configured in register: VOP::LOC_CTRL.* When the LOC scan controller is disabled, the LOC scan controller is automatically reset. I.e. all internal counters are set to default values. NOTE: This does not affect the LOC miss counters in the VOE."), details: None, lo: 1, hi: 2 });
        fields.insert("VOP_ENA", Field { brief: Some("Enables or disables the Vitesse OAM Processor (VOP). When the the VOP is disabled, both VOP and the single VOEs can be configured, but no frame processing is done. Further each individual VOE must be enabled to enable its functionality."), details: None, lo: 0, hi: 1 });
        regs.insert("VOP_CTRL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Miscellaneous Vitesse OAM Processor Controls"), details: Some("This register contains variable settings which are global to all VOEs."), fields });
        groups.insert("COMMON", RegisterGroup { addr: Address { base: 68930, count: 1, width: 76 }, desc: "Configuration Registers for VOP.", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CM_ADDR", Field { brief: Some("Address selection within selected core memory (CMID register). Address is automatically advanced at every data access."), details: None, lo: 0, hi: 22 });
        fields.insert("CM_ID", Field { brief: Some("Refer to cmid.xls in the AS1000, misc_docs folder."), details: None, lo: 22, hi: 30 });
        regs.insert("CM_ADDR", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Address selection"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CM_DATA", Field { brief: Some("Data register for core memory access. Wider memories are big endian mapped into the 32 BIT inspection space."), details: None, lo: 0, hi: 32 });
        regs.insert("CM_DATA", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Data register for core memory access."), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RAM_ENA", Field { brief: Some("Core memory controllers are enabled when this field is set."), details: None, lo: 0, hi: 1 });
        fields.insert("RAM_INIT", Field { brief: Some("Initialize core memories. Field is automatically cleared when operation is complete ( approx. 40 us)."), details: None, lo: 1, hi: 2 });
        regs.insert("RAM_INIT", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Core reset control"), details: Some("Controls reset and initialization of the switching core. Proper startup sequence is: - Enable memories - Initialize memories - Enable core"), fields });
        groups.insert("COREMEM", RegisterGroup { addr: Address { base: 68928, count: 1, width: 2 }, desc: "Access core memory", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CNT_YELLOW_REW", Field { brief: Some("Determines if the VOE LM counters counts all frames or only GREEN frames."), details: Some("'0': do not include yellow frames in the LM count. '1': include yellow frames in the LM count."), lo: 0, hi: 1 });
        fields.insert("COLOR_SRC_SEL_REW", Field { brief: Some("Determines which internal signal carries color for the current VOE."), details: Some("\"00\": ifh.dp_color \"01\": ifh.cl_dei \"10\": REW:MAP_RES_X:MAP_VAL_A.OAM_COLOR (Output from the mapping table) \"11\": reserved for future use (do not use)"), lo: 1, hi: 3 });
        fields.insert("COSID_SRC_SEL_REW", Field { brief: Some("Selects the source of the COSID mapping."), details: Some("\"00\": ifh.cosid \"01\": ifh.tc \"10\": ifh_iprio \"11\": REW:MAP_RES_X:MAP_VAL_A.OAM_COSID (Output from the mapping table)"), lo: 3, hi: 5 });
        regs.insert("COSID_MAP_CFG_REW", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("COSID / Color control signals"), details: Some("The bit fields in this register determines the source of the COSID mapping / COLOR of frames not processed by the VOE."), fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_RX_COSID_MAP", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("PORT_RX_COSID_MAP", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("LSB of Rx Port VOE mapping table (ANA)."), details: Some("This register contains the lower 32 bits of the Port VOE Rx (ANA) COSID mapping table. The mapping in this register is used when Port DEI = 0."), fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_RX_COSID_MAP1", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("PORT_RX_COSID_MAP1", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("MSB of Rx Port VOE mapping table (ANA)."), details: Some("This register contains the upper 32 bits of the Port VOE Rx (ANA) COSID mapping table. This mapping in this register is used when Port DEI = 1"), fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_TX_COSID_MAP", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("PORT_TX_COSID_MAP", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("LSB of Tx Port VOE mapping table (REW)."), details: Some("This register contains the lower 32 bits of the Port VOE Tx (REW) COSID mapping table. This mapping in this register is used when Port DEI = 0"), fields });
        groups.insert("PORT_COSID_MAP_CONF", RegisterGroup { addr: Address { base: 71936, count: 53, width: 4 }, desc: "COSID / Color config - Port VOEs", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("SAM_LBR_RX_TRANSID_ERR_CNT", Field { brief: Some("See register description."), details: None, lo: 0, hi: 16 });
        regs.insert("SAM_LBR_RX_TRANSID_ERR_CNT", Register { addr: Address { base: 28, count: 7, width: 1 }, brief: Some("LBR/TST/CCM out of sequence errors per priority"), details: Some("When a VOE is assigned a SAM per COSID counter set, this register counts the number of out-of-sequence erorrs for LBR/TST/CCM PDUs for priorities 0-6. Depending on the PDU being counted, priority 7 is counted in the following counter. CCM: *  VOP:VOE_STAT:CCM_RX_WARNING.CCM_RX_SEQNO_ERR_CNT LBM/LBR: * VOP:VOE_STAT:LBR_RX_TRANSID_ERR_CNT.LBR_RX_TRANSID_ERR_CNT TST: * VOP:VOE_STAT:LBR_RX_TRANSID_ERR_CNT.LBR_RX_TRANSID_ERR_CNT"), fields });
        groups.insert("RAM_CTRL", RegisterGroup { addr: Address { base: 69006, count: 1, width: 1 }, desc: "Access core memory", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CNT_YELLOW_ANA", Field { brief: Some("Determines if the VOE LM counters counts all frames or only GREEN frames."), details: Some("'0': do not include yellow frames in the LM count. '1': include yellow frames in the LM count."), lo: 0, hi: 1 });
        fields.insert("COLOR_SRC_SEL_ANA", Field { brief: Some("Determines which internal signal carries color for the current VOE. This configuration is only used in ANA, the corresponding configuration in the REW is not used."), details: Some("\"00\": ifh.dp_color \"01\": ifh.cl_dei \"10\": ANA_CL:MAP_TBL:MAP_ENTRY.PATH_COLOR_VAL (Output from mapping table. Do not use for Up-MEP) \"11\": reserved for future use (do not use)"), lo: 1, hi: 3 });
        fields.insert("COSID_SRC_SEL_ANA", Field { brief: Some("Selects the source of the COSID mapping."), details: Some("\"00\": ifh.cosid \"01\": ifh.tc \"10\": ifh_iprio \"11\": ANA_CL:MAP_TBL:MAP_ENTRY.PATH_COSID_VAL (Output from mapping table. Do not use for Up-MEP)"), lo: 3, hi: 5 });
        regs.insert("COSID_MAP_CFG_ANA", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("COSID / Color control signals"), details: Some("The bit fields in this register determines the source of the COSID mapping / COLOR of frames not processed by the VOE."), fields });
        let mut fields = HashMap::new();
        fields.insert("COSID_MAP_TABLE_REW", Field { brief: Some("The table is used to map the choosen COSID in the REW. bit(2:0) will be used to map COSID = 0 bit(5:3) will be used to map COSID = 1 ... bit(23:21) will be used to map COSID = 7 When mapping a COSID, the following procedure is followed: 1) Use COSID_SRC_SEL_REW to select the source of the COSID mapping. I.e. if COSID_SRC_SEL_REW = 1 (TC) the input to the mapping table is set to the IFH.TC. 2) Map the selected value. If IFH.TC = 3, the mapped COSID will be set to COSID_MAP_TABLE_REW[11:9]"), details: None, lo: 0, hi: 24 });
        regs.insert("COSID_MAP_TABLE_REW", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("COSID mapping table"), details: Some("COSID mapping table used for mapping the selected COSID values. A single mapping table is available for each of the Service/Path VOEs."), fields });
        groups.insert("REW_COSID_MAP_CONF", RegisterGroup { addr: Address { base: 75776, count: 1024, width: 2 }, desc: "COSID / Color config in REW - Service VOEs", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("PORT_TX_COSID_MAP1", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("PORT_TX_COSID_MAP1", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("MSB of Tx Port VOE mapping table (REW)."), details: Some("This register contains the upper 32 bits of the Port VOE Tx (REW) COSID mapping table. This mapping in this register is used when Port DEI = 1"), fields });
        let mut fields = HashMap::new();
        fields.insert("SAM_LBM_TX_TRANSID", Field { brief: Some("See register description"), details: None, lo: 0, hi: 32 });
        regs.insert("SAM_LBM_TX_TRANSID", Register { addr: Address { base: 0, count: 7, width: 1 }, brief: Some("LBM/TST/CCM Tx PDUs per priority."), details: Some("When a VOE is assigned a SAM per COSID counter set, this register counts the number of Tx CCM/LBM/TST PDUs for priorities 0-6. Depending on the PDU being counted, priority 7 is counted by the following counter. CCM: * VOP:VOE_STAT:CCM_TX_SEQ_CFG.CCM_TX_SEQ LBM/LBR: * VOP:VOE_STAT:LBM_TX_TRANSID_CFG.LBM_TX_TRANSID TST: * VOP:VOE_STAT:LBM_TX_TRANSID_CFG.LBM_TX_TRANSID"), fields });
        let mut fields = HashMap::new();
        fields.insert("SAM_LBR_RX_FRM_CNT", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("SAM_LBR_RX_FRM_CNT", Register { addr: Address { base: 14, count: 7, width: 1 }, brief: Some("LBR/TST/CCM Rx PDUs per priority"), details: Some("When a VOE is assigned a SAM per COSID counter set, this register counts the number of Rx LBR/TST/CCM PDU for priorities 0-6. Depending on the PDU being counted, priority 7 is counted by the following counter. CCM: * VOP:VOE_STAT:CCM_RX_FRM_CNT.CCM_RX_VLD_FC_CNT LBM/LBR: * VOP:VOE_STAT: LBR_RX_FRM_CNT.LBR_RX_FRM_CNT TST: * VOP:VOE_STAT: LBR_RX_FRM_CNT.LBR_RX_FRM_CNT"), fields });
        let mut fields = HashMap::new();
        fields.insert("SAM_LBR_RX_TRANSID", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("SAM_LBR_RX_TRANSID", Register { addr: Address { base: 21, count: 7, width: 1 }, brief: Some("LBR/TST/CCM Rx Transaction ID per priority"), details: Some("When a VOE is assigned a SAM per COSID counter set, this register counts the latest Sequence Number / Transaction ID received in a valid LBR/TST/CCM PDU for priorities 0-6. Depending on the PDU being counted, priority 7 is stored in the following register. CCM: * VOP:VOE_STAT:CCM_RX_SEQ_CFG.CCM_RX_SEQ LBM/LBR: * VOP:VOE_STAT:LBR_RX_TRANSID_CFG.LBR_RX_TRANSID TST: * VOP:VOE_STAT:LBR_RX_TRANSID_CFG.LBR_RX_TRANSID"), fields });
        let mut fields = HashMap::new();
        fields.insert("SAM_LBR_TX_FRM_CNT", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("SAM_LBR_TX_FRM_CNT", Register { addr: Address { base: 7, count: 7, width: 1 }, brief: Some("LBR Tx PDUs per priority"), details: Some("When a VOE is assigned a SAM per COSID counter set, this register counts the number of Tx LBR PDU for priorities 0-6. Depending on the PDU being counted, priority 7 is counted by the following counter. CCM: (Not used) LBR: * VOP:VOE_STAT:LBR_TX_FRM_CNT.LBR_TX_FRM_CNT TST: (Not used)"), fields });
        groups.insert("SAM_COSID_SEQ_CNT", RegisterGroup { addr: Address { base: 77824, count: 32, width: 64 }, desc: "SAM per COSID sequence counters", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CCM_TX_FCB", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("CCM_TX_FCB_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("CCM-LM Tx sample value."), details: Some("Value of the CCM-LM.TX_FC_F field in the lastest received valid CCM-LM frame by this VOE. This value must be transmitted as CCM-LM.TX_FCB in the next CCM-LM frame transmitted by this VOE."), fields });
        let mut fields = HashMap::new();
        fields.insert("SLM_TX_FRM_CNT", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("SLM_TX_FRM_CNT", Register { addr: Address { base: 29, count: 1, width: 1 }, brief: Some("SynLM Tx frame counter."), details: Some("TX counter for counting Initiator MEP Tx SynLM PDUs (SLM / SL1). The counter value is written into the the following fields of Tx SynLM PDUs: * SLM.TxFCf * 1SL.TxFCf The counter is increased (+1) after being written to the Tx PDU. Note: To send TxFCf = 1 in the first Tx SynLM PDU, this register must be initialized to 1."), fields });
        groups.insert("VOE_CCM_LM", RegisterGroup { addr: Address { base: 69632, count: 1077, width: 2 }, desc: "VOE CCM-LM samples", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CCM_LM_PERIOD", Field { brief: Some("The VOE inserts LM information into Tx CCM frames injected by internal or external CPU if the following bit field is asserted. * VOP:VOE_STAT:CCM_STAT.CCM_LM_INSERT_NXT This is known as LM insertion. The VOE clears this bit field, when inserting LM information into a Tx CCM PDU. The assertion of this bit field can be done either by the CPU or automatically based on LOC timeout counter expiry. To enable automatic LM insertion a LOC timeout counter must be assigned for LM insertion, by programming the number of the LOC timeout counter into this field. Every time the the configured LOC timeout counter expires, the above bit field will be asserted. This configuration will NOT affect the CCM PDU period field. Note that the rate at which LM information is inserted is twice the rate indicated by the LOC_PERIOD_VAL of the selected timeout counter. I.e. if the VOP::LOC_PERIOD_CFG.LOC_PERIOD_VAL of the selected timeout counter is set to 10 ms, LM information will be inserted every 5 ms. Note: VOP:VOE_CONF:OAM_HW_CTRL.CCM_LM_ENA must be asserted prior to configuring this register."), details: Some("0: Disable automatic insertion of Loss Measurements in OAM CCM PDU n: Automatic insertion of Loss Measurements in next OAM CCM PDU when the corresponding VOP::LOC_PERIOD_CFG occurs."), lo: 10, hi: 13 });
        fields.insert("CCM_MEGID_CHK_ENA", Field { brief: Some("Configures if the VOE will validate the MEG ID of valid incoming CCM(-LM) PDUs against the valued configured in: * VOP:VOE_CONF:CCM_MEGID_CFG.CCM_MEGID If the MEGID verification fails the following sticky bit is asserted: * VOP:VOE_STAT:CCM_RX_LAST.CCM_MEGID_ERR An interrupt can optionally be generated when the state of the CCM MEGID verification changes: * VOP:VOE_STAT:INTR_STICKY.CCM_MEGID_RX_ERR_STICKY If the MEGID verification fails, the frame is marked as invalid."), details: Some("0: No MEGID check 1: Check MEG ID"), lo: 1, hi: 2 });
        fields.insert("CCM_MEPID_CHK_ENA", Field { brief: Some("If this bit is asserted, the value of the MEP ID in incoming CCM frames will be verified against the value programmed in: * VOP:VOE_CONF:PEER_MEPID_CFG.PEER_MEPID If the MEPID verification fails the following sticky bit is asserted: * VOP:VOE_STAT:CCM_RX_LAST.CCM_MEPID_ERR An interrupt can optionally be generated when the state of the CCM MEPID verification changes: * VOP:VOE_STAT:INTR_STICKY.CCM_MEPID_RX_ERR_STICKY If the MEPID verification fails, the frame is marked as invalid."), details: None, lo: 0, hi: 1 });
        fields.insert("CCM_PERIOD", Field { brief: Some("This bitfield serves two purposes: ------------------------------------------------------------ * Configures expected CCM period. * Assigns a LOC counter which will increment the LOC miss counter. The PERIOD fields of the valid incoming CCM frames will be checked against this value. If the PERIOD verification fails the following sticky bit is asserted: * VOP:VOE_STAT:CCM_RX_LAST.CCM_PERIOD_ERR An interrupt can optionally be generated when the state of the CCM PERIOD verification changes: * VOP:VOE_STAT:INTR_STICKY.CCM_PERIOD_RX_ERR_STICKY The LOC counter is assigned as indicated in the 'Encoding field'. Note: A CCM(-LM) frame is valid even when the CCM PERIOD verification fails."), details: Some("0: LOC counter is not incremented. (Zero is an illegal period value) 1: LOC counter is incremented by LOC timeout counter 0 (Verify period == 1) 2: LOC counter is incremented by LOC timeout counter 1 (Verify period == 2) 3: LOC counter is incremented by LOC timeout counter 2 (Verify period == 3) 4: LOC counter is incremented by LOC timeout counter 3 (Verify period == 4) 5: LOC counter is incremented by LOC timeout counter 4 (Verify period == 5) 6: LOC counter is incremented by LOC timeout counter 5 (Verify period == 6) 7: LOC counter is incremented by LOC timeout counter 6 (Verify period == 7)"), lo: 2, hi: 5 });
        fields.insert("CCM_PRIO", Field { brief: Some("Configures expected priority of CCM(-LM) frames received by the VOE. The VOE will verify the priority of valid incoming CCM(-LM) PDUs against this value. If the PRIO validation fails the following sticky bit is asserted: * VOP:VOE_STAT:CCM_RX_LAST.CCM_PRIO_ERR An interrupt can optionally be generated when the state of the CCM PRIO verification changes: * VOP:VOE_STAT:INTR_STICKY.CCM_PRIO_RX_ERR_STICKY Note that a CCM(-LM) frame is valid even when the CCM PRIO verification fails."), details: None, lo: 5, hi: 8 });
        fields.insert("CCM_RX_SEQ_CHK_ENA", Field { brief: Some("If asserted, the sequence number of valid CCM(-LM) frames received by the VOE is validated against the expected value. The expected value is the value of the following bit field + 1: * VOP:VOE_STAT:CCM_RX_SEQ_CFG.CCM_RX_SEQ When a valid CCM(-LM) PDU is received by the VOE, the value of the CCM(-LM).sequence_number is stored in the above bit field."), details: None, lo: 8, hi: 9 });
        fields.insert("CCM_SEQ_UPD_ENA", Field { brief: Some("If asserted, the sequence number will be updated for CCM frames transmitted from this VOE. The CCM sequence number of transmitted CCM(-LM) frames will be overwritten with the value configured in the following bit field: * VOP:VOE_STAT:CCM_TX_SEQ_CFG.CCM_TX_SEQ (Note that the above register is always updated +1 when the VOE transmits a valid CCM(-LM) PDU)"), details: None, lo: 9, hi: 10 });
        regs.insert("CCM_CFG", Register { addr: Address { base: 16, count: 1, width: 1 }, brief: Some("Miscellaneous CCM configuration"), details: Some("Misc configuration for CCM(-LM) PDU handling."), fields });
        let mut fields = HashMap::new();
        fields.insert("CCM_MEGID", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("CCM_MEGID_CFG", Register { addr: Address { base: 17, count: 12, width: 1 }, brief: Some("Configuration of CCM MEGID"), details: Some("Configures 48 byte MEG ID (lowest replication index correspond to MSB) to be verified in incoming CCM(-LM) frames. In case MEG ID verification is enabled (VOP:VOE_CONF:CCM_CFG.CCM_MEGID_CHK_ENA = 1) the value of the CCM.MEGID field of incoming CCM(-LM) frames will be verified against the value configured in this register. If there is a mismatch, the following bit will be asserted: * VOP:VOE_STAT:CCM_RX_LAST.CCM_MEGID_ERR When the above bit changes value, the VOE optionally generates an interrupt."), fields });
        let mut fields = HashMap::new();
        fields.insert("G_8113_1_INITIATOR_FUNCTION", Field { brief: Some("When running G.8113 LBM / LBR there are two phases: Discovery phase. ---------------------------- 'Initiator MEPs' transmit Discovery 'Target MEP ID' TLVs to the peers (MIPs / MEP) on the MPLS connection. The peers will respond with 'Replying MEP ID' TLVs including their MIP / MEP identification. In this phase the 'Initiator MEP' cannot verify the incoming 'Replying MEP ID' TLVs. When configured for 'Discovery', the 'Initiator VOE' will discard incoming Discovery TLVs (ID Sub-Type: 0, 1) The following sticky bit is asserted: * VOP:VOE_STAT:OAM_RX_STICKY2.G_8113_1_LBX_RX_ILLEGAL_SUBTYPE_STICKY Discarded frames can optionally be extracted to the CPU error queue: * VOP:VOE_STAT:PDU_EXTRACT.G_8113_1_LBR_RX_ERR_EXTR All other TLVs are accepted without further verification and can optionally be extracted the CPU for peer MEP identification. * VOP:VOE_CONF:OAM_CPU_COPY_CTRL.LBR_CPU_COPY_ENA Connection Verification (CV) phase. ------------------------------------------------- Once the MEP is aware the identity of the MIPs, MEP along the MPLS connection, it will transmit LBM PDUs with 'Target MEP ID' TLVs directed at the specific MIPs / MEPs. When receiving the Rx LBR PDUs it must verify that the 'Reponder MIP / MEP' matches the expected peer MIP/MEP. In this phase the VOE can be configured to expect either 'Replying MEP ID' TLV (ID Sub-Type: 2) or 'Replying MIP ID' TLV (ID Sub-Type: 3) If an unexpected ID Sub-Type is received, the frame is marked as invalid and the following sticky bit is asserted: * VOP:VOE_STAT:OAM_RX_STICKY2.G_8113_1_LBX_RX_ILLEGAL_SUBTYPE_STICKY Discarded frames can optionally be extracted to the CPU error queue: * VOP:VOE_STAT:PDU_EXTRACT.G_8113_1_LBR_RX_ERR_EXTR When an expected ID Sub-Type the contents is validated against the values configured in the VOE as follows: CV - MIP (ID Sub-Type: 3) -------------------------------------------- If 'Replying MEP ID TLV' verification is enabled: * VOP:VOE_CONF:G_8113_1_CFG.G_8113_1_LBX_MEXID_CHK_ENA The VOE will verify the content of the TLV as follows: * TLV.CarrierCode == G_8113_1_REMOTE_MIPID[13:8] * TLV.NodeID == G_8113_1_REMOTE_MIPID[7:4] * TLV.IfNum == G_8113_1_REMOTE_MIPID[3:0] CV - MEP (ID Sub-Type: 2) --------------------------------------------- If 'Replying MEP ID TLV' verification is enabled: * VOP:VOE_CONF:G_8113_1_CFG.G_8113_1_LBX_MEXID_CHK_ENA The VOE will verify the MEP ID of the incoming LBR 'Replying MEP ID' TLV. If the verification fails (MIP / MEP ID), the frame is marked as invalid. The following sticky bit is asserted: * VOP:VOE_STAT:OAM_RX_STICKY2.G_8113_1_LBX_RX_ILLEGAL_MEXID_STICKY The frame can optionally be extracted to the CPU error queue: * VOP:VOE_STAT:PDU_EXTRACT.G_8113_1_LBR_RX_ERR_EXTR"), details: Some("00: Discovery phase 01: Connection Verification - MIP 10: Connection Verification - MEP"), lo: 1, hi: 3 });
        fields.insert("G_8113_1_LBX_MEXID_CHK_ENA", Field { brief: Some("Determines whether the 'Initator/ Responder 'VOE validates the MEPID / MEGID fields when receiving LBM / LBR PDUs: = 0; Do not verify TLV MIP / MEP / MEG IDs. = 1; Verify TLV MIP / MEP / MEG IDs. The fields to be verified are as follows: 'Responder MEP': ------------------------------ LBM.TargetID.MEPID LBM.Requesting.MEPID (if present) LBM.Requesting.MEGID (if present) 'Initiator MEP': ------------------------------ LBR.ReplyingID.MEPID LBR.Requesting.MEPID (if present) LBR.Requesting.MEGID (if present)"), details: Some("0: Don't verify incoming LBM / LBR TLV MEP / MIP / MEG ID values (G.8113.1) 0: Verify incoming LBM / LBR TLV MEP / MIP / MEG ID values (G.8113.1)"), lo: 0, hi: 1 });
        regs.insert("G_8113_1_CFG", Register { addr: Address { base: 39, count: 1, width: 1 }, brief: Some("Configuration of G.8113.1 OAM"), details: Some("Register contains bit for configuring the G.8113.1 functionality of the VOE. Configuration only has effect if the VOE is configured for G.8113.1 OAM. * VOP:VOE_CONF:VOE_CTRL.G_8113_1_ENA"), fields });
        let mut fields = HashMap::new();
        fields.insert("G_8113_1_REMOTE_MIPID", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("G_8113_1_REMOTE_MIPID", Register { addr: Address { base: 40, count: 1, width: 1 }, brief: Some("G.8113.1 MIP ID verification configuration"), details: Some("When the G.8113.1 'Initator MEP' is configured for : Connection Verification - MIP: * VOP:VOE_CONF:G_8113_1_CFG.G_8113_1_INITIATOR_FUNCTION There are 14 bytes in the 'Replying MIP ID' TLV which must be verified. These are configured in this register. I practice the register is split into 4 separate registers: * G_8113_1_REMOTE_MIPID (32 bits) * G_8113_1_REMOTE_MIPID1 (32 bits) * G_8113_1_REMOTE_MIPID2 (32 bits) * G_8113_1_REMOTE_MIPID3 (16 bits) The below description will assume that these 4 registers are concatenated into one 14 byte long register. The bytes to be verified in the 'Replying MIP ID' TLV are configured as follows: * LBR.CarrierCode == G_8113_1_REMOTE_MIPID[13:8] * LBR.NodeID == G_8113_1_REMOTE_MIPID[7:4] * LBR.IfNum == G_8113_1_REMOTE_MIPID[3:0]"), fields });
        let mut fields = HashMap::new();
        fields.insert("G_8113_1_REMOTE_MIPID1", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("G_8113_1_REMOTE_MIPID1", Register { addr: Address { base: 41, count: 1, width: 1 }, brief: Some("G.8113.1 MIP ID verification configuration"), details: Some("When the G.8113.1 'Initator MEP' is configured for : Connection Verification - MIP: * VOP:VOE_CONF:G_8113_1_CFG.G_8113_1_INITIATOR_FUNCTION There are 14 bytes in the 'Replying MIP ID' TLV which must be verified. These are configured in this register. I practice the register is split into 4 separate registers: * G_8113_1_REMOTE_MIPID (32 bits) * G_8113_1_REMOTE_MIPID1 (32 bits) * G_8113_1_REMOTE_MIPID2 (32 bits) * G_8113_1_REMOTE_MIPID3 (16 bits) The below description will assume that these 4 registers are concatenated into one 14 byte long register. The bytes to be verified in the 'Replying MIP ID' TLV are configured as follows: * LBR.CarrierCode == G_8113_1_REMOTE_MIPID[13:8] * LBR.NodeID == G_8113_1_REMOTE_MIPID[7:4] * LBR.IfNum == G_8113_1_REMOTE_MIPID[3:0]"), fields });
        let mut fields = HashMap::new();
        fields.insert("G_8113_1_REMOTE_MIPID2", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("G_8113_1_REMOTE_MIPID2", Register { addr: Address { base: 42, count: 1, width: 1 }, brief: Some("G.8113.1 MIP ID verification configuration"), details: Some("When the G.8113.1 'Initator MEP' is configured for : Connection Verification - MIP: * VOP:VOE_CONF:G_8113_1_CFG.G_8113_1_INITIATOR_FUNCTION There are 14 bytes in the 'Replying MIP ID' TLV which must be verified. These are configured in this register. I practice the register is split into 4 separate registers: * G_8113_1_REMOTE_MIPID (32 bits) * G_8113_1_REMOTE_MIPID1 (32 bits) * G_8113_1_REMOTE_MIPID2 (32 bits) * G_8113_1_REMOTE_MIPID3 (16 bits) The below description will assume that these 4 registers are concatenated into one 14 byte long register. The bytes to be verified in the 'Replying MIP ID' TLV are configured as follows: * LBR.CarrierCode == G_8113_1_REMOTE_MIPID[13:8] * LBR.NodeID == G_8113_1_REMOTE_MIPID[7:4] * LBR.IfNum == G_8113_1_REMOTE_MIPID[3:0]"), fields });
        let mut fields = HashMap::new();
        fields.insert("CLEAR_DP_ON_LOOP", Field { brief: Some("When OAM PDUs are looped, the DP bits can be cleared or keep their value depending on the setting of this bit. This only affects frames being looped: * LBM --> LBR * LMM --> LMR * DMM --> DMR * SLM --> SLR"), details: Some("0: DP bits to be looped with the frame. 1: DP bits are cleared when frame is looped."), lo: 0, hi: 1 });
        fields.insert("LB_ES0_ISDX_ENA", Field { brief: Some("Used for Down-MEP only - has no effect for Up-MEP. When a PDU Message is looped to a PDU Reply, the ISDX for the PDU Reply will be changed to the value configured in: * ISDX_LB When the Reply passes through the REW, the value in this register will overwrite the IFH.FWD.ES0_ISDX_KEY_ENA. This allows the value at the egress to be different than the value assigned at the ingress, when the lookup was done for a different ISDX. Hence using this bit field it is possible to configure whether the PDU Message will use ISDX for the ES0 lookup. This is relevant for the following PDU types: * LMM --> LMR * SLM --> SLR * DMM --> DMR * LBM --> LBR"), details: None, lo: 13, hi: 14 });
        fields.insert("LB_ISDX", Field { brief: Some("All valid OAM messages (LBM, DMM, LMM, SLM) which are looped back into OAM replies (LBR, DMR, LMR, SLR) will be forwarded in the return direction with the ISDX value configured in this register."), details: Some("Valid ISDX value: 1-4095"), lo: 1, hi: 13 });
        regs.insert("LOOPBACK_CFG", Register { addr: Address { base: 14, count: 1, width: 1 }, brief: Some("OAM Loopback configuration"), details: Some("Contains configuration for loopbing back frames. I.e. returning OAM replies in response to messages. When OAM Messages are looped into OAM Replies, by the VOE, the ISDX of the OAM Reply is set to the value configured in: * LB_ISDX regardless of the ISDX of the incoming OAM Message. All OAM Replies are assigned the same ISDX value."), fields });
        let mut fields = HashMap::new();
        fields.insert("LB_DMM_ENA", Field { brief: Some("This field determines whether incoming DMM frames are looped and transmitted as DMR frames. If loopback is not enabled frames are discarded. Incoming DMM frames can optionally be extracted to the CPU, regardless of loopback setting."), details: Some("'0': OAM DMM PDU is not looped as DMR frames. '1': OAM DMM PDU is looped as a DMR frame."), lo: 0, hi: 1 });
        fields.insert("LB_LBM_ENA", Field { brief: Some("This field determines whether incoming LBM frames are looped and transmitted as LBR frames. If loopback is not enabled frames are discarded. Incoming LBM frames can optionally be extracted to the CPU, regardless of loopback setting. This setting is also used to loop SAM_SEQ frames (see VOP:VOE_CONF:SAM_NON_OAM_SEQ_CFG.*)"), details: Some("'0': OAM LBM PDU is not looped as LBR frames. '1': OAM LBM PDU is looped as a LBR frame."), lo: 2, hi: 3 });
        fields.insert("LB_LMM_ENA", Field { brief: Some("This field determines whether incoming LMM/SLM frames are looped and transmitted as LMR/SLR frames. If loopback is not enabled frames are discarded. Incoming LMM/SLM frames can optionally be extracted to the CPU, regardless of loopback setting."), details: Some("'0': OAM LMM/SLM PDU is not looped as LMR/SLR frames. '1': OAM LMM/SLM PDU is looped as a LMR/SLR frame."), lo: 1, hi: 2 });
        regs.insert("LOOPBACK_ENA", Register { addr: Address { base: 13, count: 1, width: 1 }, brief: Some("Enables loopback of OAM Messages to OAM Replies"), details: Some("Some OAM PDU types can be looped, by returning a Reply in response to a Message. The looping of these PDUs is enabled by setting the bit fields in this register. When looping a PDU, both the Message and the Reply must be enabled for PDU updating: * VOP:VOE_CONF:OAM_HW_CTRL.*"), fields });
        let mut fields = HashMap::new();
        fields.insert("MEP_UC_MAC_LSB", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("MEP_UC_MAC_LSB", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("VOE MAC Unicast address (LSB)"), details: Some("Configures the VOE Unicast MAC address (LSB). This address can be verified by the VOE when frames arrive, depending on the configuration of: VOP:VOE_CONF:VOE_CTRL.RX_DMAC_CHK_SEL"), fields });
        let mut fields = HashMap::new();
        fields.insert("MEP_UC_MAC_MSB", Field { brief: Some("See register description."), details: None, lo: 0, hi: 16 });
        regs.insert("MEP_UC_MAC_MSB", Register { addr: Address { base: 11, count: 1, width: 1 }, brief: Some("VOE MAC Unicast address (MSB)"), details: Some("Configures the VOE Unicast MAC address (MSB). This address can be verified by the VOE when frames arrive, depending on the configuration of: * VOP:VOE_CONF:VOE_CTRL.RX_DMAC_CHK_SEL"), fields });
        let mut fields = HashMap::new();
        fields.insert("CCM_DATA_CNT_ENA", Field { brief: Some("Enable / disable counting valid CCM(-LM) PDUs as data in LM counters."), details: Some("'0': Do not count as data '1': Count as data"), lo: 0, hi: 1 });
        fields.insert("DMM_DATA_CNT_ENA", Field { brief: Some("Enable / disable counting valid DMM PDUs as data in LM counters."), details: Some("'0': Do not count as data '1': Count as data"), lo: 3, hi: 4 });
        fields.insert("DMR_DATA_CNT_ENA", Field { brief: Some("Enable / disable counting valid DMR PDUs as data in LM counters."), details: Some("'0': Do not count as data '1': Count as data"), lo: 2, hi: 3 });
        fields.insert("GENERIC_DATA_CNT_MASK", Field { brief: Some("Enable / disable that valid OAM PDUs with Generic OpCodes are counted by the VOE LM counters. This bit field contains a separate bit for each of the possible 8 Generic OpCodes."), details: Some("x0x: Do NOT count generic OpCode in LM counters. x1x: DO count generic OpCode in LM counters."), lo: 12, hi: 20 });
        fields.insert("LBM_DATA_CNT_ENA", Field { brief: Some("Enable / disable counting valid LBM PDUs as data in LM counters."), details: Some("'0': Do not count as data '1': Count as data"), lo: 6, hi: 7 });
        fields.insert("LBR_DATA_CNT_ENA", Field { brief: Some("Enable / disable counting valid LBR PDUs as data in LM counters. This setting is also used to control counting SAM_SEQ frames (see VOP:VOE_CONF:SAM_NON_OAM_SEQ_CFG.*)"), details: Some("'0': Do not count as data '1': Count as data"), lo: 4, hi: 5 });
        fields.insert("LMM_DATA_CNT_ENA", Field { brief: Some("Enable / disable counting valid LMM PDUs as data in LM counters."), details: Some("'0': Do not count as data '1': Count as data"), lo: 8, hi: 9 });
        fields.insert("LMR_DATA_CNT_ENA", Field { brief: Some("Enable / disable counting valid LMR PDUs as data in LM counters."), details: Some("'0': Do not count as data '1': Count as data"), lo: 7, hi: 8 });
        fields.insert("LTM_DATA_CNT_ENA", Field { brief: Some("Enable / disable counting valid LTM PDUs as data in LM counters."), details: Some("'0': Do not count as data '1': Count as data"), lo: 10, hi: 11 });
        fields.insert("LTR_DATA_CNT_ENA", Field { brief: Some("Enable / disable counting valid LTR PDUs as data in LM counters."), details: Some("'0': Do not count as data '1': Count as data"), lo: 9, hi: 10 });
        fields.insert("SDM_DATA_CNT_ENA", Field { brief: Some("Enable / disable counting valid 1DM PDUs as data in LM counters."), details: Some("'0': Do not count as data '1': Count as data"), lo: 1, hi: 2 });
        fields.insert("TST_DATA_CNT_ENA", Field { brief: Some("Enable / disable counting valid TST PDUs as data in LM counters."), details: Some("'0': Do not count as data '1': Count as data"), lo: 5, hi: 6 });
        fields.insert("UNK_OPCODE_DATA_CNT_ENA", Field { brief: Some("If a PDU is received with an OpCode which does not match any Specific OpCode or a Generic OpCode, it will be processed as an UNKNOWN OpCode. This bit field configures if OAM frames with UNKOWN OpCode are counted as data in the LM counters."), details: Some("'0': Do not count as data '1': Count as data"), lo: 11, hi: 12 });
        regs.insert("OAM_CNT_DATA_CTRL", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("Configuration of which OAM PDUs should be counted by LM counters."), details: Some("Default behavior is that all OAM PDUs processed by a VOE (i.e. OAM PDU MEG level matches VOE MEL_VAL) will not be counted as data by the LM counters. This is according to Y.1731 Using this register (OAM_CNT_DATA_CTRL) it is possible to configure the OAM PDUs separately to be counted as data. This includes all PDUs except for SLM, SLR and 1SL which are never counted in the LM counters, unless the VOE is configured for synthetic loss measurement: * VOP:VOE_CONF_REG:VOE_MISC_CONFIG.SL_ENA The configuration in this register controls the counting in both the Rx and Tx direction. The data counters are located: Service VOE: --------------------- Egress: REW:VOE_SRV_LM_CNT.SRV_LM_CNT_LSB.SRV_LM_CNT_LSB Ingress: ANA_AC_OAM_MOD:VOE_SRV_LM_CNT.SRV_LM_CNT_LSB.SRV_LM_CNT_LSB Port VOE: ------------------- Egress: REW:VOE_PORT_LM_CNT:PORT_LM_CNT_LSB.PORT_LM_CNT_LSB Ingress: ANA_AC_OAM_MOD:VOE_PORT_LM_CNT:PORT_LM_CNT_LSB.PORT_LM_CNT_LSB"), fields });
        let mut fields = HashMap::new();
        fields.insert("CCM_LM_OAM_CNT_ENA", Field { brief: Some("Enable / disable count of OAM PDU CCM with LM content as selected OAM. For this register to take effect, the HW processing of CCM-LM frames must be enabled: * VOP:VOE_CONF:OAM_HW_CTRL.CCM_LM_ENA"), details: None, lo: 0, hi: 1 });
        fields.insert("CCM_OAM_CNT_ENA", Field { brief: Some("Enable / disable count of OAM PDU CCM as selected OAM."), details: Some("'0': Count as other OAM '1': Count as selected OAM"), lo: 1, hi: 2 });
        fields.insert("DMM_OAM_CNT_ENA", Field { brief: Some("Enable / disable count of OAM PDU DMM as selected OAM."), details: Some("'0': Count as other OAM '1': Count as selected OAM"), lo: 4, hi: 5 });
        fields.insert("DMR_OAM_CNT_ENA", Field { brief: Some("Enable / disable count of OAM PDU DMR as selected OAM."), details: Some("'0': Count as other OAM '1': Count as selected OAM"), lo: 3, hi: 4 });
        fields.insert("GENERIC_OAM_CNT_MASK", Field { brief: Some("Enable / disable that valid OAM PDUs with Generic OpCodes are counted as selected OAM. This bit field contains a separate bit for each of the possible 8 Generic OpCodes."), details: Some("x0x: Count as other OAM x1x: Count as selected OAM"), lo: 13, hi: 21 });
        fields.insert("LBM_OAM_CNT_ENA", Field { brief: Some("Enable / disable count of OAM PDU LBM as selected OAM. This setting is also used to control counting of SAM_SEQ frames (see VOP:VOE_CONF:SAM_NON_OAM_SEQ_CFG.*)"), details: Some("'0': Count as other OAM '1': Count as selected OAM"), lo: 7, hi: 8 });
        fields.insert("LBR_OAM_CNT_ENA", Field { brief: Some("Enable / disable count of OAM PDU LBR as selected OAM."), details: Some("'0': Count as other OAM '1': Count as selected OAM"), lo: 5, hi: 6 });
        fields.insert("LMM_OAM_CNT_ENA", Field { brief: Some("Enable / disable count of OAM PDU LMM/SLM as selected OAM."), details: Some("'0': Count as other OAM '1': Count as selected OAM"), lo: 9, hi: 10 });
        fields.insert("LMR_OAM_CNT_ENA", Field { brief: Some("Enable / disable count of OAM PDU LMR/SLR/1SL as selected OAM."), details: Some("'0': Count as other OAM '1': Count as selected OAM"), lo: 8, hi: 9 });
        fields.insert("LTM_OAM_CNT_ENA", Field { brief: Some("Enable / disable count of OAM PDU LTM as selected OAM."), details: Some("'0': Count as other OAM '1': Count as selected OAM"), lo: 11, hi: 12 });
        fields.insert("LTR_OAM_CNT_ENA", Field { brief: Some("Enable / disable count of OAM PDU LTR as selected OAM."), details: Some("'0': Count as other OAM '1': Count as selected OAM"), lo: 10, hi: 11 });
        fields.insert("SDM_OAM_CNT_ENA", Field { brief: Some("Enable / disable count of OAM PDU 1DM as selected OAM."), details: Some("'0': Count as other OAM '1': Count as selected OAM"), lo: 2, hi: 3 });
        fields.insert("TST_OAM_CNT_ENA", Field { brief: Some("Enable / disable count of OAM PDU TST as selected OAM."), details: Some("'0': Count as other OAM '1': Count as selected OAM"), lo: 6, hi: 7 });
        fields.insert("UNK_OPCODE_OAM_CNT_ENA", Field { brief: Some("OAM PDUs not recognized as either of the PDUs with special configuration or as a Generic OpCode, will be classified as an UNKNOWN PDU. This register configures whether UNKNOWN PDUs should be counted as selected OAM."), details: Some("'0': Count as other OAM '1': Count as selected OAM"), lo: 12, hi: 13 });
        regs.insert("OAM_CNT_OAM_CTRL", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("Configuration which OAM PDUs are counted in selected PDU counter."), details: Some("The OAM frames processed by the VOE can be counted separately in Rx and Tx direction. In each direction there are two counters: 1) Default OAM counter This counter counts all the PDU types which are NOT selected using the OAM_CNT_OAM_CTRL register: * RX_OAM_FRM_CNT * TX_OAM_FRM_CNT 2) Selected OAM counter: This counter counts all the PDU types selected for counting using the OAM_CNT_OAM_CTRL register: * RX_SEL_OAM_CNT * TX_SEL_OAM_CNT Any valid OAM PDU is counted in exactly one of the above registers. I.e. as default all OAM PDUs are not selected, and they are all counted in the default OAM counters: RX / TX _ OAM_FRM_CNT. Using this register (OAM_CNT_OAM_CTRL), PDUs can be moved to the selected coutners: RX / TX SEL_OAM_CNT. The selection of OAM PDUs for the selected counter is done commonly for the Tx and Rx direction."), fields });
        let mut fields = HashMap::new();
        fields.insert("CCM_CPU_COPY_ENA", Field { brief: Some("If asserted all valid CCM PDUs received by the VOE are extracted to the CPU. Extraction queue is determined by: * VOP::CPU_EXTR_CFG_1.CCM_CPU_QU"), details: Some("'0': No extraction to CPU '1': Extract valid CCM frames to CPU"), lo: 2, hi: 3 });
        fields.insert("CCM_LM_CPU_COPY_ENA", Field { brief: Some("If asserted all valid CCM-LM PDUs received by the VOE are extracted to the CPU. Extraction queue is determined by: * VOP::CPU_EXTR_CFG_1.CCM_LM_CPU_QU"), details: Some("'0': No extraction to CPU '1': Extract valid CCM_LM frames to CPU"), lo: 1, hi: 2 });
        fields.insert("DMM_CPU_COPY_ENA", Field { brief: Some("If asserted all valid DMM PDUs received by the VOE are extracted to the CPU. Extraction queue is determined by: * VOP::CPU_EXTR_CFG.DMM_CPU_QU"), details: Some("'0': No extraction to CPU '1': Extract valid DMM frames to CPU"), lo: 5, hi: 6 });
        fields.insert("DMR_CPU_COPY_ENA", Field { brief: Some("If asserted all valid DMR PDUs by the VOE are extracted to the CPU. Extraction queue is determined by: * VOP::CPU_EXTR_CFG.DMR_CPU_QU"), details: Some("'0': No extraction to CPU '1': Extract valid DMR frames to CPU"), lo: 4, hi: 5 });
        fields.insert("GENERIC_COPY_MASK", Field { brief: Some("This bit field contains 8 bits each of which represent one of the Generic OpCodes. If the bit representing a specific Generic OpCode is asserted, all valid PDUs received by the VOE of that type are extracted to the CPU queue configured in the following field: * VOP::OAM_GENERIC_CFG.GENERIC_OPCODE_CPU_QU"), details: Some("x0x: No CPU copy x1x: Copy to CPU"), lo: 14, hi: 22 });
        fields.insert("LBM_CPU_COPY_ENA", Field { brief: Some("If asserted all valid LBM PDUs received by the VOE are extracted to the CPU. Extraction queue is determined by: * VOP::CPU_EXTR_CFG_1.LBM_CPU_QU"), details: Some("'0': No extraction to CPU '1': Extract valid LBM frames to CPU"), lo: 7, hi: 8 });
        fields.insert("LBR_CPU_COPY_ENA", Field { brief: Some("If asserted all valid LBR PDUs received by the VOE are extracted to the CPU. Extraction queue is determined by: * VOP::CPU_EXTR_CFG_1.LBR_CPU_QU This setting is also used to control extraction of SAM_SEQ frames (see VOP:VOE_CONF:SAM_NON_OAM_SEQ_CFG.*)"), details: Some("'0': No extraction to CPU '1': Extract valid LBR frames to CPU"), lo: 6, hi: 7 });
        fields.insert("LMM_CPU_COPY_ENA", Field { brief: Some("If asserted all valid LMM/SLM PDUs received by the VOE are extracted to the CPU. Extraction queue is determined by: * VOP::CPU_EXTR_CFG.LMM_CPU_QU"), details: Some("'0': No extraction to CPU '1': Extract valid LMM frames to CPU"), lo: 10, hi: 11 });
        fields.insert("LMR_CPU_COPY_ENA", Field { brief: Some("If asserted all valid LMR / SLR / 1SL  PDUs received by the VOE are extracted to the CPU. Extraction queue is determined by: * VOP::CPU_EXTR_CFG.LMR_CPU_QU"), details: Some("'0': No extraction to CPU '1': Extract valid LMR frames to CPU"), lo: 9, hi: 10 });
        fields.insert("LTM_CPU_COPY_ENA", Field { brief: Some("If asserted all valid LTM PDUs received by the VOE are extracted to the CPU. Extraction queue is determined by: * VOP::CPU_EXTR_CFG_1.LT_CPU_QU"), details: Some("'0': No extraction to CPU '1': Extract valid LTM frames to CPU"), lo: 12, hi: 13 });
        fields.insert("LTR_CPU_COPY_ENA", Field { brief: Some("If asserted all valid LTR PDUs received by the VOE are extracted to the CPU. Extraction queue is determined by: * VOP::CPU_EXTR_CFG_1.LT_CPU_QU"), details: Some("'0': No extraction to CPU '1': Extract valid LTR frames to CPU"), lo: 11, hi: 12 });
        fields.insert("PDU_ERR_EXTRACT_CCM_ONLY", Field { brief: Some("The configuration of this bit field influences the following PDU error verification: RX: ---------- * RX_MEL_LOW * DMAC_RX_ERR * PDU_VERSION_RX_ERR TX: -------------- * TX_BLOCK_ERR The checks mentioned above will be done for all PDU types, however the associated sticky bit assertion and extraction of PDUs will depend on the setting of this register."), details: Some("0: Assert sticky bit and extract PDU for all PDU types. 1: Assert sticky bit and extract PDU only for CCM(-LM) frames."), lo: 0, hi: 1 });
        fields.insert("SDM_CPU_COPY_ENA", Field { brief: Some("If asserted all valid 1DM PDUs received by the VOE are extracted to the CPU. Extraction queue is determined by: * VOP::CPU_EXTR_CFG.DMR_CPU_QU (This PDU type reuses the DMR extraction queue)"), details: Some("'0': No extraction to CPU '1': Extract valid 1DM frames to CPU"), lo: 3, hi: 4 });
        fields.insert("TST_CPU_COPY_ENA", Field { brief: Some("If asserted all valid TST PDUs received by the VOE are extracted to the CPU. Extraction queue is determined by: * VOP::CPU_EXTR_CFG_1.TST_CPU_QU"), details: Some("'0': No extraction to CPU '1': Extract valid TST frames to CPU"), lo: 8, hi: 9 });
        fields.insert("UNK_OPCODE_CPU_COPY_ENA", Field { brief: Some("Configures whether OAM PDUs with UNKNOWN opcode should be extracted to the CPU. Extracted frames are extracted to the default CPU queue, configured in: * VOP::CPU_EXTR_CFG.DEF_COPY_QU"), details: Some("'0': No CPU copy '1': Copy to CPU"), lo: 13, hi: 14 });
        regs.insert("OAM_CPU_COPY_CTRL", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("CPU extraction for the supported OAM PDU OpCodes."), details: Some("Configures CPU copy for the supported OAM PDU OpCodes. Configuring a PDU type for CPU extraction, will result in all valid OAM PDUs of this type to extracted to the CPU. Invalid OAM PDUs are not extracted. OAM PDUs are considered invalid if they fail either of the following checks: * MEL check (Must match the VOE) * MAC check * CCM validation (CCM/CCM-LM frames only) * SynLM check fails (SLM/SLR/1SL) Frames extracted by asserting this bit field are extracted to the destination queues configured of the VOP: * VOP::CPU_EXTR_CFG.* * VOP::CPU_EXTR_CFG_1.*"), fields });
        let mut fields = HashMap::new();
        fields.insert("CCM_ENA", Field { brief: Some("Enable HW processing of valid CCM PDUs received by the VOE in both the Tx and the Rx direction."), details: None, lo: 1, hi: 2 });
        fields.insert("CCM_LM_ENA", Field { brief: Some("Enable HW processing of valid CCM-LM PDUs received by the VOE in both the Tx and the Rx direction. CC-LM is only supported on the priority configured in the following priority: * VOP:VOE_CONF:CCM_CFG.CCM_PRIO If an Rx CCM PDU is received on another priority than this, statistics are updated as if it was a CCM-LM PDU, but no values are sampled for use in the Tx direction: * CCM-LM.TX_FC_F * FC LM Rx counter when the CCM-LM frame was received These values are sampled for valid CCM-LM PDUs received on the correct priority. The result of the priority test for the latest valid Rx CCM-LM PDU is stored: * VOP:VOE_STAT:CCM_RX_LAST.CCM_PRIO_ERR Note: CCM_ENA must be asserted when asserting CCM_LM_ENA"), details: None, lo: 0, hi: 1 });
        fields.insert("DMM_ENA", Field { brief: Some("Enable HW processing of valid DMM PDUs received by the VOE in both the Tx and the Rx direction."), details: None, lo: 4, hi: 5 });
        fields.insert("DMR_ENA", Field { brief: Some("Enable HW processing of valid DMR PDUs received by the VOE in both the Tx and the Rx direction."), details: None, lo: 3, hi: 4 });
        fields.insert("LBM_ENA", Field { brief: Some("Enable HW processing of valid LBM PDUs received by the VOE in both the Tx and the Rx direction."), details: None, lo: 7, hi: 8 });
        fields.insert("LBR_ENA", Field { brief: Some("Enable HW processing of valid LBR PDUs received by the VOE in both the Tx and the Rx direction."), details: None, lo: 6, hi: 7 });
        fields.insert("LBR_TLV_CRC_VERIFY_ENA", Field { brief: Some("Assertion of this bit field requires LBR_ENA to be asserted. If this bit field is asserted, the incoming LBR PDUs will be checked for having a TLV of type = \"Test TLV\" (Type= 32). If the TLV Test PDU includes a CRC-32 field, the CRC is calculated across the Data Pattern, and the CRC-32 field is verified. The number of Test TLV with CRC-32 error is counted in: * VOP:VOE_CRC_ERR:LBR_CRC_ERR_CNT.LBR_CRC_ERR_CNT Note: The Test TLV must be the first TLV in the received LBR PDU. In case several Test TLVs are present in the same PDU, only the first is checked for CRC. Note: This should not be enabled at the same time as: * TST_TLV_CRC_VERIFY_ENA (The TST and LBM/LBR are expected to mutually exclusive, hence they will use the same TLV_CRC_ERR counter)"), details: None, lo: 5, hi: 6 });
        fields.insert("LMM_ENA", Field { brief: Some("Enable HW processing of valid LMM/SLM PDUs received by the VOE in both the Tx and the Rx direction."), details: None, lo: 11, hi: 12 });
        fields.insert("LMR_ENA", Field { brief: Some("Enable HW processing of valid LMR/SLR/1SL PDUs received by the VOE in both the Tx and the Rx direction."), details: None, lo: 10, hi: 11 });
        fields.insert("SDM_ENA", Field { brief: Some("Enable HW processing of valid 1DM PDUs received by the VOE in both the Tx and the Rx direction."), details: None, lo: 2, hi: 3 });
        fields.insert("TST_ENA", Field { brief: Some("Enable HW processing of valid TST PDUs received by the VOE in both the Tx and the Rx direction."), details: None, lo: 9, hi: 10 });
        fields.insert("TST_TLV_CRC_VERIFY_ENA", Field { brief: Some("Assertion of this bit field requires TST_ENA to be asserted. If this bit field is asserted, the incoming TST PDUs will be checked for having a TLV of type = \"Test TLV\" (Type= 32). If the TLV Test PDU includes a CRC-32 field, the CRC is calculated across the Data Pattern, and the CRC-32 field is verified. The number of Test TLV with CRC-32 error is counted in: * VOP:VOE_CRC_ERR:LBR_CRC_ERR_CNT.LBR_CRC_ERR_CNT Note: The Test TLV must be the first TLV in the received TST PDU. In case several Test TLVs are present in the same PDU, only the first is checked for CRC. Note: This should not be enabled at the same time as: * LBR_TLV_CRC_VERIFY_ENA (The TST and LBM/LBR are expected to mutually exclusive, hence they will use the same TLV_CRC_ERR counter)"), details: None, lo: 8, hi: 9 });
        regs.insert("OAM_HW_CTRL", Register { addr: Address { base: 12, count: 1, width: 1 }, brief: Some("OAM HW processing control"), details: Some("Configures per OAM OpCode if it is processed by the VOE. If an OAM PDU type is not enabled in this register, the OAM PDU will not be updated by the VOE. This allows the PDU processing to be done in SW. OAM PDU statistics are updated regardless of this setting. When OAM PDU is disabled, the following functions are still performed by the VOE: * Generic Y.1731 frame validation: MEL filtering, DMAC check. No PDU specific filtering (CCM only) * The Rx sticky bits will be set for a PDU. * OAM PDUs can be extracted to the CPU. * OAM PDUs can be counted as data. * OAM PDUs specific counters are updated. Further TST / LBR Test TLV CRC can be enabled, using the following bit fields: * TST_TLV_CRC_VERIFY_ENA * LBR_TLV_CRC_VERIFY_ENA"), fields });
        let mut fields = HashMap::new();
        fields.insert("PATH_VOEID", Field { brief: Some("Assigns a Path VOE to the VOE. Must be enabled by: PATH_VOE_ENA = 1"), details: Some("Index of the Path VOE. Must point to a VOE in the pool of Service VOEs (0-255)"), lo: 0, hi: 10 });
        fields.insert("PATH_VOE_ENA", Field { brief: Some("Configures if a service VOE is part of a path VOE."), details: None, lo: 10, hi: 11 });
        regs.insert("PATH_VOE_CFG", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Path MEP configuration"), details: Some("The VOE supports hierarchical LM counting. This implies that when a VOE is processing a frame, it can update the LM counter of the VOE configured at the Server Layer, if a Server Layer exists. Within the scope of the register list, a VOE configured at the Server Layer is referred to as Path VOE. This register is used to assign a Path VOE to the current service VOE. Port VOEs are considered as Server Layer VOEs per default, and can not be assigned at Path VOEs. Assigning a Path VOE to the VOE implies that all frames received by this VOE, will also be counted by the Path VOE indicated by the following register: * PATH_VOEID The path VOE must be enabled by asserting the following field: * PATH_VOE_ENA Note, that the VOE assigned as Path VOP must be enabled for Path VOE operation: * VOP:VOE_CONF:VOE_CTRL.VOE_IS_PATH"), fields });
        let mut fields = HashMap::new();
        fields.insert("GENERIC_VOE_PASS_ENA", Field { brief: Some("Each of the bits in the register represents a Generic OpCode. See: VOP::OAM_GENERIC_CFG.* When asserting a bit in the register, the corresponding Generic OpCode will be allowed to pass though VOE, rather than be terminated, when received at the same MEL as is configured for the VOE. This can be used to allow e.g. Ring PDUs to be copied and to pass transparently through the VOE."), details: None, lo: 0, hi: 8 });
        regs.insert("PDU_VOE_PASS", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Allow PDUs to pass through the VOE."), details: Some("Standard Y.1731 MEL filtering requires a MEP to terminate / block all OAM PDUs received at the samel level as configured for the MEP. It is default behavior for the VOE to implement this MEL filtering. This behavior can be altered for generic OpCodes by asserting this bit."), fields });
        let mut fields = HashMap::new();
        fields.insert("PEER_MEPID", Field { brief: Some("See register description."), details: None, lo: 0, hi: 16 });
        regs.insert("PEER_MEPID_CFG", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Configuration of CCM MEPID"), details: Some("Configures 16 bit MEP ID of the peer MEP. This value is used for two purposes: CCM(-LM): -------------------------- This value is verified against incoming CCM(-LM) frames. In case MEP ID verification is enabled (VOP:VOE_CONF:CCM_CFG.CCM_MEPID_CHK_ENA = 1) the value of the CCM.MEPID field of incoming CCM/CCM-LM frames will be verified against the value configured in this register. If there is a mismatch, the following bit will be asserted: * VOP:VOE_STAT:CCM_RX_LAST.CCM_MEPID_ERR When the above bit changes value, the VOE optionally generates an interrupt. LBM / LBR TLV verification (G.8113.1 OAM) ----------------------------------------------------------------------- The peer MEP ID is used to verify the MEP ID contained in the Rx LBM'Target MEP / MIP ID' / LBR 'Replying MEP / MIP ID TLV."), fields });
        let mut fields = HashMap::new();
        fields.insert("PER_COSID_CCM", Field { brief: Some("Enable SAM per COSID sequence numbering for the following PDUs * CCM(-LM) This bit field MUST not be asserted at the same time as: PER_COSID_LBM When SAM per COSID sequence numbering is enabled, the VOE will use the SAM counter set configured in: * PER_COSID_CNT_SET"), details: None, lo: 5, hi: 6 });
        fields.insert("PER_COSID_CNT_SET", Field { brief: Some("When per COSID sequence numbering is enabled by asserting one of the following bitfields, this register selectes which of the per COSID counter sets will be used for per COSID statistics. Per COSID sequence numbering is enabled by asserting one of the following bit fields: * PER_COSID_LBM * PER_COSID_CCM Counters are located in CSR register group: * VOP:SAM_COSID_SEQ_CNT:*"), details: None, lo: 0, hi: 5 });
        fields.insert("PER_COSID_LBM", Field { brief: Some("Enable SAM per COSID sequence numbering for the following PDUs * TST * LBM/LBR * non OAM sequence numbering (see VOP:VOE_CONF:SAM_NON_OAM_SEQ_CFG.*) Note that the above PDUs are mutually exclusive. This bit field MUST not be asserted at the same time as: PER_COSID_CCM When SAM per COSID sequence numbering is enabled, the VOE will use the SAM counter set configured in: * PER_COSID_CNT_SET"), details: None, lo: 6, hi: 7 });
        regs.insert("SAM_COSID_SEQ_CFG", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("SAM per COSID sequence numbering"), details: Some("As per default, the VOE will use a single sequence number across all COSIDs for each of the following PDU types: * CCM * LBM/LBR, TST or SAM_SEQ (mutually exclusive) Additionally the VOP includes 32 counter sets which can be used for SAM per COSID sequence numbering of the following PDU types: * CCM * LBM/LBR, TST or SAM_SEQ (mutually exclusive) This register is used to configure the VOE for per COSID sequence numbering by assigning one of the SAM per COSID counter sets to the VOE. The per COSID sequence numbering is implemented by using the corresponding register in the VOE to count priority 7, while the remaining priorities (0-6) are counted using a dedicated RAM. The SAM per COSID counters (prio: 0 - 6) are located in: * VOP:SAM_COSID_SEQ_CNT NOTE: The appointed per COSID counter set can be used for either LBM/LBR/TST or CCM, hence only one of the below registers may be asserted. * PER_COSID_LBM * PER_COSID_CCM Asserting both is a misconfiguration. When per COSID sequence numbering is enabled, the VOE will use the counter set configured in: * PER_COSID_CNT_SET"), fields });
        let mut fields = HashMap::new();
        fields.insert("SAM_SEQ_INIT", Field { brief: Some("Asserting this bit will configure the VOE as initiator of non OAM frames with sequence number (SAM_SEQ). This must NOT be asserted at the same time as asserting: * SAM_SEQ_RESP = 1"), details: None, lo: 9, hi: 10 });
        fields.insert("SAM_SEQ_OFFSET_SEQ_NO", Field { brief: Some("This configures the 16-bit offset to the sequence number to be updates within the non OAM frame (SAM_SEQ). For Ethernet frames this field MUST be programmed a value no less than 2 bytes (register value = 1), to avoid overwriting the EPID field. For UDP frames this field MUST be programmed a value no less than 8 bytes (register value =4), to avoid overwriting the UDP protocol information. The valid values are: ETH: 1 - 33 IPv4/IPv6: 4 - 33 The sequence number in the PDU MUST be located within the first CELL of the frame on the cell bus (JR2 cell size=176 bytes, incl. 28 bytes of IFH). This implies that in case of a long encapsulation (e.g. IPv6 over ETH over MPLS over ETH) there will be an upper limit to the valid value of the offset value."), details: Some("0: Illegal value 1,2,3: Offset = 2,4,6 bytes (Legal for Ethernet, NOT legal for IPv4/IPv6) 4 ....: Offset = 8 .... bytes (Legal for Ethernet and IPv4 / IPv6)"), lo: 2, hi: 8 });
        fields.insert("SAM_SEQ_RESP", Field { brief: Some("Asserting this bit will configure the VOE as responder of non OAM frames with sequence number (SAM_SEQ). This must NOT be asserted at the same time as asserting: * SAM_SEQ_INIT = 1"), details: None, lo: 8, hi: 9 });
        fields.insert("SAM_SEQ_RX_ERR_CNT_ENA", Field { brief: Some("Asserting this bitfield requires: * SAM_SEQ_INIT = 1 When the Initiator function receives non OAM frames with sequence numbers, it can count either: 1) Number of frames received with FORWARD-SEQ-NUMBER-ERROR = 1 2) Number of frames received where the sequence number does not match the sequence number received in the previous frame + 1. Frames 1) are always counted. If SAM_SEQ_RX_ERR_CNT_ENA = 1 also frames 2) will be counted. The configuration of this bit also determines which frames frames will assert the sticky bit: * VOP:VOE_STAT:OAM_RX_STICKY.LBR_TRANSID_ERR_STICKY and be extracted to the CPU based on the following configuration: * VOP:VOE_STAT:PDU_EXTRACT.SAM_RX_SEQ_ERR_EXTR"), details: Some("0: Count only Rx SAM_SEQ frames with FORWARD-SEQ-NUMBER-ERROR = 1 1: Count Rx SAM_SEQ frames with FORWARD-SEQ-NUMBER-ERROR = 1 or with unexpected sequence number."), lo: 0, hi: 1 });
        fields.insert("SAM_SEQ_UPD_CHKSUM", Field { brief: Some("If the non OAM frames are IP/UDP frames, the VOE must update not only the sequence number but also the UDP checksum correction field, to avoid altering the UDP checksum. For this to happen, this register must be asserted."), details: Some("0: Do not update the UDP checksum correction field 1: Update the UDP checksum correction field to avoid changing the UDP checksum, when updating the SAM_SEQ frame (Sequence number / FORWARD-SEQ-NUM-ERROR)"), lo: 1, hi: 2 });
        regs.insert("SAM_NON_OAM_SEQ_CFG", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Support for SAM sequence numbering of non OAM frames."), details: Some("The VOE can be configured to support sequence numbering of non OAM frames. This can be used for testing as specified in SAM or RFC2544 etc. Note that the configuring support for sequence numbering of non OAM frames excludes the use of the following PDU types for this VOE: * TST * LBM * LBR This is because the statistics used to support non OAM sequence numbering re-uses the registers otherwise used for processing the above PDUs. This functionality is referred to as SAM_SEQ."), fields });
        let mut fields = HashMap::new();
        fields.insert("SLM_PRIO", Field { brief: Some("The VOE supports only a single priority (COSID) when configured for SynLM. If the frame priority of Tx / Rx SynLM PDUs processed by the VOE does not match the configured value, the frame is considered to be invalid."), details: None, lo: 0, hi: 3 });
        regs.insert("SLM_CONFIG", Register { addr: Address { base: 29, count: 1, width: 1 }, brief: Some("Configurations for Synthetic Loss Measurements"), details: Some("This register contains miscellaneous configurations for Synthetic Loss Measurement."), fields });
        let mut fields = HashMap::new();
        fields.insert("SLM_PEER_ENA", Field { brief: Some("If enabled, SLM_PEER_MEPID contains a valid MEPID"), details: None, lo: 0, hi: 1 });
        fields.insert("SLM_PEER_MEPID", Field { brief: Some("MEPID used to identify the peer MEP from which the SL PDU is received / to which the SL PDU is sent. Only valid if SLM_PEER_ENA = 1"), details: None, lo: 1, hi: 14 });
        regs.insert("SLM_PEER_LIST", Register { addr: Address { base: 31, count: 8, width: 1 }, brief: Some("A list of the MEPIDs with which SLM is supported."), details: Some("This list can be programmed with up to 8 MEPIDs which identify the peer MEPs which are part of the SynLM session. When a SynLM PDU is processed by the VOE, the VOE will match the MEPID of the peer MEP (found in the SynLM PDU). If a match is found, the VOE will use the index of the row which matches the MEPID to identify which peer MEP the frame is sent to / received from. This index is used when updating the Rx / Tx LM counters for a VOE which is enabled for SynLM."), fields });
        let mut fields = HashMap::new();
        fields.insert("SLM_TEST_ID", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("SLM_TEST_ID", Register { addr: Address { base: 30, count: 1, width: 1 }, brief: Some("SynLM Initiator Test ID"), details: Some("A SynLM session is identified by a SynLM Test ID. The VOE supports a single Test ID for each Initiator function. The Initiator function will validate the Test ID of incoming SLR PDUs. If the Test ID of the incoming SLR PDU doest not match the value configured in this register, the frame will be considered invalid and the following sticky bit is asserted: * VOP:VOE_STAT:OAM_RX_STICKY2.RX_SLM_TESTID_ERR_STICKY The VOE will not verify the Test ID in incoming PDUs when acting as a Remote MEP."), fields });
        let mut fields = HashMap::new();
        fields.insert("LBM_UPDATE_ENA", Field { brief: Some("If asserted, the transaction ID will be updated for valid LBM frames transmitted by this VOE. This can be used to avoid overwriting the Tx ID for externally generated LBM frames."), details: None, lo: 1, hi: 2 });
        fields.insert("TST_UPDATE_ENA", Field { brief: Some("If asserted, the transaction ID will be updated for valid TST frames transmitted by this VOE. This can be used to avoid overwriting the Tx ID for externally generated TST frames."), details: None, lo: 0, hi: 1 });
        regs.insert("TX_TRANSID_UPDATE", Register { addr: Address { base: 15, count: 1, width: 1 }, brief: Some("Configures updating sequence numbers / transactions ID (TX)"), details: Some("The configuration in this register group determines whether the VOE will update the sequence number / transaction ID for valid Tx frames."), fields });
        let mut fields = HashMap::new();
        fields.insert("BLOCK_DATA_RX", Field { brief: Some("Asserting this bit will block all Rx frames not processed or blocked by MEL filtering in the VOE. This blocking will not interfer with OAM PDU's processed or MEL filtered by the VOE, but it will block all service frames in the Rx direction. The following frames will be blocked: * OAM PDU's with MEL_HIGH * Data frames Frames discarded by this blocking will counted in the following counter: * VOP:VOE_STAT:RX_OAM_DISCARD.RX_FRM_DISCARD_CNT Frames blocked by this functionality will be counted as part of the LM Rx counters."), details: None, lo: 2, hi: 3 });
        fields.insert("BLOCK_DATA_TX", Field { brief: Some("Asserting this bit will block all Tx frames not blocked by MEL filtering in the VOE. It will not affect PDU's injected into the VOE. This blocking will not interfer with OAM PDU's processed or MEL filtered by the VOE, but it will block all service frames in the Tx direction. The following frames will be blocked: * OAM PDU's with MEL_HIGH * Data frames Frames discarded by this blocking will counted in the following counter: * VOP:VOE_STAT:TX_OAM_DISCARD.TX_FRM_DISCARD_CNT Frames blocked by this functionality will not be counted as part of the LM Tx counters."), details: None, lo: 1, hi: 2 });
        fields.insert("BLOCK_MEL_HIGH_RX", Field { brief: Some("When asserted, the VOE will block Y.1731 PDUs with MEL higher than the configured MEP MEL in the Rx direction. This can be used to terminate higher MEL frames when the VOE is located at the border of a MEG domain. This bit should always be enabled when the VOE is configured for G.8113.1 - VOP:VOE_CONF:VOE_CTRL.G_8113_1_ENA"), details: Some("0: Allow Rx PDUs with MEL HIGH to pass the VOE. 1: Block Rx PDUs with MEL HIGH to pass the VOE."), lo: 3, hi: 4 });
        fields.insert("EXTERN_DM_TSTAMP", Field { brief: Some("When asserted, the VOE will assume that an external device updates the Timestamp information in Y.1731 Delay Measurement PDUs (DMM / DMR / 1DM). Hence the VOE will not update the DM PDUs with TS information. The VOE will however, still extract and loop DM PDUs according to VOE configuration."), details: None, lo: 4, hi: 5 });
        fields.insert("G_8113_1_ENA", Field { brief: Some("Assert to configure the VOE for G.8113.1 MPLS OAM. When the VOE is enabled for G.8113.1 it will support : - Verifying the LBM / LBR MEP ID TLVs - Disabling the MEL CHECK When the VOE is enabled for G.8113.1 it will NOT support: - Validation of TST TLVs for Rx LBR / TST PDUs When the VOE is configured for G.8113.1 the blocking of Rx OAM PDUs with MEL HIGH should always be enabled: * VOP:VOE_CONF:VOE_CTRL.BLOCK_MEL_HIGH_RX"), details: Some("0: VOE processes according to Y.1731 (Ethernet OAM) 1: VOE processes according to G.8113.1 (MPLS OAM)"), lo: 9, hi: 10 });
        fields.insert("MEL_VAL", Field { brief: Some("This register configures the MEL value for the VOE, used for Y.1731 MEL filtering. PDUs passing the VOE with MEL above this MEL_VAL will be treated as data. PDUs passing the VOE with MEL below this MEL_VAL will be discarded. PDUs passing the VOE with MEL equal to this MEL_VAL are optionally processed by the VOE / copied to CPU. The processing of OAM PDUs with a MEL value equal to the VOE MEL_VAL depends on the following: * If the PDU was inserted by the CPU * If the PDU type is enabled for processing by the VOE * If the PDU is received on the Active or Passive side of the VOE."), details: None, lo: 11, hi: 14 });
        fields.insert("RX_DMAC_CHK_SEL", Field { brief: Some("Configures the DMAC check performed when received from the peer MEP. This check can be disabled for Generic OpCodes. See VOP::OAM_GENERIC_CFG.GENERIC_DMAC_CHK_DIS In case of MPLS-TP encapsulated frames, the check is performed on the Customer DMAC (Inner DMAC) If DMAC check fails, the frame is discarded. The following sticky bit is asserted when the VOE receives an OAM PDU which fails the DMAC check: * VOP:VOE_STAT:OAM_RX_STICKY.DMAC_RX_ERR_STICKY"), details: Some("VOE configured as MEP: 0: No DMAC check 1: Check DMAC against MEP_UC_MAC_MSB and MEP_UC_MAC_LSB 2: Check DMAC against MEP_MC_MAC_MSB and MEP_MC_MAC_LSB 3: Check DMAC against either MEP_UC_MAC_MSB and MEP_UC_MAC_LSB or MEP_MC_MAC_MSB and MEP_MC_MAC_LSB"), lo: 6, hi: 8 });
        fields.insert("SAT_TEST_VOE", Field { brief: Some("Configure the current VOE to be used as SAT test VOE. When the VOE is used as SAT test VOE, the OAM frames being processed by the VOE must be counted in the egress statistics, which is not the default VOE behavior."), details: Some("0: Configure as standard VOE 1: Configure as SAT test VOE"), lo: 0, hi: 1 });
        fields.insert("UPMEP_ENA", Field { brief: Some("Configures VOE for Down-MEP or Up-MEP operation. NOTE: Port VOE may NOT be configured for Up-MEP functionality, they only support Down-MEP implementation."), details: Some("0: Configure VOE for Down-MEP functionality. 1: Configure VOE for Up-MEP functionality."), lo: 10, hi: 11 });
        fields.insert("VERIFY_VERSION_ENA", Field { brief: Some("On reception of an OAM PDU in the Rx direction, the VOE will verify that the Y.1731 version number in the OAM PDU header is valid according to the configured valid versions: - VOP::VERSION_CTRL.* - VOP::VERSION_CTRL_2.* The VERSION is verified for all but GENERIC and UNKNOWN PDUs, since these are not processed by the VOE. This bit field can disable the VERSION verification as part of the Rx verification. If the VERSION verification fails, the following sticky bit is asserted: * VOP:VOE_STAT:OAM_RX_STICKY.PDU_VERSION_RX_ERR_STICKY OAM PDUs which fail the version check can optionally be extracted using the following configuration bit: * VOP:VOE_STAT:PDU_EXTRACT.PDU_VERSION_RX_ERR_EXTR"), details: None, lo: 5, hi: 6 });
        fields.insert("VOE_ENA", Field { brief: Some("Enables VOE functionality. When the VOE is not enabled, it will not do any OAM processing or update statistics. The VOE can be configured while not enabled."), details: Some("0: Disable VOE 1: Enable VOE for MEP processing of OAM PDUs."), lo: 14, hi: 15 });
        fields.insert("VOE_IS_PATH", Field { brief: Some("If another VOE is pointing to this VOE as a Path VOE using the following configuration: * VOP:VOE_CONF:PATH_VOE_CFG.PATH_VOEID * VOP:VOE_CONF:PATH_VOE_CFG.PATH_VOE_ENA this register MUST be set to '1'. If not this register must be set to '0'."), details: Some("'0': This VOE is not configured as PATH VOE in another VOE. '1': This VOE is configured as PATH VOE in another VOE."), lo: 8, hi: 9 });
        regs.insert("VOE_CTRL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Misc. VOE control configuration"), details: Some("This register includes configuration of misc. VOE properties."), fields });
        let mut fields = HashMap::new();
        fields.insert("VOE_MEPID", Field { brief: Some("See register description."), details: None, lo: 0, hi: 16 });
        regs.insert("VOE_MEPID_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("VOE MEPID"), details: Some("The MEPID of the VOE. This is currently only used for SLM and LBM / LBR TLV verification (G.8113.1 only)."), fields });
        let mut fields = HashMap::new();
        fields.insert("LM_CNT_BYTE", Field { brief: Some("If this field is asserted, the VOE will count bytes instead of frames. This is not 100% supported and tested. Feature is only available for Service / Path VOEs. Byte count is disabled for Port VOEs."), details: None, lo: 1, hi: 2 });
        fields.insert("MPLS_OAM_ENA", Field { brief: Some("The VOE will process either Y.1731 or MPLS OAM PDUs depending on the configuration of this register. To enable a specific VOE for MPLS OAM processing, the corresponding bit in this register must be asserted."), details: Some("'0': VOE is configured to process Y.1731 OAM PDUs '1': VOE is configured to process MPLS-TP OAM PDUs"), lo: 2, hi: 3 });
        fields.insert("SL_ENA", Field { brief: Some("Enable the VOE for Synthetic Loss Measurements. If enabled, the normal LM counters are used differently than when running standard frame loss measurements. The Rx counters are used to count SLR/SL1 frames received from different Peer MEPs. The Tx counters are used to count SLR/SL1 frames transmitted to different Peer MEPs. Note that there is no counting of data frames or other NON SL OAM PDUs. Asserting this register will avoid any other VOEs from updating the LM counters of this VOE as part of a hierarchical LM counter update."), details: None, lo: 0, hi: 1 });
        regs.insert("VOE_MISC_CONFIG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Miscellanous per VOE configuration"), details: Some("Miscellaneous per VOE configuration."), fields });
        groups.insert("VOE_CONF", RegisterGroup { addr: Address { base: 0, count: 1077, width: 64 }, desc: "Configuration per Vitesse OAM MEP Endpoints (VOE) for Y.1731 OAM", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("MEP_MC_MAC_MSB", Field { brief: Some("See register description."), details: None, lo: 0, hi: 16 });
        regs.insert("COMMON_MEP_MC_MAC_MSB", Register { addr: Address { base: 75, count: 1, width: 1 }, brief: Some("VOP Multicast MAC address configuration (MSB)"), details: Some("Each VOE can be addressed using either a common Multicast MAC address or a VOE specific Unicast MAC address. This register configures the Multicast Address common to all the VOEs. The full MAC address is a concatenation of the folliowing registers: 1) VOP::COMMON_MEP_MC_MAC_LSB 2) VOP::COMMON_MEP_MC_MAC_MSB The default value of this register is determined by 802.1ag. The DMAC check to be performed for each VOE is configured in the following bit field: VOP:VOE_CONF:VOE_CTRL.RX_DMAC_CHK_SEL Note that only the upper 44 bits are matched, since the lower 4 bits of the DMAC address contain the MEG level."), fields });
        groups.insert("VOE_CONF_REG", RegisterGroup { addr: Address { base: 79872, count: 1077, width: 1 }, desc: "VOE configuration registers", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CT_IF_STATUS_VALUE_ANA", Field { brief: None, details: None, lo: 0, hi: 3 });
        fields.insert("CT_IF_STATUS_VLD_ANA", Field { brief: None, details: None, lo: 3, hi: 4 });
        fields.insert("CT_PORT_STATIS_VALUE_ANA", Field { brief: None, details: None, lo: 4, hi: 6 });
        fields.insert("CT_PORT_STATUS_VLD_ANA", Field { brief: None, details: None, lo: 6, hi: 7 });
        regs.insert("CT_CCM_TLV_INFO_ANA", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Contains info om G.8113.1 LBM/LBR TLVs"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CT_OAM_MISC_REW", Field { brief: None, details: None, lo: 0, hi: 32 });
        regs.insert("CT_OAM_DATA1_REW", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Context data"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CT_OAM_SEQ_ANA", Field { brief: Some("Context register containing Sequence Number or Transaction ID"), details: None, lo: 0, hi: 32 });
        regs.insert("CT_OAM_DATA_ANA", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Analyzer context data"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CT_BLOCK_DATA_ANA", Field { brief: None, details: None, lo: 7, hi: 8 });
        fields.insert("CT_CCM_LM_AS_SEL_ANA", Field { brief: None, details: None, lo: 8, hi: 9 });
        fields.insert("CT_CHK_SEQ_ANA", Field { brief: None, details: None, lo: 11, hi: 12 });
        fields.insert("CT_ENTRY_VALID_ANA", Field { brief: Some("[MCC_DEBUG]"), details: None, lo: 30, hi: 31 });
        fields.insert("CT_FRAME_PRIO_ANA", Field { brief: None, details: None, lo: 4, hi: 7 });
        fields.insert("CT_LOOKUP_TYPE_ANA", Field { brief: Some("[MCC_DEBUG]"), details: Some("0: OAM Frame is TX 1: OAM Frame is RX"), lo: 26, hi: 30 });
        fields.insert("CT_NON_OAM_ERR_CNT_ANA", Field { brief: None, details: None, lo: 3, hi: 4 });
        fields.insert("CT_NON_OAM_FWD_ERR_ANA", Field { brief: None, details: None, lo: 2, hi: 3 });
        fields.insert("CT_OAM_GEN_IDX_ANA", Field { brief: None, details: None, lo: 18, hi: 21 });
        fields.insert("CT_OAM_PDU_ANA", Field { brief: Some("[MCC_DEBUG] OAM PDU currently being processed"), details: None, lo: 21, hi: 26 });
        fields.insert("CT_OAM_TYPE_ANA", Field { brief: Some("[MCC_DEBUG] OAM type currently being processed"), details: None, lo: 0, hi: 2 });
        fields.insert("CT_SEL_OAM_ANA", Field { brief: Some("Determines if the PDU is to be counted as Selected OAM or NON Selected OAM."), details: Some("0: Count as NON Selected OAM 1: Count as Selected OAM"), lo: 9, hi: 10 });
        fields.insert("CT_SRC_PORT_ANA", Field { brief: Some("[MCC_DEBUG] Source port."), details: None, lo: 12, hi: 18 });
        fields.insert("CT_UPD_SEQ_ANA", Field { brief: Some("[MCC_DEBUG]"), details: None, lo: 10, hi: 11 });
        regs.insert("CT_OAM_INFO_ANA", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("[MCC_DEBUG] Context for ports on the ANA interface"), details: Some("[MCC_DEBUG] Tx LM frame counters  by VOE."), fields });
        let mut fields = HashMap::new();
        fields.insert("CT_CCM_NONZERO_ENDTLV_ANA", Field { brief: None, details: None, lo: 18, hi: 19 });
        fields.insert("CT_CCM_PERIOD_ERR_ANA", Field { brief: Some("[MCC_DEBUG] PDU was correctly validaded by the VOE and is ready to be processed."), details: None, lo: 20, hi: 21 });
        fields.insert("CT_CCM_PRIO_ERR_ANA", Field { brief: Some("[MCC_DEBUG] PDU was correctly validaded by the VOE and is ready to be processed."), details: None, lo: 19, hi: 20 });
        fields.insert("CT_EXTRACT_CAUSE_ANA", Field { brief: Some("[MCC_DEBUG]"), details: None, lo: 13, hi: 18 });
        fields.insert("CT_EXTRACT_QU_ANA", Field { brief: None, details: None, lo: 10, hi: 13 });
        fields.insert("CT_MEL_HIGH_ANA", Field { brief: Some("[MCC_DEBUG]"), details: None, lo: 23, hi: 24 });
        fields.insert("CT_PDU_HW_ENA_ANA", Field { brief: Some("[MCC_DEBUG] PDU was correctly validaded by the VOE and is ready to be processed."), details: None, lo: 21, hi: 22 });
        fields.insert("CT_SAM_SEQ_CCM_ANA", Field { brief: None, details: None, lo: 8, hi: 9 });
        fields.insert("CT_SAM_SEQ_IDX_ANA", Field { brief: None, details: None, lo: 3, hi: 8 });
        fields.insert("CT_SAM_SEQ_LBM_ANA", Field { brief: None, details: None, lo: 9, hi: 10 });
        fields.insert("CT_SYNLM_PEER_IDX_ANA", Field { brief: None, details: None, lo: 0, hi: 3 });
        fields.insert("CT_VALID_PDU_ANA", Field { brief: Some("[MCC_DEBUG] PDU was correctly validaded by the VOE and is ready to be processed."), details: None, lo: 22, hi: 23 });
        regs.insert("CT_OAM_STICKY_ANA", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("[MCC_DEBUG]"), details: Some("[MCC_DEBUG]"), fields });
        groups.insert("VOE_CONTEXT_ANA", RegisterGroup { addr: Address { base: 72704, count: 110, width: 8 }, desc: "[MCC_DEBUG] Contains the context for the VOE if in REW.", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CCM_RX_FCB", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("CCM_RX_FCB_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("CCM-LM Rx LM sample value."), details: Some("This is the value of the Rx LM counter sampled when the latest CCM-LM frame was received. This value must be transmitted as CCM-LM.RX_FCB in the next CCM-LM frame transmitted by this VOE."), fields });
        let mut fields = HashMap::new();
        fields.insert("CT_IF_STATUS_VALUE_REW", Field { brief: None, details: None, lo: 0, hi: 3 });
        fields.insert("CT_IF_STATUS_VLD_REW", Field { brief: None, details: None, lo: 3, hi: 4 });
        fields.insert("CT_PORT_STATIS_VALUE_REW", Field { brief: None, details: None, lo: 4, hi: 6 });
        fields.insert("CT_PORT_STATUS_VLD_REW", Field { brief: None, details: None, lo: 6, hi: 7 });
        regs.insert("CT_CCM_TLV_INFO_REW", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Contains info om G.8113.1 LBM/LBR TLVs"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CT_OAM_SEQ_REW", Field { brief: Some("Context register containing Sequence Number or Transaction ID"), details: None, lo: 0, hi: 32 });
        regs.insert("CT_OAM_DATA_REW", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Context data"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CT_BLOCK_DATA_REW", Field { brief: None, details: None, lo: 7, hi: 8 });
        fields.insert("CT_CCM_LM_AS_SEL_REW", Field { brief: None, details: None, lo: 8, hi: 9 });
        fields.insert("CT_CHK_SEQ_REW", Field { brief: None, details: None, lo: 11, hi: 12 });
        fields.insert("CT_ENTRY_VALID_REW", Field { brief: Some("[MCC_DEBUG]"), details: None, lo: 30, hi: 31 });
        fields.insert("CT_FRAME_PRIO_REW", Field { brief: None, details: None, lo: 4, hi: 7 });
        fields.insert("CT_LOOKUP_TYPE_REW", Field { brief: Some("[MCC_DEBUG]"), details: Some("0: OAM Frame is TX 1: OAM Frame is RX"), lo: 26, hi: 30 });
        fields.insert("CT_NON_OAM_ERR_CNT_REW", Field { brief: None, details: None, lo: 3, hi: 4 });
        fields.insert("CT_NON_OAM_FWD_ERR_REW", Field { brief: None, details: None, lo: 2, hi: 3 });
        fields.insert("CT_OAM_GEN_IDX_REW", Field { brief: Some("Generic index from if the OpCode is generic."), details: None, lo: 18, hi: 21 });
        fields.insert("CT_OAM_PDU_REW", Field { brief: Some("[MCC_DEBUG] OAM PDU currently being processed"), details: None, lo: 21, hi: 26 });
        fields.insert("CT_OAM_TYPE_REW", Field { brief: Some("[MCC_DEBUG] OAM type currently being processed"), details: None, lo: 0, hi: 2 });
        fields.insert("CT_SEL_OAM_REW", Field { brief: Some("Determines if the PDU is to be counted as Selected OAM or NON Selected OAM."), details: Some("0: Count as NON Selected OAM 1: Count as Selected OAM"), lo: 9, hi: 10 });
        fields.insert("CT_SRC_PORT_REW", Field { brief: Some("[MCC_DEBUG] Source port."), details: None, lo: 12, hi: 18 });
        fields.insert("CT_UPD_SEQ_REW", Field { brief: Some("[MCC_DEBUG]"), details: None, lo: 10, hi: 11 });
        regs.insert("CT_OAM_INFO_REW", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("[MCC_DEBUG] Context for ports on the REW interface"), details: Some("[MCC_DEBUG] Tx LM frame counters  by VOE."), fields });
        let mut fields = HashMap::new();
        fields.insert("CT_CCM_NONZERO_ENDTLV_REW", Field { brief: None, details: None, lo: 18, hi: 19 });
        fields.insert("CT_CCM_PERIOD_ERR_REW", Field { brief: Some("[MCC_DEBUG] PDU was correctly validaded by the VOE and is ready to be processed."), details: None, lo: 20, hi: 21 });
        fields.insert("CT_CCM_PRIO_ERR_REW", Field { brief: Some("[MCC_DEBUG] PDU was correctly validaded by the VOE and is ready to be processed."), details: None, lo: 19, hi: 20 });
        fields.insert("CT_EXTRACT_CAUSE_REW", Field { brief: Some("[MCC_DEBUG]"), details: None, lo: 13, hi: 18 });
        fields.insert("CT_EXTRACT_QU_REW", Field { brief: None, details: None, lo: 10, hi: 13 });
        fields.insert("CT_MEL_HIGH_REW", Field { brief: Some("[MCC_DEBUG]"), details: None, lo: 23, hi: 24 });
        fields.insert("CT_PDU_HW_ENA_REW", Field { brief: Some("[MCC_DEBUG] PDU was correctly validaded by the VOE and is ready to be processed."), details: None, lo: 21, hi: 22 });
        fields.insert("CT_SAM_SEQ_CCM_REW", Field { brief: None, details: None, lo: 8, hi: 9 });
        fields.insert("CT_SAM_SEQ_IDX_REW", Field { brief: None, details: None, lo: 3, hi: 8 });
        fields.insert("CT_SAM_SEQ_LBM_REW", Field { brief: None, details: None, lo: 9, hi: 10 });
        fields.insert("CT_SYNLM_PEER_IDX_REW", Field { brief: None, details: None, lo: 0, hi: 3 });
        fields.insert("CT_VALID_PDU_REW", Field { brief: Some("[MCC_DEBUG] PDU was correctly validaded by the VOE and is ready to be processed."), details: None, lo: 22, hi: 23 });
        regs.insert("CT_OAM_STICKY_REW", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("[MCC_DEBUG]"), details: Some("[MCC_DEBUG]"), fields });
        groups.insert("VOE_CONTEXT_REW", RegisterGroup { addr: Address { base: 69120, count: 53, width: 8 }, desc: "[MCC_DEBUG] Contains the context for the VOE if in REW.", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CT_OAM_MISC_ANA", Field { brief: None, details: None, lo: 0, hi: 32 });
        regs.insert("CT_OAM_DATA1_ANA", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Analyzer Context data"), details: None, fields });
        groups.insert("VOE_CRC_ERR", RegisterGroup { addr: Address { base: 81920, count: 1077, width: 1 }, desc: "Count the number of CRC errors in Rx LBR / TST TLVs", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("HMO_CCM_RX_BAD_NXT", Field { brief: Some("If asserted the following 6 bitfields will be asserted every time the VOE matches the current HMO scan: * VOP:VOE_STAT:PDU_EXTRACT.CCM_ZERO_PERIOD_RX_ERR_EXTR * VOP:VOE_STAT:PDU_EXTRACT.RX_MEL_LOW_ERR_EXTR * VOP:VOE_STAT:PDU_EXTRACT.CCM_MEGID_RX_ERR_EXTR * VOP:VOE_STAT:PDU_EXTRACT.CCM_MEPID_RX_ERR_EXTR * VOP:VOE_STAT:PDU_EXTRACT.CCM_PERIOD_RX_ERR_EXTR * VOP:VOE_STAT:PDU_EXTRACT.CCM_PRIO_RX_ERR_EXTR"), details: None, lo: 9, hi: 10 });
        fields.insert("HMO_CCM_RX_CCM_NXT", Field { brief: Some("If asserted the following bit will be asserted every time the VOE matches the current HMO scan: * VOP:VOE_STAT:PDU_EXTRACT.CCM_RX_CCM_NXT_EXTR"), details: None, lo: 11, hi: 12 });
        fields.insert("HMO_CCM_RX_TLV_NON_ZERO", Field { brief: Some("If asserted the following bit will be asserted every time the VOE matches the current HMO scan: * VOP:VOE_STAT:PDU_EXTRACT.CCM_RX_TLV_NON_ZERO_EXTR"), details: None, lo: 10, hi: 11 });
        fields.insert("HMO_EXTRACT_PEER_RX", Field { brief: Some("This value will be written to the following register every time the VOE matches the current HMO scan: * VOP:VOE_STAT:SYNLM_EXTRACT.EXTRACT_PEER_RX"), details: None, lo: 0, hi: 8 });
        fields.insert("HMO_RX_TEST_FRM_NXT", Field { brief: Some("If asserted the following bit will be asserted every time the VOE matches the current HMO scan: * VOP:VOE_STAT:PDU_EXTRACT.RX_TEST_FRM_NXT_EXTR"), details: None, lo: 8, hi: 9 });
        fields.insert("HMO_SLOT", Field { brief: Some("Determines which of the HMO scan timers that is active for this VOE"), details: None, lo: 12, hi: 15 });
        regs.insert("AUTO_HIT_ME_ONCE", Register { addr: Address { base: 20, count: 1, width: 1 }, brief: Some("Auto assertion of Hit Me Once bits."), details: Some("This register configures the VOE for auto Hit-Me-Once (HMO), which allows certain frames to be extracted with regular intervals without CPU interventions. The VOE can be configured to extract certain frames with regular intervals using the 2 HMO scan timers. When a HMO scan is active, the VOE will update the HMO extraction bits which are configured for the active HMO scan, provided that the currenly active HMO SLOT matches the HMO SLOT configured for the VOE. HMO scan timer configuration: * VOP::HMO_TIMER_CFG.* Further the currenly active HMO slot must match: * VOP:VOE_STAT:AUTO_HIT_ME_ONCE.HMO_SLOT If the current HMO scan matches the HMO_SLOT of an active HMO scan, the VOE will assert the HMO extract bits configured for the active HMO scan. See the detailed description in the bit fields descriptions."), fields });
        let mut fields = HashMap::new();
        fields.insert("CCM_RX_MEL_ERR_CNT", Field { brief: Some("Number of CCM(-LM) PDUs received with MEL lower than the MEL configured for the VOE. This counter is updated regardless of the value of: * VOP:VOE_CONF:OAM_HW_CTRL.CCM_ENA"), details: None, lo: 0, hi: 16 });
        regs.insert("CCM_ERR", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("CCM MEL error counter"), details: Some("Counts CCM(-LM) PDUs received with specific CCM errors."), fields });
        let mut fields = HashMap::new();
        fields.insert("CCM_RX_MEGID_ERR_CNT", Field { brief: Some("Number of CCM(-LM) PDUs received at the correct MEL, but failing the MEGID verification."), details: None, lo: 16, hi: 32 });
        fields.insert("CCM_RX_MEPID_ERR_CNT", Field { brief: Some("Number of CCM(-LM) PDUs received at the correct MEL, but failing the MEPID verification."), details: None, lo: 0, hi: 16 });
        regs.insert("CCM_RX_ERR_1", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("CCM error counter"), details: Some("Counts CCM(-LM) PDUs received with specific CCM errors. These counters are only updated when: * VOP:VOE_CONF:OAM_HW_CTRL.CCM_ENA = 1"), fields });
        let mut fields = HashMap::new();
        fields.insert("CCM_RX_INVLD_FC_CNT", Field { brief: Some("Counts number of Rx invalid CCM(-LM) PDUs received by the VOE. Invalid CCM(-LM) PDUs will not clear the CCM_MISS_CNT. Invalid CCM(-LM) PDUs are defined as the CCM(-LM) PDUs which do not pass VOE Rx validation."), details: None, lo: 0, hi: 16 });
        fields.insert("CCM_RX_VLD_FC_CNT", Field { brief: Some("Counts the number of valid Rx OAM CCM PDUs received by the VOE. Valid CCM(-LM) PDUs will clear the CCM_MISS counter."), details: None, lo: 16, hi: 32 });
        regs.insert("CCM_RX_FRM_CNT", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Number of valid / invalid CCM(-LM) PDUs received by the VOE."), details: Some("Counts the number of valid / invalid Rx OAM CCM PDUs received by the VOE. Valid CCM(-LM) PDUs will clear the CCM_MISS counter. Counters are updated regardless of the value of: * VOP:VOE_CONF:OAM_HW_CTRL.CCM_ENA * VOP:VOE_CONF:OAM_HW_CTRL.CCM_LM_ENA"), fields });
        let mut fields = HashMap::new();
        fields.insert("CCM_LOC_DEFECT", Field { brief: Some("Status of current Loss Of Continuity interrupt. This bitfield is asserted by the LOC Controller and deasserted upon reception of a valid CCM(-LM) frame. When the value of this bit field changes, the following sticky bit is asserted: * VOP:VOE_STAT:INTR_STICKY.CCM_LOC_STICKY Optionally the interrupt is asserted."), details: Some("0: No LOC condition exists in VOE. 1: LOC condition exists in VOE."), lo: 3, hi: 4 });
        fields.insert("CCM_MEGID_ERR", Field { brief: Some("If the value of the MEGID field in a CCM(-LM) payload received is different from the MEGID value configured for the VOE, the CCM(-LM) frame is invalid. The MEG ID is configured in: * VOP:VOE_CONF:CCM_MEGID_CFG.CCM_MEGID This register holds the value of the latest MEG ID check performed by the VOE. If the result of the MEG ID check changes, the corresponding sticky bit is asserted: * VOP:VOE_STAT:INTR_STICKY.CCM_MEGID_RX_ERR_STICKY This allows interrupt generation when result of the incoming CCM_MEGID check changes. This check will be done for CCM(-LM) frames only. MEGID checking is enabled by: * VOP:VOE_CONF:CCM_CFG.CCM_MEGID_CHK_ENA = 1 CCM PDUs received by the VOE, which fail the MEG ID verification can optionally be extracted to the CPU using the following bit field: * VOP:VOE_STAT:PDU_EXTRACT.CCM_MEGID_RX_ERR_EXTR Extracted CCM PDUs are extracted to the following CPU queue: * VOP::CPU_EXTR_CFG.CPU_ERR_QU"), details: Some("0: No MEGID error detected in the last valid CCM(-LM) frame received. 1: Detected MEGID error in the last valid CCM(-LM) frame received."), lo: 1, hi: 2 });
        fields.insert("CCM_MEPID_ERR", Field { brief: Some("If the value of the MEPID field in a CCM(-LM) payload received is different from the MEPID value configured for the VOE, the CCM(-LM) frame is invalid. The MEP ID is configured in: * VOP:VOE_CONF:PEER_MEPID_CFG.PEER_MEPID This register holds the value of the latest MEP ID check performed by the VOE. If the result of the MEP ID check changes, the corresponding sticky bit is asserted: * VOP:VOE_STAT:INTR_STICKY.CCM_MEPID_RX_ERR_STICKY This allows interrupt generation when result of the incoming CCM_MEPID check changes. This check will be done for CCM(-LM) frames only. MEP ID check is enabled by setting: VOP:VOE_CONF:CCM_CFG.CCM_MEPID_CHK_ENA = 1 CCM PDUs received by the VOE, which fail the MEP ID verification can optionally be extracted to the CPU using the following bit field: * VOP:VOE_STAT:PDU_EXTRACT.CCM_MEPID_RX_ERR_EXTR Extracted CCM PDUs are extracted to the following CPU queue: * VOP::CPU_EXTR_CFG.CPU_ERR_QU"), details: Some("0: No MEPID error detected in the last valid CCM(-LM) frame received. 1: Detected MEPID error in the last valid CCM(-LM) frame received."), lo: 2, hi: 3 });
        fields.insert("CCM_PERIOD_ERR", Field { brief: Some("For all valid CCM(-LM) frames received by the VOE, the value of the CCM(-LM) PERIOD field is validated against the CCM_PERIOD configured for the VOE: * VOP:VOE_CONF:CCM_CFG.CCM_PERIOD This bit fields reflects the result of this check for the last CCM(-LM) frame received by the VOE. If the value of the CCM_PERIOD check changes, the corresponding STICKY bit is asserted: * VOP:VOE_STAT:INTR_STICKY.CCM_PERIOD_RX_ERR_STICKY This allows interrupt generation when result of the incoming CCM_PERIOD check changes. CCM(-LM) PDUs received by the VOE, which fail the CCM PERIOD verification can optionally be extracted to the CPU using the following bit field: * VOP:VOE_STAT:PDU_EXTRACT.CCM_PERIOD_RX_ERR_EXTR Extracted CCM PDUs are extracted to the following CPU queue: CCM: ----------------------------------- * VOP::CPU_EXTR_CFG_1.CCM_CPU_QU CCM-LM: ----------------------------------- * VOP::CPU_EXTR_CFG_1.CCM_LM_CPU_QU"), details: Some("0: No PERIOD error detected in the last valid CCM(-LM) frame received. 1: Detected PERIOD error in the last valid CCM(-LM) frame received."), lo: 7, hi: 8 });
        fields.insert("CCM_PRIO_ERR", Field { brief: Some("For all valid CCM(-LM) frames received by the VOE, the value of the CCM(-LM) frame priority is validated against the CCM_PRIO configured for the VOE: * VOP:VOE_CONF:CCM_CFG.CCM_PRIO This bit fields reflects the result of this check for the last CCM(-LM) frame received by the VOE. If the value of the CCM_PRIO check changes, the corresponding STICKY bit is asserted: * VOP:VOE_STAT:INTR_STICKY.CCM_PRIO_RX_ERR_STICKY CCM(-LM) PDUs received by the VOE, which fail the CCM PRIORITY verification can optionally be extracted to the CPU using the following bit field: * VOP:VOE_STAT:PDU_EXTRACT.CCM_PRIO_RX_ERR_EXTR CCM: ----------------------------------- * VOP::CPU_EXTR_CFG_1.CCM_CPU_QU CCM-LM: ----------------------------------- * VOP::CPU_EXTR_CFG_1.CCM_LM_CPU_QU"), details: Some("0: No PRIO error detected in the last valid CCM(-LM) frame received. 1: Detected PRIO error in the last valid CCM(-LM) frame received."), lo: 6, hi: 7 });
        fields.insert("CCM_RX_MEL_LOW_ERR", Field { brief: Some("If the MEL value of an Rx OAM PDU is lower than the MEL configured for the VOE, this is an RX_MEL_LOW error. This register holds the result of the latest RX_MEL_LOW verification performed by the VOE for a valid CCM(-LM) PDU. If the RX_MEL_LOW verification fails for a CCM(-LM) PDU, the following sticky bit is asserted: * VOP:VOE_STAT:INTR_STICKY.CCM_RX_MEL_LOW_ERR_STICKY This allows interrupt generation when the result of the incoming RX_MEL_LOW check changes for CCM(-LM) frames. OAM PDUs received by the VOE, which fail the RX_MEL_LOW verification can optionally be extracted to the CPU using the following bit field: * VOP:VOE_STAT:PDU_EXTRACT.RX_MEL_LOW_ERR_EXTR Extracted CCM PDUs are extracted to the following CPU queue: * VOP::CPU_EXTR_CFG.CPU_ERR_QU"), details: Some("0: No Rx MEL LOW error detected in the last valid CCM(-LM) frame received. 1: Detected Rx MEL LOW error in the last valid CCM(-LM) frame received."), lo: 0, hi: 1 });
        fields.insert("CCM_RX_RDI", Field { brief: Some("The value of RDI bit received with the last valid CCM(-LM) frame. When this status changes, the following sticky bit will be asserted: * VOP:VOE_STAT:INTR_STICKY.CCM_RX_RDI_STICKY This allows interrupt generation when the incoming RDI stat changes."), details: Some("0: RDI bit was '0' in the last valid CCM(-LM) frame. 1: RDI bit was '1' in the last valid CCM(-LM) frame."), lo: 4, hi: 5 });
        fields.insert("CCM_RX_SRC_PORT", Field { brief: Some("The source port on which the last CCM(-LM) PDU was received. Can be used for implementing E-Line services over networks using Ethernet Ring protection, without learning the MAC addresses. When the CPU flushes the MAC table, it can instruct the VOE to detect when CCM(-LM) PDUs are received a number of times on the same front port. This register contains the latest front port on which a valid CCM(-LM) PDU was received. The number of consecutive frames recieved on the same port (not counting the first one) are counted by the following counter: * VOP:VOE_STAT:CCM_STAT.CCM_RX_SRC_PORT_CNT When a number of consecutive CCM(-LM) PDUs have been received on the same front port, the following sticky bit is asserted: * VOP:VOE_STAT:INTR_STICKY.CCM_RX_SRC_PORT_DETECT_STICKY This can optionally generate an interrupt. The number of consecutive CCM(-LM) PDUs which must be received on the same front port before asserting the sticky bit is configured in the following bitfield: * VOP::VOP_CTRL.CCM_RX_SRC_PORT_DETECT_CNT"), details: Some("Port number of the last port on which a valid Rx CCM(-LM) PDU was received."), lo: 13, hi: 19 });
        fields.insert("CCM_ZERO_PERIOD_ERR", Field { brief: Some("If the value of the PERIOD field in a CCM(-LM) payload received is ZERO, the CCM(-LM) frame is invalid. The value of the period of all Rx CCM(-LM)  frames, is checked for a non ZERO value. This register holds the value of the latest check performed by the VOE. If the result of the ZERO period check changes, the corresponding sticky bit is asserted: * VOP:VOE_STAT:INTR_STICKY.CCM_ZERO_PERIOD_RX_ERR_STICKY This allows interrupt generation when result of the incoming CCM_ZERO_PERIOD check changes. This check will be done for CCM(-LM) frames only. CCM PDUs received by the VOE, which fail the CCM_ZERO_PERIOD verification can optionally be extracted to the CPU using the following bit field: * VOP:VOE_STAT:PDU_EXTRACT.CCM_ZERO_PERIOD_RX_ERR_EXTR Extracted CCM PDUs are extracted to the following CPU queue: * VOP::CPU_EXTR_CFG.CPU_ERR_QU"), details: Some("0: No ZERO period error detected in the last valid CCM(-LM) frame received. 1: Detected ZERO period error in the last valid CCM(-LM) frame received."), lo: 5, hi: 6 });
        fields.insert("TLV_INTERFACE_STATUS", Field { brief: Some("If a (CCM-LM) frame carries a \"Interface Status TLV\" the value of this TLV is sampled and stored in this  register. When this status changes, the following sticky bit will be asserted: * VOP:VOE_STAT:INTR_STICKY.TLV_INTERFACE_STATUS_STICKY This allows interrupt generation when the value of the incoming \"Interface Status TLV\" changes."), details: None, lo: 8, hi: 11 });
        fields.insert("TLV_PORT_STATUS", Field { brief: Some("If a (CCM-LM) frame carries a \"Port Status TLV\" the value of this TLV is sampled and stored in this  register. When this status changes, the following sticky bit will be asserted: * VOP:VOE_STAT:INTR_STICKY.TLV_PORT_STATUS_STICKY This allows interrupt generation when the value of the incoming \"Port Status TLV\" changes."), details: None, lo: 11, hi: 13 });
        regs.insert("CCM_RX_LAST", Register { addr: Address { base: 26, count: 1, width: 1 }, brief: Some("Misc. CCM(-LM) statistics for the latest Rx frame."), details: Some("This register contains a number of status bits. Each status bit indicates the latest result of a specific check performed on Rx CCM PDUs. Each of the status bits in this register corresponds to a sticky bit in the following register: * VOP:VOE_STAT:INTR_STICKY.* When a status bit this in this register (CCM_RX_LAST) changes its value, the corresponding sticky bit is asserted. The bits in this register are status bits updated by the VOE, and the values should never be altered by the CPU, because they must represent the state of the latest valid CCM PDU. Bit field \"CCM_LOC_DEFECT\" differs from the other bit fields because it is updated not only when a CCM(-LM) PDU is received, but also by the LOC Controller, when a LOC condition is detected."), fields });
        let mut fields = HashMap::new();
        fields.insert("CCM_RX_SEQ", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("CCM_RX_SEQ_CFG", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("Latest Rx CCM Sequence number"), details: Some("This register contains the CCM sequence number of the latest valid CCM(-LM) PDU received  by the VOE. The register is automatically updated upon reception of a valid CCM(-LM) PDU. If Rx CCM sequence number checking is enabled, the expected value of the next CCM(-LM) sequence number is the value contained in this register + 1. Rx CCM sequence number checking is enabled using the following bit field: * VOP:VOE_CONF:CCM_CFG.CCM_SEQ_UPD_ENA"), fields });
        let mut fields = HashMap::new();
        fields.insert("CCM_RX_PERIOD_ERR_CNT", Field { brief: Some("Number of valid CCM(-LM) received with Period error. The Period of the incoming CCM(-LM) PDUs is checked against the following value: * VOP:VOE_CONF:CCM_CFG.CCM_PERIOD"), details: None, lo: 0, hi: 16 });
        fields.insert("CCM_RX_SEQNO_ERR_CNT", Field { brief: Some("Number of valid CCM received with sequence number error. Sequence numbers are counted when the CCM.SequenceNumber of a valid CCM PDU is not equal to the previously received sequence number + 1. The previously received CCM_PDU.SequenceNumber is stored in: * VOP:VOE_STAT:CCM_RX_SEQ_CFG.CCM_RX_SEQ"), details: None, lo: 16, hi: 32 });
        regs.insert("CCM_RX_WARNING", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Number of valid CCM(-LM) received with sequence error"), details: Some("This register contains counters for the following CCM(-LM) PDU warnings: * Sequence Errors * Period Errors These counters are only updated when: * VOP:VOE_CONF:OAM_HW_CTRL.CCM_ENA = 1 Frames included in these frame counts are valid CCM(-LM) PDUs."), fields });
        let mut fields = HashMap::new();
        fields.insert("CCM_LM_INSERT_NXT", Field { brief: Some("If this bitfield is asserted, CCM-LM info will be inserted into next CCM frame transmitted by the VOE. (Note: VOP:VOE_CONF:OAM_HW_CTRL.CCM_LM_ENA must be asserted prior to asserting this register.) Upon transmission of CCM-LM information, the bit is cleared by the VOE. If the VOE is configured for automatic LM insertion, this bitfield is automatically asserted by the VOE every time CCM_LM_PERIOD has occured. Automatic LM insertion is configured: * VOP:VOE_CONF:CCM_CFG.CCM_LM_PERIOD LM Insertion can also be forced by SW writing a '1' to this register. This function can be used to implement Dual Ended LM flow, by inserting LM information into the CCM frames with a given period."), details: None, lo: 7, hi: 8 });
        fields.insert("CCM_MISS_CNT", Field { brief: Some("Specifies the number of CCM half periods has passed without CCM messages received from the peer MEP. Cleared when the VOE receives a valid CCM PDU from the peer associated with MEP. It will be periodically incremented by the LOC timer configured by the following register: * VOP:VOE_CONF:CCM_CFG.CCM_PERIOD When the CCM_MISS counter is incremented to 7, an interrupt is generated if so configured in the following bit field: * VOP:VOE_STAT:INTR_ENA.CCM_LOC_INTR_ENA"), details: Some("<7: No Loss of continuity ==7: Loss of continuity"), lo: 3, hi: 6 });
        fields.insert("CCM_RX_SRC_PORT_CNT", Field { brief: Some("The VOE will count the number of consecutive CCM(-LM) PDUs received on a front port. This can be used for implementing E-Line services over networks using Ethernet Ring protection. The number of consecutive frames recieved on the same port (not counting the first one) are counted by this counter (CCM_RX_SRC_PORT_CNT). The front port on which the last valid CCM(-LM) PDU was received is stored in: * VOP:VOE_STAT:CCM_RX_LAST.CCM_RX_SRC_PORT When the CPU flushes the MAC table, it can instruct the VOE to detect when CCM(-LM) PDUs are received a number of times on the same front port. When a number of consecutive CCM(-LM) PDUs have been received on the same front port, the following sticky bit is asserted: * VOP:VOE_STAT:INTR_STICKY.CCM_RX_SRC_PORT_DETECT_STICKY This can optionally generate an interrupt. The number of consecutive CCM(-LM) PDUs which must be received on the same front port before asserting the sticky bit is configured in the following bitfield: * VOP::VOP_CTRL.CCM_RX_SRC_PORT_DETECT_CNT This field is updated by the VOE and should never be altered by the CPU."), details: None, lo: 0, hi: 3 });
        fields.insert("CCM_TX_RDI", Field { brief: Some("This configures the value to be inserted in the RDI field in the next valid CCM(-LM) PDU being transmitted by the VOE."), details: None, lo: 6, hi: 7 });
        regs.insert("CCM_STAT", Register { addr: Address { base: 25, count: 1, width: 1 }, brief: Some("Misc. CCM statistics"), details: Some("This bit fields in this register contain misc. CCM(-LM) statistics."), fields });
        let mut fields = HashMap::new();
        fields.insert("CCM_TX_SEQ", Field { brief: Some("See Register Description"), details: None, lo: 0, hi: 32 });
        regs.insert("CCM_TX_SEQ_CFG", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Configuration of CCM Sequence number"), details: Some("Configures CCM Sequence number to be inserted into the next CCM or CCM-LM PDU. The sequence number of valid CCM(-LM) PDUs is overwritten in the Tx direction depending on the configuration of the following bit field: * VOP:VOE_CONF:CCM_CFG.CCM_SEQ_UPD_ENA Counters are updated regardless of the value of: * VOP:VOE_CONF:OAM_HW_CTRL.CCM_ENA * VOP:VOE_CONF:OAM_HW_CTRL.CCM_LM_ENA"), fields });
        let mut fields = HashMap::new();
        fields.insert("DMM_RX_PDU_CNT", Field { brief: Some("Counts the number of valid Rx DMM PDUs received by the VOE."), details: None, lo: 16, hi: 24 });
        fields.insert("DMM_TX_PDU_CNT", Field { brief: Some("Counts the number of valid Tx DMM/1DM PDUs transmitted by the VOE."), details: None, lo: 24, hi: 32 });
        fields.insert("DMR_RX_PDU_CNT", Field { brief: Some("Counts the number of valid Rx DMR/1DM PDUs received by the VOE."), details: None, lo: 0, hi: 8 });
        fields.insert("DMR_TX_PDU_CNT", Field { brief: Some("Counts the number of valid Tx DMR PDUs transmitted by the VOE."), details: None, lo: 8, hi: 16 });
        regs.insert("DM_PDU_CNT", Register { addr: Address { base: 15, count: 1, width: 1 }, brief: Some("DM stat counters."), details: Some("This register contains counters for the number of valid DM PDUs. The counters are shared between the following PDU types: * DMM/DMR * 1DM"), fields });
        let mut fields = HashMap::new();
        fields.insert("G_8113_1_REMOTE_MIPID3", Field { brief: Some("See register description."), details: None, lo: 0, hi: 16 });
        regs.insert("G_8113_1_REMOTE_MIPID3", Register { addr: Address { base: 43, count: 1, width: 1 }, brief: Some("G.8113.1 MIP ID verification configuration"), details: Some("When the G.8113.1 'Initator MEP' is configured for : Connection Verification - MIP: * VOP:VOE_CONF:G_8113_1_CFG.G_8113_1_INITIATOR_FUNCTION There are 14 bytes in the 'Replying MIP ID' TLV which must be verified. These are configured in this register. I practice the register is split into 4 separate registers: * G_8113_1_REMOTE_MIPID (32 bits) * G_8113_1_REMOTE_MIPID1 (32 bits) * G_8113_1_REMOTE_MIPID2 (32 bits) * G_8113_1_REMOTE_MIPID3 (16 bits) The below description will assume that these 4 registers are concatenated into one 14 byte long register. The bytes to be verified in the 'Replying MIP ID' TLV are configured as follows: * LBR.CarrierCode == G_8113_1_REMOTE_MIPID[13:8] * LBR.NodeID == G_8113_1_REMOTE_MIPID[7:4] * LBR.IfNum == G_8113_1_REMOTE_MIPID[3:0]"), fields });
        let mut fields = HashMap::new();
        fields.insert("CCM_LOC_INTR_ENA", Field { brief: Some("Enables interrupt generation when the following sticky bit is asserted: * VOP:VOE_STAT:INTR_STICKY.CCM_LOC_STICKY"), details: Some("0: Disable interrupt 1: Enable interrupt"), lo: 3, hi: 4 });
        fields.insert("CCM_MEGID_INTR_ENA", Field { brief: Some("Enables interrupt generation when the following sticky bit is asserted: * VOP:VOE_STAT:INTR_STICKY.CCM_MEGID_RX_ERR_STICKY"), details: Some("0: Disable interrupt 1: Enable interrupt"), lo: 1, hi: 2 });
        fields.insert("CCM_MEPID_INTR_ENA", Field { brief: Some("Enables interrupt generation when the following sticky bit is asserted: * VOP:VOE_STAT:INTR_STICKY.CCM_MEPID_RX_ERR_STICKY"), details: Some("0: Disable interrupt 1: Enable interrupt"), lo: 2, hi: 3 });
        fields.insert("CCM_PERIOD_INTR_ENA", Field { brief: Some("Enables interrupt generation when the following sticky bit is asserted: * VOP:VOE_STAT:INTR_STICKY.CCM_PERIOD_RX_ERR_STICKY"), details: Some("0: Disable interrupt 1: Enable interrupt"), lo: 7, hi: 8 });
        fields.insert("CCM_PRIO_INTR_ENA", Field { brief: Some("Enables interrupt generation when the following sticky bit is asserted: * VOP:VOE_STAT:INTR_STICKY.CCM_PRIO_RX_ERR_STICKY"), details: Some("0: Disable interrupt 1: Enable interrupt"), lo: 6, hi: 7 });
        fields.insert("CCM_RX_MEL_LOW_INTR_ENA", Field { brief: Some("Enables interrupt generation when the following sticky bit is asserted: * VOP:VOE_STAT:INTR_STICKY.CCM_RX_MEL_LOW_ERR_STICKY"), details: Some("0: Disable interrupt 1: Enable interrupt"), lo: 0, hi: 1 });
        fields.insert("CCM_RX_RDI_INTR_ENA", Field { brief: Some("Enables interrupt generation when the following sticky bit is asserted: * VOP:VOE_STAT:INTR_STICKY.CCM_RX_RDI_STICKY"), details: Some("0: Disable interrupt 1: Enable interrupt"), lo: 4, hi: 5 });
        fields.insert("CCM_RX_SRC_PORT_DETECT_INTR_ENA", Field { brief: Some("Enables interrupt generation when the following sticky bit is asserted: * VOP:VOE_STAT:INTR_STICKY.CCM_RX_SRC_PORT_DETECT_STICKY"), details: None, lo: 10, hi: 11 });
        fields.insert("CCM_ZERO_PERIOD_INTR_ENA", Field { brief: Some("Enables interrupt generation when the following sticky bit is asserted: * VOP:VOE_STAT:INTR_STICKY.CCM_ZERO_PERIOD_RX_ERR_STICKY"), details: Some("0: Disable interrupt 1: Enable interrupt"), lo: 5, hi: 6 });
        fields.insert("TLV_INTERFACE_STATUS_INTR_ENA", Field { brief: Some("Enables interrupt generation when the following sticky bit is asserted: * VOP:VOE_STAT:INTR_STICKY.TLV_INTERFACE_STATUS_STICKY"), details: None, lo: 8, hi: 9 });
        fields.insert("TLV_PORT_STATUS_INTR_ENA", Field { brief: Some("Enables interrupt generation when the following sticky bit is asserted: * VOP:VOE_STAT:INTR_STICKY.TLV_PORT_STATUS_STICKY"), details: None, lo: 9, hi: 10 });
        regs.insert("INTR_ENA", Register { addr: Address { base: 28, count: 1, width: 1 }, brief: Some("Enable VOE interrupt sources"), details: Some("This register contains a bitfield for each of the interrupt sources defined for the VOE. This allows enabling the interrupts independently. Status of interrupt sources can be found in VOP:VOE_STAT:INTR_STICKY Current status of the VOE interrupt can be found in VOP::INTR"), fields });
        let mut fields = HashMap::new();
        fields.insert("CCM_LOC_STICKY", Field { brief: Some("Indicates when the Loss Of Continuity (LOC) status of this VOE changes. The current LOC status is contained in: * VOP:VOE_STAT:CCM_RX_LAST.CCM_LOC_DEFECT The sticky bit can optionally be configured to generate an interrupt: * VOP:VOE_STAT:INTR_ENA.CCM_LOC_INTR_ENA"), details: Some("0: No change in the LOC status. 1: LOC status changed."), lo: 1, hi: 2 });
        fields.insert("CCM_MEGID_RX_ERR_STICKY", Field { brief: Some("Indicate a change in the status of the MEG ID check of incoming CCM(-LM) frames. When a CCM(-LM) frame is received by the VOE, the result of the MEG ID check is compared to the value stored in: * VOP:VOE_STAT:CCM_RX_LAST.CCM_MEGID_ERR If the value changes, the sticky bit is asserted. This can optionally be configured to generate an interrupt:: * VOP:VOE_STAT:INTR_ENA.CCM_MEGID_INTR_ENA"), details: Some("0: No change in the result of the MEG ID check. 1: The result of the MEG ID check changed."), lo: 5, hi: 6 });
        fields.insert("CCM_MEPID_RX_ERR_STICKY", Field { brief: Some("Indicate a change in the status of the MEP ID check of incoming CCM(-LM) frames. When a CCM(-LM) frame is received by the VOE, the result of the MEP ID check is compared to the value stored in: * VOP:VOE_STAT:CCM_RX_LAST.CCM_MEPID_ERR If the value changes, the sticky bit is asserted. This can optionally be configured to generate an interrupt: * VOP:VOE_STAT:INTR_ENA.CCM_MEPID_INTR_ENA Sticky bit is only asserted when: * VOP:VOE_CONF:OAM_HW_CTRL.CCM_ENA = 1"), details: Some("0: No change in the result of the MEP ID check. 1: The result of the MEP ID check changed."), lo: 4, hi: 5 });
        fields.insert("CCM_PERIOD_RX_ERR_STICKY", Field { brief: Some("Indicate a change in the status of the PERIOD check of incoming CCM(-LM) frames. When a CCM(-LM) frame is received by the VOE, the result of the PERIOD check is compared to the value stored in: * VOP:VOE_STAT:CCM_RX_LAST.CCM_PERIOD_ERR If the value changes, the sticky bit is asserted. This can optionally be configured to generate an interrupt: * VOP:VOE_STAT:INTR_ENA.CCM_PERIOD_INTR_ENA"), details: Some("0: No change in the result of the PERIOD check. 1: The result of the PERIOD check changed."), lo: 3, hi: 4 });
        fields.insert("CCM_PRIO_RX_ERR_STICKY", Field { brief: Some("Indicate a change in the status of the PRIO check of incoming CCM(-LM) frames. When a CCM(-LM) frame is received by the VOE, the result of the PRIO check is compared to the value stored in: * VOP:VOE_STAT:CCM_RX_LAST.CCM_PRIO_ERR If the value changes, the sticky bit is asserted. This can optionally be configured to generate an interrupt: * VOP:VOE_STAT:INTR_ENA.CCM_PRIO_INTR_ENA"), details: Some("0: No change in the result of the PRIO check. 1: The result of the PRIO check changed."), lo: 2, hi: 3 });
        fields.insert("CCM_RX_MEL_LOW_ERR_STICKY", Field { brief: Some("Indicate a change in the status of the MEL low check of incoming CCM(-LM) frames. When a CCM(-LM) frame is received by the VOE, the result of the MEL low check is compared to the value stored in: * VOP:VOE_STAT:CCM_RX_LAST.CCM_RX_MEL_LOW_ERR If the value changes, the sticky bit is asserted. This can optionally be configured to generate an interrupt: * VOP:VOE_STAT:INTR_ENA.CCM_RX_MEL_LOW_INTR_ENA"), details: Some("0: No change in the result of the Rx MEL low check. 1: The result of the Rx MEL low check changed."), lo: 6, hi: 7 });
        fields.insert("CCM_RX_RDI_STICKY", Field { brief: Some("Indicate a change in the status of the RDI of incoming CCM(-LM) frames. When a CCM(-LM) frame is received by the VOE, the result of the RDI is compared to the value stored in: * VOP:VOE_STAT:CCM_RX_LAST.CCM_RX_RDI If the value changes, the sticky bit is asserted. This can optionally be configured to generate an interrupt: * VOP:VOE_STAT:INTR_ENA.CCM_RX_RDI_INTR_ENA"), details: Some("0: No change in the Rx RDI value. 1: The value of the Rx RDI value changed."), lo: 0, hi: 1 });
        fields.insert("CCM_RX_SRC_PORT_DETECT_STICKY", Field { brief: Some("The number of succesive OAM PDUs received on the same port are counted in the following register: * VOP:VOE_STAT:CCM_STAT.CCM_RX_SRC_PORT_CNT When this value reaches the value configured in: * VOP::VOP_CTRL.CCM_RX_SRC_PORT_DETECT_CNT This sticky bit is asserted. This sticky bit can optionally generate an interrupt depending on the following bit field: * VOP:VOE_STAT:INTR_ENA.CCM_RX_SRC_PORT_DETECT_INTR_ENA"), details: Some("0: CCM(-LM) Rx port is not stable. 1: CCM(-LM) Rx port is considered stable."), lo: 10, hi: 11 });
        fields.insert("CCM_ZERO_PERIOD_RX_ERR_STICKY", Field { brief: Some("Indicate a change in the status of the ZERO period check of incoming CCM(-LM) frames. When a CCM(-LM) frame is received by the VOE, the result of the ZERO period check is compared to the value stored in: * VOP:VOE_STAT:CCM_RX_LAST.CCM_ZERO_PERIOD_ERR If the value changes, the sticky bit is asserted. This can optionally be configured to generate an interrupt: * VOP:VOE_STAT:INTR_ENA.CCM_ZERO_PERIOD_INTR_ENA (According to G.8021 CCM(-LM) frames with PERIOD = 0 is an illegal value.)The sticky bit can optionally be configured to generate an interrupt:"), details: Some("0: No change in the result of the ZERO period check. 1: The result of the ZERO period check changed."), lo: 7, hi: 8 });
        fields.insert("TLV_INTERFACE_STATUS_STICKY", Field { brief: Some("Indicate a change in the value of the \"Interface Status TLV\" of incoming CCM(-LM) frames. When a CCM(-LM) frame which includes a \"Interface Status TLV\" is received by the VOE, the value of the \"Interface Status TLV\" is compared to the value stored in: * VOP:VOE_STAT:CCM_RX_LAST.TLV_INTERFACE_STATUS If the value changes, the sticky bit is asserted. This can optionally be configured to generate an interrupt: * VOP:VOE_STAT:INTR_ENA.TLV_INTERFACE_STATUS_INTR_ENA"), details: None, lo: 8, hi: 9 });
        fields.insert("TLV_PORT_STATUS_STICKY", Field { brief: Some("Indicate a change in the value of the \"Port Status TLV\" of incoming CCM(-LM) frames. When a CCM(-LM) frame which includes a \"Port Status TLV\" is received by the VOE, the value of the \"Port Status TLV\" is compared to the value stored in: * VOP:VOE_STAT:CCM_RX_LAST.TLV_PORT_STATUS If the value changes, the sticky bit is asserted. This can optionally be configured to generate an interrupt: * VOP:VOE_STAT:INTR_ENA.TLV_PORT_STATUS_INTR_ENA"), details: None, lo: 9, hi: 10 });
        regs.insert("INTR_STICKY", Register { addr: Address { base: 27, count: 1, width: 1 }, brief: Some("CCM(-LM) sticky status indications"), details: Some("Each of the sticky bits in this register is closely related to a specific status bit in the following register: * VOP:VOE_STAT:CCM_RX_LAST.* The above register contains a number of status bits. Each status bit indicates the latest result of a specific check performed on incoming CCM(-LM) PDUs. If the value of one of these status bits change, the corresponding sticky bit in this register is asserted. Hence if the RDI bit of the incoming CCM frames change from '1' --> '0', this will cause the following changes: * VOP:VOE_STAT:CCM_RX_LAST.CCM_RX_RDI is modified: '1' --> '0' * VOP:VOE_STAT:INTR_STICKY.CCM_RX_RDI_STICKY is asserted. Each of the sticky bits in this register can optionally be configured to generate an interrupt, using the following register: * VOP:VOE_STAT:INTR_ENA.* Sticky bits are only asserted when: * VOP:VOE_CONF:OAM_HW_CTRL.CCM_ENA = 1"), fields });
        let mut fields = HashMap::new();
        fields.insert("LBM_TX_TRANSID", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("LBM_TX_TRANSID_CFG", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("Configuration of LBM transaction ID."), details: Some("This register holds the transaction ID to be inserted into the next valid LBM PDU transmitted by the VOE. LBM Tx frames will be updated with this value if updating is enabled: * VOP:VOE_CONF:TX_TRANSID_UPDATE.LBM_UPDATE_ENA When updating a Tx LBM frame, the VOE will automatically increment the value of this register by 1."), fields });
        let mut fields = HashMap::new();
        fields.insert("LBR_RX_FRM_CNT", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("LBR_RX_FRM_CNT", Register { addr: Address { base: 13, count: 1, width: 1 }, brief: Some("Count number of received LBR frames"), details: Some("Counts number of valid LBR PDUs received by the VOE."), fields });
        let mut fields = HashMap::new();
        fields.insert("LBR_RX_TRANSID", Field { brief: Some("See bit group description."), details: None, lo: 0, hi: 32 });
        regs.insert("LBR_RX_TRANSID_CFG", Register { addr: Address { base: 12, count: 1, width: 1 }, brief: Some("The latest LBR Transaction ID"), details: Some("Holds the value of the transaction ID of the last valid expected LBR PDU received by the VOE. When a valid LBR PDU is received by the VOE, it is validated against the value of this register + 1. In case the received Transaction ID does not match the expected, it will result in the assertion of the following sticky bit: * VOP:VOE_STAT:OAM_RX_STICKY.LBR_TRANSID_ERR_STICKY Further the following error counter is increased: * VOP:VOE_STAT:LBR_RX_TRANSID_ERR_CNT.LBR_RX_TRANSID_ERR_CNT The register is only updated when: * VOP:VOE_CONF:OAM_HW_CTRL.LBR_ENA = 1 or * VOP:VOE_CONF:OAM_HW_CTRL.TST_ENA = 1"), fields });
        let mut fields = HashMap::new();
        fields.insert("LBR_RX_TRANSID_ERR_CNT", Field { brief: Some("See register description"), details: None, lo: 0, hi: 32 });
        regs.insert("LBR_RX_TRANSID_ERR_CNT", Register { addr: Address { base: 14, count: 1, width: 1 }, brief: Some("Number of valid LBR frames with transaction ID error."), details: Some("Counts number of valid OAM LBR PDUs received by the VOE for which the transaction ID differs from the expected value: * VOP:VOE_STAT:LBR_RX_TRANSID_CFG.LBR_RX_TRANSID + 1 When the above counter is increased, the following sticky bit is asserted: * VOP:VOE_STAT:OAM_RX_STICKY.LBR_TRANSID_ERR_STICKY"), fields });
        let mut fields = HashMap::new();
        fields.insert("LBR_TX_FRM_CNT", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("LBR_TX_FRM_CNT", Register { addr: Address { base: 11, count: 1, width: 1 }, brief: Some("LBR PDU TX counter."), details: Some("Number of LBR PDUs transmitted by the VOE. This number will be equal to the number of LBM PDUs received by the VOE, assuming that no PDUs were lost during the loop."), fields });
        let mut fields = HashMap::new();
        fields.insert("LMM_RX_PDU_CNT", Field { brief: Some("Counts the number of valid Rx LMM PDUs received by the VOE."), details: None, lo: 16, hi: 24 });
        fields.insert("LMM_TX_PDU_CNT", Field { brief: Some("Counts the number of valid Tx LMM / CCM-LM PDUs transmitted by the VOE."), details: None, lo: 24, hi: 32 });
        fields.insert("LMR_RX_PDU_CNT", Field { brief: Some("Counts the number of valid Rx LMR / CCM-LM PDUs received by the VOE."), details: None, lo: 0, hi: 8 });
        fields.insert("LMR_TX_PDU_CNT", Field { brief: Some("Counts the number of valid Tx LMR PDUs transmitted by the VOE."), details: None, lo: 8, hi: 16 });
        regs.insert("LM_PDU_CNT", Register { addr: Address { base: 16, count: 1, width: 1 }, brief: Some("LM stat counters."), details: Some("This register contains counters for the number of valid LM PDUs. The counters are shared between the following PDU types: * LMM/LMR * CCM_LM (only counted if CCM_LM_ENA = 1) Counters are updated regardless of the value of the PDU enable signals: * VOP:VOE_CONF:OAM_HW_CTRL.*"), fields });
        let mut fields = HashMap::new();
        fields.insert("CCM_LM_RX_STICKY", Field { brief: Some("Asserted when the VOE receives a valid CCM-LM PDU"), details: Some("'0': No valid CCM-LM PDU received '1': Valid CCM-LM PDU received"), lo: 11, hi: 12 });
        fields.insert("CCM_RX_SEQ_ERR_STICKY", Field { brief: Some("Valid CCM(-LM) PDU with sequence error received by VOE. Only updated when updating the CCM sequence number is enable: * VOP:VOE_CONF:CCM_CFG.CCM_SEQ_UPD_ENA Only updated when: * VOP:VOE_CONF:OAM_HW_CTRL.CCM_ENA = 1"), details: Some("0: No errors detected in the incoming CCM Seq Number. 1: Detected error in the incoming CCM Seq Number."), lo: 2, hi: 3 });
        fields.insert("CCM_RX_STICKY", Field { brief: Some("Asserted when the VOE receives a valid CCM PDU."), details: Some("'0': No valid CCM PDU received '1': Valid CCM PDU received"), lo: 12, hi: 13 });
        fields.insert("CCM_RX_TLV_NON_ZERO_STICKY", Field { brief: Some("The VOE supports the following two (CCM-LM) TLVs in HW, provided that they are located as the first TLVs after the CCM(-LM) payload. - \"Port Status TLV\" (see VOP:VOE_STAT:CCM_RX_LAST.TLV_PORT_STATUS) - \"Interface Status\" (see VOP:VOE_STAT:CCM_RX_LAST.TLV_INTERFACE_STATUS) Indicates that an OAM PDU was received by the VOE with an End TLV which is NON ZERO. In this context the \"End TLV\" denotes the first TLV after the CCM(-LM) PDU bypassing the \"Port Status TLV\" and the \"Interface Status TLV\" is these are present. This is a valid option according to 802.1ag. The additional TLV following the CCM PDU cannot be processed by the VOE, but frames including such a TLV can be extracted to the CPU, using the following register: * VOP:VOE_STAT:PDU_EXTRACT.CCM_RX_TLV_NON_ZERO_EXTR Frames are extracted to one of the following queues depending on whether the PDU is CCM or CCM-LM * VOP::CPU_EXTR_CFG_1.CCM_CPU_QU * VOP::CPU_EXTR_CFG_1.CCM_LM_CPU_QU"), details: Some("0: No CCM PDU with NON ZERO TLV received by the VOE. 1: CCM PDU with NON ZERO TLV was received by the VOE."), lo: 3, hi: 4 });
        fields.insert("DMAC_RX_ERR_STICKY", Field { brief: Some("The VOE discarded an Rx OAM PDU with correct MEL, which failed the DMAC check configured in: * VOP:VOE_CONF:VOE_CTRL.RX_DMAC_CHK_SEL OAM PDUs failing DMAC check can optionally be extracted using: * VOP:VOE_STAT:PDU_EXTRACT.DMAC_RX_ERR_EXTR Frames failing the DMAC validation can optionally be extracted to the CPU error queue: * VOP::CPU_EXTR_CFG.CPU_ERR_QU The DMAC check is performed for all PDU types. It is configureble if all PDU types or only for CCM(-LM) PDUs are extracted and cause the assertion of a sticky bit: * VOP:VOE_CONF:OAM_CPU_COPY_CTRL.PDU_ERR_EXTRACT_CCM_ONLY"), details: Some("0: No DMAC errors detected. 1: An OAM PDU failed the DMAC check."), lo: 5, hi: 6 });
        fields.insert("DMM_RX_STICKY", Field { brief: Some("Asserted when the VOE receives a valid DMM PDU"), details: Some("'0': No valid DMM PDU received '1': Valid DMM PDU received"), lo: 15, hi: 16 });
        fields.insert("DMR_RX_STICKY", Field { brief: Some("Asserted when the VOE receives a valid DMR PDU"), details: Some("'0': No valid DMR PDU received '1': Valid DMR PDU received"), lo: 14, hi: 15 });
        fields.insert("GENERIC_RX_STICKY_MASK", Field { brief: Some("Asserted when the VOE receives a valid OAM PDU with an OpCode which is configured as a GENERIC OPCODE in the following register: * VOP::OAM_GENERIC_CFG.* There is a separate bit to indicate the reception of each of the configured GENERIC OpCodes."), details: None, lo: 24, hi: 32 });
        fields.insert("LBM_RX_STICKY", Field { brief: Some("Asserted when the VOE receives a valid LBM PDU"), details: Some("'0': No valid LBM PDU received '1': Valid LBM PDU received"), lo: 17, hi: 18 });
        fields.insert("LBR_RX_STICKY", Field { brief: Some("Asserted when the VOE receives a valid LBR PDU"), details: Some("'0': No valid LBR PDU received '1': Valid LBR PDU received"), lo: 16, hi: 17 });
        fields.insert("LBR_TRANSID_ERR_STICKY", Field { brief: Some("Standard LBM/LBR: -------------------------------- Valid LBR frame was received with Transaction ID which did not match the expected value of: * VOP:VOE_STAT:LBR_RX_TRANSID_CFG.LBR_RX_TRANSID + 1 SAM_SEQ (Non OAM sequence numbering) -------------------------------- The assertion of this bit will depend on the following configuration: * VOP:VOE_CONF:SAM_NON_OAM_SEQ_CFG.SAM_SEQ_RX_ERR_CNT_ENA"), details: Some("0: No LBR / SAM_SEQ with sequence error was received VOE. 1: LBR / SAM_SEQ with sequence error was received by VOE."), lo: 6, hi: 7 });
        fields.insert("LMM_RX_STICKY", Field { brief: Some("Asserted when the VOE receives a valid LMM PDU"), details: Some("'0': No valid LMM PDU received '1': Valid LMM PDU received"), lo: 20, hi: 21 });
        fields.insert("LMR_RX_STICKY", Field { brief: Some("Asserted when the VOE receives a valid LMR PDU"), details: Some("'0': No valid LMR PDU received '1': Valid LMR PDU received"), lo: 19, hi: 20 });
        fields.insert("LTM_RX_STICKY", Field { brief: Some("Asserted when the VOE receives a valid LTM PDU."), details: Some("'0': No valid LTM PDU received '1': Valid LTM PDU received"), lo: 22, hi: 23 });
        fields.insert("LTR_RX_STICKY", Field { brief: Some("Asserted when the VOE receives a valid LTR PDU"), details: Some("'0': No valid LTR PDU received '1': Valid LTR PDU received"), lo: 21, hi: 22 });
        fields.insert("NON_OAM_SEQ_RX_STICKY", Field { brief: Some("Sticky bit is asserted when the VOE receives a non OAM frame with sequence number. This requires that the VOE is configured as either SAM_SEQ Initiator: * VOP:VOE_CONF:SAM_NON_OAM_SEQ_CFG.SAM_SEQ_INIT or as SAM_SEQ Responder: * VOP:VOE_CONF:SAM_NON_OAM_SEQ_CFG.SAM_SEQ_RESP When configured for \"SAM_SEQ Initiator\" this bit indicates reception of NON_OAM_RSP. When configured for \"SAM_SEQ Responder\" this bit indicates reception of NON_OAM_MSG."), details: Some("'0': No valid SAM_SEQ frame received '1': Valid SAM_SEQ frame received"), lo: 7, hi: 8 });
        fields.insert("PDU_VERSION_RX_ERR_STICKY", Field { brief: Some("Indicates that a OAM PDU was received by the VOE with a Y.1731 version code which is not configured as valid: * VOP::VERSION_CTRL.* * VOP::VERSION_CTRL_2.* Frames with version error are discarded and can optionally be extracted to the CPU using: * VOP:VOE_STAT:PDU_EXTRACT.PDU_VERSION_RX_ERR_EXTR Frames extracted to the CPU due to Y.1731 version error are extracted to the CPU error queue: VOP::CPU_EXTR_CFG.CPU_ERR_QU It is configurable if the VERSION check is performed for all PDU types or only for CCM(-LM) PDUs using the following bit field: * VOP:VOE_CONF:OAM_CPU_COPY_CTRL.PDU_ERR_EXTRACT_CCM_ONLY"), details: Some("0: No PDU with VERSION error received by VOE. 1: PDU with VERSION error received by VOE."), lo: 4, hi: 5 });
        fields.insert("RX_MEL_HIGH_BLOCK_STICKY", Field { brief: Some("This sticky bit is asserted when a frame is discarded because the following option is enabled: * VOP:VOE_CONF:VOE_CTRL.BLOCK_MEL_HIGH_RX"), details: None, lo: 0, hi: 1 });
        fields.insert("RX_MEL_LOW_BLOCK_STICKY", Field { brief: Some("An OAM PDU was discarded because it was received by the VOE with MEL which is lower than the MEL value configure for the MEL. All Rx frames are subjected to the MEL verification, however it is configurable if the Rx MEL LOW extraction is done for all PDU types or only for CCM(-LM) PDUs using the following bit field: * VOP:VOE_CONF:OAM_CPU_COPY_CTRL.PDU_ERR_EXTRACT_CCM_ONLY"), details: None, lo: 1, hi: 2 });
        fields.insert("SDM_RX_STICKY", Field { brief: Some("Asserted when the VOE receives a valid 1DM PDU"), details: Some("'0': No valid 1DM PDU received '1': Valid 1DM PDU received"), lo: 13, hi: 14 });
        fields.insert("SL1_RX_STICKY", Field { brief: Some("Asserted when the VOE receives a valid 1SL PDU."), details: Some("'0': No valid 1SL PDU received '1': Valid 1SL PDU received"), lo: 8, hi: 9 });
        fields.insert("SLM_RX_STICKY", Field { brief: Some("Asserted when the VOE receives a valid SLM PDU."), details: Some("'0': No valid SLM PDU received '1': Valid SLM PDU received"), lo: 10, hi: 11 });
        fields.insert("SLR_RX_STICKY", Field { brief: Some("Asserted when the VOE receives a valid SLR PDU."), details: Some("'0': No valid SLR PDU received '1': Valid SLR PDU received"), lo: 9, hi: 10 });
        fields.insert("TST_RX_STICKY", Field { brief: Some("Asserted when the VOE receives a valid TST PDU"), details: Some("'0': No valid TST PDU received '1': Valid TST PDU received"), lo: 18, hi: 19 });
        fields.insert("UNK_OPCODE_RX_STICKY", Field { brief: Some("Asserted when the VOE receives a valid OAM PDU with an OpCode which is detected as UNKNOWN. UNKNOWN OpCode is used for OAM PDU types which do not have dedicated HW support and which is not encoded as a GENERIC PDU."), details: Some("'0': No PDU received '1': PDU with UNKNOWN OpCode received"), lo: 23, hi: 24 });
        regs.insert("OAM_RX_STICKY", Register { addr: Address { base: 23, count: 1, width: 1 }, brief: Some("Rx Sticky bits"), details: Some("The sticky bits included in this register can be subdivided into two groups: ------------------------------------------------------------------------ -------------------------------------------- * Valid OAM PDUs: Sticky bits which indicate that a valid OAM PDU is received by the VOE. * Error conditions: The VOE detected a given error condition. Valid OAM PDU sticky bits: --------------------------------------------------- The PDU specific Rx sticky bits: * \"xxx\"_RX_STICKY will be asserted even when the PDU is not enabled (VOE_CONF.OAM_HW_CTRL), to allow detecting PDU types which are not expected. Error conditions: ----------------------------------------------------- For the remaining sticky bits the VOE will require the PDU type to be enabled, before asserting the sticky bits. The OAM PDU is considered valid when: * PDU MEL is equal to the VOE MEL. * DMAC is verified according to VOE configuration (VOP:VOE_CONF:VOE_CTRL.RX_DMAC_CHK_SEL) * PDU version matches configuration. For CCM(-LM) frames the following checks are performed to validate the PDU: * Verify MEGID * Verify MEPID * Verify Period is NON Zero"), fields });
        let mut fields = HashMap::new();
        fields.insert("G_8113_1_LBR_RX_ILL_LBK_IND_STICKY", Field { brief: Some("Only valid if the VOE is configured for G.8113.1 OAM: * VOP:VOE_CONF:VOE_CTRL.G_8113_1_ENA The 'Initiator VOE' will verify the value of the incoming 'Loopback Indicator' in the 'Requesting MEP ID TLV' (if present). If the value is != 1 this sticky bit is asserted and the PDU is marked invalid. The frame can optionally be extracted to the CPU error queue: LBR: ----------- * VOP:VOE_STAT:PDU_EXTRACT.G_8113_1_LBR_RX_ERR_EXTR"), details: None, lo: 0, hi: 1 });
        fields.insert("G_8113_1_LBX_RX_ILLEGAL_MEXID_STICKY", Field { brief: Some("Only valid if the VOE is configured for G.8113.1 OAM: * VOP:VOE_CONF:VOE_CTRL.G_8113_1_ENA If MIP / MEP / MEG ID verification is enabled: * VOP:VOE_CONF:G_8113_1_CFG.G_8113_1_LBX_MEXID_CHK_ENA The VOE will validate the MIP / MEP / MEG ID of incoming LBM or LBR PDUs: * Rx LBM: -------------------- - Validate LBM.TargetTLV.MEP_ID (Mandatory TLV) - Validate LBM.Requesting.MEP_ID (Optional TLV) - Validate LBM.Requesting.MEG_ID (Optional TLV) For LBR PDUs the validation is depending on configured 'Initiator VOE' configuration: * VOP:VOE_CONF:G_8113_1_CFG.G_8113_1_INITIATOR_FUNCTION For LBR PDUs the following fields are configured. * Rx LBR (CV - MIP): ---------------------------------- - Validate LBR.ReplyingTLV.CarrierCode + NodeID + IfNum (Mandatory TLV) - Validate LBR.Requesting.MEP_ID (Optional TLV) - Validate LBR.Requesting.MEG_ID (Optional TLV) * Rx LBR (CV - MEP): ---------------------------------- - Validate LBR.TargetTLV.MEP_ID (Mandatory TLV) - Validate LBR.Requesting.MEP_ID (Optional TLV) - Validate LBR.Requesting.MEG_ID (Optional TLV) If the verification fails, this sticky bit is asserted and the frame is marked as invalid. The frame can optionally be extracted to the CPU error queue depending on the PDU type: LBM: ----------- * VOP:VOE_STAT:PDU_EXTRACT.G_8113_1_LBM_RX_ERR_EXTR LBR: ----------- * VOP:VOE_STAT:PDU_EXTRACT.G_8113_1_LBR_RX_ERR_EXTR"), details: None, lo: 1, hi: 2 });
        fields.insert("G_8113_1_LBX_RX_ILLEGAL_SUBTYPE_STICKY", Field { brief: Some("Only valid if the VOE is configured for G.8113.1 OAM: * VOP:VOE_CONF:VOE_CTRL.G_8113_1_ENA Only valid if the VOE is configured for G.8113.1 OAM: * VOP:VOE_CONF:VOE_CTRL.G_8113_1_ENA If an LBM or LBR PDU is received with an illegal ID Sub-Type in the mandatory TLV: * LBM mandatory TLV: 'Target MEP/MIP TLV' (TLV type 33) * LBR mandatory TLV: 'Replying MEP/MIP TLV' (TLV type 34) This sticky bit is asserted and the frame is marked as invalid. The frame can optionally be extracted to the CPU error queue depending on the PDU type: LBM: ----------- * VOP:VOE_STAT:PDU_EXTRACT.G_8113_1_LBM_RX_ERR_EXTR LBR: ----------- * VOP:VOE_STAT:PDU_EXTRACT.G_8113_1_LBR_RX_ERR_EXTR"), details: None, lo: 2, hi: 3 });
        fields.insert("G_8113_1_LBX_RX_MISSING_TLV_STICKY", Field { brief: Some("Only valid if the VOE is configured for G.8113.1 OAM: * VOP:VOE_CONF:VOE_CTRL.G_8113_1_ENA If an LBM or LBR PDU is received without the mandatory TLV: * LBM mandatory TLV: 'Target MEP/MIP TLV' (TLV type 33) * LBR mandatory TLV: 'Replying MEP/MIP TLV' (TLV type 34) This sticky bit is asserted and the frame is marked as invalid. The frame can optionally be extracted to the CPU error queue depending on the PDU type: LBM: ----------- * VOP:VOE_STAT:PDU_EXTRACT.G_8113_1_LBM_RX_ERR_EXTR LBR: ----------- * VOP:VOE_STAT:PDU_EXTRACT.G_8113_1_LBR_RX_ERR_EXTR"), details: None, lo: 3, hi: 4 });
        fields.insert("RX_INI_ILLEGAL_MEPID_STICKY", Field { brief: Some("When an SLR PDU is received by an Initiator MEP, the VOE will verify that the SLR.SRC_MEPID of the incoming frame matches the Initiator's own MEPID: * VOP:VOE_CONF:VOE_MEPID_CFG.VOE_MEPID If the SLR.SRC_MEPID does not match the above value, this sticky bit is asserted and the frame is considered invalid. Frames which fail the SynLM Initiator MEP MEPID check can optionally be extracted to the CPU error queue: * VOP:VOE_STAT:PDU_EXTRACT.SL_ERR_EXTR"), details: None, lo: 4, hi: 5 });
        fields.insert("RX_SLM_MEPID_ERR_STICKY", Field { brief: Some("When SynLM frames are received from a SynLM peer MEP, the VOE will verify the MEPID of the incoming PDU against the list of valid peer MEPIDs programmed in the VOE: * VOP:VOE_CONF:SLM_PEER_LIST.SLM_PEER_MEPID If no match is found, this sticky bit is asserted and the frame is considered invalid. Whether the VOE matches the SRC_MEPID or the RCV_MEPID depends on the PDU type and the direction of the PDU (RX/TX). Frames which fail the SynLM peer MEPID check can optionally be extracted to the CPU error queue: * VOP:VOE_STAT:PDU_EXTRACT.SL_ERR_EXTR"), details: None, lo: 5, hi: 6 });
        fields.insert("RX_SLM_PRIO_ERR_STICKY", Field { brief: Some("The VOE received an SLM/SLR/1SL frame with a priority which is different from the value programmed for the VOE in the following register: * VOP:VOE_CONF:SLM_CONFIG.SLM_PRIO Frames which fail the SynLM PRIO check can optionally be extracted to the CPU error queue: * VOP:VOE_STAT:PDU_EXTRACT.SL_ERR_EXTR"), details: None, lo: 6, hi: 7 });
        fields.insert("RX_SLM_TESTID_ERR_STICKY", Field { brief: Some("The VOE received an SLR frame with a TEST ID which is different from the value programmed for the VOE in the following register: * VOP:VOE_CONF:SLM_TEST_ID.SLM_TEST_ID If the SLR.TEST_ID does not match the above value, this sticky bit is asserted and the frame is considered invalid. Frames which fail the TEST_ID check can optionally be extracted to the CPU error queue: * VOP:VOE_STAT:PDU_EXTRACT.SL_ERR_EXTR"), details: None, lo: 7, hi: 8 });
        regs.insert("OAM_RX_STICKY2", Register { addr: Address { base: 24, count: 1, width: 1 }, brief: Some("Rx Sticky bits - continued"), details: Some("Rx sticky bits related to SymLM frame verification."), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_BLOCK_ERR_STICKY", Field { brief: Some("This register is asserted if a frame is blocked in the Tx direction due to a MEL value which is too low. A low MEL value will result as one of two conditions: ------------------------------------------------------------------------ ------------ 1) Injection Tx PDU If an OAM PDU is injected by the CPU in the Tx direction with a MEL different from the MEL configured for the VOE. 2) Forwarding Tx PDU If a frame from a front port (non CPU inject) is forwarded in the Tx direction with a MEL which is equal to or lower that the MEL configured for the VOE. The MEL for the VOE is configured in the following bit field: * VOP:VOE_CONF:VOE_CTRL.MEL_VAL The assertion of this sticky bit depends on the setting of the following bit field: * VOP:VOE_CONF:OAM_CPU_COPY_CTRL.PDU_ERR_EXTRACT_CCM_ONLY"), details: None, lo: 1, hi: 2 });
        fields.insert("TX_SLM_PRIO_ERR_STICKY", Field { brief: Some("If a SynLM PDU is transmitted with a priority (COSID) which is different from the SynLM PRIO configured for the VOE, * VOP:VOE_CONF:SLM_CONFIG.SLM_PRIO the frame will be marked as invalid and this sticky bit is asserted. Frames which fail the tx prio test can optionally be extracted to the CPU error queue: * VOP:VOE_STAT:PDU_EXTRACT.SL_ERR_EXTR"), details: None, lo: 0, hi: 1 });
        regs.insert("OAM_TX_STICKY", Register { addr: Address { base: 22, count: 1, width: 1 }, brief: Some("Tx sticky bits"), details: Some("VOE Tx sticky bits."), fields });
        let mut fields = HashMap::new();
        fields.insert("CCM_MEGID_RX_ERR_EXTR", Field { brief: Some("If asserted, all OAM PDUs which assert the following status bit will be extracted to the CPU: * VOP:VOE_STAT:CCM_RX_LAST.CCM_MEGID_ERR PDUs will be extracted to the following CPU queue: * VOP::CPU_EXTR_CFG.CPU_ERR_QU. The extraction will be \"Hit Me Once\" or \"Extract All\" depending on the configuration of: * EXTRACT_HIT_ME_ONCE"), details: Some("0: Do not extract to CPU. 1: Extract frames to CPU."), lo: 11, hi: 12 });
        fields.insert("CCM_MEPID_RX_ERR_EXTR", Field { brief: Some("If asserted, all OAM PDUs which assert the following status bit will be extracted to the CPU: * VOP:VOE_STAT:CCM_RX_LAST.CCM_MEPID_ERR PDUs will be extracted to the following CPU queue: * VOP::CPU_EXTR_CFG.CPU_ERR_QU. The extraction will be \"Hit Me Once\" or \"Extract All\" depending on the configuration of: * EXTRACT_HIT_ME_ONCE"), details: Some("0: Do not extract to CPU. 1: Extract frames to CPU."), lo: 10, hi: 11 });
        fields.insert("CCM_PERIOD_RX_ERR_EXTR", Field { brief: Some("If asserted, all OAM PDUs which assert the following status bit will be extracted to the CPU: * VOP:VOE_STAT:CCM_RX_LAST.CCM_PERIOD_ERR PDUs will be extracted to the following CPU queue: CCM: --------------- * VOP::CPU_EXTR_CFG_1.CCM_CPU_QU. CCM-LM: --------------- * VOP::CPU_EXTR_CFG_1.CCM_LM_CPU_QU. The extraction will be \"Hit Me Once\" or \"Extract All\" depending on the configuration of: * EXTRACT_HIT_ME_ONCE"), details: Some("0: Do not extract to CPU. 1: Extract frames to CPU."), lo: 9, hi: 10 });
        fields.insert("CCM_PRIO_RX_ERR_EXTR", Field { brief: Some("If asserted, all OAM PDUs which assert the following status bit will be extracted to the CPU: * VOP:VOE_STAT:CCM_RX_LAST.CCM_PRIO_ERR PDUs will be extracted to the following CPU queue: CCM: --------------- * VOP::CPU_EXTR_CFG_1.CCM_CPU_QU. CCM-LM: --------------- * VOP::CPU_EXTR_CFG_1.CCM_LM_CPU_QU. The extraction will be \"Hit Me Once\" or \"Extract All\" depending on the configuration of: * EXTRACT_HIT_ME_ONCE"), details: Some("0: Do not extract to CPU. 1: Extract frames to CPU."), lo: 8, hi: 9 });
        fields.insert("CCM_RX_CCM_NXT_EXTR", Field { brief: Some("If asserted the next valid CCM(-LM) frame will be extracted to the CPU. Frames are extracted to one of the following queues depending on whether the PDU is CCM or CCM-LM CCM: ------------- * VOP::CPU_EXTR_CFG_1.CCM_CPU_QU CCM-LM: ------------- * VOP::CPU_EXTR_CFG_1.CCM_LM_CPU_QU This extraction is always implemented as: \"Hit Me Once\""), details: Some("0: Do not extract to CPU. 1: Extract next valid CCM PDU to CPU."), lo: 6, hi: 7 });
        fields.insert("CCM_RX_TLV_NON_ZERO_EXTR", Field { brief: Some("If asserted, all CCM(-LM) PDUs which assert the following sticky bit will be extracted to the CPU: * VOP:VOE_STAT:OAM_RX_STICKY.CCM_RX_TLV_NON_ZERO_STICKY Frames are extracted to one of the following queues depending on whether the PDU is CCM or CCM-LM CCM: ------------ * VOP::CPU_EXTR_CFG_1.CCM_CPU_QU CCM-LM: ----------------- * VOP::CPU_EXTR_CFG_1.CCM_LM_CPU_QU The extraction will be \"Hit Me Once\" or \"Extract All\" depending on the configuration of: * EXTRACT_HIT_ME_ONCE This bit field allows the next CCM frame with Second TLV to CPU. (IEEE802.1AG relevant only)."), details: Some("0: Do not extract to CPU. 1: Extract frames to CPU."), lo: 7, hi: 8 });
        fields.insert("CCM_ZERO_PERIOD_RX_ERR_EXTR", Field { brief: Some("If asserted, all OAM PDUs which assert the following status bit will be extracted to the CPU: * VOP:VOE_STAT:CCM_RX_LAST.CCM_ZERO_PERIOD_ERR PDUs will be extracted to the following CPU queue: * VOP::CPU_EXTR_CFG.CPU_ERR_QU. The extraction will be \"Hit Me Once\" or \"Extract All\" depending on the configuration of: * EXTRACT_HIT_ME_ONCE"), details: Some("0: Do not extract to CPU. 1: Extract frames to CPU."), lo: 16, hi: 17 });
        fields.insert("DMAC_RX_ERR_EXTR", Field { brief: Some("If asserted, all OAM PDUs which assert the following sticky bit will be extracted to the CPU: * VOP:VOE_STAT:OAM_RX_STICKY.DMAC_RX_ERR_STICKY PDUs will be extracted to the following CPU queue: * VOP::CPU_EXTR_CFG.CPU_ERR_QU. The extraction will be \"Hit Me Once\" or \"Extract All\" depending on the configuration of: * EXTRACT_HIT_ME_ONCE"), details: Some("0: Do not extract to CPU. 1: Extract frames to CPU."), lo: 13, hi: 14 });
        fields.insert("EXTRACT_HIT_ME_ONCE", Field { brief: Some("Is used to configure whether the following extract bits are implemented as \"Hit Me Once\" or \"Extract all\": * CCM_ZERO_PERIOD_RX_ERR_EXTR * RX_MEL_LOW_ERR_EXTR * RX_MEL_HIGH_BLOCK_EXTR * DMAC_RX_ERR_EXTR * PDU_VERSION_RX_ERR_EXTR * CCM_MEGID_RX_ERR_EXTR * CCM_MEPID_RX_ERR_EXTR * CCM_PERIOD_RX_ERR_EXTR * CCM_PRIO_RX_ERR_EXTR * CCM_RX_TLV_NON_ZERO_EXTR * RX_TEST_FRM_NXT_EXTR * TX_BLOCK_ERR_EXTR * SAM_RX_SEQ_ERR_EXTR * SL_ERR_EXTR * G_8113_1_LBM_RX_ERR_EXTR * G_8113_1_LBR_RX_ERR_EXTR This configuration bit has no effect on the following extraction bit: \"CCM_RX_CCM_NXT_EXTR\" The above extraction bits can be enabled for 'auto HMO'. When 'auto HMO' is enabled, the extraction is always done 'Hit-Me-Once' regardless of the configuration of the 'EXTRACT_HIT_ME_ONCE' bit field. For information on 'auto HMO' see register group: * VOP:VOE_STAT:AUTO_HIT_ME_ONCE.*"), details: Some("0: Extract all frames meeting the condition of the extract bits (Extract all). 1: Extract only the next frame which meets the condition of the extract bits (Hit Me once)."), lo: 17, hi: 18 });
        fields.insert("G_8113_1_LBM_RX_ERR_EXTR", Field { brief: Some("Only valid if the VOE is configured for G.8113.1 OAM: * VOP:VOE_CONF:VOE_CTRL.G_8113_1_ENA If this bit is asserted any LBM Rx PDU which asserts either of the following sticky bits will be extracted to the CPU error queue. * VOP:VOE_STAT:OAM_RX_STICKY2.G_8113_1_LBX_RX_MISSING_TLV_STICKY * VOP:VOE_STAT:OAM_RX_STICKY2.G_8113_1_LBX_RX_ILLEGAL_SUBTYPE_STICKY * VOP:VOE_STAT:OAM_RX_STICKY2.G_8113_1_LBX_RX_ILLEGAL_MEXID_STICKY"), details: None, lo: 1, hi: 2 });
        fields.insert("G_8113_1_LBR_RX_ERR_EXTR", Field { brief: Some("Only valid if the VOE is configured for G.8113.1 OAM: * VOP:VOE_CONF:VOE_CTRL.G_8113_1_ENA If this bit is asserted any LBR Rx PDU which asserts either of the following sticky bits will be extracted to the CPU error queue. * VOP:VOE_STAT:OAM_RX_STICKY2.G_8113_1_LBX_RX_MISSING_TLV_STICKY * VOP:VOE_STAT:OAM_RX_STICKY2.G_8113_1_LBX_RX_ILLEGAL_SUBTYPE_STICKY * VOP:VOE_STAT:OAM_RX_STICKY2.G_8113_1_LBX_RX_ILLEGAL_MEXID_STICKY * VOP:VOE_STAT:OAM_RX_STICKY2.G_8113_1_LBR_RX_ILL_LBK_IND_STICKY"), details: None, lo: 0, hi: 1 });
        fields.insert("PDU_VERSION_RX_ERR_EXTR", Field { brief: Some("If asserted, all OAM PDUs which assert the following sticky bit will be extracted to the CPU: * VOP:VOE_STAT:OAM_RX_STICKY.PDU_VERSION_RX_ERR_STICKY PDUs will be extracted to the following CPU queue: * VOP::CPU_EXTR_CFG.CPU_ERR_QU. The extraction will be \"Hit Me Once\" or \"Extract All\" depending on the configuration of: * EXTRACT_HIT_ME_ONCE"), details: Some("0: Do not extract to CPU. 1: Extract frames to CPU."), lo: 12, hi: 13 });
        fields.insert("RX_MEL_HIGH_BLOCK_EXTR", Field { brief: Some("If asserted, all OAM PDUs which assert the following status bit will be extracted to the CPU: * VOP:VOE_STAT:OAM_RX_STICKY.RX_MEL_HIGH_BLOCK_STICKY PDUs will be extracted to the following CPU queue: * VOP::CPU_EXTR_CFG.CPU_ERR_QU. The extraction will be \"Hit Me Once\" or \"Extract All\" depending on the configuration of: * EXTRACT_HIT_ME_ONCE"), details: Some("0: Do not extract to CPU. 1: Extract frames to CPU."), lo: 14, hi: 15 });
        fields.insert("RX_MEL_LOW_ERR_EXTR", Field { brief: Some("If asserted, all OAM PDUs which assert the following sticky bit will be extracted to the CPU: * VOP:VOE_STAT:OAM_RX_STICKY.RX_MEL_LOW_BLOCK_STICKY PDUs will be extracted to the following CPU queue: * VOP::CPU_EXTR_CFG.CPU_ERR_QU. The extraction will be \"Hit Me Once\" or \"Extract All\" depending on the configuration of: * EXTRACT_HIT_ME_ONCE"), details: Some("0: Do not extract to CPU. 1: Extract frames to CPU."), lo: 15, hi: 16 });
        fields.insert("RX_TEST_FRM_NXT_EXTR", Field { brief: Some("If asserted by SW, the next valid OAM PDU received of one of the following PDU types will be extracted: * TST * LBR * NON_OAM_MSG Only the first PDU is extracted, regardless of which of the three PDU types it is. When a PDU has been extracted, the bit will be cleared by the VOE, regardless of the value of: * EXTRACT_HIT_ME_ONCE The PDU is extracted to the queue assigned to the relevant PDU type in the CPU extract queues."), details: Some("0: Do not extract to CPU. 1: Extract frames to CPU."), lo: 5, hi: 6 });
        fields.insert("SAM_RX_SEQ_ERR_EXTR", Field { brief: Some("Extract non OAM sequence numbered frames in the SAM_SEQ Initiator. Out of sequence non OAM frames is further indicated by asserting the following sticky bit: * VOP:VOE_STAT:OAM_RX_STICKY.LBR_TRANSID_ERR_STICKY The frames which are extracted due to this bit will depend on the config following configuration: * VOP:VOE_CONF:SAM_NON_OAM_SEQ_CFG.SAM_SEQ_RX_ERR_CNT_ENA PDUs will be extracted to the following CPU queue: * VOP::CPU_EXTR_CFG_1.LBR_CPU_QU The extraction will be \"Hit Me Once\" or \"Extract All\" depending on the configuration of: * EXTRACT_HIT_ME_ONCE"), details: Some("0: Do not extract to CPU. 1: Extract frames to CPU."), lo: 3, hi: 4 });
        fields.insert("SL_ERR_EXTR", Field { brief: Some("If asserted the VOE will extract frames asserting one of the following sticky bits: * VOP:VOE_STAT:OAM_RX_STICKY2.RX_SLM_TESTID_ERR_STICKY * VOP:VOE_STAT:OAM_RX_STICKY2.RX_SLM_PRIO_ERR_STICKY * VOP:VOE_STAT:OAM_RX_STICKY2.RX_SLM_MEPID_ERR_STICKY * VOP:VOE_STAT:OAM_RX_STICKY2.RX_INI_ILLEGAL_MEPID_STICKY * VOP:VOE_STAT:OAM_TX_STICKY.TX_SLM_PRIO_ERR_STICKY The extraction will be \"Hit Me Once\" or \"Extract All\" depending on the configuration of: * EXTRACT_HIT_ME_ONCE"), details: Some("0: Do not extract to CPU. 1: Extract frames to CPU."), lo: 2, hi: 3 });
        fields.insert("TX_BLOCK_ERR_EXTR", Field { brief: Some("If asserted, all OAM PDUs which assert the following sticky bit will be extracted to the CPU: * VOP:VOE_STAT:OAM_TX_STICKY.TX_BLOCK_ERR_STICKY PDUs will be extracted to the following CPU queue: * VOP::CPU_EXTR_CFG.CPU_ERR_QU. The extraction will be \"Hit Me Once\" or \"Extract All\" depending on the configuration of: * EXTRACT_HIT_ME_ONCE"), details: Some("0: Do not extract to CPU. 1: Extract frames to CPU."), lo: 4, hi: 5 });
        regs.insert("PDU_EXTRACT", Register { addr: Address { base: 19, count: 1, width: 1 }, brief: Some("Extraction of PDU errors to the CPU_ERR_QU"), details: Some("Each of the bit fields in this register represent a specific PDU condition, which will cause the next PDU meeting the condition to be copied to the CPU if the matching bit is asserted. All the bits - with the exception of \"CCM_RX_CCM_NXT_EXTR\" and \"RX_TEST_FRM_NXT_EXTR\" - are encoded as either \"Extract All\" or \"Hit Me Once\" (This is different if auto HMO is enabled for the VOE, see description of HMO below) This depends on the value of bit field: * EXTRACT_HIT_ME_ONCE If configured for \"Hit Me Once\" then the VOE will clear the bit, when a PDU which meets the condition has been copied to the CPU. To extract another frame meeting the same condition, the CPU must re-assert the bit. If not configured for \"Hit Me Once\" the VOE will not clear the extraction bit and all frames matching the condition will be extracted, until the extraction bit is cleared by SW. \"CCM_RX_CCM_NXT_EXTR\" will always be implemented as \"Hit Me Once\". If all the CCM(-LM) frames are to be extracted, use the PDU specific extract bits: * VOP:VOE_CONF:OAM_CPU_COPY_CTRL.* If the VOE is enabled for auto HMO, the registers which are enabled for auto HMO will always be extracted Hit-Me-Once, regardless of the value of : * EXTRACT_HIT_ME_ONCE Auto HMO is configured in the following register: * VOP:VOE_STAT:AUTO_HIT_ME_ONCE"), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_FRM_DISCARD_CNT", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("RX_OAM_DISCARD", Register { addr: Address { base: 18, count: 1, width: 1 }, brief: Some("OAM Rx discard counter"), details: Some("Number of Rx frames discarded by the VOE, due to: * MEL filtering * DMAC check * Version check * MEL block high * CCM verification * SLM/SLR/SL1 verification * If SAM_SEQ frames are received on a VOE not enabled for SAM_SEQ processing (See VOP:VOE_CONF:SAM_NON_OAM_SEQ_CFG.*)"), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_OAM_FRM_CNT", Field { brief: Some("See register description"), details: None, lo: 0, hi: 32 });
        regs.insert("RX_OAM_FRM_CNT", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Count non-selected OAM PDU received by VOE."), details: Some("All PDU types can be configured as either selected or non-selected PDUs. This register counts the number of valid Rx OAM PDUs configured as non-selected PDU type. Selected OAM PDUs are configured in: VOP:VOE_CONF:OAM_CNT_OAM_CTRL.*"), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_SEL_OAM_FRM_CNT", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("RX_SEL_OAM_CNT", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Count selected OAM PDU received by VOE."), details: Some("All PDU types can be configured as either selected or non-selected PDUs. This register counts the number of valid Rx OAM PDUs configured as selected PDU type, received by the VOE. Selected OAM PDUs are configured in: VOP:VOE_CONF:OAM_CNT_OAM_CTRL.*"), fields });
        let mut fields = HashMap::new();
        fields.insert("EXTRACT_HMO", Field { brief: Some("If asserted, the frame extraction due to a match in the following register: * VOP:VOE_STAT:SYNLM_EXTRACT.EXTRACT_PEER_RX will be done \"Hit Me Once\" If not asserted all frames matching the above will be extracted to CPU."), details: None, lo: 8, hi: 9 });
        fields.insert("EXTRACT_PEER_RX", Field { brief: Some("When the Initiator MEP enabled for SynLM processes Rx SLR / 1SL PDUs, they are extracted if so configured in this register. Configuring this register allows for extracting only Rx frames from selected SynLM peer MEPs. The register width is 8. Each bit represents a SynLM peer MEP. The SynLM peer MEP associated with an Rx PDU is determined from matching the MEPID of the Rx SynLM PDU against the configured list of SynLM peer MEPIDs: * VOP:VOE_CONF:SLM_PEER_LIST.SLM_PEER_MEPID If the bit (in the current register) representing the SynLM peer index of the Rx frame, the frame is extracted to the CPU. The extraction will be done either extract ALL or extract \"Hit Me Once\" depending on the value of the the following bit field: * VOP:VOE_STAT:SYNLM_EXTRACT.EXTRACT_HMO"), details: None, lo: 0, hi: 8 });
        regs.insert("SYNLM_EXTRACT", Register { addr: Address { base: 21, count: 1, width: 1 }, brief: Some("Extraction of SynLM Rx PDUs"), details: Some("This register allows extraction of SLR/1SL PDUs received from selected Peer MEPs."), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_FRM_DISCARD_CNT", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("TX_OAM_DISCARD", Register { addr: Address { base: 17, count: 1, width: 1 }, brief: Some("OAM Tx discard counter"), details: Some("The number of Tx frames discarded by the VOE due to: MEL filtering (Blocking in the Tx direction)"), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_OAM_FRM_CNT", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("TX_OAM_FRM_CNT", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Count non-selected OAM PDUs transmitted by VOE."), details: Some("All PDU types can be configured as either selected or non-selected PDUs. This register counts the number of valid Tx OAM PDUs configured as non-selected PDU type. Selected OAM PDUs are configured in: VOP:VOE_CONF:OAM_CNT_OAM_CTRL.*"), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_SEL_OAM_FRM_CNT", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("TX_SEL_OAM_CNT", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Count selected OAM PDUs transmitted by VOE."), details: Some("All PDU types can be configured as either selected or non-selected PDUs. This register counts the number of valid Tx OAM PDUs configured as selected PDU type. Selected OAM PDUs are configured in: VOP:VOE_CONF:OAM_CNT_OAM_CTRL.*"), fields });
        groups.insert("VOE_STAT", RegisterGroup { addr: Address { base: 131072, count: 1077, width: 32 }, desc: "Per VOE statistics and counters (Y.1731 OAM)", regs });
        out.insert("VOP", Target { desc: "The Vitesse OAM MEP Processor (VOP) implements the HW support for implementing OAM MEPs. The HW support for implementing an OAM MEP is implemented in a sub block, referred to as: Vitesse OAM Endpoint (VOE). The VOEs can be configured for either Ethernet PDU processing or MPLS-TP PDU processing. This CSR target us used for configuring VOEs configured for Ethernet processing. The VOP includes the following: * 256 Service / Path VOEs * 11 Port VOEs (10 front ports + NPI) VOEs are configured for either Ethernet or MPLS-TP support using the following register: * VOP:VOE_CONF_REG:VOE_MISC_CONFIG.MPLS_OAM_ENA Use CSR target VOP to configure VOEs configured for Ethernet. To configure VOEs configured for MPLS-TP, use CSR target: VOP_MPLS. For VOEs configured for MPLS-TP, the following register groups are invalid: * VOP:VOE_CONF:* * VOP:VOE_STAT:*", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("BFD_CC_AUTH_ENA", Field { brief: Some("The configuration of this bit field indicates if the incoming BFD CC PDUs are expected to have the AUTH bit set. The value of the AUTH bit in the incoming BFD PDUs is verified as part of the Rx verification  AUTH_MISMATCH test. If this test fails, the following sticky bit is asserted: * VOP_MPLS:VOE_STAT_MPLS:BFD_RX_STICKY.AUTH_MISMATCH_ERR_STICKY"), details: None, lo: 9, hi: 10 });
        fields.insert("BFD_CC_RFC6428", Field { brief: Some("The VOE can accept two different G-ACH Channel Types as being valid BFD CC PDUs, depending of the setting of this register. If the VOE receives a MPLS-TP with the G-ACH Channel Type which is not the one configured for BFD CC, the PDU will be classified as either Generic or Unknown G-ACH Channel Type. I.e. if BFD_CC_RFC6428 = 1, MPLS-TP PDUs with G-ACH Channel Type = 0x0007 will be classified as either Generic or UNKNOWN G-ACH Channel Type."), details: Some("The pending on configuration of this bit field, the VOE will expect the following G-ACH Channel Type for BFD CC PDUs: 0: 0x0007 (RFC_5885) 1: 0x0022 (RFC_6428)"), lo: 22, hi: 23 });
        fields.insert("BFD_COORDINATED_MODE_ENA", Field { brief: Some("This bit field configures whether the BFD session is running in: 0: Independent BFD Mode 1: Coordinated BFD Mode"), details: None, lo: 16, hi: 17 });
        fields.insert("BFD_CV_AUTH_ENA", Field { brief: Some("The configuration of this bit field indicates if the incoming BFD CV PDUs are expected to have the AUTH bit set. The value of the AUTH bit in the incoming BFD PDUs is verified as part of the Rx verification  AUTH_MISMATCH test. If this test fails, the following sticky bit is asserted: * VOP_MPLS:VOE_STAT_MPLS:BFD_RX_STICKY.AUTH_MISMATCH_ERR_STICKY"), details: None, lo: 8, hi: 9 });
        fields.insert("BFD_MAX_LEN", Field { brief: Some("As part of the Rx verification of BFD PDUs, the BFD lengh field is compared to the value configured in this bitfield as part of the MAX_LEN test. If the MAX_LEN test fails, the frame is discarded at the following sticky bit is asserted. * VOP_MPLS:VOE_STAT_MPLS:BFD_RX_STICKY.MAX_LEN_ERR_STICKY"), details: None, lo: 0, hi: 8 });
        fields.insert("BFD_RX_SAMPLE_ENA", Field { brief: Some("If enabled the VOE will update the following registers based on the information received in valid BFD CC PDUs: Coordinated / NEIS: * VOP_MPLS:VOE_STAT_MPLS:BFD_SRC_INFO.BFD_REMOTE_STATE_SRC * VOP_MPLS:VOE_STAT_MPLS:BFD_SRC_INFO.BFD_REMOTE_DIAG_SRC * VOP_MPLS:VOE_STAT_MPLS:BFD_SRC_INFO.BFD_REMOTE_DM_SRC FEIS session: * VOP_MPLS:VOE_STAT_MPLS:BFD_SINK_INFO.BFD_REMOTE_STATE_SINK * VOP_MPLS:VOE_STAT_MPLS:BFD_SINK_INFO.BFD_REMOTE_DIAG_SINK * VOP_MPLS:VOE_STAT_MPLS:BFD_SINK_INFO.BFD_REMOTE_DM_SINK The session to which a BFD PDU belongs is determined as part of the BFD Rx verification, based on comparing the BFD PDU Your Discriminator to the values configured in the following bit fields: * VOP_MPLS:VOE_CONF_MPLS:BFD_CONFIG.BFD_COORDINATED_MODE_ENA Coordinated / NEIS session: * VOP_MPLS:VOE_CONF_MPLS:BFD_LOCAL_DISCR_SRC.BFD_LOCAL_DISCR_SRC FEIS session: * VOP_MPLS:VOE_CONF_MPLS:BFD_LOCAL_DISCR_SINK.BFD_LOCAL_DISCR_SINK"), details: None, lo: 18, hi: 19 });
        fields.insert("BFD_RX_VERIFY_CC_ENA", Field { brief: Some("If this field is asserted all incoming BFD CC PDUs will be verified in HW. Deasserting this field will disable all Rx validation of BFD CC PDUs."), details: None, lo: 15, hi: 16 });
        fields.insert("BFD_RX_VERIFY_CV_ENA", Field { brief: Some("If this field is asserted all incoming BFD CV PDUs will be verified in HW. Deasserting this field will disable all Rx validation of BFD CV PDUs."), details: None, lo: 14, hi: 15 });
        fields.insert("BFD_RX_VERIFY_DISCR_ENA", Field { brief: Some("When disabled, the Your/My Discriminator fields of incoming BFD CC/CV PDUs are not verified of BFD CC/CV PDUs. The BFD PDU is assumed to  belong to the Coordinated / NEIS session. When an Rx PDU does not match any of the configured discriminators, the following sticky bit is asserted: * VOP_MPLS:VOE_STAT_MPLS:BFD_RX_STICKY.YOUR_DISCR_ERR_STICKY This test is disabled if: * BFD_RX_VERIFY_CC_ENA = 0 * BFD_RX_VERIFY_CV_ENA = 0 depending on the PDU type."), details: None, lo: 11, hi: 12 });
        fields.insert("BFD_RX_VERIFY_FLAGS_ENA", Field { brief: Some("When enabled, the Rx verification will verify: Detect Mult is ZERO Multipoint asserted Auth Bit matches configured Demand bit is asserted F and P bits are not set in the same frame. If any of the above test fails, the corresponding sticky bit is asserted (VOP_MPLS:VOE_STAT_MPLS:BFD_RX_STICKY.*): * DM_ZERO_ERR_STICKY * M_BIT_SET_ERR_STICKY * AUTH_MISMATCH_ERR_STICKY * D_BIT_SET_ERR_STICKY * P_AND_F_BIT_SET_ERR_STICKY The AUTH-bit testing is further dependent on the following bit fields: * BFD_CC_AUTH_ENA * BFD_CV_AUTH_ENA The FLAGS test is disabled if: * BFD_RX_VERIFY_CC_ENA = 0 * BFD_RX_VERIFY_CV_ENA = 0 depending on the PDU type."), details: None, lo: 10, hi: 11 });
        fields.insert("BFD_RX_VERIFY_MIN_LEN_ENA", Field { brief: Some("If not enabled, the MIN_LEN test will not be done as part of the BFD Rx verification of BFD CC/CV PDUs. This testing will depend on the setting of the following bit fields: * BFD_CC_AUTH_ENA * BFD_CV_AUTH_ENA When an Rx PDU fails the MIN_LEN test, the following sticky bit is asserted: * VOP_MPLS:VOE_STAT_MPLS:BFD_RX_STICKY.MIN_LEN_ERR_STICKY The MIN_LEN test is disabled if: * BFD_RX_VERIFY_CC_ENA = 0 * BFD_RX_VERIFY_CV_ENA = 0 depending on the PDU type."), details: None, lo: 12, hi: 13 });
        fields.insert("BFD_RX_VERIFY_VERSION_ENA", Field { brief: Some("If not enabled, the VERSION test will not be done as part of the BFD Rx verification of BFD CC/CV PDUs. This testing will depend on the setting of the following bit fields: * BFD_CC_AUTH_ENA * BFD_CV_AUTH_ENA When an Rx PDU fails the VERSION test, the following sticky bit is asserted: * VOP_MPLS:VOE_STAT_MPLS:BFD_RX_STICKY.VERSION_ERR_STICKY The VERSION test is disabled if: * BFD_RX_VERIFY_CC_ENA = 0 * BFD_RX_VERIFY_CV_ENA = 0 depending on the PDU type."), details: None, lo: 13, hi: 14 });
        fields.insert("BFD_SCAN_PERIOD", Field { brief: Some("The configuration of this bit field specifies the LOC timeout counter to be used for LOC scan for this VOE. Every time the LOC timeout counter indicated by this register causes a scan, the VOE LOC counter is incremented. The LOC counter is cleared upon reception of a valid BFD CC/CV PDU. The LOC counter is located in the following bit field: * VOP_MPLS:VOE_STAT_MPLS:BFD_STAT.BFD_MISS_CNT"), details: Some("0: Indicates that the LOC counter is not incremented. 1: Indicates that the LOC counter is incremented by LOC timeout counter 0 2: Indicates that the LOC counter is incremented by LOC timeout counter 1 3: Indicates that the LOC counter is incremented by LOC timeout counter 2 4: Indicates that the LOC counter is incremented by LOC timeout counter 3 5: Indicates that the LOC counter is incremented by LOC timeout counter 4 6: Indicates that the LOC counter is incremented by LOC timeout counter 5 7: Indicates that the LOC counter is incremented by LOC timeout counter 6"), lo: 19, hi: 22 });
        fields.insert("BFD_TX_UPDATE_ENA", Field { brief: Some("If enabled, the VOE will update the following fields in the outgoing PDUs when transmitting BFD CC / CV PDUs * BFD.STATE * BFD.DIAG * BFD.DM"), details: None, lo: 17, hi: 18 });
        regs.insert("BFD_CONFIG", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("MPLS-TP BFD configuration."), details: Some("This register contains misc. bit fields used to figure the BFD session monitored by the VOE."), fields });
        let mut fields = HashMap::new();
        fields.insert("BFD_LOCAL_DISCR_SINK", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("BFD_LOCAL_DISCR_SINK", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("BFD Local Discriminator (BFD_SINK)"), details: Some("The Discriminator of the Local BFD Sink. Only used if the BFD session is configured for Independent Mode: * VOP_MPLS:VOE_CONF_MPLS:BFD_CONFIG.BFD_COORDINATED_MODE_ENA = 0"), fields });
        let mut fields = HashMap::new();
        fields.insert("BFD_LOCAL_DISCR_SRC", Field { brief: Some("See the register description."), details: None, lo: 0, hi: 32 });
        regs.insert("BFD_LOCAL_DISCR_SRC", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("BFD Local Discriminator (BFD_SRC)"), details: Some("The Discriminator of the Local BFD Source."), fields });
        let mut fields = HashMap::new();
        fields.insert("BFD_REMOTE_DISCR_SRC", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("BFD_REMOTE_DISCR_SRC", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("BFD Remote Discriminator (BFD_SRC)"), details: Some("The Discriminator of the remote BFD entity communicating with the Local BFD Source"), fields });
        let mut fields = HashMap::new();
        fields.insert("BFD_CC_CPU_COPY_ENA", Field { brief: Some("If asserted all valid BFD CC PDUs received by the VOE are extracted to the CPU. Extraction queue is determined by: * VOP::CPU_EXTR_MPLS.BFD_CC_CPU_QU"), details: Some("'0': No extraction to CPU '1': Extract valid BFD CC PDUs to CPU"), lo: 1, hi: 2 });
        fields.insert("BFD_CV_CPU_COPY_ENA", Field { brief: Some("If asserted all valid BFD CV PDUs received by the VOE are extracted to the CPU. Extraction queue is determined by: * VOP::CPU_EXTR_MPLS.BFD_CV_CPU_QU"), details: Some("'0': No extraction to CPU '1': Extract valid BFD CV frames to CPU"), lo: 0, hi: 1 });
        fields.insert("GENERIC_COPY_MASK", Field { brief: Some("This bit field contains 8 bits each of which represent one of the Generic G-ACH Channel Types. If the bit representing a specific Generic G-ACH Channel Type is asserted, all valid PDUs received by the VOE of that type are extracted to the CPU queue configured in the following bit fields: * VOP::MPLS_GENERIC_CODEPOINT.GENERIC_CODEPOINT_CPU_QU"), details: Some("x0x: No CPU copy x1x: Copy to CPU"), lo: 3, hi: 11 });
        fields.insert("UNK_CPT_CPU_COPY_ENA", Field { brief: Some("Configures whether MPLS-TP OAM PDUs with UNKNOWN G-ACH Channel Type should be extracted to the CPU. Extracted frames are extracted to the default CPU queue, configured in: * VOP::CPU_EXTR_CFG.DEF_COPY_QU"), details: Some("'0': No CPU copy '1': Copy to CPU"), lo: 2, hi: 3 });
        regs.insert("CPU_COPY_CTRL_MPLS", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("CPU extraction for the supported MPLS-TP OAM G-ACH Channel Types."), details: Some("Configures CPU copy for the supported MPLS-TP PDU G-ACH Channel Types. Configuring a PDU type for CPU extraction, will result in all valid OAM PDUs of this type to extracted to the CPU. The PDU will be extsracted to the extraction queue configured for the G-ACH Channel Type in the following registers: * VOP::CPU_EXTR_MPLS.* Invalid OAM PDUs are not extracted based on the configuration in this register group. OAM PDUs are considered invalid if they fail either of the following checks: * Protocol Specific verification (E.g. BFD Rx / Tx verification)"), fields });
        let mut fields = HashMap::new();
        fields.insert("BFD_CC_CNT_DATA_ENA", Field { brief: Some("Enable / disable count of valid BFD CC OAM PDUs as part of the LM counters."), details: Some("'0': Do not count as data '1': Count as data"), lo: 1, hi: 2 });
        fields.insert("BFD_CV_CNT_DATA_ENA", Field { brief: Some("Enable / disable count of valid BFD CV OAM PDUs as part of the LM counters."), details: Some("'0': Do not count as data '1': Count as data"), lo: 0, hi: 1 });
        fields.insert("GENERIC_CPT_CNT_DATA_MASK", Field { brief: Some("Enable / disable that valid MPLS-TP OAM PDUs with Generic G-ACH Channel Type are counted by the VOE LM counters. This bit field contains a separate bit for each of the possible 8 Generic G-ACH Channel Types."), details: Some("x0x: Do NOT count generic Channel Type in LM counters. x1x: DO count generic Channel Type in LM counters."), lo: 3, hi: 11 });
        fields.insert("UNK_CPT_CNT_DATA_ENA", Field { brief: Some("If a PDU is received with an G-ACH Channel Type which does not match any Specific G-ACH Channel Type or a Generic G-ACH Channel Type, it will be processed as an UNKNOWN G-ACH Channel Type. This bit field configures if OAM frames with UNKNOWN G-ACH Channel Type are counted as data in the LM counters."), details: Some("'0': Do not count as data '1': Count as data"), lo: 2, hi: 3 });
        regs.insert("OAM_CNT_DATA_MPLS", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("Configuration of which OAM PDUs should be counted by LM counters."), details: Some("Default behavior is that all MPLS-TP OAM PDUs processed by a VOE will not be counted as part of the LM count. Using this register (OAM_CNT_DATA_MPLS) it is possible to configure the OAM PDUs separately to be counted as part of the LM count. Frames are counted separately in the Rx and Tx direction. The data counters are located: Service VOE: --------------------- Egress: REW:VOE_SRV_LM_CNT.SRV_LM_CNT_LSB.SRV_LM_CNT_LSB Ingress: ANA_AC_OAM_MOD:VOE_SRV_LM_CNT.SRV_LM_CNT_LSB.SRV_LM_CNT_LSB Port VOE: ------------------- Egress: REW:VOE_PORT_LM_CNT:PORT_LM_CNT_LSB.PORT_LM_CNT_LSB Ingress: ANA_AC_OAM_MOD:VOE_PORT_LM_CNT:PORT_LM_CNT_LSB.PORT_LM_CNT_LSB"), fields });
        let mut fields = HashMap::new();
        fields.insert("BFD_CC_CNT_SEL_ENA", Field { brief: Some("This register configures whether valid BFD CC PDUs are counted Selected OAM or NON Selected OAM."), details: Some("'0': Count as other OAM '1': Count as selected OAM"), lo: 1, hi: 2 });
        fields.insert("BFD_CV_CNT_SEL_ENA", Field { brief: Some("This register configures whether valid BFD CV PDUs are counted Selected OAM or NON Selected OAM."), details: Some("'0': Count as other OAM '1': Count as selected OAM"), lo: 0, hi: 1 });
        fields.insert("GENERIC_CPT_CNT_SEL_MASK", Field { brief: Some("Enable / disable that valid OAM PDUs with Generic G-ACH Channel Type are counted as selected OAM. This bit field contains a separate bit for each of the possible 8 Generic opcodes."), details: Some("x0x: Count as other OAM x1x: Count as selected OAM"), lo: 3, hi: 11 });
        fields.insert("UNK_CPT_CNT_SEL_ENA", Field { brief: Some("MPLS-TP OAM PDUs not recognized as either one of the PDUs with special configuration or as a Generic G-ACH Channel Type, will be classified as an UNKNOWN PDU. This register configures whether UNKNOWN PDUs should be counted as selected OAM."), details: Some("'0': Count as other OAM '1': Count as selected OAM"), lo: 2, hi: 3 });
        regs.insert("OAM_CNT_SEL_MPLS", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Configuration which MPLS-TP Channel Types are counted in selected PDU counter."), details: Some("The OAM frames processed by the VOE can be counted separately in Rx and Tx direction. In each direction there are two counters: 1) Selected OAM counter: -------------------------------------------------------- This counter counts all the PDU types selected for counting using the OAM_CNT_SEL_MPLS register: * VOP_MPLS:VOE_STAT_MPLS:RX_CNT_SEL_OAM_MPLS * VOP_MPLS:VOE_STAT_MPLS:TX_CNT_SEL_OAM_MPLS 2) NON Selected OAM counter: -------------------------------------------------------- * VOP_MPLS:VOE_STAT_MPLS:RX_CNT_NON_SEL_OAM_MPLS * VOP_MPLS:VOE_STAT_MPLS:TX_CNT_NON_SEL_OAM_MPLS Any valid OAM PDU is counted in exactly one of the above registers. I.e. as default all OAM PDUs are not selected, and they are all counted in the default OAM counters: RX / TX_CNT_NON_SEL_OAM_MPLS. Using this register (OAM_CNT_SEL_MPLS), PDUs can be moved to the selected counters: RX / TX_CNT_SEL_OAM_MPLS. The selection of OAM PDUs for the selected counter is done commonly for the Tx and Rx direction."), fields });
        let mut fields = HashMap::new();
        fields.insert("BFD_CC_ENA", Field { brief: Some("Enable HW processing of valid BFD CC PDUs received by the VOE in both the Tx and the Rx direction. If this is disabled, no verification of the YourDiscriminator is done of the incoming BFD CC PDUs. All Rx PDUs will be processed as belonging to the Coordinated Mode. I.e. a BFD CC PDUs will never be processed as belonging to the FEIS Session."), details: None, lo: 1, hi: 2 });
        fields.insert("BFD_CV_ENA", Field { brief: Some("Enable HW processing of valid BFD CV PDUs received by the VOE in both the Tx and the Rx direction. If this is disabled, no verification of the YourDiscriminator is done of the incoming BFD CV PDUs. All Rx PDUs will be processed as belonging to the Coordinated Mode. I.e. a BFD CV PDUs will never be processed as belonging to the FEIS Session."), details: None, lo: 0, hi: 1 });
        regs.insert("OAM_HW_CTRL_MPLS", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("OAM HW processing control"), details: Some("Configures per MPLS-TP G-ACH Channel Type if it is processed by VOE hardware. If an MPLS-TP OAM type is not enabled in this register, the OAM PDU will not be modified by the VOE. This implies that the OAM PDU is not updated. However, note the following: * The Rx sticky bits will be set for a PDU, even when the HW processing is not enabled. * OAM PDU can be extracted to the CPU, even when HW processing is not enabled. * LM counters will be updated. * SEL / non SEL counters are updated."), fields });
        let mut fields = HashMap::new();
        fields.insert("PATH_VOEID", Field { brief: Some("Assigns a Path VOE to the VOE. Must be enabled by: PATH_VOE_ENA = 1"), details: None, lo: 0, hi: 10 });
        fields.insert("PATH_VOE_ENA", Field { brief: Some("Configures if a service VOE is part of a Path VOE."), details: None, lo: 10, hi: 11 });
        regs.insert("PATH_VOE_MPLS", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("Path MEP configuration"), details: Some("This register is used to assign a Path VOE to the current service VOE. Assigning a Path VOE to a Service VOE implies that all frames received by this VOE, will also be counted by the Path VOE. The VOE index of the Path VOE is configured by the following bit field: * PATH_VOEID The path VOE must be enabled by asserting the following field: * PATH_VOE_ENA"), fields });
        let mut fields = HashMap::new();
        fields.insert("UPMEP_ENA", Field { brief: Some("Configures VOE for Down-MEP or Up-MEP functionality. Note: Port VOE may NOT be configured for Up-MEP functionality, they only support Down-MEP implementation."), details: None, lo: 1, hi: 2 });
        fields.insert("VOE_ENA", Field { brief: Some("Enables VOE functionality. When the VOE is not enabled, it will not do any OAM processing or update statistics. The VOE can be configured while not enabled."), details: None, lo: 2, hi: 3 });
        fields.insert("VOE_IS_PATH", Field { brief: Some("If another VOE is pointing to this VOE as a Path VOE using the following configuration: * VOP_MPLS:VOE_CONF_MPLS:PATH_VOE_MPLS.PATH_VOEID * VOP_MPLS:VOE_CONF_MPLS:PATH_VOE_MPLS.PATH_VOE_ENA this register MUST be set to '1'. If not this register must be set to '0'."), details: None, lo: 0, hi: 1 });
        regs.insert("VOE_CTRL_MPLS", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Misc. VOE control configuration"), details: Some("This register includes configuration of misc. VOE control properties."), fields });
        groups.insert("VOE_CONF_MPLS", RegisterGroup { addr: Address { base: 65536, count: 1077, width: 16 }, desc: "Configuration per Vitesse OAM MEP Endpoints (VOE) for MPLS-TP OAM", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("BFD_CC_RX_INVLD_CNT", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("BFD_CC_RX_INVLD_CNT_REG", Register { addr: Address { base: 18, count: 1, width: 1 }, brief: Some("Invalid BFD CC Rx count."), details: Some("The number of invalid BFD CC PDUs received by the VOE. Invalid PDUs are Rx BFD CC PDUs which are discarded due to failing the BFD Rx verification."), fields });
        let mut fields = HashMap::new();
        fields.insert("BFD_CC_RX_VLD_CNT", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("BFD_CC_RX_VLD_CNT_REG", Register { addr: Address { base: 16, count: 1, width: 1 }, brief: Some("Valid BFD CC Rx count."), details: Some("The number of valid BFD CC PDUs received by the VOE."), fields });
        let mut fields = HashMap::new();
        fields.insert("BFD_CC_TX_CNT", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("BFD_CC_TX_CNT_REG", Register { addr: Address { base: 14, count: 1, width: 1 }, brief: Some("Valid BFD CC Tx count."), details: Some("The number of BFD CC PDUs transmitted by the VOE."), fields });
        let mut fields = HashMap::new();
        fields.insert("BFD_CV_RX_INVLD_CNT", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("BFD_CV_RX_INVLD_CNT_REG", Register { addr: Address { base: 19, count: 1, width: 1 }, brief: Some("Invalid BFD CV Rx count."), details: Some("The number of invalid BFD CV PDUs received by the VOE. Invalid PDUs are Rx BFD CV PDUs which are discarded due to failing the BFD Rx verification."), fields });
        let mut fields = HashMap::new();
        fields.insert("BFD_CV_RX_VLD_CNT", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("BFD_CV_RX_VLD_CNT_REG", Register { addr: Address { base: 17, count: 1, width: 1 }, brief: Some("Valid BFD CV Rx count."), details: Some("The number of valid BFD CV PDUs received by the VOE."), fields });
        let mut fields = HashMap::new();
        fields.insert("BFD_CV_TX_CNT", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("BFD_CV_TX_CNT_REG", Register { addr: Address { base: 15, count: 1, width: 1 }, brief: Some("Valid BFD CV Tx count."), details: Some("The number of BFD CV PDUs transmitted by the VOE."), fields });
        let mut fields = HashMap::new();
        fields.insert("BFD_REMOTE_DISCR_SINK", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("BFD_REMOTE_DISCR_SINK", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("BFD Remote Discriminator (BFD_SINK)"), details: Some("The Discriminator of the remote BFD entity communicating with the Local BFD Sink. Only used if the BFD session is configured for Independent Mode: * VOP_MPLS:VOE_CONF_MPLS:BFD_CONFIG.BFD_COORDINATED_MODE_ENA = 0"), fields });
        let mut fields = HashMap::new();
        fields.insert("BFD_LOC_DEFECT", Field { brief: Some("Contains the current LOC state. When this value is changed (by LOC timer or Rx of valid BFD CC/CV) a sticky bit is asserted: * VOP_MPLS:VOE_STAT_MPLS:INTR_STICKY_MPLS.BFD_LOC_CHANGE_STICKY An interrupt may optionally be generated: * VOP_MPLS:VOE_STAT_MPLS:INTR_ENA_MPLS.BFD_LOC_CHANGE_INT_ENA"), details: None, lo: 0, hi: 1 });
        regs.insert("BFD_RX_LAST", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("Result of previous BFD testing"), details: Some("To detect changes in certain BFD states, this register stores the values of the testing of the previous BFD PDU."), fields });
        let mut fields = HashMap::new();
        fields.insert("AUTH_MISMATCH_ERR_STICKY", Field { brief: Some("Sticky bit asserted if an incoming BFD PDU fails the AUTH_MISMATCH test. The VOE is configured with the expected value of the incoming BFD PDUs: BFD CC: * VOP_MPLS:VOE_CONF_MPLS:BFD_CONFIG.BFD_CC_AUTH_ENA BFD CV: * VOP_MPLS:VOE_CONF_MPLS:BFD_CONFIG.BFD_CV_AUTH_ENA The AUTH_MISMATCH test will fail if the incoming BFD PDUs AUTH bit does not match the configured value."), details: None, lo: 2, hi: 3 });
        fields.insert("DM_ZERO_ERR_STICKY", Field { brief: Some("Sticky bit asserted if an incoming Rx BFD PDU fails the DM_ZERO test: Incoming Rx BFD PDUs are discarded if the Detect Mult field is ZERO."), details: None, lo: 6, hi: 7 });
        fields.insert("D_BIT_SET_ERR_STICKY", Field { brief: Some("Sticky bit is asserted if an Rx BFD PDU fails the D_BIT_SET test. Frames failing this test are discarded. The D_BIT_SET test will fail if a BFD PDU is received with the D bit = 1."), details: None, lo: 1, hi: 2 });
        fields.insert("MAX_LEN_ERR_STICKY", Field { brief: Some("Sticky bit asserted if an incoming BFD frame fails the MAX_LEN test. The MAX_LEN will discard incoming BFD PDUs if the LENGTH field in the BFD PDU is larger than the configured MAX_LEN: * VOP_MPLS:VOE_CONF_MPLS:BFD_CONFIG.BFD_MAX_LEN"), details: None, lo: 7, hi: 8 });
        fields.insert("MIN_LEN_ERR_STICKY", Field { brief: Some("Sticky bit asserted if an incoming BFD frame fails the MIN_LEN test. MIN_LEN test will discard incoming BFD frames based on the value of the AUTH bit and the LENGTH field in the BFD PDU: AUTH = 0: Discard PDU if LENGTH < 24 bytes AUTH = 1: Discard PDU if LENGTH < 26 bytes"), details: None, lo: 8, hi: 9 });
        fields.insert("MY_DISCR_ERR_STICKY", Field { brief: Some("Sticky bit asserted if an incoming Rx BFD PDU is discarded because it fails the MY_DISCR verification. The MY_DISCR test will match the My Discriminator field in the Rx BFD PDU, based on which session the BFD PDU belongs to. Coordinated or NEIS session: * VOP_MPLS:VOE_CONF_MPLS:BFD_REMOTE_DISCR_SRC.BFD_REMOTE_DISCR_SRC FEIS session: * VOP_MPLS:VOE_CONF_MPLS:BFD_REMOTE_DISCR_SINK.BFD_REMOTE_DISCR_SINK The session is determined based on matching the BFD PDU Your Discriminator against the following values: * VOP_MPLS:VOE_CONF_MPLS:BFD_LOCAL_DISCR_SRC.BFD_LOCAL_DISCR_SRC * VOP_MPLS:VOE_CONF_MPLS:BFD_LOCAL_DISCR_SINK.BFD_LOCAL_DISCR_SINK"), details: None, lo: 4, hi: 5 });
        fields.insert("M_BIT_SET_ERR_STICKY", Field { brief: Some("Sticky bit asserted if an incoming BFD PDU fails the M_BIT_SET test. Incoming Rx BFD PDUs are discarded if the M bit is set."), details: None, lo: 5, hi: 6 });
        fields.insert("P_AND_F_BIT_SET_ERR_STICKY", Field { brief: Some("Sticky bit is asserted if an Rx BFD PDU fails the P_AND_F_BIT_SET test. Frames failing this test are discarded. The P_AND_F_BIT_SET fails if a BFD PDU is received with both the Poll Flag = 1 and the Final flag = 1"), details: None, lo: 0, hi: 1 });
        fields.insert("VERSION_ERR_STICKY", Field { brief: Some("Sticky bit is asserted when a frame is discarded because the BFD_CC/CV.VERSION field does not match the value configured in the following register: * VOP::VERSION_CTRL_MPLS.BFD_VERSION"), details: None, lo: 9, hi: 10 });
        fields.insert("YOUR_DISCR_ERR_STICKY", Field { brief: Some("Sticky bit asserted if an incoming BFD PDU fails the YOUR_DISCR test. The YOUR_DISCR test will match the Your Discriminator field of the Rx BFD PDU against the values configured in the following registers, to determine which session the BFD PDU belongs to: Coordinated or NEIS session: * VOP_MPLS:VOE_CONF_MPLS:BFD_LOCAL_DISCR_SRC.BFD_LOCAL_DISCR_SRC FEIS session: * VOP_MPLS:VOE_CONF_MPLS:BFD_LOCAL_DISCR_SINK.BFD_LOCAL_DISCR_SINK The match will depend on the configuration of the following bit field: * VOP_MPLS:VOE_CONF_MPLS:BFD_CONFIG.BFD_COORDINATED_MODE_ENA"), details: None, lo: 3, hi: 4 });
        regs.insert("BFD_RX_STICKY", Register { addr: Address { base: 12, count: 1, width: 1 }, brief: Some("BFD Rx verification sticky bits."), details: Some("This register contains a sticky bit for each of the tests performed as part of the BFD Rx PDU validation. Frames causing the sticky to be asserted will be discarded if not extracted to the CPU. The extraction of BFD PDUs is configured in the following register: * VOP_MPLS:VOE_STAT_MPLS:PDU_EXTRACT_MPLS.* Notice that the Rx verification depends on the following registers: * VOP_MPLS:VOE_CONF_MPLS:BFD_CONFIG.BFD_RX_VERIFY_* PDUs faling the Rx verification can optionally be extracted by configuring the following bit field: * VOP_MPLS:VOE_STAT_MPLS:PDU_EXTRACT_MPLS.BFD_RX_ERR_EXTR"), fields });
        let mut fields = HashMap::new();
        fields.insert("BFD_LOCAL_DIAG_SINK", Field { brief: Some("BFD diagnostic code of the Local BFD_SINK. This register is configured by SW - never updated by VOE. If configured to do so, the VOE will write this value into all valid Tx BFD CC/CV PDUs DIAG field transmitted by the BFD_SINK. The VOE will update the Tx PDUs based on the following configuration: * VOP_MPLS:VOE_CONF_MPLS:BFD_CONFIG.BFD_TX_UPDATE_ENA"), details: Some("See RFC6428"), lo: 21, hi: 26 });
        fields.insert("BFD_LOCAL_DM_SINK", Field { brief: Some("BFD Detect Mult of the Local BFD_SINK. This register is configured by SW - never updated by VOE. If configured to do so, the VOE will write this value into all valid Tx BFD CC/CV PDUs DETECT MULT field transmitted by the BFD_SINK. The VOE will update the Tx PDUs based on the following configuration: * VOP_MPLS:VOE_CONF_MPLS:BFD_CONFIG.BFD_TX_UPDATE_ENA"), details: None, lo: 8, hi: 16 });
        fields.insert("BFD_LOCAL_STATE_SINK", Field { brief: Some("BFD State of the Local BFD_SINK. This register is configured by SW - never updated by VOE. If configured to do so, the VOE will write this value into all valid Tx BFD CC/CV PDUs STATE field of all PDUs transmitted by the BFD_SINK. The VOE will update the Tx PDUs based on the following configuration: * VOP_MPLS:VOE_CONF_MPLS:BFD_CONFIG.BFD_TX_UPDATE_ENA"), details: Some("00 - AdminDown 01 - Down 10 - Init 11 - Up"), lo: 28, hi: 30 });
        fields.insert("BFD_REMOTE_DIAG_SINK", Field { brief: Some("BFD diagnostic code of the remote BFD entity communicating with the Local BFD_SINK. If configured to do so, the VOE HW will update this bit field with the DIAG CODE value of the last valid BFD CC PDU received by the BFD_SINK. Updating this bit field is enabled by the following configuration: * VOP_MPLS:VOE_CONF_MPLS:BFD_CONFIG.BFD_RX_SAMPLE_ENA"), details: Some("See RFC6428"), lo: 16, hi: 21 });
        fields.insert("BFD_REMOTE_DM_SINK", Field { brief: Some("BFD Detect Mult of the remote BFD entity communicating with the Local BFD_SINK. If configured to do so, the VOE HW will update this bit field with the Detect Mult value of the last valid BFD CC PDU received by the BFD_SINK. Updating this bit field is enabled by the following configuration: * VOP_MPLS:VOE_CONF_MPLS:BFD_CONFIG.BFD_RX_SAMPLE_ENA"), details: None, lo: 0, hi: 8 });
        fields.insert("BFD_REMOTE_STATE_SINK", Field { brief: Some("BFD State of the remote BFD entity communicating with the Local BFD_SINK If configured to do so, the VOE HW will update this bit field with the value of the last valid BFD CC PDU received by the BFD_SINK. Updating this bit field is enabled by the following configuration: * VOP_MPLS:VOE_CONF_MPLS:BFD_CONFIG.BFD_RX_SAMPLE_ENA"), details: Some("00 - AdminDown 01 - Down 10 - Init 11 - Up"), lo: 26, hi: 28 });
        regs.insert("BFD_SINK_INFO", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("BFD info related to the Local BFD Sink session (BFD_SINK)"), details: Some("Misc. configuration related to the Local BFD Sink (BFD_SINK). The bit fields in this register are only used when the BFD session is configured for Independent Mode: * VOP_MPLS:VOE_CONF_MPLS:BFD_CONFIG.BFD_COORDINATED_MODE_ENA = 0"), fields });
        let mut fields = HashMap::new();
        fields.insert("BFD_LOCAL_DIAG_SRC", Field { brief: Some("BFD diagnostic code of the Local BFD_SRC. This register is configured by SW - never updated by VOE. If configured to do so, the VOE will write this value into all valid Tx BFD CC/CV PDUs DIAG field transmitted by the BFD_SRC. The VOE will update the Tx PDUs based on the following configuration: * VOP_MPLS:VOE_CONF_MPLS:BFD_CONFIG.BFD_TX_UPDATE_ENA"), details: Some("See RFC6428"), lo: 21, hi: 26 });
        fields.insert("BFD_LOCAL_DM_SRC", Field { brief: Some("BFD Detect Mult of the Local BFD_SRC. This register is configured by SW - never updated by VOE. If configured to do so, the VOE will write this value into all valid Tx BFD CC/CV PDUs DETECT MULT field transmitted by the BFD_SRC. The VOE will update the Tx PDUs based on the following configuration: * VOP_MPLS:VOE_CONF_MPLS:BFD_CONFIG.BFD_TX_UPDATE_ENA"), details: None, lo: 8, hi: 16 });
        fields.insert("BFD_LOCAL_STATE_SRC", Field { brief: Some("BFD State of the Local BFD_SRC. This register is configured by SW - never updated by VOE. If configured to do so, the VOE will write this value into all valid Tx BFD CC/CV PDUs STATE field transmitted by the BFD_SRC. The VOE will update the Tx PDUs based on the following configuration: * VOP_MPLS:VOE_CONF_MPLS:BFD_CONFIG.BFD_TX_UPDATE_ENA"), details: Some("00 - AdminDown 01 - Down 10 - Init 11 - Up"), lo: 28, hi: 30 });
        fields.insert("BFD_REMOTE_DIAG_SRC", Field { brief: Some("BFD diagnostic code of the remote BFD entity communicating with the Local BFD_SRC. If configured to do so, the VOE HW will update this bit field with the DIAG CODE value of the last valid BFD CC PDU received by the BFD_SRC. Updating this bit field is enabled by the following configuration: * VOP_MPLS:VOE_CONF_MPLS:BFD_CONFIG.BFD_RX_SAMPLE_ENA"), details: Some("See RFC6428"), lo: 16, hi: 21 });
        fields.insert("BFD_REMOTE_DM_SRC", Field { brief: Some("BFD Detect Mult of the remote BFD entity communicating with the Local BFD_SRC. If configured to do so, the VOE HW will update this bit field with the Detect Mult value of the last valid BFD CC PDU received by the BFD_SRC. Updating this bit field is enabled by the following configuration: * VOP_MPLS:VOE_CONF_MPLS:BFD_CONFIG.BFD_RX_SAMPLE_ENA"), details: None, lo: 0, hi: 8 });
        fields.insert("BFD_REMOTE_STATE_SRC", Field { brief: Some("BFD State of the remote BFD entity communicating with the Local BFD_SRC. If configured to do so, the VOE HW will update this bit field with the value of the last valid BFD CC PDU received by the BFD_SRC. Updating this bit field is enabled by the following configuration: * VOP_MPLS:VOE_CONF_MPLS:BFD_CONFIG.BFD_RX_SAMPLE_ENA"), details: Some("00 - AdminDown 01 - Down 10 - Init 11 - Up"), lo: 26, hi: 28 });
        regs.insert("BFD_SRC_INFO", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("BFD info related to the Local BFD Source session (BFD_SRC)"), details: Some("Misc. configuration related to the Local BFD Source (BFD_SRC)."), fields });
        let mut fields = HashMap::new();
        fields.insert("BFD_MISS_CNT", Field { brief: Some("BFD Loss of Continuity (LOC) Counter. This counter is incremented by the LOC SCAN timer programmed in the following bit field: * VOP_MPLS:VOE_CONF_MPLS:BFD_CONFIG.BFD_SCAN_PERIOD The LOC counter is cleared every time a valid BFD CC/CV PDU is received. The VOE will generate a LOC event when the BFD_MISS_CNT is equal to the value in the relevant Detect Multiplier. Which Detect Multiplier is used depends on whether the BFD session is configured for \"Coordinated Mode\" or \"Independent Mode\"."), details: None, lo: 0, hi: 9 });
        regs.insert("BFD_STAT", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("BFD statistics"), details: Some("Register contains misc. BFD related statistics."), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_MY_DISCR_MISMATCH", Field { brief: Some("Sticky bit asserted if a BFD PDU is transmitted by a VOE and the VOE is configured to update the BFD PDU: * VOP_MPLS:VOE_CONF_MPLS:BFD_CONFIG.BFD_TX_UPDATE_ENA and the Tx BFD PDU My Discriminator value does not match any of the configured BFD Discriminator Values: Coordinated or NEIS session: * VOP_MPLS:VOE_CONF_MPLS:BFD_LOCAL_DISCR_SRC.BFD_LOCAL_DISCR_SRC FEIS session: * VOP_MPLS:VOE_CONF_MPLS:BFD_LOCAL_DISCR_SINK.BFD_LOCAL_DISCR_SINK The type of sesssion must be configured using the following bit field: * VOP_MPLS:VOE_CONF_MPLS:BFD_CONFIG.BFD_COORDINATED_MODE_ENA"), details: None, lo: 0, hi: 1 });
        regs.insert("BFD_TX_STICKY", Register { addr: Address { base: 13, count: 1, width: 1 }, brief: Some("BFD Tx verification sticky bits."), details: Some("This register contains sticky bits indicating the different Tx errors detected by the VOE."), fields });
        let mut fields = HashMap::new();
        fields.insert("BFD_CC_RX_STICKY", Field { brief: Some("Asserted when the VOE receives a valid BFD CC PDU."), details: Some("'0': No Valid BFD CC PDU received '1': Valid BFD CC received"), lo: 1, hi: 2 });
        fields.insert("BFD_CV_RX_STICKY", Field { brief: Some("Asserted when the VOE receives a valid BFD CV PDU"), details: Some("'0': No Valid BFD CV PDU received '1': Valid BFD CV received"), lo: 0, hi: 1 });
        fields.insert("GENERIC_CPT_RX_STICKY_MASK", Field { brief: Some("Asserted when VOE receives a valid OAM PDU with an G-ACH Channel Type which is configured as a Generic G-ACH Channel Type in the following register: * VOP::MPLS_GENERIC_CODEPOINT.GENERIC_CODEPOINT_VAL There is a separate bit to indicate the reception of each of the configured Generic G-ACH Channel Types."), details: Some("x0x: No CPU copy x1x: Copy to CPU"), lo: 3, hi: 11 });
        fields.insert("UNK_CPT_RX_STICKY", Field { brief: Some("Asserted when VOE receives a valid MPLS-TP OAM PDU with an G-ACH Channel Type which is detected as UNKNOWN. UNKNOWN G-ACH Channel Type is used for OAM PDU types which do not have dedicated HW support and which is not encoded as a Generic G-ACH Channel Type."), details: Some("'0': No UNKNOWN PDU received. '1': PDU with UNKNOWN Channel Type received."), lo: 2, hi: 3 });
        regs.insert("CPT_RX_STICKY_MPLS", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("Rx Sticky bits"), details: Some("Sticky bits are asserted when a valid MPLS-TP OAM PDU is received by the VOE. The G-ACH Channel Type specific Rx sticky bits: * \"xxx\"_RX_STICKY will be asserted even when the PDU is not enabled (VOP_MPLS:VOE_CONF_MPLS:OAM_HW_CTRL_MPLS.*), to allow detecting PDU types which are not expected."), fields });
        let mut fields = HashMap::new();
        fields.insert("BFD_LOC_CHANGE_INT_ENA", Field { brief: Some("When asserted, the following sticky bit will cause a VOE interrupt: * VOP_MPLS:VOE_STAT_MPLS:INTR_STICKY_MPLS.BFD_LOC_CHANGE_STICKY"), details: None, lo: 10, hi: 11 });
        fields.insert("BFD_RX_DIAG_CHANGE_SINK_INT_ENA", Field { brief: Some("When asserted, the following sticky bit will cause a VOE interrupt: * VOP_MPLS:VOE_STAT_MPLS:INTR_STICKY_MPLS.BFD_RX_DIAG_CHANGE_SINK_STICKY"), details: None, lo: 2, hi: 3 });
        fields.insert("BFD_RX_DIAG_CHANGE_SRC_INT_ENA", Field { brief: Some("When asserted, the following sticky bit will cause a VOE interrupt: * VOP_MPLS:VOE_STAT_MPLS:INTR_STICKY_MPLS.BFD_RX_DIAG_CHANGE_SRC_STICKY"), details: None, lo: 7, hi: 8 });
        fields.insert("BFD_RX_DM_CHANGE_SINK_INT_ENA", Field { brief: Some("When asserted, the following sticky bit will cause a VOE interrupt: * VOP_MPLS:VOE_STAT_MPLS:INTR_STICKY_MPLS.BFD_RX_DM_CHANGE_SINK_STICKY"), details: None, lo: 4, hi: 5 });
        fields.insert("BFD_RX_DM_CHANGE_SRC_INT_ENA", Field { brief: Some("When asserted, the following sticky bit will cause a VOE interrupt: * VOP_MPLS:VOE_STAT_MPLS:INTR_STICKY_MPLS.BFD_RX_DM_CHANGE_SRC_STICKY"), details: None, lo: 9, hi: 10 });
        fields.insert("BFD_RX_F_SET_SINK_INT_ENA", Field { brief: Some("When asserted, the following sticky bit will cause a VOE interrupt: * VOP_MPLS:VOE_STAT_MPLS:INTR_STICKY_MPLS.BFD_RX_F_SET_SINK_STICKY"), details: None, lo: 0, hi: 1 });
        fields.insert("BFD_RX_F_SET_SRC_INT_ENA", Field { brief: Some("When asserted, the following sticky bit will cause a VOE interrupt: * VOP_MPLS:VOE_STAT_MPLS:INTR_STICKY_MPLS.BFD_RX_F_SET_SRC_STICKY"), details: None, lo: 5, hi: 6 });
        fields.insert("BFD_RX_P_SET_SINK_INT_ENA", Field { brief: Some("When asserted, the following sticky bit will cause a VOE interrupt: * VOP_MPLS:VOE_STAT_MPLS:INTR_STICKY_MPLS.BFD_RX_P_SET_SINK_STICKY"), details: None, lo: 1, hi: 2 });
        fields.insert("BFD_RX_P_SET_SRC_INT_ENA", Field { brief: Some("When asserted, the following sticky bit will cause a VOE interrupt: * VOP_MPLS:VOE_STAT_MPLS:INTR_STICKY_MPLS.BFD_RX_P_SET_SRC_STICKY"), details: None, lo: 6, hi: 7 });
        fields.insert("BFD_RX_STATE_CHANGE_SINK_INT_ENA", Field { brief: Some("When asserted, the following sticky bit will cause a VOE interrupt: * VOP_MPLS:VOE_STAT_MPLS:INTR_STICKY_MPLS.BFD_RX_STATE_CHANGE_SINK_STICKY"), details: None, lo: 3, hi: 4 });
        fields.insert("BFD_RX_STATE_CHANGE_SRC_INT_ENA", Field { brief: Some("When asserted, the following sticky bit will cause a VOE interrupt: * VOP_MPLS:VOE_STAT_MPLS:INTR_STICKY_MPLS.BFD_RX_STATE_CHANGE_SRC_STICKY"), details: None, lo: 8, hi: 9 });
        regs.insert("INTR_ENA_MPLS", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("Sticky bit interrupt enable"), details: Some("The bitfields in this register are interrupt enable for the corresponding sticky bits in the following register: * VOP_MPLS:VOE_STAT_MPLS:INTR_STICKY_MPLS.* If an interrupt is enabled, the interrupt is asserted when the corresponding sticky bit is asserted."), fields });
        let mut fields = HashMap::new();
        fields.insert("BFD_LOC_CHANGE_STICKY", Field { brief: Some("This sticky bit is asserted when the VOE Loss of Continuity (LOC) detect state changes. The following two events will cause the assertion of this sticky bit: * The BFD_MISS_CNT is increased to 2 x the session Detect Mult (LOC detection). * A valid BFD CC/CV PDU is received by the VOE which is in LOC state."), details: None, lo: 10, hi: 11 });
        fields.insert("BFD_RX_DIAG_CHANGE_SINK_STICKY", Field { brief: Some("When the BFD Sink receives a valid BFD CC PDU, this sticky bit is asserted if the 'Diag' value in the Rx BFD CC PDU is different from the previous value received. The previous value is stored in: * VOP_MPLS:VOE_STAT_MPLS:BFD_SINK_INFO.BFD_REMOTE_DIAG_SINK This event will generate an interrupt if so enabled in: * VOP_MPLS:VOE_STAT_MPLS:INTR_ENA_MPLS.BFD_RX_DIAG_CHANGE_SINK_INT_ENA"), details: None, lo: 2, hi: 3 });
        fields.insert("BFD_RX_DIAG_CHANGE_SRC_STICKY", Field { brief: Some("When the BFD Source receives a valid BFD CC PDU, this sticky bit is asserted if the 'Diag' value in the Rx BFD CC PDU is different from the previous value received. The previous value is stored in: * VOP_MPLS:VOE_STAT_MPLS:BFD_SRC_INFO.BFD_REMOTE_DIAG_SRC This event will generate an interrupt if so enabled in: * VOP_MPLS:VOE_STAT_MPLS:INTR_ENA_MPLS.BFD_RX_DIAG_CHANGE_SRC_INT_ENA"), details: None, lo: 7, hi: 8 });
        fields.insert("BFD_RX_DM_CHANGE_SINK_STICKY", Field { brief: Some("When the BFD Sink receives a valid BFD CC PDU, this sticky bit is asserted if the 'Detect Mult' value in the Rx BFD CC PDU is different from the previous value received. The previous value is stored in: * VOP_MPLS:VOE_STAT_MPLS:BFD_SINK_INFO.BFD_REMOTE_DM_SINK This event will generate an interrupt if so enabled in: * VOP_MPLS:VOE_STAT_MPLS:INTR_ENA_MPLS.BFD_RX_DM_CHANGE_SINK_INT_ENA"), details: None, lo: 4, hi: 5 });
        fields.insert("BFD_RX_DM_CHANGE_SRC_STICKY", Field { brief: Some("When the BFD Source receives a valid BFD CC PDU, this sticky bit is asserted if the 'Detect Mult' value in the Rx BFD CC PDU is different from the previous value received. The previous value is stored in: * VOP_MPLS:VOE_STAT_MPLS:BFD_SRC_INFO.BFD_REMOTE_DM_SRC This event will generate an interrupt if so enabled in: * VOP_MPLS:VOE_STAT_MPLS:INTR_ENA_MPLS.BFD_RX_DM_CHANGE_SRC_INT_ENA"), details: None, lo: 9, hi: 10 });
        fields.insert("BFD_RX_F_SET_SINK_STICKY", Field { brief: Some("When the BFD Sink receives a valid BFD CC PDU, this sticky bit is asserted if the Final Flag is asserted in the Rx BFD CC PDU. This event will generate an interrupt if so enabled in: * VOP_MPLS:VOE_STAT_MPLS:INTR_ENA_MPLS.BFD_RX_F_SET_SINK_INT_ENA"), details: None, lo: 0, hi: 1 });
        fields.insert("BFD_RX_F_SET_SRC_STICKY", Field { brief: Some("When the BFD Source receives a valid BFD CC PDU, this sticky bit is asserted if the Final Flag is asserted in the Rx BFD CC PDU. This event will generate an interrupt if so enabled in: * VOP_MPLS:VOE_STAT_MPLS:INTR_ENA_MPLS.BFD_RX_F_SET_SRC_INT_ENA"), details: None, lo: 5, hi: 6 });
        fields.insert("BFD_RX_P_SET_SINK_STICKY", Field { brief: Some("When the BFD Sink receives a valid BFD CC PDU, this sticky bit is asserted if the Poll Flag is asserted in the Rx BFD CC PDU. This event will generate an interrupt if so enabled in: * VOP_MPLS:VOE_STAT_MPLS:INTR_ENA_MPLS.BFD_RX_P_SET_SINK_INT_ENA"), details: None, lo: 1, hi: 2 });
        fields.insert("BFD_RX_P_SET_SRC_STICKY", Field { brief: Some("When the BFD Source receives a valid BFD CC PDU, this sticky bit is asserted if the Poll Flag is asserted in the Rx BFD CC PDU. This event will generate an interrupt if so enabled in: * VOP_MPLS:VOE_STAT_MPLS:INTR_ENA_MPLS.BFD_RX_P_SET_SRC_INT_ENA"), details: None, lo: 6, hi: 7 });
        fields.insert("BFD_RX_STATE_CHANGE_SINK_STICKY", Field { brief: Some("When the BFD Sink receives a valid BFD CC PDU, this sticky bit is asserted if the 'State' value in the Rx BFD CC PDU is different from the previous value received. The previous value is stored in: * VOP_MPLS:VOE_STAT_MPLS:BFD_SINK_INFO.BFD_REMOTE_STATE_SINK This event will generate an interrupt if so enabled in: * VOP_MPLS:VOE_STAT_MPLS:INTR_ENA_MPLS.BFD_RX_STATE_CHANGE_SINK_INT_ENA"), details: None, lo: 3, hi: 4 });
        fields.insert("BFD_RX_STATE_CHANGE_SRC_STICKY", Field { brief: Some("When the BFD Source receives a valid BFD CC PDU, this sticky bit is asserted if the 'State' value in the Rx BFD CC PDU is different from the previous value received. The previous value is stored in: * VOP_MPLS:VOE_STAT_MPLS:BFD_SRC_INFO.BFD_REMOTE_STATE_SRC This event will generate an interrupt if so enabled in: * VOP_MPLS:VOE_STAT_MPLS:INTR_ENA_MPLS.BFD_RX_STATE_CHANGE_SRC_INT_ENA"), details: None, lo: 8, hi: 9 });
        regs.insert("INTR_STICKY_MPLS", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("Sticky bits with interrupt capability"), details: Some("The sticky bits in this register will cause a VOE interrupt if the interrupt is enabled by the corresponding enable bit field in: * VOP_MPLS:VOE_STAT_MPLS:INTR_ENA_MPLS.* If an interrupt is enabled, the interrupt is asserted when the corresponding sticky bit is asserted."), fields });
        let mut fields = HashMap::new();
        fields.insert("BFD_CC_RX_NEXT_GOOD_EXTR", Field { brief: Some("Extract the next valid BFD CC PDU received by the VOE."), details: None, lo: 7, hi: 8 });
        fields.insert("BFD_CV_RX_NEXT_GOOD_EXTR", Field { brief: Some("Extract the next valid BFD CV PDU received by the VOE."), details: None, lo: 6, hi: 7 });
        fields.insert("BFD_RX_ERR_EXTR", Field { brief: Some("Asserting this bit will extract BFD PDUs which fail the Rx verification test. Extraction will be done Hit Me Once or all frames depending on the following bit field: * EXTRACT_HIT_ME_ONCE"), details: None, lo: 1, hi: 2 });
        fields.insert("BFD_RX_F_SET_EXTR", Field { brief: Some("Asserting this bit will extract frames with the Final flag set. Extraction will be done Hit Me Once or all frames depending on the following bit field: * EXTRACT_HIT_ME_ONCE"), details: None, lo: 2, hi: 3 });
        fields.insert("BFD_RX_PARAM_CHANGE_EXTR", Field { brief: Some("Will extract the next valid Rx BFD PDU if one of the following parameters changed since the last BFD PDU belonging to the same session (Coordinated / NEIS / FEIS): * BFD.DM * BFD.DIAG * BFD.STATE Extraction will be done Hit Me Once or all frames depending on the following bit field: * EXTRACT_HIT_ME_ONCE"), details: None, lo: 4, hi: 5 });
        fields.insert("BFD_RX_P_SET_EXTR", Field { brief: Some("Asserting this bit will extract frames with the Poll flag set. Extraction will be done Hit Me Once or all frames depending on the following bit field: * EXTRACT_HIT_ME_ONCE"), details: None, lo: 3, hi: 4 });
        fields.insert("BFD_TX_ERR_EXTR", Field { brief: Some("Asserting this bit will extract BFD PDUs which fail the Tx verification test. Extraction will be done Hit Me Once or all frames depending on the following bit field: * EXTRACT_HIT_ME_ONCE"), details: None, lo: 0, hi: 1 });
        fields.insert("EXTRACT_HIT_ME_ONCE", Field { brief: Some("The configuration of this bit field determines whether the following configuration bits cause extraction of the Next Frame Only (Hit Me Once) or all the Frames matching a given criteria: * BFD_RX_PARAM_CHANGE_EXTR * BFD_RX_P_SET_EXTR * BFD_RX_F_SET_EXTR * BFD_RX_ERR_EXTR * BFD_TX_ERR_EXTR"), details: None, lo: 5, hi: 6 });
        regs.insert("PDU_EXTRACT_MPLS", Register { addr: Address { base: 11, count: 1, width: 1 }, brief: Some("Extraction of MPLS PDUs"), details: Some("This register contains a number of bit fields which are used to configure extraction of certains MPLS PDUs, which match a given criteria. Note that some of the registers will extract either 'NEXT FRAME only ' (Hit Me Once) or 'ALL FRAMES' matching a given criteria, based on the configuration of the following bitfield: * EXTRACT_HIT_ME_ONCE"), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_CNT_NON_SEL_OAM_MPLS", Field { brief: Some("See register description"), details: None, lo: 0, hi: 32 });
        regs.insert("RX_CNT_NON_SEL_OAM_MPLS", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Count non-selected OAM PDU received by the VOE."), details: Some("All PDU types can be configured as either selected or non-selected PDUs. This register counts the number of valid OAM PDUs configured as non-selected PDU type, received by the VOE. Selected OAM PDUs are configured in: * VOP_MPLS:VOE_CONF_MPLS:OAM_CNT_SEL_MPLS.*"), fields });
        let mut fields = HashMap::new();
        fields.insert("RX_CNT_SEL_OAM_MPLS", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("RX_CNT_SEL_OAM_MPLS", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Count selected OAM PDU received by the VOE."), details: Some("All PDU types can be configured as either selected or non-selected PDUs. This register counts the number of valid OAM PDUs configured as selected PDU type, received by the VOE. Selected OAM PDUs are configured in: * VOP_MPLS:VOE_CONF_MPLS:OAM_CNT_SEL_MPLS.*"), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_CNT_NON_SEL_OAM_MPLS", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("TX_CNT_NON_SEL_OAM_MPLS", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("Count NON-selected OAM PDUs transmitted by the VOE."), details: Some("All PDU types can be configured as either selected or non-selected PDUs. This register counts the number of valid OAM PDUs configured as non-selected PDU type, transmitted by the VOE. Selected OAM PDUs are configured in: * VOP_MPLS:VOE_CONF_MPLS:OAM_CNT_SEL_MPLS.*"), fields });
        let mut fields = HashMap::new();
        fields.insert("TX_CNT_SEL_OAM_MPLS", Field { brief: Some("See register description."), details: None, lo: 0, hi: 32 });
        regs.insert("TX_CNT_SEL_OAM_MPLS", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Count selected OAM PDUs transmitted by the VOE."), details: Some("All PDU types can be configured as either selected or non-selected PDUs. This register counts the number of valid OAM PDUs configured as selected PDU type, transmitted by the VOE. Selected OAM PDUs are configured in: * VOP_MPLS:VOE_CONF_MPLS:OAM_CNT_SEL_MPLS.*"), fields });
        groups.insert("VOE_STAT_MPLS", RegisterGroup { addr: Address { base: 0, count: 1077, width: 32 }, desc: "Per VOE statistics and counters (MPLS-TP OAM)", regs });
        out.insert("VOP_MPLS", Target { desc: "The Vitesse OAM MEP Processor (VOP) implements the HW support for implementing OAM MEPs. The HW support for implementing an OAM MEP is implemented in a sub block, referred to as: Vitesse OAM Endpoint (VOE). The VOEs can be configured for either Ethernet PDU processing or MPLS-TP PDU processing. This CSR target us used for configuring VOEs configured for MPLS-TP processing. The VOP includes the following: * 256 Service / Path VOEs * 11 Port VOEs (11 front ports) VOEs are configured for either Ethernet or MPLS-TP support using the following register: * VOP:VOE_CONF_REG:VOE_MISC_CONFIG.MPLS_OAM_ENA Use CSR target VOP_MPLS to configure VOEs configured for MPLS_TP. To configure VOEs configured for Ethernet use CSR target: VOP. For VOEs configured for Ethernet, the following register groups are invalid: * VOP:CONF_MPLS:* * VOP:STAT_MPLS:* Note that the VOP_MPLS CSR target shares the same physical RAM as VOP CSR target. The RAM is initialized to the VOP CSR target values (Ethernet VOE). Hence the initial values listed in the VOP_MPLS are not valid. Prior to using a VOE configured for MPLS, all REGISTERS MUST BE INITIALIZED.", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("EWIS_DETECT_MASK", Field { brief: Some("Enable eWIS LOF to control signal detect."), details: Some("0: Inhibit eWIS LOF to control signal detect. 1: Enable eWIS LOF to control signal detect."), lo: 1, hi: 2 });
        fields.insert("OTN_DETECT_MASK", Field { brief: Some("Enable OTN LOF to control signal detect."), details: Some("0: Inhibit OTN LOF to control signal detect. 1: Enable OTN LOF to control signal detect."), lo: 2, hi: 3 });
        fields.insert("PCS_DETECT_MASK", Field { brief: Some("Enable PCS lock to control signal detect."), details: Some("0: Inhibit PCS lock to control signal detect. 1: Enable PCS lock to control signal detect."), lo: 0, hi: 1 });
        regs.insert("DATA_VALID_DETECT_CTRL", Register { addr: Address { base: 9, count: 1, width: 1 }, brief: Some("Data valid detect control register."), details: Some("Data valid detect control register. Selects the sources for valid data detection. Controls various functions in the deserializer macro which are swiched when the digital logic has detected a valid signal. Note: The three possible sources are first masked and than ORed together."), fields });
        let mut fields = HashMap::new();
        fields.insert("DFT_ACTIVE_HI_MASK", Field { brief: Some("Mask (enable) a XFI_INT if DFT_ACTIVE is asserted"), details: Some("0: Inhibit dft_active from generating a XFI_INT 1: Enable dft_active to generate a XFI_INT"), lo: 25, hi: 26 });
        fields.insert("DFT_ACTIVE_LO_MASK", Field { brief: Some("Mask (enable) a XFI_INT if DFT_ACTIVE is not asserted"), details: Some("0: Inhibit dft_active from generating a XFI_INT 1: Enable dft_active to generate a XFI_INT"), lo: 24, hi: 25 });
        fields.insert("DFT_INCOMPLETE_HI_MASK", Field { brief: Some("Mask (enable) a XFI_INT if dft_incomplete is asserted"), details: Some("0: Inhibit dft_incomplete from generating a XFI_INT 1: Enable dft_incomplete to generate a XFI_INT"), lo: 27, hi: 28 });
        fields.insert("DFT_INCOMPLETE_LO_MASK", Field { brief: Some("Mask (enable) a XFI_INT if dft_incomplete is not asserted"), details: Some("0: Inhibit dft_incomplete from generating a XFI_INT 1: Enable dft_incomplete to generate a XFI_INT"), lo: 26, hi: 27 });
        fields.insert("DFT_INSTABLE_HI_MASK", Field { brief: Some("Mask (enable) a XFI_INT if dft_instable is asserted"), details: Some("0: Inhibit dft_instable from generating a XFI_INT 1: Enable dft_instable to generate a XFI_INT"), lo: 29, hi: 30 });
        fields.insert("DFT_INSTABLE_LO_MASK", Field { brief: Some("Mask (enable) a XFI_INT if dft_instable is not asserted"), details: Some("0: Inhibit dft_instable from generating a XFI_INT 1: Enable dft_instable to generate a XFI_INT"), lo: 28, hi: 29 });
        fields.insert("DFT_NO_SYNC_HI_MASK", Field { brief: Some("Mask (enable) a XFI_INT if dft_no_sync is asserted"), details: Some("0: Inhibit dft_no_sync from generating a XFI_INT 1: Enable dft_no_sync to generate a XFI_INT"), lo: 31, hi: 32 });
        fields.insert("DFT_NO_SYNC_LO_MASK", Field { brief: Some("Mask (enable) a XFI_INT if dft_no_sync is not asserted"), details: Some("0: Inhibit dft_no_sync from generating a XFI_INT 1: Enable dft_no_sync to generate a XFI_INT"), lo: 30, hi: 31 });
        fields.insert("DFT_STUCK_AT_01_HI_MASK", Field { brief: Some("Mask (enable) a XFI_INT if dft_stuck_at_01 is asserted"), details: Some("0: Inhibit dft_stuck_at_01 from generating a XFI_INT 1: Enable dft_stuck_at_01 to generate a XFI_INT"), lo: 22, hi: 23 });
        fields.insert("DFT_STUCK_AT_PAR_HI_MASK", Field { brief: Some("Mask (enable) a XFI_INT if dft_stuck_at_par is asserted"), details: Some("0: Inhibit dft_stuck_at_par from generating a XFI_INT 1: Enable dft_stuck_at_par to generate a XFI_INT"), lo: 23, hi: 24 });
        fields.insert("RXSIGDET_HI_MASK", Field { brief: Some("Mask (enable) a XFI_INT if RXSIGDET_HI_STICKY is asserted"), details: Some("0: Inhibit RXSIGDET_HI_STICKY from generating a XFI_INT 1: Enable the RXSIGDET_HI_STICKY to generate a XFI_INT"), lo: 13, hi: 14 });
        fields.insert("RXSIGDET_LO_MASK", Field { brief: Some("Mask (enable) a XFI_INT if RXSIGDET_LO_STICKY is asserted"), details: Some("0: Inhibit RXSIGDET_LO_STICKY from generating a XFI_INT 1: Enable RXSIGDET_LO_STICKY to generate a XFI_INT"), lo: 12, hi: 13 });
        fields.insert("RX_LOS_HI_MASK", Field { brief: Some("Mask (enable) a XFI_INT if RX_LOS_HI_STICKY is asserted"), details: Some("0: Inhibit RX_LOS_HI_STICKY from generating a XFI_INT 1: Enable RX_LOS_HI_STICKY to generate a XFI_INT"), lo: 15, hi: 16 });
        fields.insert("RX_LOS_LO_MASK", Field { brief: Some("Mask (enable) a XFI_INT if RX_LOS_LO_STICKY is asserted"), details: Some("0: Inhibit RX_LOS_LO_STICKY from generating a XFI_INT 1: Enable RX_LOS_LO_STICKY to generate a XFI_INT"), lo: 14, hi: 15 });
        fields.insert("RX_PLL_LOCK_HI_MASK", Field { brief: Some("Mask (enable) a XFI_INT if RX_PLL_LOCK_HI_STICKY is asserted"), details: Some("0: Inhibit RX_PLL_LOCK_HI_STICKY from generating a XFI_INT 1: Enable RX_PLL_LOCK_HI_STICKY to generate a XFI_INT"), lo: 17, hi: 18 });
        fields.insert("RX_PLL_LOCK_LO_MASK", Field { brief: Some("Mask (enable) a XFI_INT if RX_PLL_LOCK_LO_STICKY is asserted"), details: Some("0: Inhibit RX_PLL_LOCK_LO_STICKY from generating a XFI_INT 1: Enable RX_PLL_LOCK_LO_STICKY to generate a XFI_INT"), lo: 16, hi: 17 });
        fields.insert("TX_FIFO_LOS_HI_MASK", Field { brief: Some("Mask (enable) a XFI_INT if IF_PLL_LOCK_HI_STICKY is asserted"), details: Some("0: Inhibit TX_FIFO_LOS_HI_STICKY from generating a XFI_INT 1: Enable TX_FIFO_LOSss_HI_STICKY to generate a XFI_INT"), lo: 21, hi: 22 });
        fields.insert("TX_PLL_LOCK_HI_MASK", Field { brief: Some("Mask (enable) a XFI_INT if TX_PLL_LOCK_HI_STICKY is asserted"), details: Some("0: Inhibit TX_PLL_LOCK_HI_STICKY from generating a XFI_INT 1: Enable TX_PLL_LOCK_HI_STICKY to generate a XFI_INT"), lo: 19, hi: 20 });
        fields.insert("TX_PLL_LOCK_LO_MASK", Field { brief: Some("Mask (enable) a XFI_INT if TX_PLL_LOCK_LO_STICKY is asserted"), details: Some("0: Inhibit TX_PLL_LOCK_LO_STICKY from generating a XFI_INT 1: Enable TX_PLL_LOCK_LO_STICKY to generate a XFI_INT"), lo: 18, hi: 19 });
        regs.insert("HSS_MASK", Register { addr: Address { base: 7, count: 1, width: 1 }, brief: Some("XFI HSS macro sticky interrupt masks (enables)"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RXSIGDET_STATUS", Field { brief: Some("Signal detect indicator"), details: Some("0: No signal 1: Active signal detected on the serial input"), lo: 12, hi: 13 });
        fields.insert("RX_LOS_STATUS", Field { brief: Some("Current value of XFI LOS pin driven by HSS XFP/SFP+"), details: Some("0: Pin is driven low 1: Pin is driven high"), lo: 14, hi: 15 });
        fields.insert("RX_PLL_LOCK_STATUS", Field { brief: Some("RC-PLL lock status of Deserializer"), details: Some("0: RC-PLL is not locked 1: RC-PLL is locked"), lo: 16, hi: 17 });
        fields.insert("TX_FIFO_LOS_STATUS", Field { brief: Some("TX_FIFO loss of sync This can occur if the core clock sourcing the Tx port of the XFI is out of phase with the XFI Tx clock, or if the core clock glitches."), details: Some("0: TX_FIFO is not out of sync 1: TX_FIFO is out of sync"), lo: 20, hi: 21 });
        fields.insert("TX_PLL_LOCK_STATUS", Field { brief: Some("RC-PLL lock status of Serializer"), details: Some("0: RC-PLL is not locked 1: RC-PLL is locked"), lo: 18, hi: 19 });
        regs.insert("HSS_STATUS", Register { addr: Address { base: 8, count: 1, width: 1 }, brief: Some("XFI HSS macro current status"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DFT_ACTIVE_HI_STICKY", Field { brief: Some("The DFT_ACTIVE signal was detected asserted (since this bit was last cleared)"), details: Some("0: DFT_ACTIVE was not detected asserted (since this bit was last cleared) 1: DFT_ACTIVE was detected asserted (since this bit was last cleared)"), lo: 25, hi: 26 });
        fields.insert("DFT_ACTIVE_LO_STICKY", Field { brief: Some("The DFT_ACTIVE signal was detected deasserted (since this bit was last cleared)"), details: Some("0: DFT_ACTIVE was not detected deasserted (since this bit was last cleared) 1: DFT_ACTIVE was detected deasserted (since this bit was last cleared)"), lo: 24, hi: 25 });
        fields.insert("DFT_INCOMPLETE_HI_STICKY", Field { brief: Some("The DFT_INCOMPLETE signal was detected asserted (since this bit was last cleared)"), details: Some("0: DFT_INCOMPLETE was not detected asserted (since this bit was last cleared) 1: DFT_INCOMPLETE was detected asserted (since this bit was last cleared)"), lo: 27, hi: 28 });
        fields.insert("DFT_INCOMPLETE_LO_STICKY", Field { brief: Some("The DFT_INCOMPLETE signal was detected deasserted (since this bit was last cleared)"), details: Some("0: DFT_INCOMPLETE was not detected deasserted (since this bit was last cleared) 1: DFT_INCOMPLETE was detected deasserted (since this bit was last cleared)"), lo: 26, hi: 27 });
        fields.insert("DFT_INSTABLE_HI_STICKY", Field { brief: Some("The DFT_INSTABLE signal was detected asserted (since this bit was last cleared)"), details: Some("0: DFT_INSTABLE was not detected asserted (since this bit was last cleared) 1: DFT_INSTABLE was detected asserted (since this bit was last cleared)"), lo: 29, hi: 30 });
        fields.insert("DFT_INSTABLE_LO_STICKY", Field { brief: Some("The DFT_INSTABLE signal was detected deasserted (since this bit was last cleared)"), details: Some("0: DFT_INSTABLE was not detected deasserted (since this bit was last cleared) 1: DFT_INSTABLE was detected deasserted (since this bit was last cleared)"), lo: 28, hi: 29 });
        fields.insert("DFT_NO_SYNC_HI_STICKY", Field { brief: Some("The DFT_NO_SYNC signal was detected asserted (since this bit was last cleared)"), details: Some("0: DFT_NO_SYNC was not detected asserted (since this bit was last cleared) 1: DFT_NO_SYNC was detected asserted (since this bit was last cleared)"), lo: 31, hi: 32 });
        fields.insert("DFT_NO_SYNC_LO_STICKY", Field { brief: Some("The DFT_NO_SYNC signal was detected deasserted (since this bit was last cleared)"), details: Some("0: DFT_NO_SYNC was not detected deasserted (since this bit was last cleared) 1: DFT_NO_SYNC was detected deasserted (since this bit was last cleared)"), lo: 30, hi: 31 });
        fields.insert("DFT_STUCK_AT_01_HI_STICKY", Field { brief: Some("The DFT_STUCK_AT_01 signal was detected asserted (since this bit was last cleared)"), details: Some("0: DFT_STUCK_AT_01 was not detected asserted (since this bit was last cleared) 1: DFT_STUCK_AT_01 was detected asserted (since this bit was last cleared)"), lo: 22, hi: 23 });
        fields.insert("DFT_STUCK_AT_PAR_HI_STICKY", Field { brief: Some("The DFT_STUCK_AT_PAR signal was detected asserted (since this bit was last cleared)"), details: Some("0: DFT_STUCK_AT_PAR was not detected asserted (since this bit was last cleared) 1: DFT_STUCK_AT_PAR was detected asserted (since this bit was last cleared)"), lo: 23, hi: 24 });
        fields.insert("RXSIGDET_HI_STICKY", Field { brief: Some("HSS11G macro RXSIGDET output port was detected asserted (since this bit was last cleared)"), details: Some("0: RXSIGDET was not detected asserted (since this bit was last cleared) 1: RXSIGDET was detected asserted (since this bit was last cleared)"), lo: 13, hi: 14 });
        fields.insert("RXSIGDET_LO_STICKY", Field { brief: Some("HSS11G macro RXSIGDET output port was detected deasserted (since this bit was last cleared)"), details: Some("0: RXSIGDET was not detected deasserted (since this bit was last cleared) 1: RXSIGDET was detected deasserted (since this bit was last cleared)"), lo: 12, hi: 13 });
        fields.insert("RX_LOS_HI_STICKY", Field { brief: Some("XFI RX_LOS input pin was detected asserted (since this bit was last cleared)."), details: Some("0: RX_LOS was not detected asserted (since this bit was last cleared) 1: RX_LOS was detected asserted (since this bit was last cleared)"), lo: 15, hi: 16 });
        fields.insert("RX_LOS_LO_STICKY", Field { brief: Some("XFI RX_LOS input pin was detected deasserted (since this bit was last cleared)"), details: Some("0: RX_LOS was not detected deasserted (since this bit was last cleared) 1: RX_LOS was detected deasserted (since this bit was last cleared)"), lo: 14, hi: 15 });
        fields.insert("RX_PLL_LOCK_HI_STICKY", Field { brief: Some("RX_PLL_LOCK input pin was detected asserted (since this bit was last cleared)"), details: Some("0: RX_PLL_LOCK was not detected asserted (since this bit was last cleared) 1: RX_PLL_LOCK was detected asserted (since this bit was last cleared)"), lo: 17, hi: 18 });
        fields.insert("RX_PLL_LOCK_LO_STICKY", Field { brief: Some("RX_PLL_LOCK input pin was detected deasserted (since this bit was last cleared)."), details: Some("0: RX_PLL_LOCK was not detected deasserted (since this bit was last cleared) 1: RX_PLL_LOCK was detected deasserted (since this bit was last cleared)"), lo: 16, hi: 17 });
        fields.insert("TX_FIFO_LOS_HI_STICKY", Field { brief: Some("The TX_FIFO was detected asserted (since this bit was last cleared)"), details: Some("0: TX_FIFO_LOS was not detected asserted (since this bit was last cleared) 1: TX_FIFO_LOS was detected asserted (since this bit was last cleared)"), lo: 21, hi: 22 });
        fields.insert("TX_PLL_LOCK_HI_STICKY", Field { brief: Some("TX_PLL_LOCK input pin was detected asserted (since this bit was last cleared)"), details: Some("0: TX_PLL_LOCK was not detected asserted (since this bit was last cleared) 1: TX_PLL_LOCK was detected asserted (since this bit was last cleared)"), lo: 19, hi: 20 });
        fields.insert("TX_PLL_LOCK_LO_STICKY", Field { brief: Some("TX_PLL_LOCK input pin was detected deasserted (since this bit was last cleared)."), details: Some("0: TX_PLL_LOCK was not detected deasserted (since this bit was last cleared) 1: TX_PLL_LOCK was detected deasserted (since this bit was last cleared)"), lo: 18, hi: 19 });
        regs.insert("HSS_STICKY", Register { addr: Address { base: 6, count: 1, width: 1 }, brief: Some("XFI HSS macro status sticky bits"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ANEG_ACTIVE_MASK", Field { brief: Some("Global mask (enable) the ANEG_ACTIVE status as a source of the XFI_INT."), details: Some("0: Disable ANEG_ACTIVE status from setting XFI_INT (default) 1: Enable ANEG_ACTIVE status to set XFI_INT"), lo: 16, hi: 17 });
        fields.insert("ANEG_KR_INT_MASK", Field { brief: Some("Global mask (enable) the ANEG_INT status as a source of the XFI_INT."), details: Some("0: Disable ANEG_KR_INT status from setting XFI_INT (default) 1: Enable ANEG_KR_INT status to set XFI_INT"), lo: 18, hi: 19 });
        fields.insert("RXSIGDET_INV", Field { brief: Some("Invert polarity of rx_sigdet_i prior to summing it with rx_los_i to generate xfi_ssf_o. See SSF_MASK Encoding field. Note: The \"good\" case for RX_SIGDET is when the SERDES delivers a '1'. Therefor the signal is per default inverted."), details: Some("0: Do not invert the RX_SIGDET before summing it to generate the XFI_SSF output (default) 1: Invert the RX_SIGDET before summing it to generate the XFI_SSF output"), lo: 27, hi: 28 });
        fields.insert("RXSIGDET_MASK", Field { brief: Some("Enable rx_sigdet_i prior to summing it with rx_los_i to generate xfi_ssf_o. See SSF_MASK Encoding field."), details: Some("0: Inhibit the RX_SIGDET (either polarity) from the XFI_SSF output 1: Enable the RX_SIGDET (either polarity) to the XFI_SSF output"), lo: 26, hi: 27 });
        fields.insert("RX_LOS_INV", Field { brief: Some("Invert polarity of rx_los_i prior to summing it with rx_sigdet_i to generate xfi_ssf_o. See SSF_MASK Encoding field."), details: Some("0: Do not invert the RX_LOS before summing it to generate the XFI_SSF output (default) 1: Invert the RX_LOS before summing it to generate the XFI_SSF output"), lo: 25, hi: 26 });
        fields.insert("RX_LOS_MASK", Field { brief: Some("Enable rx_los_i prior to summing it with rx_sigdet_i to generate xfi_ssf_o. See SSF_MASK Encoding field."), details: Some("0: Inhibit the RX_LOS (either polarity) from the XFI_SSF output 1: Enable the RX_LOS (either polarity) to the XFI_SSF output"), lo: 24, hi: 25 });
        fields.insert("RX_PLL_LOCK_INV", Field { brief: Some("Invert polarity of rx_pll_lock_i prior to summing it with rxsigdet_i and rx_los_i to generate xfi_ssf_o. See SSF_MASK Encoding field. Note: The \"good\" case for RX_PLL_LOCK is when the SERDES delivers a '1'. Therefor the signal is per default inverted."), details: Some("0: Do not invert the RX_PLL_LOCK before summing it to generate the XFI_SSF output (default) 1: Invert the RX_PLL_LOCK before summing it to generate the XFI_SSF output"), lo: 29, hi: 30 });
        fields.insert("RX_PLL_LOCK_MASK", Field { brief: Some("Enable rx_pll_lock_i prior to summing it with rxsigdet_i and rx_los_i to generate xfi_ssf_o. See SSF_MASK Encoding field."), details: Some("0: Inhibit the RX_PLL_LOCK (either polarity) from the XFI_SSF output 1: Enable the RX_PLL_LOCK (either polarity) to the XFI_SSF output"), lo: 28, hi: 29 });
        fields.insert("SSF_MASK", Field { brief: Some("Global mask (enable) the XFI_SSF output. xfi_ssf_o =\tSSF_MASK & ( rx_los_mask & (rx_los_inv ^ rx_los_i) | rx_sigdet_mask & (rx_sigdet_inv ^ rx_sigdet_i) | rx_pll_lock_mask & rx_pll_lock_ssf_r | tx_pll_lock_mask  & tx_pll_lock_ssf_r"), details: Some("0: Inhibit XFI_SSF from being asserted 1: Enable the XFI_SSF to use the RX_LOS and the RX_SIGDET states, polarities, and masks"), lo: 20, hi: 21 });
        fields.insert("TX_PLL_LOCK_INV", Field { brief: Some("Invert polarity of tx_pll_lock_i prior to summing it with rxsigdet_i and rx_los_i to generate xfi_ssf_o. See SSF_MASK Encoding field. Note: The \"good\" case for TX_PLL_LOCK is when the SERDES delivers a '1'. Therefor the signal is per default inverted."), details: Some("0: Do not invert the TX_PLL_LOCK before summing it to generate the XFI_SSF output (default) 1: Invert the TX_PLL_LOCK before summing it to generate the XFI_SSF output"), lo: 31, hi: 32 });
        fields.insert("TX_PLL_LOCK_MASK", Field { brief: Some("Enable tx_pll_lock_i prior to summing it with rxsigdet_i and rx_los_i to generate xfi_ssf_o. See SSF_MASK Encoding field."), details: Some("0: Inhibit the TX_PLL_LOCK (either polarity) from the XFI_SSF output 1: Enable the TX_PLL_LOCK (either polarity) to the XFI_SSF output"), lo: 30, hi: 31 });
        fields.insert("XFI_MASK", Field { brief: Some("Global mask (enable) the XFI_INT output."), details: Some("0: Disable XFI_INT output, regardless of the STICKY and corresponding MASK states 1: Enable XFI_INT, using STICKY and corresponding MASK states"), lo: 0, hi: 1 });
        regs.insert("INT_CTRL", Register { addr: Address { base: 3, count: 1, width: 1 }, brief: Some("SSF INT control/masks and global XFI INT mask"), details: Some("Control and mask of the asynchronous XFI_SFF output. The global XFI_INT mask located here supersede the individual masks. Note: SSF status is also captured in the HSS_STICKY and HSS_STATUS registers."), fields });
        let mut fields = HashMap::new();
        fields.insert("KR_ANEG_10G_STICKY", Field { brief: Some("ANEG requires SD10G65-macro (RX+TX) be setup to 10.3125G mode"), details: Some("0: No action required 1: Macro must be reconfigured, SW has to clear this bit after reconfiguration (by writing a 1 to this bit-group)!"), lo: 8, hi: 9 });
        fields.insert("KR_ANEG_1G_STICKY", Field { brief: Some("ANEG requires SD10G65-macro (RX+TX) be setup to 1.25G mode"), details: Some("0: No action required 1: Macro must be reconfigured, SW has to clear this bit after reconfiguration (by writing a 1 to this bit-group)!"), lo: 2, hi: 3 });
        fields.insert("KR_ANEG_3G_STICKY", Field { brief: Some("ANEG requires SD10G65_-macro (RX+TX) be setup to 3.125G mode"), details: Some("0: No action required 1: Macro must be reconfigured, SW has to clear this bit after reconfiguration (by writing a 1 to this bit-group)!"), lo: 5, hi: 6 });
        fields.insert("KR_ANEG_FEC_STICKY", Field { brief: Some("ANEG requires KR_FEC state be changed (required state see KR_FEC_ENABLE)"), details: Some("0: No action required 1: KR_FEC must be reconfigured, SW has to clear this bit after reconfiguration (by writing a 1 to this bit-group)!"), lo: 9, hi: 10 });
        fields.insert("KR_ANEG_RATE_STICKY", Field { brief: Some("ANEG requires KR rate selection be changed (required state see KR_FEC_ENABLE)"), details: Some("0: No action required 1: KR rate must be reconfigured, SW has to clear this bit after reconfiguration (by writing a 1 to this bit-group)!"), lo: 10, hi: 11 });
        fields.insert("KR_ANEG_RX10G_STICKY", Field { brief: Some("ANEG requires SD10G65_RX-macro be setup to 10.3125G mode"), details: Some("0: No action required 1: Macro must be reconfigured, SW has to clear this bit after reconfiguration (by writing a 1 to this bit-group)!"), lo: 6, hi: 7 });
        fields.insert("KR_ANEG_RX1G_STICKY", Field { brief: Some("ANEG requires SD10G65_RX-macro be setup to 1.25G mode"), details: Some("0: No action required 1: Macro must be reconfigured, SW has to clear this bit after reconfiguration (by writing a 1 to this bit-group)!"), lo: 0, hi: 1 });
        fields.insert("KR_ANEG_RX3G_STICKY", Field { brief: Some("ANEG requires SD10G65_RX-macro be setup to 3.125G mode"), details: Some("0: No action required 1: Macro must be reconfigured, SW has to clear this bit after reconfiguration (by writing a 1 to this bit-group)!"), lo: 3, hi: 4 });
        fields.insert("KR_ANEG_TX10G_STICKY", Field { brief: Some("ANEG requires SD10G65_TX-macro be setup to 10.3125G mode"), details: Some("0: No action required 1: Macro must be reconfigured, SW has to clear this bit after reconfiguration (by writing a 1 to this bit-group)!"), lo: 7, hi: 8 });
        fields.insert("KR_ANEG_TX1G_STICKY", Field { brief: Some("ANEG requires SD10G65_TX-macro be setup to 1.25G mode"), details: Some("0: No action required 1: Macro must be reconfigured, SW has to clear this bit after reconfiguration (by writing a 1 to this bit-group)!"), lo: 1, hi: 2 });
        fields.insert("KR_ANEG_TX3G_STICKY", Field { brief: Some("ANEG requires SD10G65_TX-macro be setup to 3.125G mode"), details: Some("0: No action required 1: Macro must be reconfigured, SW has to clear this bit after reconfiguration (by writing a 1 to this bit-group)!"), lo: 4, hi: 5 });
        fields.insert("KR_FEC_ENABLE", Field { brief: Some("KR-ANEG FEC negotiation result"), details: Some("0: KR_FEC shall be disabled 1: KR_FEC shall be enabled"), lo: 16, hi: 17 });
        fields.insert("KR_FEC_INT_MASK", Field { brief: Some("Masking of KR FEC interrupt"), details: Some("0: Inhibit KR_FEC interrupt propagation 1: Enable KR_FEC interrupt"), lo: 12, hi: 13 });
        fields.insert("KR_INT_MASK", Field { brief: Some("Global Masking of KR interrupt"), details: Some("0: Inhibit KR interrupt propagation 1: Enable KR interrupt"), lo: 15, hi: 16 });
        fields.insert("KR_INT_POL", Field { brief: Some("Polarity of KR interrupt"), details: Some("0: High-active (0 is inactive level) 1: Low-active (1 is inactive level)"), lo: 14, hi: 15 });
        fields.insert("KR_MODE_INT_MASK", Field { brief: Some("Masking of KR MODE interrupt"), details: Some("0: Inhibit KR_MODE interrupt propagation 1: Enable KR_MODE interrupt"), lo: 11, hi: 12 });
        fields.insert("KR_RATE", Field { brief: Some("ANEG link partner rate negotiation result (link-HCD)"), details: Some("0: 10G 1: 1G 2: 3G"), lo: 17, hi: 19 });
        fields.insert("KR_RATE_INT_MASK", Field { brief: Some("Masking of KR RATE interrupt"), details: Some("0: Inhibit KR_RATE select interrupt propagation 1: Enable KR_RATE select interrupt"), lo: 13, hi: 14 });
        regs.insert("KR_CONTROL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("KR mode control"), details: Some("Control operating modes initiated by KR"), fields });
        let mut fields = HashMap::new();
        fields.insert("SSF_HYST_ENA", Field { brief: Some("Enable timing and hysteresis as defined in SSF_HYST_TIMING_CTRL."), details: Some("0: SSF is immediately asserted to the core. 1: SSF signal to core is timed as defined by SSF_HYST_TIMING_CTRL."), lo: 0, hi: 1 });
        regs.insert("SSF_HYST_ENA_CTRL", Register { addr: Address { base: 4, count: 1, width: 1 }, brief: Some("SSF set / reset hysteresis enable register."), details: Some("SSF set / reset hysteresis enable register. Enables the timing of asserting or deasserting SSF"), fields });
        let mut fields = HashMap::new();
        fields.insert("SSF_ASSERT_TIMING", Field { brief: Some("Time a SSF must be active before it is forwarded to the core. Resolution: One tick is 102.4 ns."), details: Some("Number of ticks SSF must be constantly active before it is reported to the core. E.g. a value of 23 would result in a wait time of 2.3552 us."), lo: 0, hi: 12 });
        fields.insert("SSF_DEASSERT_TIMING", Field { brief: Some("Time a SSF must be inactive before it is forwarded to the core. Resolution: One tick is 102.4 ns."), details: Some("Number of ticks SSF must be constantly inactive before it is reported to the core."), lo: 16, hi: 28 });
        regs.insert("SSF_HYST_TIMING_CTRL", Register { addr: Address { base: 5, count: 1, width: 1 }, brief: Some("SSF set / reset hysteresis control register."), details: Some("SSF set / reset hysteresis control register. Controls the timing of asserting or deasserting SSF"), fields });
        let mut fields = HashMap::new();
        fields.insert("DES_100FX_PHASE_SEL", Field { brief: Some("Phase selection of DES in 100fx mode"), details: Some("0: CDR locked at bit 9 1: CDR locked at bit 4"), lo: 31, hi: 32 });
        fields.insert("ENDIAN", Field { brief: Some("Set the data-type/endian mode of the core to HSS interface"), details: Some("0: Core 64/66 data: bit 63 first, followed by the remaining bits leading to bit 0 (default) 1: Core 64/66 data: bit 0 first, followed by the remaining bits leading to bit 63"), lo: 4, hi: 5 });
        fields.insert("EXT_RX_SYNC_CTRL_SEL", Field { brief: Some("Select external macro for sync_ctrl information for DES."), details: Some("0: Select macro 0 1: Select macro 1 2: Select macro 2 3: Select macro 3"), lo: 12, hi: 16 });
        fields.insert("EXT_SYNC_CTRL_SEL", Field { brief: Some("Select external macro for sync_ctrl information."), details: Some("0: Select macro 0 1: Select macro 1 2: Select macro 2 3: Select macro 3"), lo: 27, hi: 31 });
        fields.insert("FX100_ENA", Field { brief: Some("Enable 100Base-FX mode. Enables specific deserializer cp/md handling (requires enabling external cp/md sourceing in the SerDes macro. PORT_SEL must be set to 1 (40-bit mode) for 100Base-FX mode."), details: Some("0: Disable 1: Enable"), lo: 26, hi: 27 });
        fields.insert("FX100_KICK_MODE", Field { brief: Some("Enable kick-out-of-180-degree functionality."), details: Some("0: Enable PCS controlled kicking (kicking allowed in case of no sync) 1: Disable kicking 2: Enable kicking at any time 3: Reserved"), lo: 23, hi: 25 });
        fields.insert("FX100_MODE", Field { brief: Some("Select 100Base-FX operation mode."), details: Some("0: Normal mode (optimal bit is copied to all bits) 1: Simple mode (received data not modified)"), lo: 25, hi: 26 });
        fields.insert("FX100_SWAP_CP_MD", Field { brief: Some("Swap cp/md signals in 100Base-FX mode."), details: Some("0: No swapping of cp and md 1: Swap cp and md"), lo: 22, hi: 23 });
        fields.insert("PORT_SEL", Field { brief: Some("Active port selection. Only one port can be active at a time."), details: Some("0: 64-bit port is active. 1: 40-bit port is active."), lo: 21, hi: 22 });
        fields.insert("RX_INVERT", Field { brief: Some("Invert data received from the HSS Rx data port"), details: Some("0: Non-inverted data from the Rx data port 1: Inverted data from the Rx data port"), lo: 9, hi: 10 });
        fields.insert("SEL_LINELB", Field { brief: Some("Select the line Rx data loopback path instead of the core Tx data as the source of the internal Tx data path."), details: Some("0: Core Tx data selected (default) 1: Line Rx data (loopback) selected"), lo: 6, hi: 7 });
        fields.insert("SPI_CLK_DIV", Field { brief: Some("Clock divider for SPI Master"), details: Some("f(spi_clk) = f(system_clk)/(SPI_CLK_DIV+2)"), lo: 16, hi: 20 });
        fields.insert("SW_ENA", Field { brief: Some("SW_ENA input to XFI clk_rst_sync modules (internal Tx-clock, core Tx clock-input, internal Rx-clock)"), details: Some("0: SW_ENA deasserted (default) 1: SW_ENA asserted"), lo: 1, hi: 2 });
        fields.insert("SW_RST", Field { brief: Some("SW_RST input to XFI clk_rst_sync modules (internal Tx-clock, core Tx clock-input, internal Rx-clock)"), details: Some("0: SW_RST deasserted 1: SW_RST asserted (default)"), lo: 0, hi: 1 });
        fields.insert("TXF_ERR_MODE", Field { brief: Some("TX_FIFO error mode control When deasserted (default), if single Tx-data word is read outside the 'safe' zone (where a full-cycle of setup and hold are guaranteed), the TX_LOS status will be asserted. Due to synchronization uncertainties it is possible to be 'on-edge' and still make timing, having a whole cycle plus something less than a cycle for setup and hold timing. When this field is asserted, two concecutive read cycles outside the 'safe' zone must occur to generate the TX_LOS status. This allows a known (slew-rate limited) drift rate to dither 'on-edge' out of the 'safe' zone for a cycle and not generate the TX_LOS if read timing returns to the 'safe' zone on the following cycle."), details: Some("0: A single read outside the 'safe' zone generates a TX_LOS condition (default) 1: Monitor for two concecutive out of 'safe' zone cycles to generate TX_LOS"), lo: 5, hi: 6 });
        fields.insert("TX_AUTORESYNC", Field { brief: Some("Automatically assert a hardware TX_RESYNC when TX_FIFO_LOS is detected"), details: Some("0: TX_FIFO will not resync when an LOS event is detected 1: TX_FIFO will resync when an LOS event is detected"), lo: 3, hi: 4 });
        fields.insert("TX_INVERT", Field { brief: Some("Invert data driven into the HSS Tx data port (txad)"), details: Some("0: Non-inverted data to the Tx data port 1: Inverted data to the Tx data port"), lo: 8, hi: 9 });
        fields.insert("TX_RESYNC_SHOT", Field { brief: Some("Resynchronize the core/XFI data phase crossing logic Must always be asserted after SW_RST or SW_ENA"), details: Some("0: No action 1: Set TX_RESYNC, HW will clear this bit when sync has completed"), lo: 2, hi: 3 });
        fields.insert("TX_USE_FIFO", Field { brief: Some("The 64-bit port can be equipped with a FIFO to ease 64/66-bit originated clock variations."), details: Some("0: TX-FIFO is bypassed. 1: TX-FIFO is enabled."), lo: 20, hi: 21 });
        regs.insert("XFI_MODE", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("XFI modes"), details: Some("Control and operating modes of the XFI."), fields });
        let mut fields = HashMap::new();
        fields.insert("ANEG_ACTIVE_STATUS", Field { brief: Some("Unmasked status of the ANEG_ACTIVE status output When the ANEG_ACTIVE_MASK is set, this status is a source of the XFI_INT."), details: Some("0: The ANEG_ACTIVE status is deasserted (low) 1: The ANEG_ACTIVE status is asserted (high)"), lo: 16, hi: 17 });
        fields.insert("ANEG_KR_INT_STATUS", Field { brief: Some("Unmasked status of the ANEG_KR_INT status output When the ANEG_KR_INT_MASK is set, this status is a source of the XFI_INT."), details: Some("0: The ANEG_KR_INT status is deasserted (low) 1: The ANEG_KR_INT status is asserted (high)"), lo: 18, hi: 19 });
        fields.insert("RECEIVER_DETECT_STATUS", Field { brief: Some("Status from macro: Receiver detected."), details: Some("0: XFI has no receiver detected 1: XFI has a receiver detected"), lo: 24, hi: 25 });
        fields.insert("SSF_STATUS", Field { brief: Some("Status of the XFI_SSF output port"), details: Some("0: XFI_SSF deasserted 1: XFI_SSF asserted"), lo: 20, hi: 21 });
        fields.insert("XFIINT_STATUS", Field { brief: Some("Status of XFI_INT output port XFI_INT = XFI_MASK & (RXINT_STATUS | TXINT_STATUS)"), details: Some("0: XFI_INT deasserted 1: XFI_INT asserted"), lo: 0, hi: 1 });
        regs.insert("XFI_STATUS", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("XFI interrupt status"), details: Some("The XFI_INT, its sources, and the XFI_SSF are visible from this register."), fields });
        groups.insert("XFI_CONTROL", RegisterGroup { addr: Address { base: 0, count: 1, width: 10 }, desc: "XFI controls", regs });
        out.insert("XFI_SHELL", Target { desc: "\\see vtss_target_XFI_SHELL_e XFI shell", groups });

        let mut groups = HashMap::new();
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("QLIMIT_CONG_CNT_MAX", Field { brief: None, details: None, lo: 0, hi: 12 });
        regs.insert("QLIMIT_CONG_CNT_MAX_STAT", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Maximum amount of congested scheduling elements in the share"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("QLIMIT_SHR_MON_CLR", Field { brief: Some("Clear shared memory pool monitoring statistics."), details: None, lo: 0, hi: 1 });
        regs.insert("QLIMIT_MON_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Monitor configuration"), details: Some("Replicated for each classified priority"), fields });
        let mut fields = HashMap::new();
        fields.insert("QLIMIT_SHR_WM", Field { brief: None, details: None, lo: 0, hi: 15 });
        regs.insert("QLIMIT_SHR_WM_STAT", Register { addr: Address { base: 15, count: 2, width: 1 }, brief: Some("Current per SE watermark"), details: None, fields });
        groups.insert("QLIMIT_MON", RegisterGroup { addr: Address { base: 1604, count: 4, width: 3 }, desc: "Shared memory pool monitoring", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("QLIMIT_CONG_CNT", Field { brief: Some("Number of congested queues on the scheduling element"), details: None, lo: 0, hi: 6 });
        regs.insert("QLIMIT_CONG_CNT", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Current congestion count for the scheduling element"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("QLIMIT_MAX_MODE_ENA", Field { brief: Some("Queue limitation is for this port used in MAX mode, setting upper limits for a queue. Otherwise a minimum guarantee is given by the calculated queue maximum size"), details: None, lo: 0, hi: 1 });
        fields.insert("QLIMIT_SHR_VAL", Field { brief: Some("Index of shared resource to use"), details: None, lo: 1, hi: 3 });
        regs.insert("QLIMIT_PORT_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Queue Limitation Configuration"), details: None, fields });
        groups.insert("QLIMIT_PORT", RegisterGroup { addr: Address { base: 1422, count: 57, width: 2 }, desc: "Queue Limitation Configuration", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("DROP_STAT_BASE_ADDR", Field { brief: Some("Drop counter set base address."), details: None, lo: 6, hi: 17 });
        fields.insert("DROP_STAT_COS8_ENA", Field { brief: Some("Select the number of counters for this VPORT."), details: Some("0: 4 counters included. Qos x and x+4 shares counter 1: 8 counters included, and two counter sets will be used"), lo: 0, hi: 1 });
        fields.insert("DROP_STAT_COS_SEL", Field { brief: Some("Configures which classified parameter to use when selecting drop stat index."), details: Some("0: Use IPRIO as COS input selector 1: Use COSID as COS input selector 2: Use TC as COS input selector 3: Use PCP as COS input selector"), lo: 1, hi: 3 });
        fields.insert("DROP_STAT_OAM_CNT_SEL", Field { brief: Some("Configures which OAM is counted in the from stat counter. Ref: ANA_L2:ISDX:MISC_CFG.QGRP_OAM_TYPE"), details: Some("bit0: Enable / disable drop count of EVC MEP OAM bit1: Enable / disable drop count of OVC / PW MEP OAM bit2: Enable / disable drop count of DOWN MEP OAM"), lo: 3, hi: 6 });
        regs.insert("DROP_STAT_CTRL", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Per egress port mapping of qgrp to drop stat index"), details: None, fields });
        groups.insert("QLIMIT_QUEUE", RegisterGroup { addr: Address { base: 1300, count: 4, width: 1 }, desc: "Queue Size Table", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("QLIMIT_SE_USE", Field { brief: Some("Total use for all queues on the schedulling element"), details: None, lo: 0, hi: 15 });
        regs.insert("QLIMIT_SE_USE", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Current use for the scheduling element"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("QUEUE_KILLED", Field { brief: Some("This queue was have had one or more discards due to the queue limitation algorithm"), details: None, lo: 0, hi: 1 });
        fields.insert("QUEUE_SIZE", Field { brief: Some("Current size of queue used for queue size limitation"), details: None, lo: 1, hi: 12 });
        regs.insert("QUEUE_SIZE", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Current queue size"), details: None, fields });
        groups.insert("QLIMIT_SE", RegisterGroup { addr: Address { base: 1288, count: 4, width: 2 }, desc: "SE Size Table", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("QLIMIT_ACT_CNT", Field { brief: Some("Return the current number of active queues in the share."), details: None, lo: 0, hi: 15 });
        fields.insert("QLIMIT_CONG_CNT", Field { brief: None, details: None, lo: 15, hi: 27 });
        regs.insert("QLIMIT_CONG_CNT_STAT", Register { addr: Address { base: 13, count: 1, width: 1 }, brief: Some("Current amount of congested scheduling elements in the share"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("QLIMIT_EGR_DIS", Field { brief: Some("Disable queue limitation for the port. If either queue limitation is disabled for the source port, or for the destination port, the queue limitation algorithm is bypassed."), details: None, lo: 0, hi: 1 });
        fields.insert("QLIMIT_IGR_DIS", Field { brief: Some("Disable queue limitation for the port. If either queue limitation is disabled for the source port, or for the destination port, the queue limitation algorithm is bypassed."), details: None, lo: 1, hi: 2 });
        regs.insert("QLIMIT_DIS_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Queue Limitation Configuration"), details: Some("Disabling queue limitation per port."), fields });
        let mut fields = HashMap::new();
        fields.insert("QLIMIT_QUE_ACT", Field { brief: None, details: None, lo: 0, hi: 6 });
        regs.insert("QLIMIT_QUE_ACT_CFG", Register { addr: Address { base: 11, count: 1, width: 1 }, brief: Some("Size of an active queue"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("QLIMIT_QUE_CONG", Field { brief: None, details: None, lo: 0, hi: 6 });
        regs.insert("QLIMIT_QUE_CONG_CFG", Register { addr: Address { base: 10, count: 1, width: 1 }, brief: Some("Size of a congested queue"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("QLIMIT_SE_CONG", Field { brief: Some("An SE is regarded congested when its total queue size exceeds this."), details: None, lo: 0, hi: 20 });
        regs.insert("QLIMIT_SE_CONG_CFG", Register { addr: Address { base: 12, count: 1, width: 1 }, brief: Some("Size of congested SE"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("QLIMIT_SHR_ATOP", Field { brief: Some("When filling exceeds this level, all active queues start tail dropping."), details: None, lo: 0, hi: 15 });
        regs.insert("QLIMIT_SHR_ATOP_CFG", Register { addr: Address { base: 2, count: 2, width: 1 }, brief: Some("Maximum congested size of shared area"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("QLIMIT_SHR_CTOP", Field { brief: Some("When filling exceeds this level, all congested queues start tail dropping."), details: None, lo: 0, hi: 15 });
        regs.insert("QLIMIT_SHR_CTOP_CFG", Register { addr: Address { base: 4, count: 2, width: 1 }, brief: Some("Maximum congested size of shared area"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("QLIMIT_SHR_FILL", Field { brief: None, details: None, lo: 0, hi: 15 });
        regs.insert("QLIMIT_SHR_FILL_STAT", Register { addr: Address { base: 14, count: 1, width: 1 }, brief: Some("Current use of the shared area"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("QLIMIT_SHR_QDIV", Field { brief: Some("This amount can be shared between large SEs"), details: None, lo: 0, hi: 15 });
        regs.insert("QLIMIT_SHR_QDIV_CFG", Register { addr: Address { base: 8, count: 2, width: 1 }, brief: Some("Maximum area to distribute between large SE users"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("QLIMIT_SHR_QLIM", Field { brief: Some("When filling exceeds this level, all queues are limited in size depending on number of congested queues."), details: None, lo: 0, hi: 15 });
        regs.insert("QLIMIT_SHR_QLIM_CFG", Register { addr: Address { base: 6, count: 2, width: 1 }, brief: Some("Maximum area use before queue limitation kicks in"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("QLIMIT_SHR_TOP", Field { brief: Some("When total consumption of a shared area exceeds this level, all queues belonging to the area start tail dropping"), details: None, lo: 0, hi: 15 });
        regs.insert("QLIMIT_SHR_TOP_CFG", Register { addr: Address { base: 0, count: 2, width: 1 }, brief: Some("Maximum size of shared area"), details: None, fields });
        groups.insert("QLIMIT_SHR", RegisterGroup { addr: Address { base: 1536, count: 4, width: 17 }, desc: "Shared memory pool configuration", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("QMAP_QOS_SEL", Field { brief: Some("Configures which classified parameter to use when selecting scheduling input."), details: Some("0: Use IPRIO as input selector (SRCP for normal queue mode) 1: Use COSID as input selector 2: Use TC as input selector 3: Use PCP as input selector"), lo: 0, hi: 2 });
        regs.insert("QMAP_QOS_TBL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Per port mapping of qgrp"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("QMAP_SE_VAL", Field { brief: Some("Scheduling element to use for frames going to the specific port with the specific lookup index"), details: None, lo: 0, hi: 12 });
        regs.insert("QMAP_SE_TBL", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Per port mapping of qgrp"), details: None, fields });
        groups.insert("QMAP_QOS_TBL", RegisterGroup { addr: Address { base: 1280, count: 4, width: 2 }, desc: "Select scheduling modes", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("QMAP_VPORT_VAL", Field { brief: Some("Maps the indexed (QGRP,DPORT) set into a virtual port number. This number is used by the queue mapping system when determining target queue through QMAP_SE_TBL and QMAP_QOS_TBL."), details: None, lo: 0, hi: 12 });
        regs.insert("QMAP_VPORT_TBL", Register { addr: Address { base: 0, count: 53, width: 1 }, brief: Some("Mapping into virtual ports"), details: None, fields });
        groups.insert("QMAP_SE_TBL", RegisterGroup { addr: Address { base: 1296, count: 4, width: 1 }, desc: "Select scheduling modes", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("STAT_CLEAR_SHOT", Field { brief: Some("Set STAT_CLEAR_SHOT to clear counters for the port or service index selected by STAT_VIEW. Auto-cleared when complete (1us). Multiple counters can be cleared at the same time by setting multiple bits in STAT_CLEAR_SHOT."), details: Some("Bit 0: Clear Rx port counters (Packet, LS byte and MS byte) Bit 1: Clear Tx port counters (Packet, LS byte and MS byte) Bit 2: Clear ingress service counters (Packet, LS byte and MS byte) Bit 3: Clear egress service counters (Packet, LS byte and MS byte) When bits 0-1 are used a port number must be configured in STAT_VIEW. When bits 2 is used an ingress service index must be configured in STAT_VIEW. When bits 3 is used an egress service index must be configured in STAT_VIEW."), lo: 18, hi: 22 });
        fields.insert("STAT_SRV_PKT_ONLY", Field { brief: Some("Set to enable use of all of the service counter memory for packet counting."), details: None, lo: 4, hi: 5 });
        fields.insert("STAT_VIEW", Field { brief: Some("Selects the port or service for which counters can be accessed using QSYS:STAT. Also used to select the port or service index for which to clear statistics counters, ref. STAT_CFG.STAT_CLEAR_SHOT."), details: None, lo: 5, hi: 18 });
        fields.insert("STAT_WRAP_DIS", Field { brief: Some("Counters are by default wrapping when exceeding their maximum value, and software must thus do a subtraction with the previous readen value to see how much the total count has changed. If wrapping is disabled, the counters will clear on read, and saturate at their maximum value. Software can thus detect that a counter overflow has happened, and do not need storing the previous read values. The configuration exists replicated per statistics group as the STAT_CLEAR_SHOT describes."), details: None, lo: 0, hi: 4 });
        regs.insert("STAT_CFG", Register { addr: Address { base: 117, count: 1, width: 1 }, brief: Some("Statistics configuration"), details: None, fields });
        groups.insert("QMAP_VPORT_TBL", RegisterGroup { addr: Address { base: 1024, count: 4, width: 64 }, desc: "Mapping into virtual ports", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("CNT", Field { brief: Some("Counter value, ref. QSYS:STAT."), details: None, lo: 0, hi: 32 });
        regs.insert("CNT", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Counter values"), details: Some("See description for QSYS:STAT."), fields });
        let mut fields = HashMap::new();
        fields.insert("QLIMIT_SHR_FILL_MAX", Field { brief: None, details: None, lo: 0, hi: 15 });
        regs.insert("QLIMIT_SHR_FILL_MAX_STAT", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Maximum use of the shared area"), details: None, fields });
        groups.insert("STAT", RegisterGroup { addr: Address { base: 0, count: 1024, width: 1 }, desc: "Frame statistics", regs });
        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("FWD_CPU_DROP_CNT", Field { brief: Some("Counts number of frames discarded towards the cpu, since queue system reset."), details: None, lo: 0, hi: 32 });
        regs.insert("FWD_CPU_DROP_CNT", Register { addr: Address { base: 63, count: 1, width: 1 }, brief: Some("Counter for number of frames discarded towards the cpu"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FWD_IDLE_CNT", Field { brief: Some("The maximum number of clock cycles between guaranteed CSR access to res_stat counters."), details: None, lo: 0, hi: 13 });
        regs.insert("FWD_CTRL", Register { addr: Address { base: 2, count: 1, width: 1 }, brief: Some("Forwarder mischeleaneous configuration"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FWD_DROP_CPU_STICKY", Field { brief: Some("A CPU directed frame copy was canceled."), details: None, lo: 3, hi: 4 });
        fields.insert("FWD_DROP_LEARN_STICKY", Field { brief: Some("A learnall frame copy was canceled."), details: None, lo: 2, hi: 3 });
        fields.insert("FWD_DROP_MIRR_STICKY", Field { brief: Some("A mirror copy was canceled."), details: None, lo: 1, hi: 2 });
        fields.insert("FWD_DROP_NORM_STICKY", Field { brief: Some("A switched frame copy was canceled to one or more egress ports."), details: None, lo: 4, hi: 5 });
        fields.insert("FWD_DROP_QMAP_STICKY", Field { brief: Some("A frame copy was discarded due to a queuemapping violation."), details: None, lo: 0, hi: 1 });
        regs.insert("FWD_DROP_EVENTS", Register { addr: Address { base: 3, count: 57, width: 1 }, brief: Some("QS drop events per port and copy type"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FWD_STAT_CNT", Field { brief: Some("Counts number of forwarding events since chip reset."), details: None, lo: 0, hi: 32 });
        regs.insert("FWD_STAT_CNT", Register { addr: Address { base: 60, count: 3, width: 1 }, brief: Some("Counters showing forwarding runs. Debugging purposes only"), details: Some("Three counters exists in the forwarder. Replication 0 counts each executed queue head processing. Replication 1 counts each occurance of a delayed processing due to egress queue system pressure, and replication 2 counts occurances of delayed process due to statistics event pressure."), fields });
        let mut fields = HashMap::new();
        fields.insert("MAP_CFG_CFG", Field { brief: Some("This value is used for indexing into the QMAP_QOS_TBL, QMAP_SE_TBL, and QLIMIT_QUEUE tables."), details: None, lo: 0, hi: 32 });
        regs.insert("MAP_CFG_CFG", Register { addr: Address { base: 1, count: 1, width: 1 }, brief: Some("Index into large tables"), details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("QMAP_MODE_NONSERVICE", Field { brief: Some("Same function as for QMAP_MODE_SERVICE, except this mode is for qgrp=0 frames."), details: None, lo: 0, hi: 2 });
        fields.insert("QMAP_MODE_SERVICE", Field { brief: Some("Scheduling mode for frames classified to queing group /=0 (service frames). In NORMAL mode, the queue number is looked up in the map tables at index 1024+qos_value. In GROUP mode, a scheduling element is assigned per queueing group, with 8 queues attached. The queue number is looked up in the tables at index qgrp. In MBH mode, the qos is looked up at index qgrp, and the scheduling index is looked up at index \"(grp and not 0xf) + qos_value\". A minimum hierachy also exist. It corresponds to GROUP mode, but the qgrp is regarded zero in the mapping."), details: Some("0: Normal mode 1: Hier mode 2: Mbh mode 3: Mini mode"), lo: 2, hi: 4 });
        regs.insert("QMAP_PORT_MODE", Register { addr: Address { base: 64, count: 53, width: 1 }, brief: Some("Basic port mode for scheduling hierarchy"), details: Some("All ports have their own scheduling hierarchy defined, consisting of a part for nonservice frames defined as frames having queing group classified to 0, and a part for the rest. The two parts can be identical if needed, in which case the modes for service and non service must have the same setting."), fields });
        let mut fields = HashMap::new();
        fields.insert("DROP_COUNT_EGRESS", Field { brief: Some("When set, a frame discarded due to lack of resources is counted on the egress port instead of the ingress. Side effect is a slower processing of multiple drops on the same frame, causing potential head-of-line blocking."), details: None, lo: 0, hi: 1 });
        regs.insert("STAT_CNT_CFG", Register { addr: Address { base: 0, count: 1, width: 1 }, brief: Some("Statistics configuration"), details: None, fields });
        groups.insert("SYSTEM", RegisterGroup { addr: Address { base: 1304, count: 1, width: 118 }, desc: "Switch configuration", regs });
        out.insert("XQS", Target { desc: "Queue Transfer Configuration", groups });
        return out;
    };

    /// Maps from PHY page name to `Page`, which contains a hierarchy
    /// of registers containing bit fields.
    pub static ref PHY_MAP: HashMap<&'static str, Page<&'static str>> = {
        let mut out = HashMap::new();

        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("UNIDIRECTIONAL", Field { brief: None, details: None, lo: 5, hi: 6 });
        fields.insert("RESTART_AUTO_NEG", Field { brief: None, details: None, lo: 9, hi: 10 });
        fields.insert("ISOLATE", Field { brief: None, details: None, lo: 10, hi: 11 });
        fields.insert("POWER_DOWN", Field { brief: None, details: None, lo: 11, hi: 12 });
        fields.insert("AUTO_NEG_ENA", Field { brief: None, details: None, lo: 12, hi: 13 });
        fields.insert("LOOP", Field { brief: None, details: None, lo: 14, hi: 15 });
        fields.insert("SW_RESET", Field { brief: None, details: None, lo: 15, hi: 16 });
        regs.insert("MODE_CONTROL", Register { addr: Address { base: 0, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("MODE_STATUS", Register { addr: Address { base: 1, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("IDENTIFIER_1", Register { addr: Address { base: 2, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("IDENTIFIER_2", Register { addr: Address { base: 3, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("10BASET_HDX", Field { brief: None, details: None, lo: 5, hi: 6 });
        fields.insert("10BASET_FDX", Field { brief: None, details: None, lo: 6, hi: 7 });
        fields.insert("100BASETX_HDX", Field { brief: None, details: None, lo: 7, hi: 8 });
        fields.insert("100BASETX_FDX", Field { brief: None, details: None, lo: 8, hi: 9 });
        regs.insert("DEVICE_AUTONEG_ADVERTISEMENT", Register { addr: Address { base: 4, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("AUTONEGOTIATION_LINK_PARTNER_ABILITY", Register { addr: Address { base: 5, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("1000BASE_T_HDX_CAPABILITY", Field { brief: None, details: None, lo: 8, hi: 9 });
        fields.insert("1000BASE_T_FDX_CAPABILITY", Field { brief: None, details: None, lo: 9, hi: 10 });
        regs.insert("1000BASE_T_CONTROL", Register { addr: Address { base: 9, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("1000BASE_T_STATUS", Register { addr: Address { base: 10, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("MMD_EEE_ACCESS", Register { addr: Address { base: 13, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("MMD_ADDR_OR_DATA", Register { addr: Address { base: 14, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("DISABLE_PARI_SWAP_CORRECTION", Field { brief: None, details: None, lo: 5, hi: 6 });
        fields.insert("HP_AUTO_MDIX_AT_FORCE", Field { brief: None, details: None, lo: 7, hi: 8 });
        regs.insert("BYPASS_CONTROL", Register { addr: Address { base: 18, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("100_1000BASETX_RX_ERR_CNT", Field { brief: None, details: None, lo: 0, hi: 7 });
        regs.insert("ERROR_COUNTER_1", Register { addr: Address { base: 19, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("EXTENDED_CONTROL_AND_STATUS_20", Register { addr: Address { base: 20, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CU_MEDIA_LINK_DISCONN_ERR_CNT", Field { brief: None, details: None, lo: 0, hi: 7 });
        regs.insert("ERROR_COUNTER_3", Register { addr: Address { base: 21, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FORCE_10BASE_T_HIGH", Field { brief: None, details: None, lo: 15, hi: 16 });
        regs.insert("EXTENDED_CONTROL_AND_STATUS", Register { addr: Address { base: 22, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FAR_END_LOOPBACK_MODE", Field { brief: None, details: None, lo: 3, hi: 4 });
        fields.insert("AMS_OVERRIDE", Field { brief: None, details: None, lo: 6, hi: 2 });
        fields.insert("MEDIA_OPERATING_MODE", Field { brief: None, details: None, lo: 8, hi: 3 });
        fields.insert("AMS_ENABLED", Field { brief: None, details: None, lo: 10, hi: 11 });
        fields.insert("AMS_PREFERENCE", Field { brief: None, details: None, lo: 11, hi: 12 });
        fields.insert("MAC_INTERFACE_MODE", Field { brief: None, details: None, lo: 12, hi: 13 });
        fields.insert("RXCLK_BUG_15388", Field { brief: None, details: None, lo: 13, hi: 14 });
        regs.insert("EXTENDED_PHY_CONTROL", Register { addr: Address { base: 23, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CONNECTOR_LOOPBACK_MODE", Field { brief: None, details: None, lo: 0, hi: 1 });
        regs.insert("EXTENDED_PHY_CONTROL_2", Register { addr: Address { base: 24, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("RX_ER_INT_MASK", Field { brief: None, details: None, lo: 0, hi: 1 });
        fields.insert("MASTER_SLAVE_RES_ERR_MASK", Field { brief: None, details: None, lo: 1, hi: 2 });
        fields.insert("LINK_SPEED_DS_DETECT_MASK", Field { brief: None, details: None, lo: 2, hi: 3 });
        fields.insert("FALSE_CARRIER_INT_MASK", Field { brief: None, details: None, lo: 3, hi: 4 });
        fields.insert("AMS_MEDIA_CHANGE_MASK", Field { brief: None, details: None, lo: 4, hi: 5 });
        fields.insert("EXTENDED_INT_MASK", Field { brief: None, details: None, lo: 5, hi: 6 });
        fields.insert("RX_FIFO_OVERFLOW_INT_MASK", Field { brief: None, details: None, lo: 5, hi: 6 });
        fields.insert("TX_FIFO_OVERFLOW_INT_MASK", Field { brief: None, details: None, lo: 6, hi: 7 });
        fields.insert("WAKE_ON_LAN_MASK", Field { brief: None, details: None, lo: 6, hi: 7 });
        fields.insert("FAST_LINK_MASK", Field { brief: None, details: None, lo: 7, hi: 8 });
        fields.insert("SYMBOL_ERR_INT_MASK", Field { brief: None, details: None, lo: 8, hi: 9 });
        fields.insert("INLINE_POW_DEV_DETECT_MASK", Field { brief: None, details: None, lo: 9, hi: 10 });
        fields.insert("AUTO_NEG_COMPLETE_MASK", Field { brief: None, details: None, lo: 10, hi: 11 });
        fields.insert("AUTO_NEG_ERROR_MASK", Field { brief: None, details: None, lo: 11, hi: 12 });
        fields.insert("FDX_STATE_CHANGE_MASK", Field { brief: None, details: None, lo: 12, hi: 13 });
        fields.insert("LINK_MASK", Field { brief: None, details: None, lo: 13, hi: 14 });
        fields.insert("SPEED_STATE_CHANGE_MASK", Field { brief: None, details: None, lo: 14, hi: 15 });
        fields.insert("INT_MASK", Field { brief: None, details: None, lo: 15, hi: 16 });
        regs.insert("INTERRUPT_MASK", Register { addr: Address { base: 25, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("INTERRUPT_STATUS", Register { addr: Address { base: 26, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("COBRA_LED_MODE_SELECT", Register { addr: Address { base: 27, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("STD_27", Register { addr: Address { base: 27, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ACTIPHY_MODE_ENABLE", Field { brief: None, details: None, lo: 6, hi: 7 });
        fields.insert("HP_AUTO_MDIX_CROSSOVER_INDICATION", Field { brief: None, details: None, lo: 13, hi: 14 });
        fields.insert("ANEG_DISABLED", Field { brief: None, details: None, lo: 14, hi: 15 });
        fields.insert("ANEG_COMPLETE", Field { brief: None, details: None, lo: 15, hi: 16 });
        regs.insert("AUXILIARY_CONTROL_AND_STATUS", Register { addr: Address { base: 28, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("LED_MODE_SELECT", Register { addr: Address { base: 29, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("LED_PULSING_ENABLE", Field { brief: None, details: None, lo: 12, hi: 13 });
        regs.insert("LED_BEHAVIOR", Register { addr: Address { base: 30, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("PAGE", Register { addr: Address { base: 31, count: 1, width: 0 }, brief: None, details: None, fields });
        out.insert("STANDARD", Page { desc: "Standard registers", base: 0, regs });

        let mut regs = HashMap::new();
        let fields = HashMap::new();
        regs.insert("REG_17E", Register { addr: Address { base: 17, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CONTENTS", Field { brief: None, details: None, lo: 0, hi: 14 });
        regs.insert("CU_MEDIA_CRC_GOOD_COUNTER", Register { addr: Address { base: 18, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FORCE_MDI_CROSSOVER", Field { brief: None, details: None, lo: 2, hi: 2 });
        fields.insert("FAST_LINK_FAILURE", Field { brief: None, details: None, lo: 4, hi: 5 });
        regs.insert("EXTENDED_MODE_CONTROL", Register { addr: Address { base: 19, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MEDIA_MODE_STATUS", Field { brief: None, details: None, lo: 6, hi: 2 });
        regs.insert("EXTENDED_PHY_CONTROL_3", Register { addr: Address { base: 20, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("RESERVED_1_WS", Register { addr: Address { base: 21, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("RESERVED_2_WS", Register { addr: Address { base: 22, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("EXTENDED_PHY_CONTROL_4", Register { addr: Address { base: 23, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PAIR_B_DISTANCE", Field { brief: None, details: None, lo: 0, hi: 6 });
        fields.insert("PAIR_A_DISTANCE", Field { brief: None, details: None, lo: 8, hi: 6 });
        fields.insert("VALID", Field { brief: None, details: None, lo: 14, hi: 15 });
        fields.insert("TRIGGER", Field { brief: None, details: None, lo: 15, hi: 16 });
        regs.insert("VERIPHY_CTRL_REG1", Register { addr: Address { base: 24, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PAIR_D_DISTANCE", Field { brief: None, details: None, lo: 0, hi: 6 });
        fields.insert("PAIR_C_DISTANCE", Field { brief: None, details: None, lo: 8, hi: 6 });
        regs.insert("VERIPHY_CTRL_REG2", Register { addr: Address { base: 25, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PAIR_D_TERMINATION_STATUS", Field { brief: None, details: None, lo: 0, hi: 4 });
        fields.insert("PAIR_C_TERMINATION_STATUS", Field { brief: None, details: None, lo: 4, hi: 4 });
        fields.insert("PAIR_B_TERMINATION_STATUS", Field { brief: None, details: None, lo: 8, hi: 4 });
        fields.insert("PAIR_A_TERMINATION_STATUS", Field { brief: None, details: None, lo: 12, hi: 4 });
        regs.insert("VERIPHY_CTRL_REG3", Register { addr: Address { base: 26, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("EPG_DATA_REG_IDX", Field { brief: None, details: None, lo: 0, hi: 4 });
        fields.insert("ETYPE_UDPDEST_OV_ENA", Field { brief: None, details: None, lo: 4, hi: 5 });
        fields.insert("SIG_CTR_ENA", Field { brief: None, details: None, lo: 5, hi: 6 });
        fields.insert("IPG_OV_ENA", Field { brief: None, details: None, lo: 6, hi: 7 });
        fields.insert("PKT_SZ_OV_ENA", Field { brief: None, details: None, lo: 7, hi: 8 });
        regs.insert("EXT_28", Register { addr: Address { base: 28, count: 1, width: 0 }, brief: None, details: None, fields });
        out.insert("EXTENDED", Page { desc: "Extended registers", base: 1, regs });

        let mut regs = HashMap::new();
        let fields = HashMap::new();
        regs.insert("CU_PMD_TX_CTRL", Register { addr: Address { base: 16, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ENABLE_1000BASE_T_FORCE_MODE", Field { brief: None, details: None, lo: 5, hi: 6 });
        fields.insert("ENABLE_10BASE_TE", Field { brief: None, details: None, lo: 15, hi: 16 });
        regs.insert("EEE_CONTROL", Register { addr: Address { base: 17, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("TESLA_RGMII_CONTROL", Register { addr: Address { base: 18, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("NANO_RGMII_SKEW_TX", Field { brief: None, details: None, lo: 0, hi: 3 });
        fields.insert("NANO_RGMII_SKEW_RX", Field { brief: None, details: None, lo: 4, hi: 3 });
        fields.insert("RX_CLK_OUT_DISABLE", Field { brief: None, details: None, lo: 11, hi: 12 });
        regs.insert("RGMII_CONTROL", Register { addr: Address { base: 20, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("WOL_LOWER_MAC_ADDR", Register { addr: Address { base: 21, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("WOL_MID_MAC_ADDR", Register { addr: Address { base: 22, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("WOL_UPPER_MAC_ADDR", Register { addr: Address { base: 23, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("WOL_LOWER_PASSWD", Register { addr: Address { base: 24, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("WOL_MID_PASSWD", Register { addr: Address { base: 25, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("WOL_UPPER_PASSWD", Register { addr: Address { base: 26, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MDINT_CMOS_DRIVE_EN", Field { brief: None, details: None, lo: 0, hi: 1 });
        fields.insert("MDINT_SIGNAL_SEP", Field { brief: None, details: None, lo: 1, hi: 2 });
        fields.insert("RESERVED_003", Field { brief: None, details: None, lo: 2, hi: 6 });
        fields.insert("ADDR_REP_COUNT", Field { brief: None, details: None, lo: 8, hi: 4 });
        fields.insert("RESERVED_002", Field { brief: None, details: None, lo: 12, hi: 13 });
        fields.insert("RESERVED_001", Field { brief: None, details: None, lo: 13, hi: 14 });
        fields.insert("SECURE_ON_PASSWD_LEN_4", Field { brief: None, details: None, lo: 14, hi: 15 });
        fields.insert("SECURE_ON_ENABLE", Field { brief: None, details: None, lo: 15, hi: 16 });
        regs.insert("WOL_CONTROL", Register { addr: Address { base: 27, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("EXTENDED_INTERRUPT_MASK", Register { addr: Address { base: 28, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("EXTENDED_INTERRUPT_STATUS", Register { addr: Address { base: 29, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("EXTENDED_RING_RESILIENCY_CTRL", Register { addr: Address { base: 30, count: 1, width: 0 }, brief: None, details: None, fields });
        out.insert("EXTENDED_2", Page { desc: "Extended registers - page 2", base: 2, regs });

        let mut regs = HashMap::new();
        let fields = HashMap::new();
        regs.insert("MAC_SERDES_PCS_CONTROL", Register { addr: Address { base: 16, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("MAC_SERDES_PCS_STATUS", Register { addr: Address { base: 17, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("MAC_SERDES_CLAUSE_37_ADVERTISED_ABILITY", Register { addr: Address { base: 18, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("REVERED_18", Register { addr: Address { base: 18, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("MAC_SERDES_STATUS", Register { addr: Address { base: 20, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CNT", Field { brief: None, details: None, lo: 0, hi: 13 });
        fields.insert("ACTIVE", Field { brief: None, details: None, lo: 15, hi: 16 });
        regs.insert("MEDIA_SERDES_TX_GOOD_PACKET_COUNTER", Register { addr: Address { base: 21, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CNT", Field { brief: None, details: None, lo: 0, hi: 7 });
        fields.insert("TX_PREAMBLE_FIX", Field { brief: None, details: None, lo: 13, hi: 14 });
        fields.insert("TX_SELECT", Field { brief: None, details: None, lo: 14, hi: 2 });
        regs.insert("MEDIA_SERDES_TX_CRC_ERROR_COUNTER", Register { addr: Address { base: 22, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("MEDIA_SERDES_PCS_CONTROL", Register { addr: Address { base: 23, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("MEDIA_SIG_DET", Field { brief: None, details: None, lo: 0, hi: 1 });
        fields.insert("MEDIA_ANEG_COMPLETE", Field { brief: None, details: None, lo: 1, hi: 2 });
        fields.insert("MEDIA_LINK_STATUS", Field { brief: None, details: None, lo: 2, hi: 3 });
        fields.insert("LP_ANEG_CAP", Field { brief: None, details: None, lo: 3, hi: 4 });
        fields.insert("LP_HALF_DUPLEX", Field { brief: None, details: None, lo: 4, hi: 5 });
        fields.insert("LP_FULL_DUPLEX", Field { brief: None, details: None, lo: 5, hi: 6 });
        fields.insert("10MB_LINK_STATUS", Field { brief: None, details: None, lo: 12, hi: 13 });
        fields.insert("100BASEFX_PROTO_XFER_LINK_STATUS", Field { brief: None, details: None, lo: 13, hi: 14 });
        regs.insert("MEDIA_SERDES_PCS_STATUS", Register { addr: Address { base: 24, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("MEDIA_SERDES_CLAUSE_37_LP_ABILITY", Register { addr: Address { base: 26, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("FIBER_SERDES_FREQ", Field { brief: None, details: None, lo: 6, hi: 7 });
        fields.insert("100FX_HLS_DETECT", Field { brief: None, details: None, lo: 7, hi: 8 });
        fields.insert("COMMA_POSITION", Field { brief: None, details: None, lo: 8, hi: 11 });
        fields.insert("COMMA_DETECT", Field { brief: None, details: None, lo: 12, hi: 13 });
        fields.insert("100FX_FEFI_DETECT", Field { brief: None, details: None, lo: 13, hi: 14 });
        fields.insert("SIG_DETECT", Field { brief: None, details: None, lo: 14, hi: 15 });
        fields.insert("COMMA_REALIGN", Field { brief: None, details: None, lo: 15, hi: 16 });
        regs.insert("MEDIA_SERDES_STATUS", Register { addr: Address { base: 27, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("CNT", Field { brief: None, details: None, lo: 0, hi: 13 });
        regs.insert("MEDIA_MAC_SERDES_RX_GOOD_COUNTER", Register { addr: Address { base: 28, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("MEDIA_MAC_SERDES_RX_CRC_CRC_ERR_COUNTER", Register { addr: Address { base: 29, count: 1, width: 0 }, brief: None, details: None, fields });
        out.insert("EXTENDED_3", Page { desc: "Extended registers - page 3", base: 3, regs });

        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("1588_SOFT_RESET", Field { brief: None, details: None, lo: 15, hi: 16 });
        regs.insert("1588_PPS_0_MUX_CTRL", Register { addr: Address { base: 21, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ENABLE_OUTPUT_PORT", Field { brief: None, details: None, lo: 14, hi: 15 });
        fields.insert("ENABLE_INPUT_PORT", Field { brief: None, details: None, lo: 15, hi: 16 });
        regs.insert("SPI_DAISY_CHAIN_CTRL", Register { addr: Address { base: 26, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("SELECT_DAISY_CHAIN_CNTR", Field { brief: None, details: None, lo: 15, hi: 14 });
        regs.insert("SPI_DAISY_CHAIN_CNTR", Register { addr: Address { base: 28, count: 1, width: 0 }, brief: None, details: None, fields });
        out.insert("EXTENDED_4", Page { desc: "Extended registers - page 4", base: 4, regs });

        let mut regs = HashMap::new();
        let fields = HashMap::new();
        regs.insert("MACSEC_CSR_DATA_LSB", Register { addr: Address { base: 17, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("MACSEC_CSR_DATA_MSB", Register { addr: Address { base: 18, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("MACSEC_19", Register { addr: Address { base: 19, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("MACSEC_20", Register { addr: Address { base: 20, count: 1, width: 0 }, brief: None, details: None, fields });
        out.insert("MACSEC", Page { desc: "MACSEC page", base: 4, regs });

        let mut regs = HashMap::new();
        let fields = HashMap::new();
        regs.insert("GPIO_0", Register { addr: Address { base: 0, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("GPIO_3", Register { addr: Address { base: 3, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("GPIO_4", Register { addr: Address { base: 4, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("GPIO_5", Register { addr: Address { base: 5, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("GPIO_6", Register { addr: Address { base: 6, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("GPIO_7", Register { addr: Address { base: 7, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("GPIO_8", Register { addr: Address { base: 8, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("GPIO_9", Register { addr: Address { base: 9, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("GPIO_10", Register { addr: Address { base: 10, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("GPIO_11", Register { addr: Address { base: 11, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("GPIO_12", Register { addr: Address { base: 12, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("GPIO0", Field { brief: None, details: None, lo: 0, hi: 2 });
        fields.insert("GPIO1", Field { brief: None, details: None, lo: 2, hi: 2 });
        fields.insert("GPIO2", Field { brief: None, details: None, lo: 8, hi: 2 });
        fields.insert("GPIO3", Field { brief: None, details: None, lo: 10, hi: 2 });
        regs.insert("SIGDET_GPIO_CONTROL", Register { addr: Address { base: 13, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("GPIO4", Field { brief: None, details: None, lo: 0, hi: 2 });
        fields.insert("GPIO5", Field { brief: None, details: None, lo: 2, hi: 2 });
        fields.insert("COMA_MODE_OUTPUT_DATA", Field { brief: None, details: None, lo: 12, hi: 13 });
        fields.insert("COMA_MODE_OUTPUT_ENABLE", Field { brief: None, details: None, lo: 13, hi: 14 });
        fields.insert("GPIO12_GPIO13", Field { brief: None, details: None, lo: 14, hi: 2 });
        regs.insert("GPIO_CONTROL_2", Register { addr: Address { base: 14, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("GPIO_15", Register { addr: Address { base: 15, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("GPIO_INPUT", Register { addr: Address { base: 15, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("GPIO_OUTPUT", Register { addr: Address { base: 16, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("GPIO0", Field { brief: None, details: None, lo: 0, hi: 1 });
        fields.insert("GPIO1", Field { brief: None, details: None, lo: 1, hi: 2 });
        fields.insert("GPIO2", Field { brief: None, details: None, lo: 4, hi: 5 });
        fields.insert("GPIO3", Field { brief: None, details: None, lo: 5, hi: 6 });
        fields.insert("GPIO4", Field { brief: None, details: None, lo: 8, hi: 9 });
        fields.insert("GPIO5", Field { brief: None, details: None, lo: 9, hi: 10 });
        regs.insert("GPIO_IN_OUT_CONF", Register { addr: Address { base: 17, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("MICRO_PAGE", Register { addr: Address { base: 18, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("GPIO_CONTROL_3", Register { addr: Address { base: 19, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("MAC_MODE_AND_FAST_LINK", Register { addr: Address { base: 19, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("PORT_0_ENABLE", Field { brief: None, details: None, lo: 0, hi: 1 });
        fields.insert("PORT_1_ENABLE", Field { brief: None, details: None, lo: 1, hi: 2 });
        fields.insert("PORT_2_ENABLE", Field { brief: None, details: None, lo: 2, hi: 3 });
        fields.insert("PORT_3_ENABLE", Field { brief: None, details: None, lo: 3, hi: 4 });
        fields.insert("SCL_CLK_FREQ", Field { brief: None, details: None, lo: 4, hi: 2 });
        fields.insert("DEV_ADDR", Field { brief: None, details: None, lo: 9, hi: 7 });
        regs.insert("I2C_MUX_CONTROL_1", Register { addr: Address { base: 20, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("ADDR", Field { brief: None, details: None, lo: 7, hi: 0 });
        fields.insert("RD", Field { brief: None, details: None, lo: 8, hi: 9 });
        fields.insert("ENA_I2C_MUX_ACCESS", Field { brief: None, details: None, lo: 9, hi: 10 });
        fields.insert("PHY_PORT_ADDR", Field { brief: None, details: None, lo: 10, hi: 1 });
        fields.insert("MUX_READY", Field { brief: None, details: None, lo: 15, hi: 16 });
        regs.insert("I2C_MUX_CONTROL_2", Register { addr: Address { base: 21, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("WRITE_DATA", Field { brief: None, details: None, lo: 0, hi: 8 });
        fields.insert("READ_DATA", Field { brief: None, details: None, lo: 8, hi: 8 });
        regs.insert("I2C_MUX_DATA_READ_WRITE", Register { addr: Address { base: 22, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("RECOVERED_CLOCK_0_CONTROL", Register { addr: Address { base: 23, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("RECOVERED_CLOCK_1_CONTROL", Register { addr: Address { base: 24, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("ENHANCED_LED_CONTROL", Register { addr: Address { base: 25, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("TEMP_CONF", Register { addr: Address { base: 26, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("TEMP_VAL", Register { addr: Address { base: 28, count: 1, width: 0 }, brief: None, details: None, fields });
        let mut fields = HashMap::new();
        fields.insert("TESLA_E", Field { brief: None, details: None, lo: 0, hi: 1 });
        regs.insert("EXTENDED_REVISION", Register { addr: Address { base: 30, count: 1, width: 0 }, brief: None, details: None, fields });
        out.insert("GPIO", Page { desc: "GPIO registers", base: 16, regs });

        let mut regs = HashMap::new();
        let mut fields = HashMap::new();
        fields.insert("READ", Field { brief: None, details: None, lo: 14, hi: 15 });
        fields.insert("CMD_BIT", Field { brief: None, details: None, lo: 15, hi: 16 });
        regs.insert("1588_16", Register { addr: Address { base: 16, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("1588_CSR_DATA_LSB", Register { addr: Address { base: 17, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("1588_CSR_DATA_MSB", Register { addr: Address { base: 18, count: 1, width: 0 }, brief: None, details: None, fields });
        out.insert("1588", Page { desc: "1588 (PTP) registers", base: 5512, regs });

        let mut regs = HashMap::new();
        let fields = HashMap::new();
        regs.insert("TEST_PAGE_0", Register { addr: Address { base: 0, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("TEST_PAGE_1", Register { addr: Address { base: 1, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("TEST_PAGE_2", Register { addr: Address { base: 2, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("TEST_PAGE_3", Register { addr: Address { base: 3, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("TEST_PAGE_5", Register { addr: Address { base: 5, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("TEST_PAGE_8", Register { addr: Address { base: 8, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("TEST_PAGE_9", Register { addr: Address { base: 9, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("TEST_PAGE_12", Register { addr: Address { base: 12, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("TEST_PAGE_19", Register { addr: Address { base: 19, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("TEST_PAGE_20", Register { addr: Address { base: 20, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("TEST_PAGE_22", Register { addr: Address { base: 22, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("TEST_PAGE_23", Register { addr: Address { base: 23, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("TEST_PAGE_24", Register { addr: Address { base: 24, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("TEST_PAGE_25", Register { addr: Address { base: 25, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("TEST_PAGE_27", Register { addr: Address { base: 27, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("TEST_PAGE_28", Register { addr: Address { base: 28, count: 1, width: 0 }, brief: None, details: None, fields });
        out.insert("TEST", Page { desc: "Test registers", base: 10800, regs });

        let mut regs = HashMap::new();
        let fields = HashMap::new();
        regs.insert("TR_0", Register { addr: Address { base: 0, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("TR_1", Register { addr: Address { base: 1, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("TR_2", Register { addr: Address { base: 2, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("TR_16", Register { addr: Address { base: 16, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("TR_17", Register { addr: Address { base: 17, count: 1, width: 0 }, brief: None, details: None, fields });
        let fields = HashMap::new();
        regs.insert("TR_18", Register { addr: Address { base: 18, count: 1, width: 0 }, brief: None, details: None, fields });
        out.insert("TR", Page { desc: "Token ring registers", base: 21173, regs });
        return out;
    };
}
